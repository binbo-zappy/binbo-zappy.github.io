<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>5.3 磁盘和固态硬盘</title>
    <link href="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-3-%E7%A3%81%E7%9B%98%E5%92%8C%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98/"/>
    <url>/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-3-%E7%A3%81%E7%9B%98%E5%92%8C%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h1 id="5-3-磁盘组织与管理"><a href="#5-3-磁盘组织与管理" class="headerlink" title="5.3 磁盘组织与管理"></a><strong>5.3 磁盘组织与管理</strong></h1><h2 id="1-磁盘的结构"><a href="#1-磁盘的结构" class="headerlink" title="1. 磁盘的结构"></a><strong>1. 磁盘的结构</strong></h2><h3 id="1-1-磁盘、磁道、扇区"><a href="#1-1-磁盘、磁道、扇区" class="headerlink" title="1.1 磁盘、磁道、扇区"></a>1.1 <strong>磁盘、磁道、扇区</strong></h3><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-3-%E7%A3%81%E7%9B%98%E5%92%8C%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98/image-20241122110700006.png"></p><h3 id="1-2-如何在磁盘中读-写数据"><a href="#1-2-如何在磁盘中读-写数据" class="headerlink" title="1.2 如何在磁盘中读&#x2F;写数据"></a>1.2 <strong>如何在磁盘中读&#x2F;写数据</strong></h3><ul><li><p>需要把”磁头”移动到想要读&#x2F;写的扇区所在的磁道</p></li><li><p>磁盘会转起来, 让目标扇区从磁头下面划过, 才能完成对扇区的读&#x2F;写操作</p></li></ul><h3 id="1-3-盘面、柱面"><a href="#1-3-盘面、柱面" class="headerlink" title="1.3 盘面、柱面"></a>1.3 <strong>盘面、柱面</strong></h3><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-3-%E7%A3%81%E7%9B%98%E5%92%8C%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98/image-20241122110727198.png"></p><h3 id="1-4-磁盘的物理地址"><a href="#1-4-磁盘的物理地址" class="headerlink" title="1.4 磁盘的物理地址"></a>1.4 <strong>磁盘的物理地址</strong></h3><ul><li>可用 (柱面号, 盘面号, 扇区号)来定位任意一个”磁盘块”。在“文件的物理结构”小节中, 我们经常提到文件数据存放在外存中的几号块, 这个块号就可以转换成(柱面号, 盘面号, 扇区号)的地址转化</li><li>可根据该地址读取一个”块”<ul><li>根据”柱面号”移动磁臂, 让磁头指向指定柱面</li><li>激活指定盘面对应的磁头</li><li>磁盘旋转的过程中, 指定的扇区会从磁头下面划过, 这样就完成了对指定扇区的读&#x2F;写</li></ul></li></ul><h3 id="1-5-磁盘的分类"><a href="#1-5-磁盘的分类" class="headerlink" title="1.5 磁盘的分类"></a>1.5 <strong>磁盘的分类</strong></h3><ul><li><strong>根据磁头是否可移动</strong><ul><li><strong>活动头磁盘</strong><ul><li>磁头可以移动的称为活动头磁盘</li><li>磁臂可以来回伸缩来带动磁头定位磁道</li></ul></li><li><strong>固定头磁盘</strong><ul><li>磁头不可移动的称为固定头磁盘</li><li>这种磁盘中每个磁道都有一个磁头</li></ul></li><li><strong>根据盘片是否可更换</strong><ul><li><strong>可换盘磁盘</strong></li><li><strong>固定盘磁盘</strong></li></ul></li></ul></li></ul><h2 id="2-磁盘调度算法"><a href="#2-磁盘调度算法" class="headerlink" title="2. 磁盘调度算法"></a><strong>2. 磁盘调度算法</strong></h2><h3 id="2-1-一次磁盘读-写操作需要的时间"><a href="#2-1-一次磁盘读-写操作需要的时间" class="headerlink" title="2.1 一次磁盘读&#x2F;写操作需要的时间"></a>2.1 <strong>一次磁盘读&#x2F;写操作需要的时间</strong></h3><ul><li>**寻道时间(寻找时间)**T<sub>S</sub><ul><li>在读&#x2F;写数据前, 将磁头移动到指定磁道所花的时间<ul><li>启动磁头臂是需要时间的, 假设耗时为s</li><li>移动磁头也是需要时间的, 假设磁头匀速移动, 每跨域一个磁道耗时为m, 总共需要跨域n条磁道</li></ul></li><li>寻道时间 T<sub>S</sub> &#x3D; s + m * n</li></ul></li><li><strong>延迟时间</strong>T<sub>R</sub><ul><li>通过旋转磁盘, 使磁头定位到目标扇区所需要的时间<ul><li>设磁盘转速为r(单位: 转&#x2F;秒 或 转&#x2F;分)</li></ul></li><li>平均所需的延迟时间 T<sub>R</sub> &#x3D; (1&#x2F;2) * (1&#x2F;r) &#x3D; 1&#x2F;(2r)<ul><li>1&#x2F;r就是转一圈需要的时间, 找到目标扇区平均需要转半圈, 因此再乘以1&#x2F;2</li></ul></li></ul></li><li><strong>传输时间</strong>T<sub>t</sub><ul><li>从磁盘读&#x2F;写数据所经历的时间<ul><li>磁盘转速为r, 此次读&#x2F;写的字节数为b, 每个磁道上的字节数为N</li></ul></li><li>传输时间 T<sub>t</sub> &#x3D; (1&#x2F;r)*(b&#x2F;N) &#x3D; b&#x2F;(rN)</li><li>每个磁道要可存N字节的数据, 因此b字节的数据需要b&#x2F;N个磁道才能存储, 而读&#x2F;写一个磁道</li><li>所需的时间刚好又是转一圈所需要的时间1&#x2F;r</li></ul></li><li><strong>总的平均读取时间</strong> Ta &#x3D; Ts + 1&#x2F;(2r) + b&#x2F;(rN)<ul><li>延迟时间和传输时间都与磁盘转速相关, 而转速是硬件的固有属性, 因此操作系统也无法优化延迟时间和传输时间</li><li>但是操作系统的<strong>磁盘调度算法</strong>会直接影响<strong>寻道时间</strong></li></ul></li></ul><h3 id="2-2-磁盘调度算法"><a href="#2-2-磁盘调度算法" class="headerlink" title="2.2 磁盘调度算法"></a>2.2 <strong>磁盘调度算法</strong></h3><ul><li>先来先服务算法(FCFS)<ul><li>根据进程请求访问磁盘的先后顺序进行调度</li><li>优点: 公平; 如果请求访问的磁道比较集中的话, 算法性能还算过得去</li><li>缺点: 如果有大量进程竞争使用磁盘, 请求访问的磁道很分散, 则FCFS在性能上很差, 寻道时间长</li></ul></li><li>最短寻找时间优先(SSTF)<ul><li>SSTF算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短, 但是并不能保证总的寻道时间最短<ul><li>其实就是贪心算法的思想, 只是选择眼前最优, 但是总体未必最优</li></ul></li><li>优点: 性能较好, 平均寻道时间短</li><li>缺点: 可能产生”饥饿”现象, 磁头在一个小区域内来回地移动</li></ul></li><li>扫描算法(SCAN)<ul><li>为了防止SSTF算法产生饥饿, 可以规定只有磁头移动到最外侧磁道的时候才能往内移动, 移动到最内侧磁道的时候才能往外移动, 由于磁头移动的方式很像电梯, 因此也叫电梯算法</li><li>优点: 性能较好, 平均寻道时间较短, 不会产生饥饿现象</li><li>缺点:<ul><li>只有到达最边上的磁道时才能改变磁头移动方向</li><li>SCAN算法对于各个位置磁道的响应频率不平均</li></ul></li></ul></li><li>LOOK调度算法<ul><li>如果在磁头移动方向上已经没有别的请求, 就可以立即改变磁头移动方向(边移动边观察, 因此叫LOOK)</li><li>优点: 比起SCAN算法, 不需要每次都移动到最外侧或最内侧才改变磁头方向, 使寻道时间进一步缩短</li></ul></li><li>循环扫描算法(C-SCAN)<ul><li>规定只有磁头朝某个特定方向移动时才处理磁道访问请求, 而返回时直接快速移动至起始端而不处理任何请求</li><li>优点: 比起SCAN来说, 对于各个位置磁道的响应频率很平均 </li><li>缺点: 只有到达最边上的磁道时才能改变磁头移动方向</li></ul></li><li>C-LOOK调度算法<ul><li>如果磁头移动的方向上已经没有磁道访问请求了, 就可以立即让磁头返回, 并且磁头只需要返回到有磁道访问请求的位置即可</li><li>优点: 比起C-SCAN算法, 不需要每次都移动到最外侧或最内侧才改变磁头方向, 使寻道时间进一步缩短</li></ul></li></ul><h2 id="3-减少磁盘延迟时间的方法"><a href="#3-减少磁盘延迟时间的方法" class="headerlink" title="3. 减少磁盘延迟时间的方法"></a><strong>3. 减少磁盘延迟时间的方法</strong></h2><h3 id="3-1-交替编号"><a href="#3-1-交替编号" class="headerlink" title="3.1 交替编号"></a>3.1 <strong>交替编号</strong></h3><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-3-%E7%A3%81%E7%9B%98%E5%92%8C%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98/image-20241122111239973.png"></p><h3 id="3-2-错位命名"><a href="#3-2-错位命名" class="headerlink" title="3.2 错位命名"></a>3.2 <strong>错位命名</strong></h3><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-3-%E7%A3%81%E7%9B%98%E5%92%8C%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98/image-20241122111252768.png"></p><h3 id="3-3-磁盘地址结构的设计"><a href="#3-3-磁盘地址结构的设计" class="headerlink" title="3.3 磁盘地址结构的设计"></a>3.3 <strong>磁盘地址结构的设计</strong></h3><ul><li>使用 (柱面号, 盘面号, 扇区号)的原因<ul><li>在读取地址连续的磁盘块时, 前者不需要经常移动磁头</li></ul></li></ul><h2 id="4-磁盘的管理"><a href="#4-磁盘的管理" class="headerlink" title="4. 磁盘的管理"></a><strong>4. 磁盘的管理</strong></h2><h3 id="4-1-磁盘初始化"><a href="#4-1-磁盘初始化" class="headerlink" title="4.1 磁盘初始化"></a>4.1 <strong>磁盘初始化</strong></h3><ul><li><p>进行<strong>低级格式化(物理格式化)</strong>, <strong>将磁盘的各个磁道划分为扇区</strong>, 一个扇区通常可分为头、数据区域(如512B大小)、尾三个部分组成。管理扇区所需要的各种数据结构一般存放在头、尾两个部分, 包括扇区校验码(如奇偶校验、CRC循环冗余校验码等, 校验码用于校验扇区中的数据是否发生错误)</p></li><li><p><strong>将磁盘分区(分卷，Volume), 每个分区由若干柱面组成</strong>(即分为我们熟悉的 C盘、D盘、E盘)</p></li><li><p>进行<strong>逻辑格式化</strong>, <strong>创建文件系统</strong>。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构(如位示图、空闲分区表)</p></li></ul><h3 id="4-2-引导块"><a href="#4-2-引导块" class="headerlink" title="4.2 引导块"></a>4.2 <strong>引导块</strong></h3><ul><li><p>计算机开机时需要进行一系列初始化的工作, 这些初始化工作是通过执行**初始化程序(自举程序)**完成的</p></li><li><p>初始化程序可以放在ROM(只读存储器)中, ROM中的数据在出厂时就写入了, 并且以后不能再修改</p><ul><li>注: ROM一般是出厂时就集成在主板上的</li></ul></li><li><p>将完整初始化程序放在ROM中, 当需要更新自举程序时, 将会很不方便, 因为ROM中的数据无法更改</p></li><li><p>在实际中, ROM中只存放很小的”自举装入程序”, 完整的自举程序存放在磁盘的**启动块(引导块&#x2F;*启动分区)<strong>上, 启动块位于磁盘的固定位置, 拥有启动分区的磁盘称为</strong>启动磁盘或系统磁盘(C:盘)**</p></li><li><p>开机时计算机先运行”自举装入程序”, 通过执行该程序就可以找到引导块, 并将完整的”自举程序”读入内存, 完成初始化</p></li></ul><h3 id="4-3-坏块的管理"><a href="#4-3-坏块的管理" class="headerlink" title="4.3 坏块的管理"></a>4.3 <strong>坏块的管理</strong></h3><ul><li><p>坏了、无法正常使用的扇区就是“坏块”。这属于硬件故障, 操作系统是无法修复的。应该将坏块标记出来, 以免错误地使用到它</p></li><li><p>对于简单的磁盘, 可以在逻辑格式化时(建立文件系统时)对整个磁盘进行坏块检查, 标明哪些扇区是坏扇区</p><ul><li>例如: 在FAT表上标明(在这种方式中, 坏块对操作系统不透明)</li></ul></li><li><p>对于复杂的磁盘, <strong>磁盘控制器</strong>(磁盘设备内部的一个硬件部件)会维护一个坏块链表, 在磁盘出厂前进行<strong>低级格式化(物理格式化)<strong>时就将坏块链进行初始化, 会保留一些”备用扇区”, 用于替换坏块, 这种方案称为</strong>扇区备用</strong>, 且这种处理方式中, 坏块对操作系统透明</p></li></ul><h2 id="5-固态硬盘SSD"><a href="#5-固态硬盘SSD" class="headerlink" title="5. 固态硬盘SSD"></a><strong>5. 固态硬盘SSD</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-3-%E7%A3%81%E7%9B%98%E5%92%8C%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98/image-20241122112439752.png" alt="SSD 结构"></p><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-3-%E7%A3%81%E7%9B%98%E5%92%8C%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98/image-20241122112356429.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.2 设备独立性软件</title>
    <link href="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/"/>
    <url>/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="5-2-I-O核心子系统"><a href="#5-2-I-O核心子系统" class="headerlink" title="5.2 I&#x2F;O核心子系统"></a><strong>5.2 I&#x2F;O核心子系统</strong></h1><h2 id="1-IO核心子系统"><a href="#1-IO核心子系统" class="headerlink" title="1. IO核心子系统"></a><strong>1. IO核心子系统</strong></h2><ul><li>I&#x2F;O软件层次<ul><li>用户层软件</li><li><strong>设备独立性软件</strong></li><li><strong>设备驱动程序</strong></li><li><strong>中断处理程序</strong></li><li>硬件</li></ul></li><li>设备独立性软件、设备驱动程序、中断处理程序属于操作系统的<strong>内核部分</strong>， 即“<strong>I&#x2F;O系统</strong>”或称”<strong>I&#x2F;O核心子系统</strong>“<ul><li>因此I&#x2F;O核心子系统要实现的功能其实就是中间三层要实现的功能</li><li>考研中, 我们需要重点理解和掌握的功能是:<ul><li>I&#x2F;O调度</li><li>设备保护</li><li>假脱机技术(SPOOLing技术)<ul><li>假脱机技术需要使用到磁盘这种设备的<strong>设备独立性软件</strong>提供的服务, 所以假脱机技术一般是在<strong>用户层软件</strong>实现的</li></ul></li><li>设备分配与回收</li><li>缓冲区管理(即缓冲与高速缓存)<ul><li>除了假脱机技术外, 其他几种功能都是在<strong>设备独立性软件</strong>实现的</li></ul></li></ul></li></ul></li></ul><h3 id="1-1-I-O调度"><a href="#1-1-I-O调度" class="headerlink" title="1.1 I&#x2F;O调度"></a>1.1 <strong>I&#x2F;O调度</strong></h3><ul><li>用某种算法确定一个好的顺序来处理各个<strong>I&#x2F;O请求</strong><ul><li>如: 磁盘调度(先来先服务、最短寻道优先算法、SCAN算法、C-SCAN算法、LOOK算法、C-LOOK算法)</li><li>当多个磁盘I&#x2F;O请求到来时, 用某种调度算法确定满足I&#x2F;O请求的顺序</li><li>同理, 打印机等设备也可以用先来先服务、优先级算法、短作业优先等算法来确定I&#x2F;O调度顺序</li></ul></li></ul><h3 id="1-2-设备保护"><a href="#1-2-设备保护" class="headerlink" title="1.2 设备保护"></a>1.2 <strong>设备保护</strong></h3><ul><li>操作系统需要实现<strong>文件保护功能</strong>, 不同的用户对各个文件有不同的访问权限<ul><li>如: 只读、读和写等</li></ul></li><li>在UNIX系统中, <strong>设备被看做是一种特殊的文件</strong>, 每个设备也会有对应的<strong>FCB</strong>。当用户请求访问某个设备时, 操作系统根据FCB中记录的信息来判断该用户是否有相应的访问权限, 以此实现”<strong>设备保护</strong>“的功能(参考”<strong>文件保护</strong>“小节)</li></ul><h2 id="2-假脱机技术"><a href="#2-假脱机技术" class="headerlink" title="2. 假脱机技术"></a><strong>2. 假脱机技术</strong></h2><h3 id="2-1-脱机技术"><a href="#2-1-脱机技术" class="headerlink" title="2.1 脱机技术"></a>2.1 <strong>脱机技术</strong></h3><ul><li><p>手工操作阶段: 主机直接从I&#x2F;O设备获得数据, 由于设备速度慢, 主机速度很快, 人机速度矛盾明显, 主机要浪费很多时间来等待设备</p></li><li><p>批处理阶段: 引入了<strong>脱机输入&#x2F;输出技术</strong>(用<strong>磁带</strong>完成)</p><ul><li>在<strong>外围控制机</strong>的控制下, 慢速输入设备的数据先被输入到更快捷的磁带上, 之后主机可以从快速的磁带上读入数据, 从而缓解了速度矛盾</li><li><strong>为什么称为”脱机”?</strong><ul><li>脱离主机的控制进行的输入&#x2F;输出操作</li></ul></li><li>引入脱机技术后, 缓解了CPU与慢速I&#x2F;O设备的速度矛盾; 另一方面, 即使CPU在忙碌, 也可以提前将数据输入到磁带; 即使慢速的输出设备正在忙碌, 也可以提前将数据输出到磁带</li></ul></li></ul><h3 id="2-2-假脱机技术-SPOOLing技术"><a href="#2-2-假脱机技术-SPOOLing技术" class="headerlink" title="2.2 假脱机技术(SPOOLing技术)"></a>2.2 <strong>假脱机技术(SPOOLing技术)</strong></h3><ul><li><p>是用软件的方式模拟脱机技术</p></li><li><p>SPOOLing系统的组成如下:</p></li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/image-20241122104053709.png"></p><ul><li>在磁盘上开辟出两个存储区域 – “<strong>输入井</strong>“ 和 “<strong>输出井</strong>“<ul><li>“输入井”模拟脱机输入时的磁带, 用于收容I&#x2F;O设备输入的数据</li><li>“输出井”模拟脱机输出时的磁带, 用于收容用户进程输出的数据</li></ul></li><li>要实现SPOOLing技术, <strong>必须要有多道程序技术的支持</strong>, 系统会建立”<strong>输入进程</strong>“ 和 “<strong>输出进程</strong>“<ul><li>“输入进程”模拟脱机输入时的外围控制机</li><li>“输出进程”模拟脱机输出时的外围控制机</li></ul></li><li><strong>输入缓冲区</strong> 和 <strong>输出缓冲区</strong>是在内存中的缓冲区<ul><li>在输入进程的控制下, “输入缓冲区”用于暂存从输入设备输入的数据, 之后再转存到输入井中</li><li>在输出进程的控制下, “输出缓冲区”用于暂存从输出井送来的数据, 之后再传送到输出设备上</li></ul></li></ul><h3 id="2-3-共享打印机原理分析"><a href="#2-3-共享打印机原理分析" class="headerlink" title="2.3 共享打印机原理分析"></a>2.3 <strong>共享打印机原理分析</strong></h3><ul><li><p><strong>独占式设备</strong></p><ul><li>只允许各个进程串行使用的设备, 一段时间内只能满足一个进程的请求</li><li>例子: 若进程1正在使用打印机, 则进程2请求使用打印机时必然阻塞等待</li></ul></li><li><p><strong>共享设备</strong></p><ul><li>允许多个进程”同时”使用的设备(宏观上同时使用, 微观上可能是交替使用), 可以同时满足多个进程的使用要求</li></ul></li><li><p>打印机是种”独占式设备”, 但是可以用<strong>SPOOLing技术</strong>改造成”共享设备”</p></li><li><p>原理分析:</p><ul><li>当多个用户进程提出输出打印的请求时，系统会答应它们的请求，但是并不是真正把打印机分配给他们，而是由假脱机管理进程为每个进程做两件事:<ul><li>在磁盘输出井中为进程申请一个空闲缓冲区(也就是说，这个缓冲区是在磁盘上的)，并将要打印的数据送入其中</li><li>为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中(其实就是用来说明用户的打印数据存放位置等信息的)，再将该表挂到假脱机文件队列上。当打印机空闲时，输出进程会从文件队列的队头取出一张打印请求表，并根据表中的要求将要打印的数据从输出井传送到输出缓冲区，再输出到打印机进行打印。用这种方式可依次处理完全部的打印任务</li></ul></li><li>虽然系统中只有一台打印机, 但每个进程提出打印请求时, 系统都会为它们在输出井中为其分配一个存储区(相当于分配了一个逻辑设备), 使每个用户进程都觉得自己在独占一台打印机, 从而实现对打印机的共享</li><li><strong>SPOOLing技术</strong>可以把一台物理设备虚拟成逻辑上的多台设备, 可将独占式设备改造成共享设备</li></ul></li></ul><h2 id="3-设备的分配与回收"><a href="#3-设备的分配与回收" class="headerlink" title="3. 设备的分配与回收"></a><strong>3. 设备的分配与回收</strong></h2><h3 id="3-1-设备分配时应该考虑哪些因素"><a href="#3-1-设备分配时应该考虑哪些因素" class="headerlink" title="3.1 设备分配时应该考虑哪些因素"></a>3.1 <strong>设备分配时应该考虑哪些因素</strong></h3><ul><li><strong>设备的固有属性</strong><ul><li>独占设备: 一个时段只能分配给一个进程(如打印机)</li><li>共享设备: 可同时分配给多个进程使用(如磁盘), 各进程往往是宏观上同时共享使用设备, 而微观上交替使用</li><li>虚拟设备: 采用SPOOLing技术将独占设备改造成虚拟的共享设备, 可同时分配给多个进程使用(如采用SPOOLing技术实现的共享打印机)</li></ul></li><li><strong>设备分配算法</strong><ul><li>先来先服务、优先级高者优先、短任务优先…</li></ul></li><li><strong>设备分配中的安全性</strong><ul><li>从进程运行的安全性上考虑, 设备分配有两种方式:</li><li><strong>安全分配方式</strong>: 为进程分配一个设备后就将进程阻塞, 本次I&#x2F;O完成后才将进程唤醒<ul><li>Eg: 考虑进程请求打印机打印输出的例子</li><li>一个时间段内每个进程只能使用一个设备</li><li>优点: 破坏了”请求和保持”条件, 不会死锁</li><li>缺点: 对于一个进程来说, CPU和I&#x2F;O设备只能串行工作</li></ul></li><li><strong>不安全分配方式</strong>: 进程发出I&#x2F;O请求后, 系统为其分配I&#x2F;O设备, 进程可继续执行, 之后还可以发出新的I&#x2F;O请求, 只有某个I&#x2F;O请求得不到满足时才将进程阻塞<ul><li>一个进程可以同时使用多个设备</li><li>优点: 进程的计算任务和I&#x2F;O任务可以并行处理, 使进程迅速推进</li><li>缺点: 有可能发生死锁(采用死锁避免、死锁的检测和解除处理死锁问题)</li></ul></li></ul></li></ul><h3 id="3-2-静态分配和动态分配"><a href="#3-2-静态分配和动态分配" class="headerlink" title="3.2 静态分配和动态分配"></a>3.2 <strong>静态分配和动态分配</strong></h3><ul><li>静态分配: 进程运行前为其分配全部所需资源, 运行结束后归还资源<ul><li>破坏了”请求和保持”条件, 不会发生死锁</li></ul></li><li>动态分配: 进程运行过程中动态申请设备资源</li></ul><h3 id="3-3-设备分配管理中的数据结构"><a href="#3-3-设备分配管理中的数据结构" class="headerlink" title="3.3 设备分配管理中的数据结构"></a>3.3 <strong>设备分配管理中的数据结构</strong></h3><ul><li><p>”设备、控制器、通道“之间的关系“:</p><ul><li>一个通道可控制多个设备控制器, 每个设备控制器可控制多个设备</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/image-20241122105107110.png"></p></li><li><p><strong>设备控制表(DCT)</strong></p><ul><li>系统为每个设备配置一张DCT, 用于记录设备情况</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/image-20241122104823020.png"></p></li><li><p><strong>控制器控制表(COCT)</strong></p><ul><li>每个设备控制器都会对应一张COCT, 操作系统根据COCT的信息对控制器进行操作和管理</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/image-20241122104842310.png"></p></li><li><p><strong>通道控制表(CHCT)</strong></p><ul><li>每个通道都会对应一张CHCT, 操作系统根据CHCT的信息对通道进行操作和管理</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/image-20241122104858368.png"></p></li><li><p><strong>系统设备表(SDT)</strong></p><ul><li>记录了系统中全部设备的情况, 每个设备对应一个表目</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/image-20241122105007101.png"></p></li></ul><h3 id="3-4-设备分配的步骤"><a href="#3-4-设备分配的步骤" class="headerlink" title="3.4 设备分配的步骤"></a>3.4 <strong>设备分配的步骤</strong></h3><ul><li><strong>步骤</strong>:<ul><li>根据进程请求的<strong>物理设备名</strong>查找SDT(注:物理设备名是进程请求分配设备时提供的参数)</li><li>根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程</li><li>根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程</li><li>根据COCT找到CHCT,若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程</li></ul></li><li>注: 只有设备、控制器、通道三者都分配成功时, 这次设备分配才算成功, 之后便可启动I&#x2F;O设备进行数据传送<ul><li>缺点:<ul><li>用户编程时必须使用“物理设备名”，底层细节对用户不透明，不方便编程</li><li>若换了一个物理设备，则程序无法运行</li><li>若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待</li></ul></li><li>改进方法:<ul><li>建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名</li></ul></li></ul></li><li><strong>改进的步骤</strong>:<ul><li>根据进程请求的<strong>逻辑设备名</strong>查找SDT (注:用户编程时提供的逻辑设备名其实就是“设备类型”)</li><li>查找SDT，找到用户进程指定类型的、并且空闲的设备，将其分配给该进程。操作系统在<strong>逻辑设备表(LUT)</strong> 中新增一个表项</li><li>根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程</li><li>根据COCT找到CHCT,若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程</li></ul></li><li><strong>逻辑设备表(LUT)</strong><ul><li>逻辑设备表(LUT) 建立了逻辑设备名与物理设备名之间的映射关系</li><li>某用户进程第一次使用设备时使用逻辑设备名向操作系统发出请求，操作系统根据用户进程指定的设备类型(逻辑设备名)查找系统设备表，找到一个空闲设备分配给进程，并在LUT中增加相应表项</li><li>如果之后用户进程再次通过相同的逻辑设备名请求使用设备, 则操作系统通过LUT表即可知道用户进程实际要使用的是哪个物理设备了，并且也能知道该设备的驱动程序入口地址</li><li>逻辑设备表的设置问题: <ul><li><strong>整个系统只有一张LUT</strong>: 各用户所用的<strong>逻辑设备名不允许重复</strong>，<strong>适用于单用户操作系统</strong></li><li><strong>每个用户一张LUT</strong>: <strong>不同用户的逻辑设备名可重复</strong>，<strong>适用于多用户操作系统</strong></li></ul></li></ul></li></ul><h2 id="4-缓冲区管理"><a href="#4-缓冲区管理" class="headerlink" title="4. 缓冲区管理"></a><strong>4. 缓冲区管理</strong></h2><h3 id="4-1-缓冲区的概念"><a href="#4-1-缓冲区的概念" class="headerlink" title="4.1 缓冲区的概念"></a>4.1 <strong>缓冲区的概念</strong></h3><ul><li><p>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区</p></li><li><p>使用<strong>硬件作为缓冲区</strong>的成本较高，容量也较小，一般仅用在对速度要求非常高的场合(如<strong>存储器*管理</strong>中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本)</p></li><li><p>一般情况下，更多的是利用<strong>内存作为缓冲区</strong>，“<strong>设备独立性软件</strong>”的缓冲区管理就是要组织管理好这些缓冲区</p></li></ul><h3 id="4-2-缓冲区的作用"><a href="#4-2-缓冲区的作用" class="headerlink" title="4.2 缓冲区的作用"></a>4.2 <strong>缓冲区的作用</strong></h3><ul><li>缓和CPU与I&#x2F;O设备之间速度不匹配的矛盾<ul><li>CPU可以把要输出的数据快速地放入缓冲区, 之后就可以做别的事; 慢速的I&#x2F;O设备可以慢慢从缓冲区取走数据</li><li>数据输入时类似</li></ul></li><li>减少对CPU的中断频率，放宽对CPU中断响应时间的限制<ul><li>如果没有缓冲区, 字符型设备每输出完一个字符就要向CPU发送一次中断信号</li></ul></li><li>解决数据粒度不匹配的问题<ul><li>如输出进程每次可以生成一块数据, 但I&#x2F;O设备每次只能输出一个字符</li></ul></li><li>提高CPU与I&#x2F;O设备之间的并行性</li></ul><h3 id="4-3-单缓冲"><a href="#4-3-单缓冲" class="headerlink" title="4.3 单缓冲"></a>4.3 <strong>单缓冲</strong></h3><ul><li><p>假设某用户进程请求某种块设备读入若干块的数据。若采用<strong>单缓冲</strong>的策略，操作系统会<strong>在主存中为其分配一个缓冲区</strong>(若题目中没有特别说明，一个缓冲区的大小就是一个块)</p><ul><li>注意: <strong>当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出; 当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出</strong></li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/image-20241122105801865.png"></p></li><li><p><strong>每处理一块数据平均需要多久?</strong></p><ul><li><p>T &gt; C</p><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/image-20241122105830197.png"></p></li><li><p>T &lt; C</p><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/image-20241122105915924.png"></p></li><li><p>结论: 采用单缓冲策略, 处理一块数据平均耗时为 Max(C, T) + M</p><ul><li>可以这样理解:</li><li>当T &gt; C时, 认为T极大, 这样一次数据传输时间主要为T, 而由于单缓冲, T与M不能同时执行, 所以传输时间为 T + M</li><li>当T &lt; C时, 认为T无限接近于0, 相当于缓冲区总是满的状态, 这样一次的数据传输消耗的时间就是C + M</li></ul></li></ul></li></ul><h3 id="4-4-双缓冲"><a href="#4-4-双缓冲" class="headerlink" title="4.4 双缓冲"></a>4.4 <strong>双缓冲</strong></h3><ul><li><p>假设某用户进程请求某种块设备读入若干块的数据。若采用<strong>双缓冲</strong>的策略，操作系统会<strong>在主存中为其分配两个缓冲区</strong>(若题目中没有特别说明，一个缓冲区的大小就是一个块)</p></li><li><p><strong>每处理一块数据平均需要多久?</strong></p><ul><li><p>双缓冲题目中, 假设初始状态为: 工作区空, 其中一个缓冲区满, 另一个缓冲区空</p></li><li><p>T &gt; C + M</p><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/image-20241122110227430.png"></p></li><li><p>T &lt; C + M</p><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/image-20241122110243845.png"></p></li><li><p>结论: 采用双缓冲策略, 处理一个数据块的平均耗时为 Max(T, C + M)</p><ul><li>可以这样理解:<ul><li>当T &gt; C + M时, 认为T极大, 这样一次数据传输时间为T, 而由于双缓冲, T与M能够同时执行, 所以传输时间为 T</li><li>当T &lt; C + M时, 认为T无限接近于0, 相当于缓冲区总是满的状态, 这样一次的数据传输消耗的时间就是C + M</li></ul></li></ul></li></ul></li></ul><h3 id="4-5-使用单-双缓冲在通信时的区别"><a href="#4-5-使用单-双缓冲在通信时的区别" class="headerlink" title="4.5 使用单&#x2F;双缓冲在通信时的区别"></a>4.5 <strong>使用单&#x2F;双缓冲在通信时的区别</strong></h3><ul><li>两台机器之间通信时, 可以配置缓冲区用于数据的发送和接收</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/image-20241122110402354.png"></p><ul><li>显然, 若两个相互通信的机器只设置单缓冲区, 在任一时刻只能实现数据的单向传输</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/image-20241122110422084.png"></p><ul><li>若两个相互通信的机器设置双缓冲区, 则同一时刻可以实现双向的数据传输</li></ul><h3 id="4-6-循环缓冲"><a href="#4-6-循环缓冲" class="headerlink" title="4.6 循环缓冲"></a>4.6 <strong>循环缓冲</strong></h3><ul><li>将多个大小相等的缓冲区链接成一个循环队列</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/image-20241122110437329.png"></p><h3 id="4-7-缓冲池"><a href="#4-7-缓冲池" class="headerlink" title="4.7 缓冲池"></a>4.7 <strong>缓冲池</strong></h3><ul><li><p><strong>缓冲池</strong>由系统中共用的缓冲区组成</p></li><li><p>这些缓冲区按使用状况可以分为: <strong>空缓冲队列</strong>、装满输入数据的缓冲队列(<strong>输入队列</strong>)、装满输出数据的缓冲队列(<strong>输出队列</strong>)</p></li><li><p>另外，根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区: <strong>用于收容输入数据的工作缓冲区(hin)</strong> 、<strong>用于提取输入数据的工作缓冲区(sin)</strong> 、<strong>用于收容输出数据的工作缓冲区(hout)</strong> 、<strong>用于提取输出数据的工作缓冲区(sout)</strong></p></li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/image-20241122110532369.png"></p><ul><li><strong>原理</strong>:<ul><li>输入进程请求输入数据<ul><li>从 空缓冲队列 队头取出一块空的缓冲区作为 收容输入数据的工作缓冲区(hin), 冲满数据后将缓冲区挂到输入队列队尾</li></ul></li><li>计算进程想要取得一块输入数据<ul><li>从 输入队列 队头取下一块缓冲区作为 提取输入数据的工作缓冲区(sin), 缓冲区读空后挂到空缓冲队列队尾</li></ul></li><li>计算进程想要将准备好的数据冲入缓冲区<ul><li>从 空缓冲队列 队头取出一块空的缓冲区作为 收容输出数据的工作缓冲区(hout), 冲满数据后将缓冲区挂到 输出队列 队尾</li></ul></li><li>输出进程请求输出数据<ul><li>从 输出队列 队头取下一块缓冲区作为 提取输出数据的工作缓冲区(sout), 缓冲区读空后挂到空缓冲队列 队尾</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第五章 设备管理-5.1 IO管理概述</title>
    <link href="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-1-IO%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-1-IO%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="5-1-I-O管理概述"><a href="#5-1-I-O管理概述" class="headerlink" title="5.1 I&#x2F;O管理概述"></a><strong>5.1 I&#x2F;O管理概述</strong></h1><h3 id="1-IO设备的概念和分类"><a href="#1-IO设备的概念和分类" class="headerlink" title="1. IO设备的概念和分类"></a><strong>1. IO设备的概念和分类</strong></h3><h3 id="1-1-什么是I-O设备"><a href="#1-1-什么是I-O设备" class="headerlink" title="1.1 什么是I&#x2F;O设备?"></a>1.1 <strong>什么是I&#x2F;O设备?</strong></h3><ul><li><p>“<strong>I&#x2F;O</strong>“就是”<strong>输入&#x2F;输出</strong>“(Input&#x2F;Output)</p></li><li><p>I&#x2F;O设备就是可以将数据输入到计算机, 或者可以接收计算机输出数据的外部设备, 属于计算机中的硬件部件</p><ul><li>鼠标、键盘 – 典型的输入型设备</li><li>显示器 – 输出型设备</li><li>移动硬盘 – 既可输入、又可输出的设备</li></ul></li><li><p>UNIX系统将外部设备抽象为一种特殊的文件, 用户可以使用与文件系统相同的方式对外部设备进行操作</p><ul><li>Write操作: 向外部设备写出数据</li><li>Read操作: 从外部设备读入数据</li></ul></li></ul><h3 id="1-2-I-O设备的分类"><a href="#1-2-I-O设备的分类" class="headerlink" title="1.2 I&#x2F;O设备的分类"></a>1.2 <strong>I&#x2F;O设备的分类</strong></h3><ul><li><strong>按使用特性分类</strong><ul><li>人机交互类外部设备: 数据传输速度慢<ul><li>鼠标、键盘、打印机等 – 用于人机交互</li></ul></li><li>存储设备: 数据传输速度快<ul><li>移动硬盘、光盘等 – 用于数据存储</li></ul></li><li>网络通信设备: 数据传输速度介于上述二者之间<ul><li>调制解调器等 – 用于网络通信</li></ul></li></ul></li><li><strong>按传输速率分类</strong><ul><li>低速设备<ul><li>鼠标、键盘等 – 传输速率为每秒几个到几百字节</li></ul></li><li>中速设备<ul><li>激光打印机等 – 传输速率为每秒数千至上万个字节</li></ul></li><li>高速设备<ul><li>磁盘等 – 传输速率为每秒数千字节至千兆字节的设备</li></ul></li></ul></li><li><strong>按信息交换的单位分类</strong><ul><li><strong>块设备</strong>: 传输速率较高, 可寻址, 即对它可随机地读&#x2F;写任一块<ul><li>磁盘等 – <strong>数据传输的基本单位是”块”</strong></li></ul></li><li><strong>字符设备</strong>: 传输速率较慢, 不可寻址, 在输入&#x2F;输出时常采用<strong>中断驱动方式</strong><ul><li>鼠标、键盘等 – <strong>数据传输的基本单位是字符</strong></li><li>中断驱动方式: 一种I&#x2F;O控制方式</li></ul></li></ul></li></ul><h2 id="2-IO控制器"><a href="#2-IO控制器" class="headerlink" title="2. IO控制器"></a><strong>2. IO控制器</strong></h2><h3 id="2-1-I-O设备的组成"><a href="#2-1-I-O设备的组成" class="headerlink" title="2.1 I&#x2F;O设备的组成"></a>2.1 <strong>I&#x2F;O设备的组成</strong></h3><ul><li><strong>机械部件</strong><ul><li>I&#x2F;O设备的机械部件主要用来执行具体I&#x2F;O操作</li><li>如我们看得见摸得着的鼠标&#x2F;键盘的按钮; 显示器的LED屏; 移动硬盘的磁臂、磁盘盘面</li></ul></li><li><strong>电子部件</strong>(I&#x2F;O控制器, 又称设备控制器)<ul><li>I&#x2F;O设备的电子部件通常是一块插入主板扩充槽的印刷电路板</li></ul></li></ul><h3 id="2-2-I-O控制器的主要功能"><a href="#2-2-I-O控制器的主要功能" class="headerlink" title="2.2 I&#x2F;O控制器的主要功能"></a>2.2 <strong>I&#x2F;O控制器的主要功能</strong></h3><ul><li><p>CPU无法直接控制I&#x2F;O设备的机械部件, 因此I&#x2F;O设备还要有一个电子部件作为CPU和I&#x2F;O设备部件之间的”中介”, <strong>用于实现CPU对设备的控制</strong></p></li><li><p>这个电子部件就是<strong>I&#x2F;O控制器</strong>, CPU可控制I&#x2F;O控制器, 又由I&#x2F;O控制器来控制设备的机械部件</p></li><li><p><strong>主要功能</strong>:</p><ul><li>接受和识别CPU发出的命令<ul><li>如CPU发来的read&#x2F;write命令, I&#x2F;O控制器中会有相应的<strong>控制寄存器</strong>来存放命令和参数</li></ul></li><li>向CPU报告设备的状态<ul><li>I&#x2F;O控制器中会有相应的<strong>状态寄存器</strong>用于记录I&#x2F;O设备的当前状态</li><li>如: 1表示空闲, 0表示忙碌</li></ul></li><li>数据交换<ul><li>I&#x2F;O控制器中会设置相应的<strong>数据寄存器</strong>。输出时, 数据寄存器用于暂存CPU发来的数据, 之后再由控制器传送设备; 输入时, 数据寄存器用于暂存设备发来的数据, 之后CPU从数据寄存器中取走数据</li></ul></li><li>地址识别<ul><li>类似于内存的地址, 为了区分设备控制器中的各个寄存器, 也需要给各个寄存器设置一个特定的”地址”。I&#x2F;O控制器通过CPU提供的”地址”来判断CPU要读&#x2F;写的是哪个寄存器</li></ul></li></ul></li></ul><h3 id="2-3-I-O控制器的组成"><a href="#2-3-I-O控制器的组成" class="headerlink" title="2.3 I&#x2F;O控制器的组成"></a>2.3 <strong>I&#x2F;O控制器的组成</strong></h3><ul><li>值得注意的小细节:<ul><li>一个I&#x2F;O控制器可能会对应多个设备</li><li>数据寄存器、控制寄存器、状态寄存器可能有多个(如: 每个控制&#x2F;状态寄存器对应一个具体的设备), 且这些寄存器都要有相应的地址, 才能方便CPU操作。有的计算机会让这些寄存器占用内存地址的一部分, 称为<strong>内存映像I&#x2F;O</strong>; 另一些计算机则采用I&#x2F;O专用地址, 即<strong>寄存器独立编址</strong></li></ul></li></ul><h3 id="2-4-两种寄存器编址方式"><a href="#2-4-两种寄存器编址方式" class="headerlink" title="2.4 两种寄存器编址方式"></a>2.4 <strong>两种寄存器编址方式</strong></h3><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-1-IO%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0/image-20241121222917201.png"></p><h2 id="3-IO控制方式"><a href="#3-IO控制方式" class="headerlink" title="3. IO控制方式"></a><strong>3. IO控制方式</strong></h2><ul><li>需要注意的问题:<ul><li>完成一次读&#x2F;写操作的流程</li><li>CPU干预的频率 </li><li>数据传送的单位</li><li>数据的流向</li><li>主要缺点和主要优点</li></ul></li></ul><h3 id="3-1-程序直接控制方式"><a href="#3-1-程序直接控制方式" class="headerlink" title="3.1 程序直接控制方式"></a>3.1 <strong>程序直接控制方式</strong></h3><ul><li><p>完成一次读&#x2F;写操作的流程(以读操作为例):</p><ul><li><p>CPU通过控制线向控制器发出读指令, 于是设备启动, 并且状态寄存器设为1(未就绪)</p></li><li><p><strong>轮询</strong>检查控制器的状态(其实就是在不断地执行程序的循环, 若状态位一直是1, 说明设备还没准备好要输入的数据, 于是CPU会不断地轮询)</p></li><li><p>输入设备准备好数据后将数据传给控制器, 并报告自身状态</p></li><li><p>控制器将输入的数据放到数据寄存器中, 并将状态改为0(已就绪)</p></li><li><p>CPU发现设备已就绪, 即可将数据寄存器中的内容读入CPU的寄存器中, 再把CPU寄存器中的内容放入内存</p></li><li><p>若还要继续读入数据, 则CPU继续发出读指令</p></li></ul></li><li><p>CPU干预的频率</p><ul><li>很频繁, I&#x2F;O操作开始之前、完成之后需要CPU的介入, 并且在等待I&#x2F;O完成的过程中CPU需要不断地轮询检查</li></ul></li><li><p>数据传送的单元</p><ul><li>每次读&#x2F;写一个<strong>字</strong></li></ul></li><li><p>数据的流向</p><ul><li><p>读操作(数据输入): I&#x2F;O设备 → CPU(指的是CPU的寄存器) → 内存</p></li><li><p>写操作(数据输出): 内存 → CPU → I&#x2F;O设备</p></li><li><p>每个字的读&#x2F;写都需要CPU的帮助</p></li></ul></li><li><p>主要缺点和主要优点</p><ul><li><p>优点: 实现简单。在读&#x2F;写指令之后, 加上实现循环检查的一系列指令即可(因此才称为”<strong>程序直接控制方式</strong>“)</p></li><li><p>缺点: CPU和I&#x2F;O设备只能串行工作, CPU需要一直轮询检查, 长期处于”忙等”状态, CPU利用率低</p></li></ul></li></ul><h3 id="3-2-中断驱动方式"><a href="#3-2-中断驱动方式" class="headerlink" title="3.2 中断驱动方式"></a>3.2 <strong>中断驱动方式</strong></h3><ul><li><p>完成一次读&#x2F;写操作的流程(以读操作为例):</p><ul><li><p>引入<strong>中断</strong>机制。由于I&#x2F;O设备速度很慢, 因此在CPU发出读&#x2F;写命令后, 可将等待I&#x2F;O的进程阻塞, 先切换到别的进程执行</p></li><li><p>当I&#x2F;O完成后, 控制器会向CPU发出一个中断信号, CPU检测到中断信号后, 会保存当前进程的运行环境信息, 转去执行中断处理程序处理该中断</p></li><li><p>处理中断的过程中, CPU从I&#x2F;O控制器读一个字的数据传送到CPU寄存器, 再写入主存</p></li><li><p>接着, CPU恢复等待I&#x2F;O的进程(或其他进程)的运行环境, 然后继续执行</p></li></ul></li><li><p>注意:</p><ul><li><p>CPU会在每个指令周期的末尾检查中断</p></li><li><p>中断处理过程中需要保存、恢复进程的运行环境, 这个过程是需要一定时间开销的。可见, 如果中断发生的频率太高, 也会降低系统性能</p></li></ul></li><li><p>CPU干预的频率</p><ul><li><p>每次I&#x2F;O操作开始之前、完成之后需要CPU的介入</p></li><li><p>等待I&#x2F;O完成的过程中CPU可以切换到别的进程执行</p></li></ul></li><li><p>数据传送的单元</p><ul><li>每次读&#x2F;写一个<strong>字</strong></li></ul></li><li><p>数据的流向</p><ul><li><p>读操作(数据输入): I&#x2F;O设备 → CPU(指的是CPU的寄存器) → 内存</p></li><li><p>写操作(数据输出): 内存 → CPU → I&#x2F;O设备</p></li></ul></li><li><p>主要缺点和主要优点</p><ul><li><p>优点: 与”程序直接控制方式”相比, 在”中断驱动方式”中, I&#x2F;O控制器会通过中断信号主动报告I&#x2F;O已完成, CPU不再需要不停地轮询。CPU和I&#x2F;O设备可并行工作, CPU利用率得到明显提升</p></li><li><p>缺点: 每个字在I&#x2F;O设备与内存之间的传输, 都需要经过CPU, 而频繁的中断处理会消耗较多的CPU时间</p></li></ul></li></ul><h3 id="3-3-DMA方式-Direct-Memory-Access-直接存储器存取"><a href="#3-3-DMA方式-Direct-Memory-Access-直接存储器存取" class="headerlink" title="3.3 DMA方式(Direct Memory Access, 直接存储器存取)"></a>3.3 <strong>DMA方式(Direct Memory Access, 直接存储器存取)</strong></h3><ul><li><p>完成一次读&#x2F;写操作的流程(以读操作为例):</p><ul><li><p>与”中断驱动方式相比”, <strong>DMA方式</strong>(主要用于块设备的I&#x2F;O控制)有这样几个改进:</p><ul><li><p>数据的传送单位是”块”, 不再是一个字、一个字的传送</p></li><li><p>数据的流向是从设备直接放入内存, 或者从内存直接到设备, 不再需要CPU作为”快递小哥”</p></li><li><p>仅在传送一个或多个数据块的开始和结束时, 才需要CPU干预</p></li></ul></li></ul></li><li><p>CPU干预的频率</p><ul><li>仅在传送一个或多个数据块的开始和结束时, 才需要CPU干预</li></ul></li><li><p>数据传送的单元</p><ul><li><p>每次读&#x2F;写一个或多个<strong>块</strong></p><ul><li>注意: 每次读写的只能是连续的多个块, 且这些块读入内存后在内存中也必须是连续的</li></ul></li></ul></li><li><p>数据的流向(不再需要经过CPU)</p><ul><li><p>读操作(数据输入): I&#x2F;O设备 → 内存</p></li><li><p>写操作(数据输出): 内存 → I&#x2F;O设备</p></li></ul></li><li><p>主要缺点和主要优点</p><ul><li><p>优点: 数据传输以”块”为单位, CPU介入频率进一步降低。数据的传输不再需要先经过CPU再写入内存, 数据传输效率进一步增加, CPU和I&#x2F;O设备的并行性得到提升</p></li><li><p>缺点: CPU每发出一条I&#x2F;O指令, 只能读&#x2F;写一个或多个连续的数据块。如果要读&#x2F;写多个离散存储的数据块, 或者要将数据分别写到不同的内存区域时, CPU要分别发出多条I&#x2F;O指令, 进行多次中断处理才能完成</p></li></ul></li></ul><h3 id="3-4-通道控制方式"><a href="#3-4-通道控制方式" class="headerlink" title="3.4 通道控制方式"></a>3.4 <strong>通道控制方式</strong></h3><ul><li><strong>通道</strong>: 一种硬件, 可以理解为是”弱鸡版的CPU”, 通道可以识别并执行一系列<strong>通道指令</strong><ul><li><p>与CPU相比, 通道可以执行的指令很单一, 并且通道程序是放在主机内存中的, 也就是说通道与CPU共享内存</p></li><li><p>一个通道可以控制多个I&#x2F;O控制器, 一个I&#x2F;O控制器可以控制多个I&#x2F;O设备</p></li></ul></li><li>完成一次读&#x2F;写操作的流程(以读操作为例):</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-1-IO%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0/image-20241122102849425.png"></p><ul><li>CPU干预的频率<ul><li>极低, 通道会根据CPU的指示执行相应的通道程序, 只有完成一组数据库的读&#x2F;写后才需要发出中断信号, 请求CPU干预</li></ul></li><li>数据传送的单元<ul><li>每次读&#x2F;写<strong>一组数据块</strong></li></ul></li><li>数据的流向(在通道的控制下进行)<ul><li>读操作(数据输入): I&#x2F;O设备 → 内存</li><li>写操作(数据输出): 内存 → I&#x2F;O设备</li></ul></li><li>主要缺点和主要优点<ul><li>优点: CPU、通道、I&#x2F;O设备可并行工作, 资源利用率很高</li><li>缺点: 实现复杂, 需要专门的通道硬件支持</li></ul></li></ul><h2 id="4-IO软件层次结构"><a href="#4-IO软件层次结构" class="headerlink" title="4. IO软件层次结构"></a><strong>4. IO软件层次结构</strong></h2><h3 id="4-1-用户层软件"><a href="#4-1-用户层软件" class="headerlink" title="4.1 用户层软件"></a>4.1 <strong>用户层软件</strong></h3><ul><li><p>用户层软件实现了与用户交互的接口, 用户可直接使用该层提供的、与I&#x2F;O操作相关的<strong>库函数</strong>对设备进行操作</p><ul><li>Eg: printf(“hello, world!”);</li></ul></li><li><p>用户层软件将用户请求翻译成格式化的I&#x2F;O请求, 并通过”系统调用”请求操作系统内核的服务</p><ul><li>Eg: printf(“hello world!”); 会被翻译成等价的write系统调用, 当然, 用户层软件也会在系统调用时填入相应参数</li></ul></li><li><p>Windows操作系统向外提供了一系列系统调用, 但是由于系统调用的格式严格, 使用麻烦, 因此在用户层上封装了一系列更方便的库函数接口供用户使用(<strong>WIndows API</strong>)</p></li></ul><h3 id="4-2-设备独立性软件-设备无关性软件"><a href="#4-2-设备独立性软件-设备无关性软件" class="headerlink" title="4.2 设备独立性软件(设备无关性软件)"></a>4.2 <strong>设备独立性软件(设备无关性软件)</strong></h3><ul><li><p>与设备的硬件特性无关的功能几乎都在这一层实现</p></li><li><p>主要实现功能:</p><ul><li>向上层提供统一的调用接口(如 read&#x2F;write <strong>系统调用</strong>)</li><li>设备的保护<ul><li>原理类似于文件保护, <strong>设备被看做是一种特殊的文件</strong>, 不同用户对各个文件的访问权限是不一样的, 同理, 对设备的访问权限也不一样</li></ul></li><li>差错处理<ul><li>设备独立性软件需要对一些设备的错误进行处理</li></ul></li><li>设备的分配与回收</li><li>数据缓冲区管理<ul><li>可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异</li></ul></li><li><strong>建立逻辑设备名到物理设备名的映射关系</strong>; 根据设备类型选择调用相应的<strong>驱动程序</strong><ul><li>用户或用户层软件发出I&#x2F;O操作相关的系统调用时, 需要指明这次要操作的I&#x2F;O设备的<strong>逻辑设备名</strong><ul><li>Eg: 去学校打印店打印时, 需要选择打印机1&#x2F;打印机2&#x2F;打印机3, 其实这些都是逻辑设备名</li></ul></li><li><strong>设备独立性软件</strong>需要通过”<strong>逻辑设备表(LUT, Logical Unit Table)</strong>“来确定<strong>逻辑设备</strong>对应的<strong>物理设备</strong>, 并找到该设备对应的<strong>设备驱动程序</strong> </li><li>操作系统可以采用两种方式管理<strong>逻辑设备表(LUT)</strong>:<ul><li>第一种方式, <strong>整个系统只设置一张LUT</strong>, 这就意味着所有用户不能使用相同的逻辑设备名,因此这种方式<strong>只适用于单用户操作系统</strong></li><li>第二种方式, <strong>为每个用户设置一张LUT</strong>, 各个用户使用的逻辑设备名可以重复, <strong>适用于多用户操作系统</strong>, 系统会在用户登录时为其建立一个用户管理进程, 而LUT就存放在用户管理进程的PCB中</li></ul></li><li><strong>为什么不同类型的I&#x2F;O设备需要有不同的驱动程序处理?</strong><ul><li>各式各样的设备, 外形不同, 其内部的电子部件(I&#x2F;O控制器)也有可能不同<ul><li>如状态寄存器判断是否忙碌的标志位不同, 有的设备用1表示忙碌, 而有的用0表示忙碌</li></ul></li><li>不同设备的内部硬件特性也不同, 这些特性只有厂家才知道, 因此厂家须提供与设备相对应的驱动程序, CPU执行驱动程序的指令序列, 来完成设置设备寄存器、检查设备状态等工作</li></ul></li></ul></li></ul></li></ul><h3 id="4-3-设备驱动程序"><a href="#4-3-设备驱动程序" class="headerlink" title="4.3 设备驱动程序"></a>4.3 <strong>设备驱动程序</strong></h3><ul><li>主要负责<strong>对硬件设备的具体控制</strong>, 将上层发出的一系列命令(如 read&#x2F;write)转化为特定设备”能听得懂”的一系列操作, 包括设置设备寄存器、检查设备状态等<ul><li>注: 驱动程序一般会以一个独立进程的方式存在</li></ul></li></ul><h3 id="4-4-中断处理程序"><a href="#4-4-中断处理程序" class="headerlink" title="4.4 中断处理程序"></a>4.4 <strong>中断处理程序</strong></h3><ul><li><p>当I&#x2F;O任务完成时, I&#x2F;O控制器会发送一个<strong>中断信号</strong>, 系统会根据<strong>中断信号类型</strong>找到相应的<strong>中断处理程序</strong>并执行</p></li><li><p>中断处理程序的处理流程如下:</p></li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-1-IO%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0/image-20241122103237525.png"></p><ul><li>可见, <strong>中断处理程序也会和硬件直接打交道</strong></li></ul><h3 id="5-输入-输出应用程序接口-驱动程序接口"><a href="#5-输入-输出应用程序接口-驱动程序接口" class="headerlink" title="5. 输入&#x2F;输出应用程序接口&amp;驱动程序接口"></a><strong>5. 输入&#x2F;输出应用程序接口&amp;驱动程序接口</strong></h3><h3 id="5-1-输入-输出应用程序接口"><a href="#5-1-输入-输出应用程序接口" class="headerlink" title="5.1 输入&#x2F;输出应用程序接口"></a>5.1 <strong>输入&#x2F;输出应用程序接口</strong></h3><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-1-IO%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0/image-20241122103326548.png"></p><ul><li>网络设备接口示例:</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-1-IO%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0/image-20241122103351593.png"></p><h3 id="5-2-阻塞-非阻塞-I-O"><a href="#5-2-阻塞-非阻塞-I-O" class="headerlink" title="5.2 阻塞&#x2F;非阻塞 I&#x2F;O"></a>5.2 <strong>阻塞&#x2F;非阻塞 I&#x2F;O</strong></h3><ul><li><strong>阻塞I&#x2F;O</strong>: 应用程序发出I&#x2F;O系统调用, <strong>进程需转为阻塞态等待</strong><ul><li>Eg: 字符设备接口 – 从键盘读一个字符(get系统调用)</li></ul></li><li><strong>非阻塞I&#x2F;O</strong>: 应用程序发出I&#x2F;O系统调用, 系统调用可迅速返回, <strong>进程无需阻塞等待</strong><ul><li>Eg: 块设备接口 – 往磁盘写数据(write系统调用)</li></ul></li></ul><h3 id="5-3-设备驱动程序接口"><a href="#5-3-设备驱动程序接口" class="headerlink" title="5.3 设备驱动程序接口"></a>5.3 <strong>设备驱动程序接口</strong></h3><ul><li><p>若各公司开发的设备驱动程序接口不统一, 则操作系统很难调用设备驱动程序</p></li><li><p><strong>统一标准的设备驱动程序接口</strong></p><ul><li>操作系统规定好设备驱动程序的接口标准, 各厂商按要求开发设备驱动程序</li><li>不同的操作系统, 对设备驱动程序接口的标准各不相同, 设备厂商必须根据操作系统的接口要求,开发相应的设备驱动程序, 设备才能被使用</li></ul></li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-1-IO%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0/image-20241122103448322.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.2 文件系统</title>
    <link href="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="4-2-文件系统的结构与虚拟文件系统"><a href="#4-2-文件系统的结构与虚拟文件系统" class="headerlink" title="4.2 文件系统的结构与虚拟文件系统"></a><strong>4.2 文件系统的结构与虚拟文件系统</strong></h1><h2 id="1-文件系统的层次结构-了解即可"><a href="#1-文件系统的层次结构-了解即可" class="headerlink" title="1. 文件系统的层次结构(了解即可)"></a><strong>1. 文件系统的层次结构(了解即可)</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20241121221253104.png"></p><ul><li>用一个例子来辅助记忆文件系统的层次结构：<ul><li>假设某用户请求删除文件“D:&#x2F;工作目录&#x2F;学生信息.xIsx”的最后100条记录<ul><li>1. 用户需要通过操作系统提供的接口发出上述请求 – <strong>用户接口</strong><ul><li>文件的基本操作 章节相关内容</li></ul></li><li>2. 由于用户提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项 – <strong>文件目录系统</strong><ul><li>文件目录 章节相关内容</li></ul></li><li>3. 不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限– <strong>存取控制模块(存取控制验证层)</strong><ul><li>文件保护 章节相关内容</li></ul></li><li>4. 验证了用户的访问权限之后，需要把用户提供的“记录号”转变为对应的逻辑地址 – <strong>逻辑文件系统与文件信息缓冲区</strong><ul><li>文件的逻辑结构 章节相关内容</li></ul></li><li>5. 知道了目标记录对应的逻辑地址后，还需要转换成实际的物理地址 – <strong>物理文件系统</strong><ul><li>文件的物理结构 章节相关内容</li></ul></li><li>6. 要删除这条记录，必定要对磁盘设备发出请求 – <strong>设备管理程序模块</strong><ul><li>设备管理 章节相关内容</li></ul></li><li>7. 删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收 – <strong>辅助分配模块</strong><ul><li>文件存储空间管理 章节相关内容</li></ul></li></ul></li></ul></li></ul><h2 id="2-文件系统的全局结构-布局"><a href="#2-文件系统的全局结构-布局" class="headerlink" title="2. 文件系统的全局结构(布局)"></a><strong>2. 文件系统的全局结构(布局)</strong></h2><h3 id="2-1-磁盘出厂到文件系统建立的过程"><a href="#2-1-磁盘出厂到文件系统建立的过程" class="headerlink" title="2.1 磁盘出厂到文件系统建立的过程:"></a>2.1 <strong>磁盘出厂到文件系统建立的过程</strong>:</h3><p>1. <strong>原始磁盘</strong></p><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20241121221040188.png"></p><p> 2. <strong>低级格式化(物理格式化)</strong></p><ul><li>划分扇区，检测坏扇区，并用备用扇区替换坏扇区</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20241121221355176.png"></p><p>3. <strong>磁盘分区(分卷，Volume)</strong></p><ul><li>将磁盘分区, 每个分区由若干柱面组成(即分为我们熟悉的 C盘、D盘、E盘)</li></ul><p>4. <strong>逻辑格式化</strong></p><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20241121221453868.png"></p><ul><li><p>完成各分区的文件系统初始化</p></li><li><p>i结点区 ：索引结点存放区域</p></li><li><p>注：逻辑格式化后，灰色部分就有实际数据了，白色部分还没有数据</p></li></ul><h3 id="2-2-文件系统在内存中的结构"><a href="#2-2-文件系统在内存中的结构" class="headerlink" title="2.2 文件系统在内存中的结构"></a>2.2 <strong>文件系统在内存中的结构</strong></h3><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20241121221632779.png"></p><h3 id="2-3-open-系统调用打开文件背后的过程"><a href="#2-3-open-系统调用打开文件背后的过程" class="headerlink" title="2.3 open 系统调用打开文件背后的过程"></a>2.3 <strong>open 系统调用打开文件背后的过程</strong></h3><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20241121221732613.png"></p><h2 id="3-虚拟文件系统-文件系统挂载-安装"><a href="#3-虚拟文件系统-文件系统挂载-安装" class="headerlink" title="3. 虚拟文件系统&amp;文件系统挂载(安装)"></a><strong>3. 虚拟文件系统&amp;文件系统挂载(安装)</strong></h2><h3 id="3-1-普通的文件系统"><a href="#3-1-普通的文件系统" class="headerlink" title="3.1 普通的文件系统"></a>3.1 <strong>普通的文件系统</strong></h3><ul><li>不同的存储设备中的文件系统有可能是不同的，提供的系统调用接口也不同</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20241121221942018.png"></p><h3 id="3-2-虚拟文件系统（VFS）"><a href="#3-2-虚拟文件系统（VFS）" class="headerlink" title="3.2 虚拟文件系统（VFS）"></a>3.2 <strong>虚拟文件系统（VFS）</strong></h3><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20241121222033809.png"></p><ul><li><p><strong>虚拟文件系统的特点</strong>:</p><ul><li>向上层用户进程提供统一标准的系统调用接口，屏蔽底层具体文件系统的实现差异</li><li><strong>VFS</strong>要求下层的文件系统必须实现某些规定的函数功能，一个新的文件系统想要在某操作系统上被使用，就必须满足该操作系统VFS的要求<ul><li>如：open&#x2F;read&#x2F;write</li></ul></li><li>每打开一个文件，<strong>VFS</strong>就在主存中新建一个<strong>vnode</strong>，用统一的数据结构表示文件，无论该文件存储在哪个文件系统</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20241121222254313.png"></p><ul><li><p>存在的问题：不同的文件系统，表示文件数据结构各不相同。打开文件后，其在内存中的表示就不同 </p><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20241121222313706.png"></p><ul><li>注意：<strong>vnode</strong>只存在于主存中，而<strong>inode</strong>既会被调入主存，也会在外存中存储</li></ul></li><li><p>打开文件后，创建<strong>vnode</strong>，并将文件信息复制到vnode中，vnode的功能指针指向具体文件系统的函数功能</p></li></ul></li></ul><h3 id="3-3-文件系统挂载（mounting）"><a href="#3-3-文件系统挂载（mounting）" class="headerlink" title="3.3 文件系统挂载（mounting）"></a>3.3 <strong>文件系统挂载（mounting）</strong></h3><ul><li>即文件系统安装&#x2F;装载 – 如何将一个文件系统挂载到操作系统中？<ul><li>文件系统挂载要做的事:<ul><li>在<strong>VFS</strong>中注册新挂载的文件系统，<strong>内存中的挂载表（mounting table）</strong>包含每个文件系统的相关信息，包含文件系统类型、容量大小等</li><li>新挂载的文件系统，要向<strong>VFS</strong>提供一个<strong>函数地址列表</strong></li><li>将新文件系统加到<strong>挂载点</strong>（mount point），也就是将新文件系统挂载在某个父目录下</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第四章 文件管理-4.1 文件系统基础</title>
    <link href="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-1-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-1-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="4-1-文件系统"><a href="#4-1-文件系统" class="headerlink" title="4.1 文件系统"></a><strong>4.1 文件系统</strong></h1><h2 id="1-初始文件管理"><a href="#1-初始文件管理" class="headerlink" title="1. 初始文件管理"></a><strong>1. 初始文件管理</strong></h2><ul><li><strong>文件</strong>：<strong>一组有意义的信息&#x2F;数据集合</strong></li></ul><h3 id="1-1-文件管理"><a href="#1-1-文件管理" class="headerlink" title="1.1 文件管理"></a>1.1 <strong>文件管理</strong></h3><ul><li><p>计算机中存放了各种各样的文件，一个<strong>文件有哪些属性</strong>？</p></li><li><p><strong>文件内部的数据应该怎样组织起来</strong>？</p></li><li><p><strong>文件之间又应该又应该怎么组织起来</strong>？</p></li><li><p>计算机系统的层次结构从下往上看，<strong>OS应提供哪些功能，才能方便用户、应用程序使用文件</strong>？</p></li><li><p>计算机系统的层次结构从上往下看，<strong>文件数据应该怎么存放在外存（磁盘）上</strong>？</p></li><li><p><strong>如何实现文件的共享和保护</strong></p></li></ul><h3 id="1-2-文件的属性"><a href="#1-2-文件的属性" class="headerlink" title="1.2 文件的属性"></a>1.2 <strong>文件的属性</strong></h3><ul><li><p><strong>文件名</strong></p><ul><li>由创建文件的用户决定文件名，主要是为了方便用户找到文件，<strong>同一目录下不允许有重名文件</strong></li></ul></li><li><p><strong>标识符</strong></p><ul><li>一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称</li></ul></li><li><p><strong>类型</strong></p><ul><li>指明文件的类型位置：文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，对用户不可见）</li></ul></li><li><p><strong>大小</strong></p><ul><li>指明文件大小</li></ul></li><li><p><strong>创建时间</strong>、<strong>上次修改时间</strong></p></li><li><p><strong>文件所有者信息</strong></p></li><li><p><strong>保护信息</strong></p><ul><li>对文件进行保护的访问控制信息</li></ul></li></ul><h3 id="1-3-文件内部的数据应该怎样组织起来？"><a href="#1-3-文件内部的数据应该怎样组织起来？" class="headerlink" title="1.3 文件内部的数据应该怎样组织起来？"></a>1.3 <strong>文件内部的数据应该怎样组织起来？</strong></h3><ul><li><strong>无结构文件</strong>（如文本文件）– 由一些二进制或字符流组成，又称“<strong>流式文件</strong>”</li><li><strong>有结构文件</strong>（如数据库表）– 由一组相似的<strong>记录</strong>组成，又称“<strong>记录式文件</strong>”<ul><li><strong>记录</strong>是一组相关<strong>数据项</strong>的集合<ul><li><strong>数据项</strong>是文件系统中最基本的数据单位</li></ul></li><li><strong>有结构文件</strong>中，<strong>各个记录间应该如何组织</strong>的问题<ul><li>应该顺序存放？还是用索引表来表示记录间的顺序？– 这是“<strong>文件的逻辑结构</strong>”重点要探讨的问题</li></ul></li></ul></li></ul><h3 id="1-4-文件之间应该怎样组织起来？"><a href="#1-4-文件之间应该怎样组织起来？" class="headerlink" title="1.4 文件之间应该怎样组织起来？"></a>1.4 <strong>文件之间应该怎样组织起来？</strong></h3><ul><li>用户可以自己创建一层一层的<strong>目录</strong>，各层目录中存放相应的<strong>文件</strong>。<strong>系统中的各个文件就通过一层一层的目录合理有序的组织起来了</strong><ul><li>所谓的“<strong>目录</strong>”其实就是我们熟悉的“<strong>文件夹</strong>”</li><li><strong>目录</strong>其实也<strong>是一种特殊的有结构文件（由记录组成）</strong>，如何实现<strong>文件目录</strong>是之后会重点探讨的问题</li></ul></li></ul><h3 id="1-5-操作系统应该向上提供哪些功能？"><a href="#1-5-操作系统应该向上提供哪些功能？" class="headerlink" title="1.5 操作系统应该向上提供哪些功能？"></a>1.5 <strong>操作系统应该向上提供哪些功能？</strong></h3><ul><li><p>可以“<strong>创建文件</strong>”（点击新建后，图形化交互进程在背后调用了“<strong>create 系统调用</strong>”）</p></li><li><p>可以<strong>“删除文件</strong>”（点击删除后，图形化交互进程在背后调用了”<strong>delete 系统调用</strong>“，将文件数据从外存中删除）</p></li><li><p>可以“<strong>读文件</strong>”，将文件数据读入内存，才能让CPU处理（双击后，“记事本”应用程序通过操作系统提供的“<strong>read 系统调用</strong>”，将文件数据从外存读入内存，并显示在屏幕上）</p></li><li><p>可以“<strong>写文件</strong>”，将更改过的文件数据写回外存（在“记事本”应用程序中编辑文件内容，点击“保存”后，“记事本”应用程序通过操作系统提供的“<strong>write 系统调用</strong>”，将文件数据从内存写回外存）</p></li><li><p>读&#x2F;写文件之前，需要通过操作系统提供的”<strong>open 系统调用</strong>“来“<strong>打开文件</strong>”</p></li><li><p>读&#x2F;写文件结束之后，需要通过操作系统提供的”<strong>close 系统调用</strong>“来“<strong>关闭文件</strong>”</p></li><li><p>可用几个基本操作完成更复杂的操作</p><ul><li>比如：“复制文件”：先创建一个新的空文件，再把源文件读入内存，再将内存中的数据写到新文件中</li></ul></li></ul><h3 id="1-6-从上往下看，文件应如何存放在外存？"><a href="#1-6-从上往下看，文件应如何存放在外存？" class="headerlink" title="1.6 从上往下看，文件应如何存放在外存？"></a>1.6 <strong>从上往下看，文件应如何存放在外存？</strong></h3><ul><li><strong>外存的结构</strong><ul><li>与内存一样，<strong>外存</strong>也是由一个个<strong>存储单元</strong>组成的，每个存储单元可以存储一定量的数据 （如1B）<ul><li><strong>每个存储单元对应一个物理地址</strong></li></ul></li><li>类似于内存分为一个个“内存块”，<strong>外存</strong>会分为一个个“<strong>块&#x2F;磁盘块&#x2F;物理块</strong>”。<strong>每个磁盘块的大小是相等的，每块一般包含2的整数幂个地址</strong>（如本例中，一块包含 2<sup>10</sup> 个地址，即 1KB）。同样类似的是，<strong>文件的逻辑地址</strong>也可以分为<strong>（逻辑块号，块内地址）</strong>，操作系统同样需要将<strong>逻辑地址转换为外存的物理地址（物理块号，块内地址）</strong>的形式。<strong>块内地址的位数取决于磁盘块的大小</strong></li><li><strong>操作系统以“块”为单位为文件分配存储空间</strong>，因此即使一个文件大小只有10B，但它依然需要占用 1KB 的磁盘块。<strong>外存中的数据读入内存时同样以块为单位</strong></li></ul></li><li><strong>文件应如何存放在外存？</strong><ul><li>文件数据放在连续的几个磁盘块中？</li><li>文件数据放在离散的几个磁盘块中？此时，应该如何记录各个磁盘块之间的先后顺序呢？</li><li>操作系统又应该怎么管理空闲磁盘块？</li><li>这些都是“<strong>文件的物理结构</strong>”部分会探讨的内容</li></ul></li></ul><h3 id="1-7-其他需要由操作系统实现的文件管理功能"><a href="#1-7-其他需要由操作系统实现的文件管理功能" class="headerlink" title="1.7 其他需要由操作系统实现的文件管理功能"></a>1.7 <strong>其他需要由操作系统实现的文件管理功能</strong></h3><ul><li><strong>文件共享</strong>：使多个用户可以共享使用一个文件</li><li><strong>文件保护</strong>：如何保证不同的用户对文件有不同的操作权限</li></ul><h2 id="2-文件的逻辑结构"><a href="#2-文件的逻辑结构" class="headerlink" title="2. 文件的逻辑结构"></a><strong>2. 文件的逻辑结构</strong></h2><ul><li><p>“<strong>逻辑结构</strong>”：就是指在用户看来，文件内部的数据应该是如何组织起来的</p></li><li><p>“<strong>物理结构</strong>”：指的是在操作系统看来，文件的数据是如何存放在外存中的</p><ul><li>类似于数据结构的“逻辑结构”和“物理结构”</li><li>如“线性表”就是一种逻辑结构，在用户角度看来，线性表就是一组有先后关系的元素序列，如：a, b, c, d, e ……</li><li>“线性表”这种逻辑结构可以用不同的物理结构实现，如：顺序表&#x2F;链表。顺序表的各个元素在逻辑上相邻，在物理上也相邻；而链表的各个元素在物理上可以是不相邻的。因此，顺序表可以实现“随机访问”，而“链表”无法实现随机访问</li><li>可见，算法的具体实现与逻辑结构、物理结构都有关（文件也一样，文件操作的具体实现与文件的逻辑结构、物理结构都有关）</li></ul></li><li><p>按文件是否有结构分类，可以分为<strong>无结构文件</strong>、<strong>有结构文件</strong>两种</p></li></ul><h3 id="2-1-无结构文件"><a href="#2-1-无结构文件" class="headerlink" title="2.1 无结构文件"></a>2.1 <strong>无结构文件</strong></h3><ul><li><p><strong>文件内部的数据就是一系列二进制流或字符流组成</strong>。又称“<strong>流式文件</strong>”</p></li><li><p>如：Windows 操作系统中的 .txt 文件，文件内部的数据其实就是一系列字符流，没有明显的结构特性。因此也不用探讨无结构文件的“逻辑结构”问题</p></li></ul><h3 id="2-2-有结构文件"><a href="#2-2-有结构文件" class="headerlink" title="2.2 有结构文件"></a>2.2 <strong>有结构文件</strong></h3><ul><li><p><strong>由一组相似的记录组成</strong>，又称“<strong>记录式文件</strong>”。每条<strong>记录</strong>又若干个<strong>数据项</strong>组成</p><ul><li>如：数据库表文件</li></ul></li><li><p>一般来说，每条<strong>记录</strong>有一个<strong>数据项</strong>可作为<strong>关键字</strong>（作为识别不同记录的ID）</p></li><li><p>根据各条记录的长度（占用的存储空间）是否相等，又可分为<strong>定长记录</strong>和<strong>可变长记录</strong>两种</p></li><li><p><strong>有结构文件的逻辑结构</strong>：根据有结构文件中的各条记录在逻辑上如何组织，可以分为三类</p><ul><li><strong>顺序文件</strong></li><li><strong>索引文件</strong></li><li><strong>索引顺序文件</strong></li></ul></li></ul><h3 id="2-3-顺序文件"><a href="#2-3-顺序文件" class="headerlink" title="2.3 顺序文件"></a>2.3 <strong>顺序文件</strong></h3><ul><li><p><strong>文件中的记录一个接一个地顺序排列（逻辑上）</strong>，<strong>记录</strong>可以是<strong>定长</strong>的或<strong>可变长</strong>的。各个记录在<strong>物理上</strong>可以<strong>顺序存储</strong>或<strong>链式存储</strong></p><ul><li><strong>顺序存储</strong>：逻辑上相邻的记录物理上也相邻（类似于顺序表）</li><li><strong>链式存储</strong>：逻辑上相邻的记录物理上不一定相邻（类似于链表）</li></ul></li><li><p><strong>顺序文件</strong>还可按<strong>记录之间的关键字顺序</strong>分为：</p><ul><li><strong>串结构</strong>：记录之间的顺序与关键字无关（通常按照记录存入的时间决定记录的顺序）</li><li><strong>顺序结构</strong>：记录之间的顺序按关键字顺序排列</li></ul></li><li><p><strong>思考</strong>:</p><ul><li><p>假设：已经知道了文件的起始地址（也就是第一个记录存放的位置）</p><ul><li>思考1：能否快速找到第 i 个记录对应的地址？（即能否实现随机存取）</li><li>思考2：能否快速找到某个关键字对应的记录存放的位置？</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-1-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20241121201519877.png"></p></li><li><p><strong>结论</strong>：定长记录的顺序文件，若物理上采用顺序存储，则可实现随机存取；若能再保证记录的顺序结构，则可实现快速检索（即根据关键字快速找到对应记录）</p><ul><li>注：一般来说，考试题目中所说的“顺序文件”指的是<strong>物理上顺序存储的顺序文件</strong>。之后的讲解中提到的顺序文件也默认如此。可见，顺序文件的<strong>缺点</strong>是<strong>增加&#x2F;删除一个记录比较困难</strong>（如果是串结构则相对简单）</li></ul></li></ul></li></ul><h3 id="2-4-索引文件"><a href="#2-4-索引文件" class="headerlink" title="2.4 索引文件"></a>2.4 <strong>索引文件</strong></h3><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-1-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20241121201802502.png"></p><ul><li><p>对于可变长记录文件，要找到第 i 个记录，必须先顺序第查找前 i-1 个记录，但是很多应用场景中又必须使用可变长记录。如何解决这个问题？</p></li><li><p><strong>索引表</strong>本身是<strong>定长记录的顺序文件</strong>。因此可以快速找到第 i 个记录对应的索引项</p></li><li><p>可将<strong>关键字作为索引号内容</strong>，若按关键字顺序排列，则还可以支持按照关键字折半查找</p></li><li><p>每当要增加&#x2F;删除一个记录时，需要对索引表进行修改。由于索引文件有很快的检索速度，因此主要<strong>用于对信息处理的及时性要求比较高的场合</strong></p></li><li><p>另外，可以用不同的数据项建立多个索引表</p><ul><li>如：学生信息表中，可用关键字“学号”建立一张索引表。也可用“姓名”建立一张索引表。这样就可以根据“姓名”快速地检索文件了</li><li>Eg：SQL 就支持根据某个数据项建立索引的功能</li></ul></li></ul><h3 id="2-5-索引顺序文件"><a href="#2-5-索引顺序文件" class="headerlink" title="2.5 索引顺序文件"></a>2.5 <strong>索引顺序文件</strong></h3><ul><li><p>思考<strong>索引文件</strong>的缺点：每个记录对应一个索引表项，因此索引表可能会很大</p><ul><li>比如：文件的每个记录平均只占 8B，而每个索引表项占32个字节，那么索引表都要比文件内容本身大4倍，这样对存储空间的利用率就太低了</li></ul></li><li><p><strong>索引顺序文件</strong>是索引文件和顺序文件思想的结合</p></li><li><p>索引顺序文件中，同样会为文件建立一张<strong>索引表</strong>，但不同的是：<strong>并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项</strong></p><ul><li>在本例中，学生记录按照学生姓名的开头字母进行分组。<strong>每个分组就是一个顺序文件，分组内的记录不需要按关键字排序</strong></li><li>用这种策略确实可以让索引表“瘦身”，但是是否会出现不定长记录的顺序文件检索速度慢的问题呢？<ul><li>若一个顺序文件有10000个记录，则根据关键字检索文件，只能从头开始顺序查找（这里指的并不是定长记录、顺序结构的顺序文件），平均须查找 5000 个记录</li><li>若采用索引顺序文件结构，可把 10000 个记录分为 √10000 &#x3D; 100 组，每组 100 个记录。则需要先顺序查找索引表找到分组（共100个分组，因此索引表长度为 100，平均需要查50 次），找到分组后，再在分组中顺序查找记录（每个分组100 个记录，因此平均需要查50 次）。可见，采用索引顺序文件结构后，平均查找次数减少为 50 + 50 &#x3D; 100 次</li><li>同理，若文件共有 10<sup>6</sup>个记录，则可分为 1000 个分组，每个分组 1000 个记录。根据关键字检索一个记录</li><li>平均需要查找 500 + 500 &#x3D; 1000 次。这个查找次数依然很多，如何解决呢？</li></ul></li></ul></li><li><p><strong>多级索引顺序文件</strong></p><ul><li>为了进一步提高检索效率，可以为顺序文件建立<strong>多级索引表</strong>。例如，对于一个含 10<sup>6</sup>个记录的文件，可先为该文件建立一张低级索引表，每 100 个记录为一组，故低级索引表中共有 10000个表项（即10000个定长记录），再把这 10000 个定长记录分组，每组100个，为其建立顶级索引表，故顶级索引表中共有 100 个表项</li></ul></li></ul><h2 id="3-文件目录"><a href="#3-文件目录" class="headerlink" title="3. 文件目录"></a><strong>3. 文件目录</strong></h2><ul><li><p>所谓<strong>文件目录</strong>就是我们很熟悉的 Windows 操作系统的“文件夹”</p></li><li><p>采用文件目录结构可以使文件之间的组织结构清晰，易于查找</p></li><li><p>编程时也可以很方便的用文件路径找到一个文件</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 如:</span><br>FILE *fp;<br>fp = fopen(“F:\data\myfile.dat”); <span class="hljs-comment">// 用户可以轻松实现“按名存取”</span><br></code></pre></td></tr></table></figure><h3 id="3-1-文件目录的实现"><a href="#3-1-文件目录的实现" class="headerlink" title="3.1 文件目录的实现"></a>3.1 <strong>文件目录的实现</strong></h3><ul><li><p>当我们双击“照片”后，操作系统会在这个<strong>目录表</strong>中找到关键字“照片”对应的<strong>目录项</strong>（也就是<strong>记录</strong>），然后从外存中将“照片”目录的信息读入内存，于是，“照片”目录中的内容就可以显示出来了</p></li><li><p>目录文件中一条一条的<strong>记录</strong>就是一个”<strong>文件控制块（FCB）</strong>“</p><ul><li>FCB 实现了文件名和文件之间的映射，使用户（用户程序）可以实现“按名存取”</li><li><strong>FCB 的有序集合称为“文件目录”</strong>，<strong>一个FCB就是一个文件目录项</strong></li><li>FCB 中包含了文件的基本信息（文件名、物理地址、逻辑结构、物理结构等），存取控制信息（是否可读&#x2F;可写、禁止访问的用户名单等），使用信息（如文件的建立时间、修改时间等）。最重要，最基本的还是<strong>文件名</strong>、<strong>文件存放的物理地址</strong></li></ul></li><li><p><strong>需要对目录进行哪些操作？</strong></p><ul><li>搜索：当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项</li><li>创建文件：创建一个新文件时，需要在其所属的目录中增加一个目录项</li><li>删除文件：当删除一个文件时，需要在目录中删除相应的目录项</li><li>显示目录：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性</li><li>修改目录：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项（如：文件重命名）</li></ul></li></ul><h3 id="3-2-目录结构"><a href="#3-2-目录结构" class="headerlink" title="3.2 目录结构"></a>3.2 <strong>目录结构</strong></h3><ul><li><strong>单级目录结构</strong><ul><li>早期操作系统并不支持多级目录，<strong>整个系统中只建立一张目录表，每个文件占一个目录项</strong></li><li>单级目录实现了“按名存取”，但是<strong>不允许文件重名</strong></li><li>在创建一个文件时，需要先检查目录表中有没有重名文件，确定不重名后才能允许建立文件，并将新文件对应的目录项插入目录表中</li><li>显然，单级目录结构不适用于多用户操作系统</li></ul></li><li><strong>两级目录结构</strong><ul><li>早期的多用户操作系统，采用<strong>两级目录结构</strong></li><li>分为<strong>主文件目录（MFD，Master File Directory）</strong>和<strong>用户文件目录（UFD，User Flie Directory）</strong></li></ul></li><li><strong>多级目录结构（树形目录结构）</strong><ul><li>用户（或用户进程）要访问某个文件时要用文件路径名标识文件，文件路径名是个字符串</li><li>各级目录之间用“&#x2F;”隔开。<strong>从根目录出发的路径</strong>称为<strong>绝对路径</strong><ul><li>例如：自拍.jpg 的绝对路径是 “&#x2F;照片&#x2F;2015-08&#x2F;自拍.jpg”</li><li>系统根据绝对路径一层一层地找到下一级目录<ul><li>刚开始<strong>从外存读入根目录的目录表</strong></li><li>找到“照片”目录的存放位置后，从外存读入对应的目录表</li><li>再找到“2015-08”目录的存放位置，再从外存读入对应目录表</li><li>最后才找到文件“自拍.jpg”的存放位置</li><li>整个过程需要3次读磁盘I&#x2F;O操作</li></ul></li></ul></li><li>很多时候，用户会连续访问同一目录内的多个文件（比如：接连查看“2015-08”目录内的多个照片文件）</li><li>显然，每次都从根目录开始查找，是很低效的，因此可以设置一个“<strong>当前目录</strong>”<ul><li>例如：此时已经打开了“照片”的目录文件，也就是说，这张目录表已调入内存，那么可以把它设置为“当前目录”，当用户想要访问某个文件时，可以使用从当前目录出发的“<strong>相对路径</strong>”</li><li>在 Linux 中，“ .”表示当前目录，因此如果“照片”是当前目录，则”自拍.jpg”的相对路径为：<ul><li>“.&#x2F;2015-08&#x2F;自拍.jpg”<ul><li>从当前路径出发，只需要查询内存中的“照片”目录表，即可知道”2015-08”目录表的存放位置</li><li>从外存调入该目录，即可知道“自拍.jpg”存放的位置了</li></ul></li><li>可见，引入“<strong>当前目录</strong>”和“<strong>相对路径</strong>”后，磁盘I&#x2F;O的次数减少了。这就提升了访问文件的效率</li></ul></li></ul></li><li><strong>树形目录结构</strong>可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护</li><li>但是，树形结构不便于实现文件的共享，为此，提出了“<strong>无环图目录结构</strong>”</li></ul></li><li><strong>无环图目录结构</strong><ul><li><strong>可以用不同的文件名指向同一个文件</strong>，甚至可以指向同一个目录（共享同一目录下的所有内容）</li><li>需要为<strong>每个共享结点设置一个共享计数器</strong>，用于记录此时有多少个地方在共享该结点<ul><li><strong>索引结点</strong>中设置一个链接计数变量count，用于表示链接到本索引结点上的用户<strong>目录项</strong>数</li></ul></li><li>用户提出删除结点的请求时，只是删除该用户的FCB、并使共享计数器减1，并不会直接删除共享结点。只有共享计数器减为0时，才删除结点</li><li>注意：共享文件不同于复制文件。在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化</li></ul></li></ul><h3 id="3-3-索引结点（FCB的改进）"><a href="#3-3-索引结点（FCB的改进）" class="headerlink" title="3.3 索引结点（FCB的改进）"></a>3.3 <strong>索引结点（FCB的改进）</strong></h3><ul><li><p><strong>思考有何好处？</strong></p><ul><li>假设一个FCB是64B，磁盘块的大小为1KB，则每个盘块中只能存放16个FCB。若一个文件目录中共有640个目录项，则共需要占用 640 &#x2F; 16 &#x3D; 40 个盘块。因此按照某文件名检索该目录，平均需要查询320 个目录项，平均需要启动磁盘20次（每次磁盘I&#x2F;O读入一块）</li><li>若使用<strong>索引结点机制</strong>，文件名占14B，索引结点指针站2B，则每个盘块可存放64个目录项，那么按文件名检索目录平均只需要</li><li>读入 320 &#x2F; 64 &#x3D; 5 个磁盘块。显然，<strong>这将大大提升文件检索速度</strong></li></ul></li><li><p>当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件</p></li><li><p>存放<strong>在外存中的索引结点</strong>称为“<strong>磁盘索引结点</strong>”，当<strong>索引结点放入内存</strong>后称为“<strong>内存索引结点</strong>”</p></li><li><p>相比之下<strong>内存索引结点中需要增加一些信息</strong>，比如：文件是否被修改、此时有几个进程正在访问该文件等</p></li></ul><h2 id="4-文件的物理结构"><a href="#4-文件的物理结构" class="headerlink" title="4. 文件的物理结构"></a><strong>4. 文件的物理结构</strong></h2><ul><li><strong>操作系统需要对磁盘块进行哪些管理？</strong><ul><li><strong>对非空闲磁盘块的管理</strong>（存放了文件数据的磁盘块）<ul><li>“<strong>文件的物理结构</strong>&#x2F;文件分配方式”要讨论的问题</li></ul></li><li><strong>对空闲磁盘块的管理</strong><ul><li>“<strong>文件存储空间管理</strong>“要讨论的问题</li></ul></li></ul></li></ul><h3 id="4-1-文件的物理结构（文件分配方式）"><a href="#4-1-文件的物理结构（文件分配方式）" class="headerlink" title="4.1 文件的物理结构（文件分配方式）"></a>4.1 <strong>文件的物理结构</strong>（文件分配方式）</h3><ul><li><p>即：文件数据应该怎样存放在外存中？</p></li><li><p><strong>连续分配</strong></p></li><li><p><strong>链接分配</strong></p><ul><li><strong>隐式链接</strong>、<strong>显示链接</strong></li></ul></li><li><p><strong>索引分配</strong></p></li></ul><h3 id="4-2-文件块、磁盘块"><a href="#4-2-文件块、磁盘块" class="headerlink" title="4.2 文件块、磁盘块"></a>4.2 <strong>文件块、磁盘块</strong></h3><ul><li><p>类似于<strong>内存分页</strong>，<strong>磁盘中的存储单元</strong>也会被分为一个个“<strong>块&#x2F;磁盘块&#x2F;物理块</strong>”。很多操作系统中，<strong>磁盘块的大小与内存块、页面的大小相同</strong></p></li><li><p><strong>内存与磁盘之间的数据交换</strong>（即读&#x2F;写操作、磁盘I&#x2F;O）都是<strong>以“块”为单位</strong>进行的。即每次读入一块，或每次写出一块</p></li><li><p>在内存管理中，进程的逻辑地址空间被分为一个一个页面</p></li><li><p>同样的，在外存管理中，为了方便对文件数据的管理，<strong>文件的逻辑地址空间也被分为了一个一个的文件“块”</strong></p><ul><li>操作系统为文件分配存储空间都是以块为单位的</li><li>若块的大小是1KB，则1MB大小的文件可以被分为1K个块</li></ul></li><li><p>于是文件的逻辑地址也可以表示为<strong>（逻辑块号，块内地址）</strong>的形式</p><ul><li>用户通过逻辑地址来操作自己的文件，<strong>操作系统要负责实现从逻辑地址到物理地址的映射</strong></li></ul></li></ul><h3 id="4-3-连续分配"><a href="#4-3-连续分配" class="headerlink" title="4.3 连续分配"></a>4.3 <strong>连续分配</strong></h3><ul><li><strong>连续分配</strong>方式要求<strong>每个文件在磁盘上占有一组连续的块</strong></li><li>用户通过逻辑地址来操作自己的文件，<strong>操作系统如何实现从逻辑地址到物理地址的映射？</strong><ul><li>（逻辑块号，块内地址）→（物理块号，块内地址），只需转换块号就行，块内地址保持不变</li><li><strong>用户</strong>给出要访问的<strong>逻辑块号</strong>，操作系统找到该<strong>文件对应的目录项（FCB）</strong><ul><li><strong>物理块号 &#x3D; 起始块号 + 逻辑块号</strong></li><li>可以直接算出逻辑块号对应的物理块号，因此<strong>连续分配支持顺序访问和直接访问（即随机访问）</strong></li></ul></li><li>当然，还需要检查用户提供的逻辑块号是否合法（ 逻辑块号 ≥ 长度 就不合法）</li></ul></li><li>读取某个磁盘块时，需要移动磁头。访问的两个磁盘块相隔越远，移动磁头所需时间就越长。<ul><li>结论：<strong>连续分配的文件在顺序读&#x2F;写时速度最快</strong></li></ul></li><li>若此时文件A要拓展，需要再增加一个磁盘块（总共需要连续的4个磁盘块）。由于采用连续结构，因此文件A占用的磁盘块必须是连续的。因此只能将文件A全部“迁移”到绿色区域<ul><li>结论：<strong>物理上采用连续分配的文件不方便拓展</strong></li><li>结论：<strong>物理上采用连续分配，存储空间利用率低，会产生难以利用的磁盘碎片，可以用紧凑来处理碎片，但是需要耗费很大的时间代价</strong></li></ul></li><li><strong>总结</strong>: <ul><li>优点：支持顺序访问和直接访问（即随机访问），连续分配的文件在顺序访问时速度最快</li><li>缺点：不方便文件拓展；存储空间利用率低，会产生磁盘碎片</li></ul></li></ul><h3 id="4-4-链接分配"><a href="#4-4-链接分配" class="headerlink" title="4.4 链接分配"></a>4.4 <strong>链接分配</strong></h3><ul><li><p><strong>链接分配采取离散分配的方式，可以为文件分配离散的磁盘块</strong>，分为<strong>隐式链接</strong>和<strong>显式链接</strong>两种</p><ul><li>考试题目中遇到未指明隐式&#x2F;显式的“链接分配”，<strong>默认指的是隐式链接的链接分配</strong></li></ul></li><li><p><strong>隐式链接</strong></p><ul><li><strong>如何实现文件的逻辑块号到物理块号的转变？</strong><ul><li><strong>用户</strong>给出要访问的<strong>逻辑块号</strong> i，操作系统找到该<strong>文件对应的目录项（FCB）</strong></li><li>从目录项中找到起始块号（即0号块），将0号逻辑块读入内存，由此知道1号逻辑块存放的物理块号，于是读入1号逻辑块，再找到2号逻辑块的存放位置……以此类推</li><li>因此，<strong>读入i号逻辑块，总共需要 i+1 次磁盘I&#x2F;O</strong><ul><li>结论：<strong>采用链式分配（隐式链接）方式的文件，只支持顺序访问，不支持随机访问，查找效率低。另外，指向下一个盘块的指针也需要耗费少量的存储空间</strong></li></ul></li></ul></li><li><strong>是否方便拓展文件？</strong><ul><li>若此时要拓展文件，则可以随便找一个空闲磁盘块，挂到文件的磁盘块链尾，并修改文件的FCB</li><li>结论：<strong>采用隐式链接的链接分配方式，很方便文件拓展。另外，所有的空闲磁盘块都可以被利用，不会有碎片问题，外存利用率高</strong></li></ul></li><li><strong>总结</strong>:<ul><li>优点：很方便文件拓展，不会有碎片问题，外存利用率高</li><li>缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间</li></ul></li></ul></li><li><p><strong>显式链接</strong></p><ul><li><strong>把用于链接文件各物理块的指针显式地存放在一张表中</strong>，即 <strong>文件分配表（FAT，File Allocation Table）</strong><ul><li>假设某个新创建的文件“aaa”依次存放在磁盘块 2 → 5 → 0 → 1</li><li>假设某个新创建的文件“bbb”依次存放在磁盘块 4 → 23 → 3</li><li>注意：<strong>一个磁盘仅设置一张FAT</strong>。开机时，将FAT读入内存，并<strong>常驻内存</strong>。 <strong>FAT 的各个表项在物理上连续存储，且每一个表项长度相同，因此“物理块号”字段可以是隐含的</strong></li></ul></li><li><strong>如何实现文件的逻辑块号到物理块号的转变？</strong><ul><li><strong>用户</strong>给出要访问的<strong>逻辑块号</strong> i，操作系统找到该<strong>文件对应的目录项（FCB）</strong></li><li>从目录项中找到起始块号，若i&gt;0，则查询内存中的<strong>文件分配表FAT</strong>，往后找到 i 号逻辑块对应的物理块号。<strong>逻辑块号转换成物理块号的过程不需要读磁盘操作</strong><ul><li>结论：<strong>采用链式分配（显式链接）方式的文件，支持顺序访问，也支持随机访问（想访问 i 号逻辑块时，并不需要依次访问之前的 0 ~ i - 1号逻辑块），由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问速度快很多</strong></li></ul></li><li>显然，<strong>显式链接也不会产生外部碎片，也可以很方便地对文件进行拓展</strong></li></ul></li><li><strong>总结</strong>:<ul><li>优点：很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高</li><li>缺点：文件分配表的需要占用一定的存储空间</li></ul></li></ul></li></ul><h3 id="4-4-索引分配"><a href="#4-4-索引分配" class="headerlink" title="4.4 索引分配"></a>4.4 <strong>索引分配</strong></h3><ul><li><strong>索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文件的各个逻辑块对应的物理块</strong><ul><li>索引表的功能类似于内存管理中的页表 – 建立逻辑页面到物理页之间的映射关系</li></ul></li><li>磁盘中存放索引表的磁盘块称为<strong>索引块</strong>，磁盘中存放文件数据的磁盘块称为<strong>数据块</strong><ul><li>假设某个新创建的文件“aaa”的数据依次存放在磁盘块 2 → 5 → 13 → 9</li><li>7号磁盘块作为“aaa”的索引块，索引块中保存了索引表的内容</li><li>注：在显式链接的链式分配方式中，<strong>文件分配表FAT</strong> 是<strong>一个磁盘对应一张</strong>，而索引分配方式中，<strong>索引表</strong>是<strong>一个文件对应一张</strong></li><li><strong>可以用固定的长度表示物理块号</strong>（如：假设磁盘总容量为 1TB &#x3D; 2<sup>40</sup>B，磁盘块大小为 1KB，则共有 2<sup>30</sup>个磁盘块，则可用 4B 表示磁盘块号），因此，<strong>索引表中的“逻辑块号”可以是隐含的</strong></li></ul></li><li><strong>如何实现文件的逻辑块号到物理块号的转换？</strong><ul><li><strong>用户</strong>给出要访问的<strong>逻辑块号</strong> i，操作系统找到该<strong>文件对应的目录项（FCB）</strong></li><li>从目录项中可知<strong>索引表</strong>存放位置，将索引表从外存读入内存，并查找索引表即可知道 i 号逻辑块在外存中的存放位置<ul><li>结论：<strong>索引分配方式可以支持随机访问。文件拓展也很容易实现（只需要给文件分配一个空闲块，并增加一个索引表项即可）但是索引表需要占用一定的存储空间</strong></li></ul></li></ul></li><li>若每个磁盘块1KB，一个索引表项4B，则一个磁盘块只能存放 256 个索引项。如果一个文件的大小超过了256块，那么<strong>一个磁盘块</strong>是<strong>装不下文件的整张索引表</strong>的，<strong>如何解决这个问题？</strong><ul><li><strong>链接方案</strong><ul><li>如果索引表太大，一个索引块装不下，那么可以<strong>将多个索引块链接起来存放</strong></li><li>假设磁盘块大小为1KB，一个索引表项占4B，则一个磁盘块只能存放256个索引项</li><li>若一个文件大小为 256 * 256KB &#x3D; 65,536 KB &#x3D; 64MB，该文件共有 256 * 256 个块，也就对应 256 * 256 个索引项，也就需要 256 个索引块来存储，这些索引块用链接方案连起来</li><li>若想要访问文件的最后一个逻辑块，就必须找到最后一个索引块（第256个索引块），而各个索引块之间是用指针链接起来的，因此必须先顺序地读入前 255 个索引块<ul><li>缺点：若文件很大，索引表很长，就需要将很多个索引块链接起来。想要找到 i 号索引块，必须先依次读入 0 ~ i-1号索引块，这就导致磁盘I&#x2F;O次数过多，查找效率低下这显然是很低效的，如何解决呢？</li></ul></li></ul></li><li><strong>多层索引</strong><ul><li><strong>建立多层索引（原理类似于多级页表）</strong>。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块…</li><li>假设磁盘块大小为1KB，一个索引表项占4B，则一个磁盘块只能存放256个索引项</li><li><strong>若某文件采用两层索引</strong>，则该文件的最大长度可以到256 * 256 * 1KB &#x3D; 65,536 KB &#x3D; 64MB</li><li>可根据逻辑块号算出应该查找索引表中的哪个表项<ul><li>如：要访问 1026 号逻辑块，则1026 &#x2F; 256 &#x3D; 4，1026 % 256 &#x3D; 2</li><li>因此可以先将一级索引表调入内存，查询 4 号表项，将其对应的二级索引表调入内存，再查询二级索引表的2号表项即可知道 1026 号逻辑块存放的磁盘块号了。访问目标数据块，需要3次磁盘I&#x2F;O</li></ul></li><li><strong>若采用三层索引</strong>，则文件的最大长度为256 * 256 * 256 * 1KB &#x3D; 16GB<ul><li>类似的，访问目标数据块，需要4次磁盘I&#x2F;O</li></ul></li><li><strong>采用 K 层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要 K + 1 次读磁盘操作</strong><ul><li>缺点：即使是小文件，访问一个数据块依然需要K + 1次读磁盘</li></ul></li></ul></li><li><strong>混合索引</strong><ul><li><strong>多种索引分配方式的结合</strong><ul><li>例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表）、还包含两级间接索引（指向两层索引表）</li><li>优点：对于小文件来说，访问一个数据块所需的读磁盘次数更少</li></ul></li></ul></li></ul></li><li><strong>重要考点</strong>:<ul><li>要会根据多层索引、混合索引的结构计算出文件的最大长度<ul><li>Key：各级索引表最大不能超过一个块</li></ul></li><li>要能自己分析访问某个数据块所需要的读磁盘次数<ul><li>Key：FCB中会存有指向顶级索引块的指针，因此可以根据FCB读入顶级索引块。每次读入下一级的索引块都需要一次读磁盘操作。另外，要注意题目条件 – 顶级索引块是否已调入内存</li></ul></li></ul></li></ul><h2 id="5-逻辑结构VS物理结构"><a href="#5-逻辑结构VS物理结构" class="headerlink" title="5. 逻辑结构VS物理结构"></a><strong>5. 逻辑结构VS物理结构</strong></h2><ul><li>逻辑结构中的链式存储和物理结构中的链接分配<ul><li>文件内部各条记录链式存储：由创建文件的用户自己设计的</li><li>文件整体用链接分配：由操作系统决定</li></ul></li><li>逻辑结构中的索引文件和物理结构中的索引分配<ul><li>索引文件的索引表：<ul><li>用户自己建立的，映射：关键字 → 记录存放的逻辑地址</li></ul></li><li>索引分配的索引表：<ul><li>操作系统建立的，映射：逻辑块号 → 物理块号</li></ul></li></ul></li></ul><h2 id="6-文件存储空间管理"><a href="#6-文件存储空间管理" class="headerlink" title="6. 文件存储空间管理"></a><strong>6. 文件存储空间管理</strong></h2><ul><li>学习时注意从三个方面进行理解:<ul><li>用什么方式记录、组织空闲块？</li><li>如何分配磁盘块</li><li>如何回收磁盘块</li></ul></li></ul><h3 id="6-1-存储空间的划分与初始化"><a href="#6-1-存储空间的划分与初始化" class="headerlink" title="6.1 存储空间的划分与初始化"></a>6.1 <strong>存储空间的划分与初始化</strong></h3><ul><li>安装Windows操作系统的时候，一个必经步骤是为<strong>磁盘分区</strong>（C:盘、D:盘、E:盘）<ul><li>存储空间的划分：将物理磁盘划分为一个个<strong>文件卷（逻辑卷、逻辑盘）</strong></li><li>存储空间的初始化：将各个<strong>文件卷</strong>划分为<strong>目录区</strong>、<strong>文件区</strong><ul><li><strong>目录区</strong>：主要存放文件目录信息（FCB）、用于磁盘存储空间管理的信息</li><li><strong>文件区</strong>：文件区用于存放文件数据</li></ul></li></ul></li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-1-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20241121214207650.png"></p><h3 id="6-2-空闲表法"><a href="#6-2-空闲表法" class="headerlink" title="6.2 空闲表法"></a>6.2 <strong>空闲表法</strong></h3><ul><li><p>适用于”<strong>连续分配方式</strong>“</p></li><li><p><strong>如何分配磁盘块</strong>:</p><ul><li>与内存管理中的动态分区分配很类似，为一个文件<strong>分配连续的存储空间</strong>。同样<strong>可采用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个区间</strong></li></ul></li><li><p><strong>如何回收磁盘块</strong>:</p><ul><li>与内存管理中的动态分区分配很类似，当回收某个存储区时需要有四种情况:</li><li>回收区的前后都没有相邻空闲区</li><li>回收区的前后都是空闲区</li><li>回收区前面是空闲区</li><li>回收区后面是空闲区</li><li>总之，<strong>回收时需要注意表项的合并问题</strong></li></ul></li></ul><h3 id="6-3-空闲链表法"><a href="#6-3-空闲链表法" class="headerlink" title="6.3 空闲链表法"></a>6.3 <strong>空闲链表法</strong></h3><ul><li><strong>空闲盘块链</strong>: 以盘块为单位组成一条空闲链<ul><li>操作系统保存着<strong>链头、链尾指针</strong></li><li><strong>如何分配磁盘块</strong>:<ul><li>若某文件申请 k 个盘块，则从链头开始依次摘下 k 个盘块分配，并修改空闲链的链头指针</li></ul></li><li><strong>如何回收磁盘块</strong>:<ul><li>回收的盘块依次挂到链尾，并修改空闲链的链尾指针</li></ul></li><li>适用于<strong>离散分配</strong>的物理结构。为文件分配多个盘块时可能要重复多次操作</li></ul></li><li><strong>空闲盘区链</strong>: 以盘区为单位组成一条空闲链<ul><li>操作系统保存着<strong>链头、链尾指针</strong></li><li><strong>如何分配磁盘块</strong>:<ul><li>若某文件申请 k 个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区，分配给文件。若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件， 注意分配后可能要修改相应的链指针、盘区大小等数据</li></ul></li><li><strong>如何回收磁盘块</strong>:<ul><li>若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾</li></ul></li><li><strong>连续分配</strong>、<strong>离散分配</strong>都适用，为一个文件分配多个盘块时效率更高</li></ul></li></ul><h3 id="6-4-位示图法"><a href="#6-4-位示图法" class="headerlink" title="6.4 位示图法"></a>6.4 <strong>位示图法</strong></h3><ul><li><strong>每个二进制位对应一个盘块</strong><ul><li>在本例中，“0” 代表盘块空闲，“1”代表盘块已分配</li></ul></li><li><strong>位示图一般用连续的“字”来表示</strong><ul><li>如本例中一个字的字长是16位</li></ul></li><li><strong>字中的每一位对应一个盘块</strong>，因此可以用<strong>（字号，位号）</strong>对应一个<strong>盘块号</strong>，当然有的题目中也描述为<strong>（行号，列号）</strong></li><li><strong>重要</strong>：要能自已推出<strong>盘块号</strong>与<strong>（字号，位号）</strong>相互转换的公式<ul><li>注意题目条件：<strong>盘块号</strong>、<strong>字号</strong>、<strong>位号</strong>到底是从0开始还是从1开始<ul><li>如本例中盘块号、字号、位号从0开始，若n表示字长，则（字号，位号）&#x3D;（i，j）的二进制位对应的盘块号 b &#x3D; n * i + j</li><li>b号盘块对应的字号 i &#x3D; b &#x2F; n，位号 j &#x3D; b % n</li></ul></li></ul></li><li><strong>如何分配磁盘块</strong>:<ul><li>若文件需要 k 个块<ul><li>顺序扫描位示图，找到K个相邻或不相邻的“0”</li><li>根据字号、位号算出对应的盘块号，将相应盘块分配给文件</li><li>将相应位设置为“1”</li></ul></li></ul></li><li><strong>如何回收磁盘块</strong>:<ul><li>根据回收的盘块号计算出对应的字号、位号</li><li>将相应二进制位设为“0</li></ul></li><li><strong>连续分配</strong>、<strong>离散分配</strong>都适用</li></ul><h3 id="6-5-成组链接法"><a href="#6-5-成组链接法" class="headerlink" title="6.5 成组链接法"></a>6.5 <strong>成组链接法</strong></h3><ul><li><p><strong>空闲表法、空闲链表法不适用于大型文件系统</strong>，因为空闲表或空闲链表可能过大</p></li><li><p>UNIX系统中采用了<strong>成组链接法</strong>对磁盘空闲块进行管理</p></li><li><p><strong>文件卷的目录区</strong>中专门用一个磁盘块作为“<strong>超级块</strong>”，当系统启动时需要<strong>将超级块读入内存</strong>，并且要保证内存与外存中的“超级块”数据一致</p><ul><li>注3: <strong>每个分组的盘块数量是存在上限的</strong></li><li>注4: <strong>最后一个分组的盘块数是比其他分组的盘块数少的</strong></li></ul></li><li><p><strong>如何分配磁盘块</strong>:</p><ul><li><p>若文件需要 1 个空闲块</p><ul><li>检查第一个分组的块数是否足够，1 &lt; 100，是足够的</li><li>分配第一个分组中的 1 个空闲块，并修改空闲盘块数</li></ul></li><li><p>若文件需要 100 个空闲块</p><ul><li>检查第一个分组的块数是否足够，100 &#x3D; 100，是足够的</li><li>分配第一个分组中的100个空闲块。但是由于300号块内存放了再下一组的信息，因此300号块的数据需要复制到超级块中</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-1-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20241121215625563.png"></p></li></ul></li><li><p><strong>如何回收磁盘块</strong>:</p><ul><li>假设每个分组最多为100个空闲块，此时第一个分组已有99个块，还要再回收一块<ul><li>可以将空闲块的信息放到第一个分组当中，并修改空闲盘块数</li></ul></li><li>假设每个分组最多为100个空闲块，此时第一个分组已有100个块，还要再回收一块<ul><li>需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组</li></ul></li></ul></li></ul><h2 id="7-文件的基本操作"><a href="#7-文件的基本操作" class="headerlink" title="7. 文件的基本操作"></a><strong>7. 文件的基本操作</strong></h2><h3 id="7-1-创建文件"><a href="#7-1-创建文件" class="headerlink" title="7.1 创建文件"></a>7.1 <strong>创建文件</strong></h3><ul><li><p>可以“<strong>创建文件</strong>”（点击新建后，图形化交互进程在背后调用了“<strong>create 系统调用</strong>”）</p></li><li><p>进行 create 系统调用 时，需要提供的几个主要参数:</p><ul><li>所需的外存空间大小（如：一个盘块，即1KB）</li><li>文件存放路径（“D:&#x2F;Demo”）</li><li>文件名（这个地方默认为“新建文本文档.txt”）</li></ul></li><li><p>操作系统在处理 create 系统调用时，主要做了两件事:</p><ul><li><strong>在外存中找到文件所需的空间</strong>（结合上小节学习的空闲链表法、位示图、成组链接法等管理策略，找到空闲空间）</li><li>根据文件存放路径的信息找到该目录对应的目录文件（此处就是D:&#x2F;Demo目录），<strong>在目录中创建该文件对应的目录项</strong>。目录项中包含了文件名、文件在外存中的存放位置等信息</li></ul></li></ul><h3 id="7-2-删除文件"><a href="#7-2-删除文件" class="headerlink" title="7.2 删除文件"></a>7.2 <strong>删除文件</strong></h3><ul><li><p>可以<strong>“删除文件</strong>”（点击删除后，图形化交互进程在背后调用了”<strong>delete 系统调用</strong>“，将文件数据从外存中删除）</p></li><li><p>进行 delete 系统调用 时，需要提供的几个主要参数:</p><ul><li>文件存放路径（“D:&#x2F;Demo”）</li><li>文件名（“test.txt” ）</li></ul></li><li><p>操作系统在处理 delete 系统调用 时，主要做了几件事:</p><ul><li>根据文件存放路径找到相应的目录文件，<strong>从目录中找到文件名对应的目录项</strong></li><li>根据该目录项记录的文件在外存的存放位置、文件大小等信息，<strong>回收文件占用的磁盘块</strong>（回收磁盘块时，根据空闲表法、空闲链表法、位图法等管理策略的不同，需要做不同的处理）</li><li><strong>从目录表中删除文件对应的目录项</strong></li></ul></li></ul><h3 id="7-3-打开文件"><a href="#7-3-打开文件" class="headerlink" title="7.3 打开文件"></a>7.3 <strong>打开文件</strong></h3><ul><li><p>读&#x2F;写文件之前，需要通过操作系统提供的”<strong>open 系统调用</strong>“来“<strong>打开文件</strong>”</p></li><li><p>在很多操作系统中，在对文件进行操作之前，要求用户先使用 open 系统调用 “打开文件”，需要提供的几个主要参数:</p><ul><li>文件存放路径（“D:&#x2F;Demo”）</li><li>文件名（“test.txt”） </li><li>要对文件的操作类型（如：r只读；rw读写等）</li></ul></li><li><p>操作系统在处理 open 系统调用 时，主要做了几件事:</p><ul><li>1. 根据文件存放路径找到相应的目录文件，从目录中<strong>找到文件名对应的的目录项</strong>，并检查该用户是否有指定的操作权限</li><li>2. <strong>将目录项复制到内存中的“打开文件表”中</strong>。并将对应表目的编号返回给用户。之后<strong>用户使用打开文件表的编号(即</strong> 文件描述符 <strong>)来指明要操作的文件</strong></li></ul></li></ul><h3 id="7-4-关闭文件"><a href="#7-4-关闭文件" class="headerlink" title="7.4 关闭文件"></a>7.4 <strong>关闭文件</strong></h3><ul><li><p>读&#x2F;写文件结束之后，需要通过操作系统提供的”<strong>close 系统调用</strong>“来“<strong>关闭文件</strong>”</p></li><li><p>进程使用完文件后，要“关闭文件”</p></li><li><p>操作系统在处理 close 系统调用 时，主要做了几件事:</p><ul><li>将进程的打开文件表相应表项删除</li><li>回收分配给该文件的内存空间等资源</li><li>系统打开文件表的打开计数器count减1，若count &#x3D; 0，则删除对应表项</li></ul></li></ul><h3 id="7-5-读文件"><a href="#7-5-读文件" class="headerlink" title="7.5 读文件"></a>7.5 <strong>读文件</strong></h3><ul><li><p>可以“<strong>读文件</strong>”，将文件数据读入内存，才能让CPU处理（双击后，“记事本”应用程序通过操作系统提供的“<strong>read 系统调用</strong>”，将文件数据从外存读入内存，并显示在屏幕上）</p></li><li><p>进程使用 read 系统调用 完成写操作:</p><ul><li>需要指明是哪个文件（在支持“打开文件”操作的系统中，<strong>只需要提供文件在打开文件表中的索引号(又称</strong> 文件描述符 <strong>)即可</strong>）</li><li>还需要指明要读入多少数据（如：读入1KB）、指明读入的数据要放在内存中的什么位置</li><li>操作系统在处理 read 系统调用 时，会从读指针指向的外存中，将指定大小的数据读入用户指定的内存区域中</li></ul></li></ul><h3 id="7-6-写文件"><a href="#7-6-写文件" class="headerlink" title="7.6 写文件"></a>7.6 <strong>写文件</strong></h3><ul><li><p>可以“<strong>写文件</strong>”，将更改过的文件数据写回外存（在“记事本”应用程序中编辑文件内容，点击“保存”后，“记事本”应用程序通过操作系统提供的“<strong>write 系统调用</strong>”，将文件数据从内存写回外存）</p></li><li><p>进程使用 write 系统调用 完成写操作:</p><ul><li>需要指明是哪个文件（在支持“打开文件”操作的系统中，<strong>只需要提供文件在打开文件表中的索引号(又称</strong> 文件描述符 <strong>)即可</strong>）</li><li>还需要指明要写出多少数据（如：写出1KB）、写回外存的数据放在内存中的什么位置</li><li>操作系统在处理write系统调用时，会从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存</li></ul></li></ul><h2 id="8-文件共享"><a href="#8-文件共享" class="headerlink" title="8. 文件共享"></a><strong>8. 文件共享</strong></h2><ul><li><strong>操作系统为用户提供文件共享功能，可以让多个用户共享地使用同一个文件</strong></li><li>注意：<strong>多个用户共享同一个文件，意味着系统中只有“一份”文件数据，并且只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化</strong>。如果是多个用户都”复制”了同一个文件，那么系统中会有“好几份”文件数据。其中一个用户修改了自己的那份文件数据，对其他用户的文件数据并没有影响</li></ul><h3 id="8-1-基于索引结点的共享方式（硬链接）"><a href="#8-1-基于索引结点的共享方式（硬链接）" class="headerlink" title="8.1 基于索引结点的共享方式（硬链接）"></a>8.1 <strong>基于索引结点的共享方式（硬链接）</strong></h3><ul><li><p>知识回顾：<strong>索引结点</strong>，是一种文件目录瘦身策略。由于检索文件时只需用到文件名，因此可以将除了文件名之外的其他信息放到索引结点中。这样目录项就只需要包含文件名、索引结点指针</p></li><li><p><strong>索引结点</strong>中设置一个链接计数变量count，<strong>用于表示链接到本索引结点上的用户目录项数</strong></p></li><li><p>若count&#x3D;2，说明此时有两个用户目录项链接到该索引结点上，或者说是有两个用户在共享此文件</p></li><li><p>若某个用户决定“删除”该文件，则只是要把用户目录中与该文件对应的目录项删除，且索引结点的count值减1</p></li><li><p>若count&gt;0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空</p></li><li><p>当count&#x3D;0时系统负责删除文件</p></li></ul><h3 id="8-2-基于符号链的共享方式（软链接）"><a href="#8-2-基于符号链的共享方式（软链接）" class="headerlink" title="8.2 基于符号链的共享方式（软链接）"></a>8.2 <strong>基于符号链的共享方式（软链接）</strong></h3><ul><li><p>当User3访问“ccc”时，操作系统判断文件“ccc”属于<strong>Link类型文件</strong>，于是会<strong>根据其中记录的路径层层查找目录</strong>，最终找到User1的目录表中的“aaa” 表项，于是就找到了文件1的索引结点</p></li><li><p><strong>即使软链接指向的共享文件已被删除，Link型文件依然存在，只是通过Link型文件中的路径去查找共享文件会失败</strong>（找不到目录项）</p></li><li><p>由于用软链接的方式访问共享文件时要查询多级目录，会有多次磁盘I&#x2F;O，因此<strong>用软链接访问共享文件的速度要比硬链接更慢</strong></p></li></ul><h2 id="9-文件保护"><a href="#9-文件保护" class="headerlink" title="9. 文件保护"></a><strong>9. 文件保护</strong></h2><ul><li>保护文件数据的安全</li></ul><h3 id="9-1-口令保护"><a href="#9-1-口令保护" class="headerlink" title="9.1 口令保护"></a>9.1 <strong>口令保护</strong></h3><ul><li><p>为文件设置一个“口令”（如: abc112233） ，用户请求访问该文件时必须提供“口令”</p><ul><li>口令一般存放在文件对应的FCB或索引结点中。用户访问文件前需要先输入“口令”，操作系统会将用户提供的口令与FCB中存储的口令进行对比，如果正确，则允许该用户访问文件</li></ul></li><li><p>优点：保存口令的空间开销不多，验证口令的时间开销也很小</p></li><li><p>缺点：正确的“口令”存放在系统内部，不够安全</p></li></ul><h3 id="9-2-加密保护"><a href="#9-2-加密保护" class="headerlink" title="9.2 加密保护"></a>9.2 <strong>加密保护</strong></h3><ul><li><p>使用某个”密码”对文件进行加密，在访问文件时需要提供正确的”密码“才能对文件进行正确的解密 </p></li><li><p>优点：保密性强，不需要在系统中存储“密码”</p></li><li><p>缺点：编码&#x2F;译码，或者说加密&#x2F;解密需要花费一定时间</p></li></ul><h3 id="9-3-访问控制"><a href="#9-3-访问控制" class="headerlink" title="9.3 访问控制"></a>9.3 <strong>访问控制</strong></h3><ul><li><p>在每个文件的FCB（或索引结点）中增加一个<strong>访问控制表（Access-Control List，ACL）</strong>，该表中记录了各个用户可以对该文件执行哪些操作</p></li><li><p><strong>精简的访问列表</strong>：以“<strong>组</strong>”为单位，<strong>标记各“组”用户可以对文件执行哪些操作</strong>，系统需要管理分组的信息</p><ul><li>如：分为系统管理员、文件主、文件主的伙伴、其他用户几个分组</li><li>当某用户想要访问文件时，系统会检查该用户所属的分组是否有相应的访问权限</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.2 虚拟内存管理</title>
    <link href="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="3-2-虚拟内存管理"><a href="#3-2-虚拟内存管理" class="headerlink" title="3.2 虚拟内存管理"></a><strong>3.2 虚拟内存管理</strong></h1><h2 id="1-虚拟内存的基本概念"><a href="#1-虚拟内存的基本概念" class="headerlink" title="1. 虚拟内存的基本概念"></a><strong>1. 虚拟内存的基本概念</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20241121183215528.png"></p><ul><li>在<strong>传统存储管理方式</strong>的基础上引入了<strong>交换技术</strong>、<strong>覆盖技术</strong>，使得内存利用率有所提升，并且能从逻辑上扩充内存容量<ul><li>传统存储管理方式：连续分配、非连续分配</li></ul></li></ul><h3 id="1-1-传统存储管理方式的特征、缺点"><a href="#1-1-传统存储管理方式的特征、缺点" class="headerlink" title="1.1 传统存储管理方式的特征、缺点"></a>1.1 <strong>传统存储管理方式的特征、缺点</strong></h3><ul><li><p>传统存储管理方式中很多暂时用不到的数据也会长期占用内存，导致内存利用率不高</p></li><li><p><strong>一次性</strong></p><ul><li>作业必须一次性全部装入内存后才能开始运行</li><li>这会造成两个问题：<ul><li>作业很大时，不能全部装入内存，导致大作业无法运行</li><li>当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降</li></ul></li></ul></li><li><p><strong>驻留性</strong></p><ul><li>一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束</li><li>事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源</li></ul></li><li><p>传统存储管理方式的这些问题可用<strong>虚拟存储技术</strong>解决</p></li></ul><h3 id="1-2-局部性原理"><a href="#1-2-局部性原理" class="headerlink" title="1.2 局部性原理"></a>1.2 <strong>局部性原理</strong></h3><ul><li><strong>时间局部性</strong><ul><li>如果执行了程序中的某条<strong>指令</strong>，那么不久后这条指令很有可能再次执行；如果某个<strong>数据</strong>被访问过，不久之后该数据很可能再次被访问（因为程序中存在大量的循环）</li></ul></li><li><strong>空间局部性</strong><ul><li>一旦程序访问了某个<strong>存储单元</strong>，在不久之后，其附近的存储单元也很有可能被访问（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）</li></ul></li><li><strong>应用</strong>：<ul><li><strong>快表</strong>机构就是将近期常访问的页表项副本放到更高速的联想寄存器中</li><li><strong>高速缓冲技术</strong>的思想：将近期会频繁访问到的数据放到更高速的存储器中，暂时用不到的数据放在更低速存储器中</li></ul></li></ul><h3 id="1-3-虚拟内存的定义和特征"><a href="#1-3-虚拟内存的定义和特征" class="headerlink" title="1.3 虚拟内存的定义和特征"></a>1.3 <strong>虚拟内存的定义和特征</strong></h3><ul><li><strong>定义</strong>:<ul><li>基于<strong>局部性原理</strong>，在程序装入时，可以将程序中<strong>很快会用到的部分装入内存，暂时用不到的部分留在外存</strong>，就可以让程序开始执行</li><li>在程序执行过程中，当<strong>所访问的信息不在内存时</strong>，由<strong>操作系统负责将所需信息从外存调入内存</strong>，然后继续执行程序</li><li>若内存空间不够，由<strong>操作系统</strong>负责<strong>将内存中暂时用不到的信息换出到外存</strong>。在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是<strong>虚拟内存</strong><ul><li>操作系统<strong>虚拟性</strong>的一个体现，实际的物理内存大小没有变，只是在逻辑上进行了扩充</li></ul></li></ul></li><li><strong>特征</strong>:<ul><li>虚拟内存有以下三个主要特征：</li><li><strong>多次性</strong>：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存</li><li><strong>对换性</strong>：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出</li><li><strong>虚拟性</strong>：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量</li></ul></li></ul><h3 id="1-4-如何实现虚拟内存技术"><a href="#1-4-如何实现虚拟内存技术" class="headerlink" title="1.4 如何实现虚拟内存技术?"></a>1.4 <strong>如何实现虚拟内存技术?</strong></h3><ul><li><p>虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。因此，虚拟内存的实现需要建立在<strong>离散分配</strong>的内存管理方式基础上</p></li><li><p><strong>传统的非连续分配存储管理</strong></p><ul><li>基本分页存储管理、基本分段存储管理、基本段页式存储管理</li></ul></li><li><p><strong>虚拟内存的实现</strong></p><ul><li><strong>请求分页存储管理</strong>、<strong>请求分段存储管理</strong>、<strong>请求段页式存储管理</strong></li></ul></li><li><p><strong>主要区别</strong>：</p><ul><li>在程序执行过程中，当<strong>所访问的信息不在内存时</strong>，由<strong>操作系统负责将所需信息从外存调入内存</strong>，然后继续执行程序<ul><li>操作系统要提供<strong>请求调页（或请求调段）</strong>功能</li></ul></li><li>若内存空间不够，由<strong>操作系统</strong>负责<strong>将内存中暂时用不到的信息换出到外存</strong><ul><li>操作系统要提供<strong>页面置换（或段置换）</strong>的功能</li></ul></li></ul></li></ul><h2 id="2-请求分页管理方式"><a href="#2-请求分页管理方式" class="headerlink" title="2. 请求分页管理方式"></a><strong>2. 请求分页管理方式</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20241121191935173.png"></p><ul><li>注意与<strong>基本分页存储管理</strong>的页表机制、地址变换流程对比学习</li></ul><h3 id="2-1-页表机制"><a href="#2-1-页表机制" class="headerlink" title="2.1 页表机制"></a>2.1 <strong>页表机制</strong></h3><ul><li><p>与基本分页管理相比，<strong>请求分页管理</strong>中，为了实现“<strong>请求调页</strong>”，操作系统需要知道每个页面是否已经调入内存；如果还没调入，那么也需要知道该页面在外存中存放的位置</p></li><li><p>当内存空间不够时，要实现“<strong>页面置换</strong>”，操作系统需要通过某些指标来决定到底换出哪个页面；有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息</p></li></ul><h3 id="2-2-缺页中断机构"><a href="#2-2-缺页中断机构" class="headerlink" title="2.2 缺页中断机构"></a>2.2 <strong>缺页中断机构</strong></h3><ul><li><p>在请求分页系统中，每当<strong>要访问的页面不在内存</strong>时，便产生一个<strong>缺页中断</strong>，然后由操作系统的<strong>缺页</strong></p></li><li><p><strong>中断处理程序处理中断</strong>。此时<strong>缺页的进程阻塞</strong>，放入阻塞队列，<strong>调页完成后再将其唤醒</strong>，放回就绪队列</p></li><li><p>如果<strong>内存中有空闲块</strong>，则<strong>为进程分配一个空闲块</strong>，将所缺页面装入该块，并<strong>修改页表中相应的页表项</strong></p></li><li><p>如果<strong>内存中没有空闲块</strong>，则<strong>由页面置换算法选择一个页面淘汰</strong>，若该页面在内存期间<strong>被修改过</strong>，则要<strong>将其写回外存</strong>。<strong>未修改过</strong>的页面<strong>不用写回外存</strong></p></li><li><p><strong>缺页中断</strong>是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于<strong>内中断</strong></p></li><li><p><strong>一条指令</strong>在执行期间，<strong>可能产生多次缺页中断</strong></p><ul><li>如：copy A to B，即将逻辑地址A中的数据复制到逻辑地址B，而A、B属于不同的页面，则有可能产生两次中断</li></ul></li></ul><h3 id="2-3-地址变换机构"><a href="#2-3-地址变换机构" class="headerlink" title="2.3 地址变换机构"></a>2.3 <strong>地址变换机构</strong></h3><ul><li><p>新增步骤1：请求调页（查到页表项时进行判断）</p></li><li><p>新增步骤2：页面置换（需要调入页面，但没有空闲内存块时进行）</p></li><li><p>新增步骤3：需要修改请求页表中的表项</p></li><li><p><strong>过程</strong>:</p></li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20241121191231469.png"></p><ul><li><strong>注意</strong>: <strong>快表</strong>中有的页面一定是在内存中的。若<strong>某个页面被换出外存，则快表中的相应表项也要删除</strong>，否则可能访问错误的页面</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20241121191315690.png"></p><ul><li><strong>补充细节</strong>:<ul><li>只有“写指令”才需要修改 “修改位”。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数</li><li>和普通的中断处理一样，缺页中断处理依然需要保留CPU现场</li><li>需要用某种“<strong>页面置换算法</strong>” 来决定一个换出页面（下节内容）</li><li>换入&#x2F;换出页面都需要启动慢速的I&#x2F;O操作，可见，如果换入&#x2F; 换出太频繁，会有很大的开销</li><li>页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中<ul><li>在具有快表机构的请求分页系统中，访问一个逻辑地址时，若发生缺页，则地址变换步骤是：<ul><li>查快表(未命中)–查慢表(发现未调入内存)–调页(调入的页面对应的表项会直接加入快表)–查快表(命中)–访问目标内存单元</li></ul></li></ul></li></ul></li></ul><h2 id="3-页面置换算法"><a href="#3-页面置换算法" class="headerlink" title="3. 页面置换算法"></a><strong>3. 页面置换算法</strong></h2><ul><li>用<strong>页面置换算法</strong>决定应该换出哪个页面，页面的换入、换出需要磁盘I&#x2F;O，会有较大的开销，因此好的页面置换算法应该追求<strong>更少的缺页率</strong><ul><li>即让换入、换出的次数尽可能地少，尽量将不经常使用的页面换出</li></ul></li></ul><h3 id="3-1-最佳置换算法（OPT）"><a href="#3-1-最佳置换算法（OPT）" class="headerlink" title="3.1 最佳置换算法（OPT）"></a>3.1 <strong>最佳置换算法（OPT）</strong></h3><ul><li><strong>最佳置换算法（OPT，Optimal）</strong>：每次选择<strong>淘汰的页面</strong>将是<strong>以后永不使用</strong>，或者<strong>在最长时间内不再被访问的页面</strong>，这样可以保证最低的缺页率</li><li>最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，<strong>最佳置换算法是无法实现的</strong></li></ul><h3 id="3-2-先进先出置换算法（FIFO）"><a href="#3-2-先进先出置换算法（FIFO）" class="headerlink" title="3.2 先进先出置换算法（FIFO）"></a>3.2 <strong>先进先出置换算法（FIFO）</strong></h3><ul><li><strong>先进先出置换算法（FIFO）</strong>：每次选择<strong>淘汰的页面</strong>是<strong>最早进入内存的页面</strong><ul><li>实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块</li></ul></li><li><strong>Belady 异常</strong> – 当为进程分配的物理块数增大时，缺页次数不减反增的异常现象<ul><li><strong>只有 FIFO 算法会产生 Belady 异常</strong>。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，算法性能差</li></ul></li></ul><h3 id="3-3-最近最久未使用置换算法（LRU）"><a href="#3-3-最近最久未使用置换算法（LRU）" class="headerlink" title="3.3 最近最久未使用置换算法（LRU）"></a>3.3 <strong>最近最久未使用置换算法（LRU）</strong></h3><ul><li><p><strong>最近最久未使用置换算法（LRU，least recently used）</strong>：每次<strong>淘汰的页面</strong>是<strong>最近最久未使用的页面</strong></p><ul><li>实现方法：赋予每个页面对应的页表项中，<strong>用访问字段记录该页面自上次被访问以来所经历的时间t</strong>。当需要淘汰一个页面时，选择现有页面中 t 值最大的，即最近最久未使用的页面</li></ul></li><li><p>该算法的实现需要专门的硬件支持，虽然算法<strong>性能好</strong>，但是<strong>实现困难，开销大</strong></p></li><li><p>在手动做题时，若需要淘汰页面，可以逆向检查此时在内存中的几个页面号。在<strong>逆向扫描过程中最后一个出现的页号就是要淘汰的页面</strong></p></li></ul><h3 id="3-4-时钟置换算法（CLOCK）"><a href="#3-4-时钟置换算法（CLOCK）" class="headerlink" title="3.4 时钟置换算法（CLOCK）"></a>3.4 <strong>时钟置换算法（CLOCK）</strong></h3><ul><li><p>最佳置换算法 性能最好，但无法实现</p></li><li><p>先进先出置换算法 实现简单，但算法性能差</p></li><li><p>最近最久未使用置换算法 性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大</p></li><li><p><strong>时钟置换算法</strong>是一种性能和开销较均衡的算法，又称<strong>CLOCK算法</strong>，或<strong>最近未用算法（NRU，Not Recently Used）</strong></p><ul><li>实现方法：为每个页面设置一个<strong>访问位</strong>，再将<strong>内存中的页面</strong>都通过链接指针<strong>链接成一个循环队列</strong>。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描 （第二轮扫描中一定会有访问位为0的页面，因此<strong>简单的CLOCK算法</strong>选择一个淘汰页面<strong>最多会经过两轮扫描</strong>）</li></ul></li></ul><h3 id="3-5-改进型的时钟置换算法"><a href="#3-5-改进型的时钟置换算法" class="headerlink" title="3.5 改进型的时钟置换算法"></a>3.5 <strong>改进型的时钟置换算法</strong></h3><ul><li><p>简单的时钟置换算法 仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行I&#x2F;O操作写回外存。<strong>只有被淘汰的页面被修改过时，才需要写回外存</strong></p></li><li><p>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。<strong>在其他条件都相同时，应优先淘汰没有修改过的页面</strong>，避免I&#x2F;O操作。这就是<strong>改进型的时钟置换算法</strong>的思想</p><ul><li><strong>修改位&#x3D;0</strong>，表示<strong>页面没有被修改过</strong>；<strong>修改位&#x3D;1</strong>，表示<strong>页面被修改过</strong></li><li>为方便讨论，用<strong>（访问位，修改位）</strong>的形式表示各页面状态。如（1，1）表示一个页面近期被访问过，且被修改过</li><li><strong>实现方法</strong>:<ul><li>将所有可能被置换的页面排成一个循环队列</li><li>第一轮：从当前位置开始扫描到第一个（0，0）的帧用于替换<ul><li>本轮扫描不修改任何标志位</li><li>第一优先级：最近没访问，且没修改的页面</li></ul></li><li>第二轮：若第一轮扫描失败，则重新扫描 ，查找第一个（0，1）的帧用于替换<ul><li><strong>本轮将所有扫描过的帧访问位设为0</strong></li><li>第二优先级：最近没访问，但修改过的页面</li></ul></li><li>第三轮：若第二轮扫描失败，则重新扫描 ，查找第一个（0，0）的帧用于替换<ul><li>本轮扫描不修改任何标志位</li><li>第三优先级：最近访问过，但没修改的页面</li></ul></li><li>第四轮：若第三轮扫描失败，则重新扫描 ，查找第一个（0，1）的帧用于替换<ul><li>第四优先级：最近访问过，且修改过的页面</li></ul></li><li>由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描 一定会有一个帧被选中，因此<strong>改进型CLOCK置换算法</strong>选择一个淘汰页面<strong>最多会进行四轮扫描</strong></li></ul></li></ul></li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20241121194134402.png"></p><h2 id="4-页面分配策略、抖动、工作集"><a href="#4-页面分配策略、抖动、工作集" class="headerlink" title="4. 页面分配策略、抖动、工作集"></a><strong>4. 页面分配策略、抖动、工作集</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20241121195528729.png"></p><h3 id="4-1-驻留集"><a href="#4-1-驻留集" class="headerlink" title="4.1 驻留集"></a>4.1 <strong>驻留集</strong></h3><ul><li><p><strong>指请求分页存储管理中给进程分配的物理块的集合</strong></p></li><li><p>在采用了虚拟存储技术的系统中，<strong>驻留集大小一般小于进程的总大小</strong></p></li><li><p>若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少</p></li><li><p>驻留集太大，又会导致多道程序并发度下降，资源利用率降低</p><ul><li>考虑一个极端情况，若某进程共 有100个页面，则该进程的驻留集大小为100时进程可以全部放入内存，运行期间不可能再发生 缺页。若驻留集大小为1，则进程运行期间必定会极频繁地缺页</li></ul></li><li><p>所以应该选择一个合适的驻留集大小</p></li></ul><h3 id="4-2-页面分配、置换策略"><a href="#4-2-页面分配、置换策略" class="headerlink" title="4.2 页面分配、置换策略"></a>4.2 <strong>页面分配、置换策略</strong></h3><ul><li><p><strong>固定分配</strong>：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，<strong>驻留集大小不变</strong></p></li><li><p><strong>可变分配</strong>：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，<strong>驻留集大小可变</strong></p></li><li><p><strong>局部置换</strong>：发生缺页时只能选<strong>进程自己的物理块</strong>进行置换</p></li><li><p><strong>全局置换</strong>：可以将<strong>操作系统保留的空闲物理块</strong>分配给缺页进程，也可以将<strong>别的进程持有的物理块</strong>置换到外存，再分配给缺页进程</p></li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20241121194614305.png"></p><ul><li><strong>全局置换</strong>意味着一个进程拥有的物理块数量必然会改变，因此<strong>不可能是固定分配</strong></li><li><strong>固定分配局部置换</strong><ul><li>系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面</li><li>这种策略的缺点是：很难在刚开始就确定应为每个进程分配多少个物理块才算合理</li><li>采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数</li></ul></li><li><strong>可变分配全局置换</strong><ul><li>刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一 个<strong>未锁定的页面</strong>换出外存，再将该物理块分配给缺页的进程<ul><li>系统会锁定一些页面，这些页面中 的内容不能置换出外存（如：重要 的内核数据可以设为“锁定”）</li></ul></li><li>采用这种策略时，只要某进程发生缺页， 都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，缺页率会增加</li><li>可变分配<strong>全局</strong>置换：只要缺页就给分配新物理块</li></ul></li><li><strong>可变分配局部置换</strong><ul><li>刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。</li><li>如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度；反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块</li><li>可变分配<strong>局部</strong>置换：要根据发生缺页的频率来动态地增加或减少进程的物理块</li></ul></li></ul><h3 id="4-3-何时调入页面"><a href="#4-3-何时调入页面" class="headerlink" title="4.3 何时调入页面"></a>4.3 <strong>何时调入页面</strong></h3><ul><li><strong>预调页策略</strong><ul><li>根据<strong>局部性原理</strong>，一次调入若干个相邻的页面可能比一次调入一个页面更高效<ul><li>主要指<strong>空间局部性</strong>，即：如果当前访问了某个内存单元，在之后很有可能会接着访问与其相邻的那些内存单元</li></ul></li><li>但如果提前调入的页面中大多数都没被访问过，则又是低效的，因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有50%左右</li><li>故这种策略<strong>主要用于进程的首次调入</strong>，由程序员指出应该先调入哪些部分<ul><li>运行前调入</li></ul></li></ul></li><li><strong>请求调页策略</strong><ul><li>进程<strong>在运行期间发现缺页时才将所缺页面调入内存</strong><ul><li>运行时调入</li></ul></li><li>由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘I&#x2F;O操作，因此I&#x2F;O开销较大</li></ul></li></ul><h3 id="4-4-从何处调入页面"><a href="#4-4-从何处调入页面" class="headerlink" title="4.4 从何处调入页面"></a>4.4 <strong>从何处调入页面</strong></h3><ul><li><p>系统<strong>拥有足够的对换区空间</strong>：页面的调入、调出都是在<strong>内存</strong>与<strong>对换区</strong>之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前，需将进程相关的数据从<strong>文件区</strong>复制到<strong>对换区</strong></p><ul><li><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20241121195220873.png"></li></ul></li><li><p>系统<strong>缺少足够的对换区空间</strong>：凡是不会被修改的数据都直接从<strong>文件区</strong>调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从<strong>文件区</strong>调入即可。对于可能被修改的部分，换出时需写回磁盘<strong>对换区</strong>，下次需要时再从<strong>对换区</strong>调入</p></li><li><p><strong>UNIX 方式</strong>：运行之前进程有关的数据全部放在<strong>文件区</strong>，故未使用过的页面，都可从<strong>文件区</strong>调入。若被使用过的页面需要换出，则写回<strong>对换区</strong>，下次需要时从<strong>对换区</strong>调入</p></li></ul><h3 id="4-5-抖动（颠簸）现象"><a href="#4-5-抖动（颠簸）现象" class="headerlink" title="4.5 抖动（颠簸）现象"></a>4.5 <strong>抖动（颠簸）现象</strong></h3><ul><li><p>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为<strong>抖动(颠簸)</strong></p></li><li><p>产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数（<strong>分配给进程的物理块不够</strong>）</p><ul><li>为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率</li><li>为了研究为应该为每个进程分配多少个物理块，Denning 提出了进程“<strong>工作集</strong>”的概念</li></ul></li></ul><h3 id="4-6-工作集"><a href="#4-6-工作集" class="headerlink" title="4.6 工作集"></a>4.6 <strong>工作集</strong></h3><ul><li><p><strong>驻留集</strong>：指请求分页存储管理中给<strong>进程分配的内存块的集合</strong></p></li><li><p><strong>工作集</strong>：指在某段时间间隔里，<strong>进程实际访问页面的集合</strong></p></li><li><p><strong>工作集大小可能小于窗口尺寸</strong>，实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若干内存块</p></li><li><p>如：窗口尺寸为5，经过一段时间的监测发现某进程的工作集最大为3，那么说明该进程有很好的局部性，可以给这个进程分配3个以上的内存块即可满足进程的运行需要。一般来说，<strong>驻留集大小不能小于工作集大小</strong>，否则进程运行过程中将频繁缺页</p></li><li><p>拓展：</p><ul><li>基于局部性原理可知，进程在一段时间内访问的页面与不久之后会访问的页面是有相关性的。因此，可以根据进程近期访问的页面集合（工作集）来设计一种页面置换算法 – 选择一个不在工作集中的页面进行淘汰</li></ul></li></ul><h2 id="5-内存映射文件"><a href="#5-内存映射文件" class="headerlink" title="5. 内存映射文件"></a><strong>5. 内存映射文件</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20241121200153539.png"></p><h3 id="5-1-内存映射文件（Memory-Mapped-Files）"><a href="#5-1-内存映射文件（Memory-Mapped-Files）" class="headerlink" title="5.1 内存映射文件（Memory-Mapped Files）"></a>5.1 <strong>内存映射文件（Memory-Mapped Files）</strong></h3><ul><li><strong>内存映射文件</strong>：操作系统向上层程序员提供的功能（<strong>系统调用</strong>）<ul><li>方便程序员访问文件数据<ul><li><strong>传统的文件访问方式</strong></li></ul></li></ul></li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20241121195856882.png"></p><ul><li><strong>内存映射文件的访问方式</strong></li><li><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20241121200028984.png"></li><li>方便多个进程共享同一个文件</li><li><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20241121200139553.png"></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第三章 内存管理-3.1 内存管理概念</title>
    <link href="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/"/>
    <url>/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="3-1-内存管理"><a href="#3-1-内存管理" class="headerlink" title="3.1 内存管理"></a><strong>3.1 内存管理</strong></h1><h2 id="1-内存的基础知识"><a href="#1-内存的基础知识" class="headerlink" title="1. 内存的基础知识"></a><strong>1. 内存的基础知识</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121102355539.png"></p><h3 id="1-1-什么是内存-有何作用"><a href="#1-1-什么是内存-有何作用" class="headerlink" title="1.1 什么是内存? 有何作用?"></a>1.1 <strong>什么是内存? 有何作用?</strong></h3><ul><li><p>内存可存放数据, 程序执行前<strong>需要先放到内存中才能被CPU处理</strong> – 缓和CPU与硬盘之间的速度矛盾</p></li><li><p>在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。那么，<strong>如何区分各个程序的数据是放在什么地方的呢?</strong></p><ul><li>方案：<strong>给内存的存储单元编地址</strong></li><li>内存中也有一个一个的“小房间”，每个小房间就是一个“<strong>存储单元</strong>“</li><li><strong>内存地址</strong>从0开始，每个地址对应一个存储单元</li><li>如果计算机“<strong>按字节编址</strong>“，则每个存储单元大小为 1字节，即 1B，即 8个二进制位</li><li>如果字长为16位的计算机“<strong>按字编址</strong>”，则每个存储单元大小为 1个字，每个字的大小为 16 个二进制位</li></ul></li><li><p>补充知识:</p><ul><li>2<sup>10</sup> &#x3D; 1K（千）</li><li>2<sup>20</sup> &#x3D; 1M（兆，百万）</li><li>2<sup>30</sup> &#x3D; 1G（十亿，千兆）</li><li>注: 有的题目会告诉我们内存的大小，让我们确定地址长度应该是多少（即要多少个二进制位才能表示相应数目的存储单元）<ul><li>Q: 一台手机&#x2F;电脑 有 4GB 内存，是什么意思？</li><li>A: 是指该内存中可以存放 4 * 2<sup>30</sup>个字节。如果是按字节编址的话，也就是有 4 * 2<sup>30</sup> &#x3D; 2<sup>32</sup>个“小房间”，这么多“小房间”，需要 2<sup>32</sup>个地址才能一一标识，所以地址需要用 32 个二进制位来表示（0~2<sup>32</sup> -1）</li></ul></li></ul></li></ul><h3 id="1-2-指令的工作原理"><a href="#1-2-指令的工作原理" class="headerlink" title="1.2 指令的工作原理"></a>1.2 <strong>指令的工作原理</strong></h3><ul><li><p>指令: 操作码 + 若干参数(可能包含地址参数)</p></li><li><p>指令的工作基于“地址”。每个地址对应一个数据的存储单元 </p></li><li><p>我们写的代码要翻译成CPU能识别的指令。这些指令会告诉CPU应该去内存的哪个地址读&#x2F;写数据，这个数据应该做什么样的处理</p></li></ul><h3 id="1-3-逻辑地址-vs-物理地址"><a href="#1-3-逻辑地址-vs-物理地址" class="headerlink" title="1.3 逻辑地址 vs 物理地址"></a>1.3 <strong>逻辑地址 vs 物理地址</strong></h3><ul><li><p><strong>物理地址（绝对地址）</strong>即内存中的实际地址</p></li><li><p>程序经过编译、链接后生成的指令中指明的是<strong>逻辑地址（相对地址）</strong></p><ul><li>即：相对于进程的起始地址而言的地址</li></ul></li></ul><h3 id="1-4-从写程序到程序运行"><a href="#1-4-从写程序到程序运行" class="headerlink" title="1.4 从写程序到程序运行"></a>1.4 <strong>从写程序到程序运行</strong></h3><ul><li><p><strong>编译</strong>：由编译程序将用户源代码编译成<strong>若干个目标模块</strong>（编译就是<strong>把高级语言翻译为机器语言</strong>）</p></li><li><p><strong>链接</strong>：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的<strong>装入模块</strong></p></li><li><p><strong>装入</strong>（装载）：由装入程序<strong>将装入模块装入内存</strong>运行</p></li></ul><h3 id="1-5-链接的三种方式"><a href="#1-5-链接的三种方式" class="headerlink" title="1.5 链接的三种方式"></a>1.5 <strong>链接的三种方式</strong></h3><ul><li><strong>静态链接</strong><ul><li><strong>在程序运行之前</strong>，先将各目标模块及它们所需的库函数连接成一个<strong>完整的可执行文件（装入模块）</strong>，之后不再拆开</li></ul></li><li><strong>装入时动态链接</strong><ul><li>将各目标模块装入内存时，<strong>边装入边链接</strong>的链接方式</li></ul></li><li><strong>运行时动态链接</strong><ul><li><strong>在程序执行中需要该目标模块时，才对它进行链接</strong></li><li>其优点是便于修改和更新，便于实现对目标模块的共享</li></ul></li></ul><h3 id="1-6-装入的三种方式"><a href="#1-6-装入的三种方式" class="headerlink" title="1.6 装入的三种方式"></a>1.6 <strong>装入的三种方式</strong></h3><ul><li><p><strong>绝对装入</strong></p><ul><li>在<strong>编译</strong>时，如果知道程序将放到内存中的哪个位置，编译程序<strong>将产生绝对地址</strong>的目标代码，装入程序按照装入模块中的地址，将程序和数据装入内存</li><li>绝对装入只适用于<strong>单道程序环境</strong></li><li>程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址</li></ul></li><li><p><strong>静态重定位(可重定位装入)</strong></p><ul><li>编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。<strong>装入</strong>时对地址进行“重定位”，<strong>将逻辑地址变换为物理地址</strong>（地址变换是在装入时一次完成的）</li><li><strong>静态重定位</strong>的特点是在一个<strong>作业装入内存时，必须分配其要求的全部内存空间</strong>，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。</li></ul></li><li><p><strong>动态重定位(动态运行时转入)</strong></p><ul><li>编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把<strong>地址转换推迟到程序真正要执行时才进行</strong>。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个<strong>重定位寄存器</strong>的支持 </li><li>重定位寄存器：存放装入模块存放的起始位置</li></ul></li><li><p>采用<strong>动态重定位</strong>时<strong>允许程序在内存中发生移动</strong></p><ul><li>可将程序分配到不连续的存储区中</li><li>在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存</li><li>便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间</li></ul></li></ul><h2 id="2-内存管理的概念"><a href="#2-内存管理的概念" class="headerlink" title="2. 内存管理的概念"></a><strong>2. 内存管理的概念</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121103658059.png"></p><h3 id="2-1-内存管理"><a href="#2-1-内存管理" class="headerlink" title="2.1 内存管理"></a>2.1 <strong>内存管理</strong></h3><ul><li>操作系统作为系统资源的管理者，当然也需要对内存进行管理，要管些什么呢？<ul><li>操作系统负责<strong>内存空间的分配与回收</strong></li><li>操作系统需要提供某种技术从逻辑上<strong>对内存空间进行扩充</strong></li><li>操作系统需要提供<strong>地址转换功能</strong>，负责程序的逻辑地址与物理地址的转换</li><li>操作系统需要提供<strong>内存保护</strong>功能。保证各进程在各自存储空间内运行，互不干扰</li></ul></li></ul><h3 id="2-2-内存空间的分配与回收"><a href="#2-2-内存空间的分配与回收" class="headerlink" title="2.2 内存空间的分配与回收"></a>2.2 <strong>内存空间的分配与回收</strong></h3><ul><li><p>操作系统要怎么记录哪些内存区域已经被分配出去了，哪些又还空闲？</p></li><li><p>很多位置都可以放，那应该放在哪里？</p></li><li><p>当进程运行结束之后，如何将进程占用的内存空间回收？</p></li><li><p><strong>分配方式</strong>:</p><ul><li><strong>连续分配管理方式</strong><ul><li><strong>连续分配</strong>：<strong>指为用户进程分配的必须是一个连续的内存空间</strong></li><li><strong>单一连续分配</strong>、<strong>固定分区分配</strong>、<strong>动态分区分配</strong></li></ul></li><li><strong>非连续分配管理方式</strong><ul><li><strong>非连续分配</strong>：<strong>指为用户进程分配的可以是一些分散的内存空间</strong></li><li><strong>基本分页存储管理</strong>、<strong>基本分段存储管理</strong>、<strong>段页式存储管理</strong></li></ul></li></ul></li></ul><h3 id="2-3-内存空间的扩充"><a href="#2-3-内存空间的扩充" class="headerlink" title="2.3 内存空间的扩充"></a>2.3 <strong>内存空间的扩充</strong></h3><ul><li><p>实现虚拟性</p></li><li><p>实现内存空间扩充的相关技术: <strong>覆盖技术</strong>、<strong>交换技术</strong>、<strong>虚拟存储技术</strong></p></li></ul><h3 id="2-4-地址转化"><a href="#2-4-地址转化" class="headerlink" title="2.4 地址转化"></a>2.4 <strong>地址转化</strong></h3><ul><li><p>为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而<strong>逻辑地址到物理地址的转换</strong>（这个过程称为<strong>地址重定位</strong>）应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况</p></li><li><p>三种装入方式:</p><ul><li><strong>绝对装入</strong>: 单道程序阶段，此时还没产生操作系统</li><li><strong>可重定位装入(静态重定位)</strong>: 用于早期的多道批处理操作系统</li><li><strong>动态运行时转入(动态重定位)</strong>: 现代操作系统</li></ul></li></ul><h3 id="2-5-内存保护"><a href="#2-5-内存保护" class="headerlink" title="2.5 内存保护"></a>2.5 <strong>内存保护</strong></h3><ul><li>内存保护可采取两种方法：<ul><li>方法一：在CPU中设置一对<strong>上、下限寄存器</strong>，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界<ul><li>假设进程1的逻辑地址空间为 0<del>179；实际物理地址空间为 100</del>279</li><li>则上限寄存器存放100, 下限寄存器存放279</li></ul></li><li>方法二：采用<strong>重定位寄存器</strong>（又称<strong>基址寄存器</strong>）和<strong>界地址寄存器</strong>（又称<strong>限长寄存器</strong>）进行越界检查。<strong>重定位寄存器中存放的是进程的起始物理地址</strong>。<strong>界地址寄存器中存放的是进程的最大逻辑地址</strong><ul><li>假设进程1的逻辑地址空间为 0<del>179；实际物理地址空间为 100</del>279</li><li>则重定位寄存器存放100, 界地址寄存器存放179</li><li>CPU先通过界地址寄存器判断指令有没有越界, 没有的话再通过重定位寄存器计算物理地址</li></ul></li></ul></li></ul><h2 id="3-覆盖与交换"><a href="#3-覆盖与交换" class="headerlink" title="3. 覆盖与交换"></a><strong>3. 覆盖与交换</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121104512608.png"></p><h3 id="3-1-覆盖技术"><a href="#3-1-覆盖技术" class="headerlink" title="3.1 覆盖技术"></a>3.1 <strong>覆盖技术</strong></h3><ul><li><p>早期的计算机内存很小，比如 IBM 推出的第一台PC机最大只支持 1MB 大小的内存。因此经常会出现内存大小不够的情况。后来人们引入了<strong>覆盖技术</strong>，用来解决“程序大小超过物理内存总和”的问题</p></li><li><p>覆盖技术的思想:</p><ul><li><strong>将程序分为多个段</strong>（多个模块），常用的段常驻内存，不常用的段在需要时调入内存</li><li>内存中分为一个“<strong>固定区</strong>”和若干个“<strong>覆盖区</strong>”</li><li>需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束）</li><li>不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存</li><li>程序按照自身逻辑结构，让那些不可能同时被访问的程序段共享同一个覆盖区</li></ul></li><li><p>缺点:</p><ul><li>必须由程序员声明覆盖结构，操作系统完成自动覆盖。对用户不透明，增加了用户编程负担</li><li>覆盖技术<strong>只用于早期的操作系统中</strong>，现在已成为历史</li></ul></li></ul><h3 id="3-2-交换-对换-技术"><a href="#3-2-交换-对换-技术" class="headerlink" title="3.2 交换(对换)技术"></a>3.2 <strong>交换(对换)技术</strong></h3><ul><li><p>内存空间紧张时，系统将<strong>内存</strong>中某些<strong>进程</strong>暂时<strong>换出外存</strong>，把<strong>外存</strong>中某些已具备运行条件的<strong>进程换入内存</strong>（进程在内存与磁盘间动态调度）</p></li><li><p><strong>中级调度（内存调度）</strong>，就是要决定将哪个处于挂起状态的进程重新调入内存</p></li><li><p><strong>思考</strong>:</p><ul><li>应该在外存（磁盘）的什么位置保存被换出的进程？<ul><li>具有对换功能的操作系统中，通常把<strong>磁盘空间</strong>分为<strong>文件区</strong>和<strong>对换区</strong>两部分</li><li><strong>文件区</strong>主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用<strong>离散分配方式</strong></li><li><strong>对换区</strong>空间只占磁盘空间的小部分，<strong>被换出的进程数据就存放在对换区</strong>。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用<strong>连续分配方式</strong>(学过<strong>文件管理</strong>章节后即可理解)，总之，<strong>对换区的I&#x2F;O速度比文件区的更快</strong></li></ul></li><li>什么时候应该交换？<ul><li>交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停</li><li>例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出</li></ul></li><li>应该换出哪些进程？<ul><li>可优先换出阻塞进程；可换出优先级低的进程；</li><li>为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间…</li></ul></li></ul></li><li><p><strong>注意</strong>：<strong>PCB 会常驻内存</strong>，不会被换出外存</p></li></ul><h2 id="4-连续分配管理方式"><a href="#4-连续分配管理方式" class="headerlink" title="4. 连续分配管理方式"></a><strong>4. 连续分配管理方式</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121110518884.png"></p><ul><li><strong>连续分配</strong>：<strong>指为用户进程分配的必须是一个连续的内存空间</strong></li></ul><h3 id="4-1-单一连续分配"><a href="#4-1-单一连续分配" class="headerlink" title="4.1 单一连续分配"></a>4.1 <strong>单一连续分配</strong></h3><ul><li><p>在<strong>单一连续分配方式</strong>中，<strong>内存</strong>被分为<strong>系统区</strong>和<strong>用户区</strong>。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。内存中只能有一道用户程序，<strong>用户程序独占整个用户区空间</strong></p></li><li><p>优点：实现简单；<strong>无外部碎片</strong>；可以采用覆盖技术扩充内存；不一定需要采取内存保护（eg：早期的 PC 操作系统 MS-DOS）</p></li><li><p>缺点：只能用于单用户、单任务的操作系统中；<strong>有内部碎片</strong>；存储器利用率极低</p><ul><li><strong>内部碎片</strong>：分配给某进程的内存区域中，如果有些部分没有用上</li><li><strong>外部碎片</strong>：内存中的某些空闲分区由于太小而难以利用</li></ul></li></ul><h2 id="4-2-固定分区分配"><a href="#4-2-固定分区分配" class="headerlink" title="4.2 固定分区分配"></a>4.2 <strong>固定分区分配</strong></h2><ul><li><p>20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个<strong>用户空间</strong>划分为<strong>若干个固定大小的分区</strong>，在<strong>每个分区中只装入一道作业</strong>，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式</p></li><li><p><strong>分区大小相等</strong></p><ul><li>缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合（比如：钢铁厂有n个相同的炼钢炉，就可把内存分为n个大小相等的区域存放n个炼钢炉控制程序）</li></ul></li><li><p><strong>分区大小不等</strong></p><ul><li>增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分</li><li>比如：划分多个小分区、适量中等分区、少量大分区</li></ul></li><li><p>操作系统需要建立一个数据结构 – <strong>分区说明表</strong>，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态（是否已分配）。当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”</p></li><li><p>优点：实现简单，<strong>无外部碎片</strong></p></li><li><p>缺点：</p><ul><li>a. 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能</li><li>b. <strong>会产生内部碎片</strong>，内存利用率低</li></ul></li></ul><h3 id="4-3-动态分区分配-可变分区分配"><a href="#4-3-动态分区分配-可变分区分配" class="headerlink" title="4.3 动态分区分配(可变分区分配)"></a>4.3 <strong>动态分区分配</strong>(可变分区分配)</h3><ul><li><p>这种分配方式<strong>不会预先划分内存分区</strong>，而是<strong>在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要</strong>。因此系统分区的大小和数目是可变的</p></li><li><p><strong>思考</strong>:</p><ul><li>系统要用什么样的数据结构记录内存的使用情况？<ul><li>可以通过<strong>空闲分区表</strong>或<strong>空闲分区链</strong>这两种数据结构记录内存使用情况</li><li><strong>空闲分区表</strong>: 每个空闲分区对应一个表项。表项中包含分区号、分区大小、分区起始地址等信息</li><li><strong>空闲分区链</strong>: 每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息</li></ul></li><li>当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？<ul><li>把一个新作业装入内存时，须按照一定的<strong>动态分区分配算法</strong>，从空闲分区表（或空闲分区链）中选出一个分区分配给该作业</li><li>由于分配算法算法对系统性能有很大的影响，因此人们对它进行了广泛的研究</li></ul></li><li>如何进行分区的分配与回收操作？<ul><li>假设系统采用的数据结构是“空闲分区表” <ul><li>分配<ul><li>可以根据实际分配情况, 对空闲分区表进行分区大小修改、删除表项等操作</li></ul></li><li>回收<ul><li>可以根据实际回收情况, 对空闲分区表进行合并表项(回收的区域有相邻的空白表项)、新增表项等操作</li></ul></li><li>注：各表项的顺序不一定按照地址递增顺序排列，具体的排列方式需要依据动态分区分配算法来确定</li></ul></li></ul></li></ul></li><li><p><strong>动态分区分配没有内部碎片，但是有外部碎片</strong></p><ul><li>如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些</li><li>“碎片”不能满足进程的需求。可以通过<strong>紧凑（拼凑，Compaction）技术来解决外部碎片</strong></li><li>“紧凑”之后需要把进程的起始地址修改, <strong>进程的起始地址</strong>存放在<strong>PCB</strong>当中, 进程上CPU运行之前,会把进程的起始地址放到<strong>重定位寄存器</strong>里</li></ul></li><li><p><strong>动态分区分配</strong>应该采用<strong>动态运行时装入(动态重定位)</strong></p><ul><li>因为通过紧凑技术会导致进程起始地址发生变化, 而动态重定位允许程序在内存中发生移动</li></ul></li></ul><h2 id="5-动态分区分配算法"><a href="#5-动态分区分配算法" class="headerlink" title="5. 动态分区分配算法"></a><strong>5. 动态分区分配算法</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121111606972.png"></p><p><strong>动态分区分配算法</strong>: <strong>在动态分区分配方式中， 当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配</strong></p><h3 id="5-1-首次适应算法-First-Fit"><a href="#5-1-首次适应算法-First-Fit" class="headerlink" title="5.1 首次适应算法(First Fit)"></a>5.1 <strong>首次适应算法</strong>(First Fit)</h3><ul><li><p>算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区</p></li><li><p>如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p></li><li><p>优点：首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。 但是这种规则也决定了当低地址部分有更小的分区可以满足需求时， 会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来（最佳适应算法的优点）</p></li></ul><h3 id="5-2-最佳适应算法-Best-Fit"><a href="#5-2-最佳适应算法-Best-Fit" class="headerlink" title="5.2 最佳适应算法(Best Fit)"></a>5.2 <strong>最佳适应算法</strong>(Best Fit)</h3><ul><li><p>算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区</p></li><li><p>如何实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p></li><li><p>缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片</p></li></ul><h3 id="5-3-最坏适应算法-Worst-Fit"><a href="#5-3-最坏适应算法-Worst-Fit" class="headerlink" title="5.3 最坏适应算法(Worst Fit)"></a>5.3 <strong>最坏适应算法</strong>(Worst Fit)</h3><ul><li><p>又称 最大适应算法（Largest Fit）</p></li><li><p>算法思想：为了解决最佳适应算法的问题 – 即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用</p></li><li><p>如何实现：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p></li><li><p>缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了</p></li></ul><h3 id="5-4-邻近适应算法-Next-Fit"><a href="#5-4-邻近适应算法-Next-Fit" class="headerlink" title="5.4 邻近适应算法(Next Fit)"></a>5.4 <strong>邻近适应算法</strong>(Next Fit)</h3><ul><li><p>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题</p></li><li><p>如何实现：空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p></li><li><p>缺点：邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用（最大适应算法的缺点）</p></li></ul><p>综合来看，<strong>四种算法中，首次适应算法的效果反而更好</strong></p><h2 id="6-基本分页存储管理的概念"><a href="#6-基本分页存储管理的概念" class="headerlink" title="6. 基本分页存储管理的概念"></a><strong>6. 基本分页存储管理的概念</strong></h2><ul><li><strong>非连续分配</strong>：<strong>指为用户进程分配的可以是一些分散的内存空间</strong></li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121123601201.png"></p><h3 id="6-1-什么是分页存储"><a href="#6-1-什么是分页存储" class="headerlink" title="6.1 什么是分页存储?"></a>6.1 <strong>什么是分页存储?</strong></h3><ul><li><p>将<strong>内存空间</strong>分为一个个<strong>大小相等的分区</strong>（比如：每个分区4KB），每个分区就是一个“<strong>页框(PageFrame)<strong>”（</strong>页框</strong>&#x3D;<strong>页帧</strong>&#x3D;<strong>内存块</strong>&#x3D;<strong>物理块</strong>&#x3D;<strong>物理页面</strong>）。每个页框有一个编号，即“<strong>页框号</strong>”（<strong>页框号</strong>&#x3D;<strong>页帧号</strong>&#x3D;<strong>内存块号</strong>&#x3D;<strong>物理块号</strong>&#x3D;<strong>物理页号</strong>），<strong>页框号从0开始</strong></p></li><li><p>将<strong>进程的逻辑地址空间</strong>也分为<strong>与页框大小相等</strong>的一个个部分，每个部分称为一个“<strong>页</strong>”或“<strong>页面</strong>” 。每个页面也有一个编号，即“<strong>页号</strong>”，<strong>页号也是从0开始</strong></p></li><li><p>注意区分 <strong>页框</strong> vs <strong>页</strong> 的概念</p></li><li><p>操作系统<strong>以页框为单位为各个进程分配内存空间</strong>。进程的每个页面分别放入一个页框中。也就是说，进程的<strong>页面</strong>与内存的<strong>页框</strong>有一一对应的关系。<strong>各个页面不必连续存放，可以放到不相邻的各个页框中</strong></p><ul><li>注：进程的最后一个页面可能没有一个页框那么大。也就是说，<strong>分页存储有可能产生内部碎片</strong>，因此页框不能太大，否则可能产生过大的内部碎片造成浪费</li></ul></li></ul><h3 id="6-2-页表"><a href="#6-2-页表" class="headerlink" title="6.2 页表"></a>6.2 <strong>页表</strong></h3><ul><li>为了能知道进程的每个<strong>页面</strong>在内存中存放的位置，操作系统要为每个进程建立一张<strong>页表</strong><ul><li>注：页表通常存在<strong>PCB</strong>（进程控制块）中</li></ul></li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121112224337.png"></p><h3 id="6-3-每个页表项多大？占几个字节？"><a href="#6-3-每个页表项多大？占几个字节？" class="headerlink" title="6.3 每个页表项多大？占几个字节？"></a>6.3 <strong>每个页表项多大？占几个字节？</strong></h3><ul><li><p>Eg：假设某系统物理内存大小为 4GB，页面大小为 4KB，则每个页表项至少应该为多少字节？</p></li><li><p>内存块大小&#x3D;页面大小&#x3D;4KB&#x3D; 2<sup>12</sup>B</p><ul><li>4GB 的内存总共会被分为 2<sup>32</sup> &#x2F; 2<sup>12</sup> &#x3D; 2<sup>20</sup>个内存块</li><li>内存块号的范围应该是 0 ~ 2<sup>20</sup> -1</li><li>内存块号至少要用 20 bit 来表示</li><li>内存按字节编址, 则至少要用3B来表示<strong>块号</strong>（3*8&#x3D;24bit）<ul><li><strong>注意</strong>：页表记录的只是内存块号，而不是内存块的起始地址！<ul><li>j 号内存块的起始地址 &#x3D; j * 内存块大小</li></ul></li><li><strong>重要考点</strong>：计算机中内存块的数量 → 页表项中块号至少占多少字节</li></ul></li></ul></li><li><p><strong>页表项连续存放</strong>，因此<strong>页号可以是隐含的，不占存储空间（类比数组）</strong></p><ul><li>假设页表中的各页表项从内存地址为 X 的地方开始连续存放，如何找到页号为 i 的页表项？</li><li>i 号页表项的存放地址 &#x3D; X + i * 页表项大小</li></ul></li></ul><h3 id="6-4-如何通过页表实现逻辑地址到物理地址的转换？"><a href="#6-4-如何通过页表实现逻辑地址到物理地址的转换？" class="headerlink" title="6.4 如何通过页表实现逻辑地址到物理地址的转换？"></a>6.4 <strong>如何通过页表实现逻辑地址到物理地址的转换？</strong></h3><ul><li><strong>进程在内存中连续存放时</strong>，操作系统是如何实现逻辑地址到物理地址的转换的？<ul><li><strong>重定位寄存器</strong>：指明了进程在内存中的起始位置</li><li>物理地址 &#x3D; 进程在内存中的起始位置 + 逻辑地址</li><li>逻辑地址相对于起始位置的“偏移量”</li></ul></li><li>将进程地址空间<strong>分页</strong>之后，操作系统该如何实现逻辑地址到物理地址的转换？<ul><li>特点：虽然进程的各个<strong>页面是离散存放的</strong>，但是<strong>页面内部是连续存放的</strong></li><li>如果要访问逻辑地址 A，则:<ul><li>确定逻辑地址A 对应的“<strong>页号</strong>”P</li><li>找到P号页面在内存中的起始地址<ul><li>通过查找页表，找到页号P对应的内存块号，计算出内存块号在内存中的起始地址</li></ul></li><li>确定逻辑地址A 的“<strong>页内偏移量</strong>”W</li></ul></li><li>逻辑地址A 对应的物理地址 &#x3D; P号页面在内存中的起始地址 + 页内偏移量W</li></ul></li></ul><h3 id="6-5-如何确定一个逻辑地址对应的页号、页内偏移量？"><a href="#6-5-如何确定一个逻辑地址对应的页号、页内偏移量？" class="headerlink" title="6.5 如何确定一个逻辑地址对应的页号、页内偏移量？"></a>6.5 <strong>如何确定一个逻辑地址对应的页号、页内偏移量？</strong></h3><ul><li><p>Eg：在某计算机系统中，页面大小是50B。某进程逻辑地址空间大小为200B，则逻辑地址 110 对应的页号、页内偏移量是多少？</p><ul><li>页号 &#x3D; 110 &#x2F; 50 &#x3D; 2</li><li>页内偏移量 &#x3D; 110 % 50 &#x3D; 10</li></ul></li><li><p>页号 &#x3D; 逻辑地址 &#x2F; 页面长度 （取除法的整数部分）</p></li><li><p>页内偏移量 &#x3D; 逻辑地址 % 页面长度（取除法的余数部分）</p></li><li><p><strong>逻辑地址 可以拆分为（页号，页内偏移量）</strong></p></li><li><p>当<strong>页面大小</strong>刚好是<strong>2的整数幂时</strong>:</p></li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121123228264.png"></p><ul><li><strong>总结：页面大小 刚好是 2的整数幂 有什么好处？</strong><ul><li>逻辑地址的拆分更加迅速 – 如果每个页面大小为 2KB，用二进制数表示逻辑地址，则末尾 K 位即为页内偏移量，其余部分就是页号。因此，如果让每个页面的大小为 2 的整数幂，计算机硬件就可以很方便地得出一个逻辑地址对应的页号和页内偏移量，而无需进行除法运算，从而提升了运行速度</li><li>物理地址的计算更加迅速 – 根据逻辑地址得到页号，根据页号查询页表从而找到页面存放的内存块号，将二进制表示的内存块号和页内偏移量拼接起来，就可以得到最终的物理地址</li></ul></li></ul><h3 id="6-6-逻辑地址结构"><a href="#6-6-逻辑地址结构" class="headerlink" title="6.6 逻辑地址结构"></a>6.6 <strong>逻辑地址结构</strong></h3><ul><li>页面大小刚好是2的整数幂时：</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121123548986.png"></p><ul><li>Tips：有些奇葩题目中<strong>页面大小有可能不是2的整数次幂</strong>，这种情况还是得用最原始的方法计算：<ul><li>页号 &#x3D; 逻辑地址 &#x2F; 页面长度 （取除法的整数部分）</li><li>页内偏移量 &#x3D; 逻辑地址 % 页面长度（取除法的余数部分）</li></ul></li></ul><h2 id="7-基本地址变换机构"><a href="#7-基本地址变换机构" class="headerlink" title="7. 基本地址变换机构"></a><strong>7. 基本地址变换机构</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121125306825.png"></p><ul><li><strong>基本地址变换机构</strong>：<strong>用于实现逻辑地址到物理地址转换的一组硬件机构</strong></li></ul><h3 id="7-1-页表寄存器"><a href="#7-1-页表寄存器" class="headerlink" title="7.1 页表寄存器"></a>7.1 <strong>页表寄存器</strong></h3><ul><li><p><strong>基本地址变换机构</strong>可以借助进程的<strong>页表</strong>将逻辑地址转换为物理地址</p></li><li><p>通常会在系统中设置一个<strong>页表寄存器</strong>(PTR)，存放<strong>页表在内存中的起始地址F</strong>和<strong>页表长度M</strong></p></li><li><p>进程未执行时，页表的始址和页表长度放在<strong>PCB</strong>(进程控制块)中，当进程被调度时，操作系统内核会把它们放到页表寄存器中</p></li></ul><h3 id="7-2-设页面大小为L，逻辑地址A到物理地址E的变换过程如下："><a href="#7-2-设页面大小为L，逻辑地址A到物理地址E的变换过程如下：" class="headerlink" title="7.2 设页面大小为L，逻辑地址A到物理地址E的变换过程如下："></a>7.2 <strong>设页面大小为L，逻辑地址A到物理地址E的变换过程如下</strong>：</h3><ul><li><p>注意: 页面大小是2的整数幂</p></li><li><p>计算<strong>页号P</strong>和<strong>页内偏移量W</strong></p><ul><li>如果用十进制数手算，则 P &#x3D; A &#x2F; L， W &#x3D; A % L</li><li>但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量</li></ul></li><li><p>比较页号P和页表长度M，若 P ≥ M， 则产生越界中断，否则继续执行</p><ul><li>注意：页号是从0开始的，而页表长度至少是1，因此P&#x3D;M时也会越界</li></ul></li><li><p>页表中页号P对应的 页表项地址 &#x3D; 页表起始地址F + 页号P * 页表项长度 ，取出该页表项内容b，即为内存块号</p><ul><li>注意区分<strong>页表项长度</strong>、 <strong>页表长度</strong>、<strong>页面大小</strong>的区别</li><li>页表长度：指的是这个页表中总共有几个页表项，即总共有几个页</li><li>页表项长度：指的是每个页表项占多大的存储空间</li><li>页面大小：指的是一个页面占多大的存储空间</li></ul></li><li><p>计算 E &#x3D; b * L + W，用得到的物理地址E去访存</p><ul><li>如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了</li></ul></li><li><p><strong>动手验证</strong>：</p><ul><li>假设页面大小L &#x3D; 1KB，最终要访问的内存块号b &#x3D; 2，页内偏移量W &#x3D; 1023</li><li>① 尝试用E &#x3D; b * L + W计算目标物理地址</li><li>② 尝试把内存块号、页内偏移量用二进制表示，并把它们拼接起来得到物理地址</li><li>对比①、②的结果是否一致</li></ul></li></ul><p><strong>例题</strong>：</p><ul><li>在<strong>分页存储管理</strong>(页式管理)的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，<strong>页式管理中地址是一维的</strong><ul><li>即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位</li></ul></li></ul><h3 id="7-3-页表项大小"><a href="#7-3-页表项大小" class="headerlink" title="7.3 页表项大小"></a>7.3 <strong>页表项大小</strong></h3><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121125207912.png"></p><h2 id="8-具有快表的地址变换机构"><a href="#8-具有快表的地址变换机构" class="headerlink" title="8. 具有快表的地址变换机构"></a><strong>8. 具有快表的地址变换机构</strong></h2><ul><li><strong>具有快表的地址变换机构</strong>：<strong>是基本地址变换机构的改进版本</strong></li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121163126476.png"></p><h3 id="8-1-什么是快表-TLB"><a href="#8-1-什么是快表-TLB" class="headerlink" title="8.1 什么是快表(TLB)?"></a>8.1 <strong>什么是快表(TLB)?</strong></h3><ul><li><strong>快表</strong>，又称<strong>联想寄存器（TLB， translation lookaside buffer）</strong>，是一种访问速度比内存快很多的<strong>高速缓存</strong>（<strong>TLB不是内存！</strong>），用来存放最近访问的页表项的副本，可以加速地址变换的速度。与此对应，<strong>内存中的页表</strong>常称为<strong>慢表</strong></li><li><strong>引入快表后的地址变换过程</strong>:<ul><li>CPU给出逻辑地址，由某个硬件算得<strong>页号</strong>、<strong>页内偏移量</strong>，将页号与<strong>快表</strong>中的所有页号进行比较</li><li>如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的<strong>内存块号</strong>，再<strong>将内存块号与页内偏移量拼接形成物理地址</strong>，最后，访问该物理地址对应的<strong>内存单元</strong>。因此，<strong>若快表命中</strong>，则访问某个逻辑地址<strong>仅需一次访存</strong>即可</li><li>如果没有找到匹配的页号，则需要访问<strong>内存中的页表</strong>，找到对应页表项，得到页面存放的<strong>内存块号</strong>，再<strong>将内存块号与页内偏移量拼接形成物理地址</strong>，最后，访问该物理地址对应的<strong>内存单元</strong>。因此，<strong>若快表未命中</strong>，则<strong>访问某个逻辑地址需要两次访存</strong><ul><li>注意：<strong>在找到页表项后，应同时将其存入快表</strong>，以便后面可能的再次访问。<strong>若快表己满，则必须按照一定的算法对旧的页表项进行替换</strong></li></ul></li><li>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间</li><li>因为<strong>局部性原理</strong>，一般来说快表的命中率可以达到90%以上<ul><li>例：某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时1us，访问一次内存耗100us。若快表的命中率为90%，那么访问一个逻辑地址的平均耗时是多少?<ul><li>(1 + 100) * 0.9 + (1 + 100 + 100) * 0.1 &#x3D; 111 us</li><li><strong>有的系统支持快表和慢表同时查找</strong>，如果是这样，平均耗时应该是：</li><li>(1 + 100) * 0.9 + (100 + 100) * 0.1 &#x3D; 110.9 us</li><li>若未采用快表机制，则访问一个逻辑地址需要：</li><li>100 + 100 &#x3D; 200us</li><li>显然，引入快表机制后，访问一个逻辑地址的速度快多了</li></ul></li></ul></li></ul></li></ul><h3 id="8-2-局部性原理"><a href="#8-2-局部性原理" class="headerlink" title="8.2 局部性原理"></a>8.2 <strong>局部性原理</strong></h3><ul><li><strong>时间局部性</strong><ul><li>如果执行了程序中的某条<strong>指令</strong>，那么不久后这条指令很有可能再次执行；如果某个<strong>数据</strong>被访问过，不久之后该数据很可能再次被访问（因为程序中存在大量的循环）</li></ul></li><li><strong>空间局部性</strong><ul><li>一旦程序访问了某个<strong>存储单元</strong>，在不久之后，其附近的存储单元也很有可能被访问（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）</li></ul></li><li>上小节介绍的基本地址变换机构中，每次要访问一个逻辑地址，都需要查询内存中的页表。由于局部性原理，可能连续很多次查到的都是同一个页表项</li></ul><h2 id="9-两级页表"><a href="#9-两级页表" class="headerlink" title="9. 两级页表"></a><strong>9. 两级页表</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121165419159.png"></p><h3 id="9-1-单级页表存在的问题"><a href="#9-1-单级页表存在的问题" class="headerlink" title="9.1 单级页表存在的问题"></a>9.1 <strong>单级页表存在的问题</strong></h3><ul><li>某计算机系统按字节寻址，支持 32 位的逻辑地址，采用分页存储管理，页面大小为4KB，页表项长度为 4B<ul><li>4KB &#x3D; 2<sup>12</sup>B，因此页内地址要用12位表示，剩余 20 位表示页号</li><li>因此，该系统中用户进程最多有 2<sup>20</sup> 页。相应的，一个进程的页表中，最多会有 2<sup>20</sup> &#x3D; 1M &#x3D;1,048,576 个页表项，所以一个页表最大需要 2<sup>20</sup> * 4B &#x3D; 2<sup>22</sup>B，共需要 2<sup>22</sup> &#x2F; 2<sup>12</sup> &#x3D; 2<sup>10</sup>个页框存储该页表，需要专门给进程分配2<sup>10</sup> &#x3D; <strong>1024个连续的页框</strong>来存放它的页表</li><li>根据页号查询页表的方法：K 号页对应的 页表项存放位置 &#x3D; 页表始址 + K * 4</li><li><strong>要在所有的页表项都连续存放的基础上才能用这种方法找到页表项</strong></li><li>根据<strong>局部性原理</strong>可知，很多时候，进程在一段时间内只需要访问某几个页面就可以正常运行了，因此没有必要让整个页表都常驻内存</li></ul></li><li>问题一：<strong>页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框</strong><ul><li>思考：我们是如何解决进程在内存中必须连续存储的问题？<ul><li>将进程地址空间分页，并为其建立一张页表，记录各页面的存放位置</li><li>同样的思路也可用于解决“页表必须连续存放”的问题，把必须连续存放的页表再分页</li><li>可将长长的页表进行分组，<strong>使每个内存块刚好可以放入一个分组</strong>（比如上面的例子中，页面大小4KB，每个页表项4B，每个页面可存放1K个页表项，因此每1K个连续的页表项为一组，每组刚好占一个内存块，再将各组离散地放到各个内存块中）</li><li>另外，要为离散分配的页表再建立一张页表，称为<strong>页目录表</strong>（又称<strong>外层页表</strong>或<strong>顶层页表</strong>）</li></ul></li></ul></li><li>问题二：<strong>没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面</strong><ul><li>可以在需要访问页面时才把页面调入内存（<strong>虚拟存储技术</strong>）, 可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存</li><li>若想访问的页面不在内存中，则产生<strong>缺页中断（内中断&#x2F;异常）</strong>，然后将目标页面从外存调入内存</li></ul></li></ul><h3 id="9-2-两级页表的原理、地址结构"><a href="#9-2-两级页表的原理、地址结构" class="headerlink" title="9.2 两级页表的原理、地址结构"></a>9.2 <strong>两级页表的原理、地址结构</strong></h3><ul><li><strong>如何实现地址变换</strong><ul><li>按照地址结构将逻辑地址拆分成三部分（一级页号、二级页号、页内偏移量）</li><li>从PCB 中读出页目录表始址，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置</li><li>根据二级页号查二级页表，找到最终想访问的内存块号</li><li>结合页内偏移量得到物理地址</li></ul></li></ul><h3 id="9-3-需要注意的几个细节"><a href="#9-3-需要注意的几个细节" class="headerlink" title="9.3 需要注意的几个细节"></a>9.3 <strong>需要注意的几个细节</strong></h3><ul><li>若分为两级页表后，页表依然很长，则可以采用更多级页表，一般来说<strong>各级页表的大小不能超过一个页面</strong><ul><li>例：某系统按字节编址，采用 40 位逻辑地址，页面大小为 4KB，页表项大小为 4B，假设采用纯页式存储，则要采用（）级页表，页内偏移量为（）位？<ul><li>页面大小 &#x3D; 4KB &#x3D; 2<sup>12</sup>B，按字节编址，因此页内偏移量为12位</li><li>页号 &#x3D; 40 - 12 &#x3D; 28 位</li><li>页面大小 &#x3D; 2<sup>12</sup>B，页表项大小 &#x3D; 4B，则每个页面可存放 2<sup>12</sup> &#x2F; 4 &#x3D; 2<sup>10</sup>个页表项</li><li>因此各级页表最多包含 2<sup>10</sup>个页表项，需要10位二进制位才能映射到 2<sup>10</sup>个页表项</li><li>因此每一级的页表对应页号应为10位，总共28位的页号至少要分为三级<ul><li>如果只分为两级页表，则一级页号占 18 位，也就是说页目录表中最多可能有 2<sup>18</sup> 个页表项，显然，一个页面是放不下这么多页表项的</li></ul></li></ul></li></ul></li><li>两级页表的访存次数分析（假设没有快表机构）<ul><li>第一次访存：访问内存中的页目录表</li><li>第二次访存：访问内存中的二级页表</li><li>第三次访存：访问目标内存单元</li></ul></li></ul><h2 id="10-基本分段存储管理方式"><a href="#10-基本分段存储管理方式" class="headerlink" title="10. 基本分段存储管理方式"></a><strong>10. 基本分段存储管理方式</strong></h2><ul><li><p><strong>基本分段存储管理</strong>：<strong>与“分页”最大的区别就是 – 离散分配时所分配地址空间的基本单位不同</strong></p></li><li><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121172738208.png"></p></li></ul><h3 id="10-1-分段"><a href="#10-1-分段" class="headerlink" title="10.1 分段"></a>10.1 <strong>分段</strong></h3><ul><li><p>进程的地址空间：按照程序<strong>自身的逻辑</strong>关系<strong>划分为若干个段</strong>，每个段都有一个段名（在低级语言中，程序员使用段名来编程），<strong>每段从0开始编址</strong></p></li><li><p>内存分配规则：以段为单位进行分配，<strong>每个段在内存中占据连续空间，但各段之间可以不相邻</strong></p></li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121171112237.png"></p><ul><li>分段系统的<strong>逻辑地址</strong>结构由<strong>段号（段名）</strong>和<strong>段内地址（段内偏移量）</strong>组成。如：</li></ul><h3 id="10-2-段表"><a href="#10-2-段表" class="headerlink" title="10.2 段表"></a>10.2 <strong>段表</strong></h3><ul><li>程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称“<strong>段表</strong>”</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121171506496.png"></p><h3 id="10-3-分段、分页管理的区别"><a href="#10-3-分段、分页管理的区别" class="headerlink" title="10.3 分段、分页管理的区别"></a>10.3 <strong>分段、分页管理的区别</strong></h3><ul><li><p><strong>页</strong>是<strong>信息的物理单位</strong>。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，<strong>对用户是不可见的</strong></p></li><li><p><strong>段</strong>是<strong>信息的逻辑单位</strong>。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。<strong>分段对用户是可见的</strong>，用户编程时需要显式地给出段名</p></li><li><p>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序</p></li><li><p><strong>分页</strong>的用户进程<strong>地址空间是一维的</strong>，程序员只需给出一个记忆符即可表示一个地址</p></li><li><p><strong>分段</strong>的用户进程<strong>地址空间是二维的</strong>，程序员在标识一个地址时，既要给出段名，也要给出段内地址</p></li><li><p><strong>分段</strong>比分页<strong>更容易实现信息的共享和保护</strong></p><ul><li>只需让各进程的段表项指向同一个段即可实现共享；页面不是按逻辑模块划分的，这就很难实现共享</li><li>不能被修改的代码称为<strong>纯代码</strong>或<strong>可重入代码</strong>（不属于临界资源），这样的代码是可以共享的。可修改的代码是不能共享的（比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一致）</li></ul></li><li><p><strong>访问一个逻辑地址需要几次访存</strong>？</p><ul><li><strong>分页（单级页表）</strong>：第一次访存 – 查内存中的页表，第二次访存 – 访问目标内存单元。总共<strong>两次访存</strong></li><li><strong>分段</strong>：第一次访存 – 查内存中的段表，第二次访存 – 访问目标内存单元。总共<strong>两次访存</strong></li><li>与分页系统类似，分段系统中也可以引入<strong>快表</strong>机构，将近期访问过的段表项放到快表中，这样可以少一次访问，加快地址变换速度</li></ul></li></ul><h2 id="11-段页式管理方式"><a href="#11-段页式管理方式" class="headerlink" title="11. 段页式管理方式"></a><strong>11. 段页式管理方式</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121182311141.png"></p><h3 id="11-1-分页、分段的优缺点分析"><a href="#11-1-分页、分段的优缺点分析" class="headerlink" title="11.1 分页、分段的优缺点分析"></a>11.1 <strong>分页、分段的优缺点分析</strong></h3><table><thead><tr><th align="center"></th><th align="center"><strong>优点</strong></th><th align="center"><strong>缺点</strong></th></tr></thead><tbody><tr><td align="center">分页管理</td><td align="center">内存空间利用率高，<strong>不会产生外部碎片</strong>，只会有少量的页内碎片</td><td align="center">不方便按照逻辑模块实现信息的共享和保护</td></tr><tr><td align="center">分段管理</td><td align="center">很方便按照逻辑模块实现信息的共享和保护</td><td align="center">如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理<strong>会产生外部碎片</strong></td></tr></tbody></table><ul><li>分段管理中产生的外部碎片也可以用“<strong>紧凑</strong>”来解决，只是需要付出较大的时间代价</li></ul><h3 id="11-2-分段-分页-段页式管理"><a href="#11-2-分段-分页-段页式管理" class="headerlink" title="11.2 分段 + 分页 &#x3D; 段页式管理"></a>11.2 <strong>分段 + 分页 &#x3D; 段页式管理</strong></h3><ul><li>将进程按逻辑模块分段，再将各段分页（如每个页面4KB)</li><li>再将内存空间分为大小相同的内存块&#x2F;页框&#x2F;页帧&#x2F;物理块</li><li>进程前将各页面分别装入各内存块中</li></ul><h3 id="11-3-段页式管理的逻辑地址结构"><a href="#11-3-段页式管理的逻辑地址结构" class="headerlink" title="11.3 段页式管理的逻辑地址结构"></a>11.3 <strong>段页式管理的逻辑地址结构</strong></h3><ul><li><strong>分段系统</strong>的<strong>逻辑地址</strong>结构由<strong>段号（段名）</strong>和<strong>段内地址（段内偏移量）</strong>组成。如：</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121181503259.png"></p><ul><li><p><strong>段页式系统</strong>的<strong>逻辑地址</strong>结构由<strong>段号</strong>、<strong>页号</strong>、<strong>页内地址（页内偏移量）</strong>组成。如：</p><ul><li>段号的位数决定了每个进程最多可以分几个段</li><li>页号位数决定了每个段最大有多少页</li><li>页内偏移量决定了页面大小、内存块大小是多少</li></ul></li><li><p>在上述例子中，若系统是按字节寻址的，则</p><ul><li>段号占16位，因此在该系统中，每个进程最多有216&#x3D;64K个段</li><li>页号占4位，因此每个段最多有24&#x3D;16页</li><li>页内偏移量占12位，因此每个页面每个内存块大小为212&#x3D;4096&#x3D;4KB</li></ul></li></ul><h3 id="11-4-段表、页表"><a href="#11-4-段表、页表" class="headerlink" title="11.4 段表、页表"></a>11.4 <strong>段表、页表</strong></h3><ul><li>每个段对应一个段表项，每个段表项由段号、页表长度、页表存放块号（页表起始地址)组成。每个段表项长度相等，段号是隐含的。</li><li>每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，页号是隐含的。</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121181902465.png"></p><h3 id="11-5-段页式管理地址变换过程"><a href="#11-5-段页式管理地址变换过程" class="headerlink" title="11.5 段页式管理地址变换过程"></a>11.5 <strong>段页式管理地址变换过程</strong></h3><ul><li><p>根据逻辑地址得到段号、页号、页内偏移量</p></li><li><p>判断段号是否越界。若S≥M,则产生越界中断，否则继续执行</p></li><li><p>查询段表找到对应的段表项，段表项的存放地址为F+S*段表项长度</p></li><li><p>检查页号是否越界，若页号≥页表长度，则发生越界中断，否则继续执行</p></li><li><p>根据页表存放块号、页号查询页表找到对应页表项</p></li><li><p>根据内存块号页内偏移量得到最终的物理地址</p></li><li><p>访问目标内存单元</p></li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121182242000.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.4 死锁</title>
    <link href="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-4-%E6%AD%BB%E9%94%81/"/>
    <url>/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-4-%E6%AD%BB%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="2-4-死锁"><a href="#2-4-死锁" class="headerlink" title="2.4 死锁"></a><strong>2.4 死锁</strong></h1><h2 id="1-死锁的概念"><a href="#1-死锁的概念" class="headerlink" title="1. 死锁的概念"></a><strong>1. 死锁的概念</strong></h2><h3 id="1-1-什么是死锁"><a href="#1-1-什么是死锁" class="headerlink" title="1.1 什么是死锁?"></a>1.1 <strong>什么是死锁?</strong></h3><ul><li><p>在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“<strong>死锁</strong>“</p></li><li><p>发生死锁后若无外力干涉，这些进程都将无法向前推进</p></li></ul><h3 id="1-2-死锁、饥饿、死循环的区别"><a href="#1-2-死锁、饥饿、死循环的区别" class="headerlink" title="1.2 死锁、饥饿、死循环的区别"></a>1.2 <strong>死锁、饥饿、死循环的区别</strong></h3><ul><li><strong>死锁</strong><ul><li>各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象</li></ul></li><li><strong>饥饿</strong><ul><li>由于长期得不到想要的资源，某进程无法向前推进的现象。</li><li>比如: 在短进程优先(SPF) 算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”</li></ul></li><li><strong>死循环</strong><ul><li>某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的</li></ul></li></ul><table><thead><tr><th></th><th align="center"><strong>共同点</strong></th><th align="center"><strong>区别</strong></th></tr></thead><tbody><tr><td>死锁</td><td align="center">都是进程无法顺利向前推进的现象(故意设计的死循环除外)</td><td align="center">死锁一定是“循环等待对方手里的资源”导致的，因此如果有死锁现象，那至少有两个或两个以上的进程同时发生死锁。另外，发生死锁的进程一定处于阻塞态</td></tr><tr><td>饥饿</td><td align="center"></td><td align="center">可能只有一个进程发生饥饿。发生饥饿的进程既可能是阻塞态(如长期得不到需要的I&#x2F;0设备)，也可能是就绪态(长期得不到处理机)</td></tr><tr><td>死循环</td><td align="center"></td><td align="center">可能只有一个进程发生死循环。死循环的进程可以上处理机运行(可以是运行态)，只不过无法像期待的那样顺利推进。死锁和饥饿问题是由于操作系统分配资源的策略不合理导致的，而死循环是由代码逻辑的错误导致的。死锁利饥饿是管理者(操作系统)的问题，死循环是被管理者的问题</td></tr></tbody></table><h3 id="1-3-死锁产生的必要条件"><a href="#1-3-死锁产生的必要条件" class="headerlink" title="1.3 死锁产生的必要条件"></a>1.3 <strong>死锁产生的必要条件</strong></h3><ul><li><p>产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生</p></li><li><p><strong>互斥条件</strong></p><ul><li>只有对必须互斥使用的资源的争抢才会导致死锁(如哲学家的筷子、打印机设备)</li><li>像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的( 因为进程不用阻塞等待这种资源)</li></ul></li><li><p><strong>不剥夺条件</strong></p><ul><li>进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放</li></ul></li><li><p><strong>请求和保持条件</strong></p><ul><li>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放</li></ul></li><li><p><strong>循环等待条件</strong></p><ul><li>存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求</li></ul></li><li><p><strong>注意</strong>:</p><ul><li><strong>发生死锁时一定有循环等待，但是发生循环等待时未必死锁(循环等待是死锁的必要不充分条件)</strong></li><li>如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了</li></ul></li></ul><h3 id="1-4-什么时候会发生死锁"><a href="#1-4-什么时候会发生死锁" class="headerlink" title="1.4 什么时候会发生死锁?"></a>1.4 <strong>什么时候会发生死锁?</strong></h3><ul><li><p>对系统资源的竞争。各进程对不可剥夺的资源(如打印机)的竞争可能引起死锁，对可剥夺的资源(CPU)的竞争是不会引起死锁的</p></li><li><p>进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁</p></li><li><p>信号量的使用不当也会造成死锁。如生产者消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。(可以把互斥信号量、同步信号量也看做是一种抽象的系统资源)</p></li><li><p>总之，<strong>对不可剥夺资源的不合理分配，可能导致死锁</strong></p></li></ul><h3 id="1-5-死锁的处理策略"><a href="#1-5-死锁的处理策略" class="headerlink" title="1.5 死锁的处理策略"></a>1.5 <strong>死锁的处理策略</strong></h3><ul><li><strong>预防死锁</strong><ul><li>破坏死锁产生的四个必要条件中的一个或几个</li></ul></li><li><strong>避免死锁</strong><ul><li>用某种方法防止系统进入<strong>不安全状态</strong>，从而避免死锁（银行家算法）</li></ul></li><li><strong>死锁的检测和解除</strong><ul><li>允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁</li></ul></li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-4-%E6%AD%BB%E9%94%81/image-20241120201152743.png"></p><h2 id="2-死锁的处理策略"><a href="#2-死锁的处理策略" class="headerlink" title="2. 死锁的处理策略"></a><strong>2. 死锁的处理策略</strong></h2><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-4-%E6%AD%BB%E9%94%81/image-20241120201628724.png"></p><h3 id="2-1-预防死锁"><a href="#2-1-预防死锁" class="headerlink" title="2.1 预防死锁"></a>2.1 <strong>预防死锁</strong></h3><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-4-%E6%AD%BB%E9%94%81/image-20241120202659002.png" alt="image-20241120202659002"></p><h4 id="2-1-1-破坏互斥条件"><a href="#2-1-1-破坏互斥条件" class="headerlink" title="2.1.1 破坏互斥条件"></a>2.1.1 <strong>破坏互斥条件</strong></h4><ul><li><strong>互斥条件</strong><ul><li>只有对必须互斥使用的资源的争抢才会导致死锁</li></ul></li><li>破坏互斥条件:<ul><li>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态，操作系统可以采用 <strong>SPOOLing 技术</strong>把独占设备在逻辑上改造成共享设备</li><li>比如: 用<strong>SPOOLing技术</strong>将打印机改造为共享设备</li></ul></li><li>缺点:<ul><li>并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥条件</li></ul></li></ul><h4 id="2-1-2-破坏不剥夺条件"><a href="#2-1-2-破坏不剥夺条件" class="headerlink" title="2.1.2 破坏不剥夺条件"></a>2.1.2 <strong>破坏不剥夺条件</strong></h4><ul><li><strong>不剥夺条件</strong><ul><li>进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放</li></ul></li><li>破坏不剥夺条件:<ul><li>方案一: 当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件</li><li>方案二: 当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）</li></ul></li><li>缺点:<ul><li>实现起来比较复杂吧</li><li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU</li><li>反复地申请和释放资源会增加系统开销，降低系统吞吐量</li><li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿</li></ul></li></ul><h4 id="2-1-3-破坏请求和保持条件"><a href="#2-1-3-破坏请求和保持条件" class="headerlink" title="2.1.3 破坏请求和保持条件"></a>2.1.3 <strong>破坏请求和保持条件</strong></h4><ul><li><strong>请求和保持条件</strong><ul><li>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放</li></ul></li><li>破坏请求和保持条件:<ul><li>可以采用静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了</li></ul></li><li>缺点:<ul><li>该策略实现起来简单，但也有明显的缺点</li><li>有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿</li></ul></li></ul><h4 id="2-1-4-破坏循环等待条件"><a href="#2-1-4-破坏循环等待条件" class="headerlink" title="2.1.4 破坏循环等待条件"></a>2.1.4 <strong>破坏循环等待条件</strong></h4><ul><li><strong>循环等待条件</strong><ul><li>存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求</li></ul></li><li>破坏循环等待条件<ul><li>可采用<strong>顺序资源分配法</strong>。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完</li><li>原理分析:<ul><li>一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象</li></ul></li></ul></li><li>缺点:<ul><li>不方便增加新的设备，因为可能需要重新分配所有的编号</li><li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费</li><li>必须按规定次序申请资源，用户编程麻烦</li></ul></li></ul><h3 id="2-2-避免死锁"><a href="#2-2-避免死锁" class="headerlink" title="2.2 避免死锁"></a>2.2 <strong>避免死锁</strong></h3><ul><li><p><strong>什么是安全序列?</strong></p><ul><li>所谓<strong>安全序列</strong>，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成</li></ul></li><li><p><strong>安全序列、不安全状态、死锁的联系</strong></p><ul><li>只要能找出一个安全序列，系统就是<strong>安全状态</strong>。当然，安全序列可能有多个</li><li>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了<strong>不安全状态</strong>。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况</li><li><strong>如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁</strong>（处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态）</li><li>因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。这也是“<strong>银行家算法</strong>”的核心思想</li></ul></li></ul><h4 id="2-2-1-银行家算法"><a href="#2-2-1-银行家算法" class="headerlink" title="2.2.1 银行家算法"></a>2.2.1 <strong>银行家算法</strong></h4><ul><li><p>银行家算法是荷兰学者 Dijkstra 为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况。后来该算法被用在操作系统中，<strong>用于避免死锁</strong></p></li><li><p><strong>核心思想</strong>:</p><ul><li>在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待</li></ul></li><li><p><strong>银行家算法</strong>:</p><ul><li>数据结构：<ul><li>长度为m的一维数组Available表示还有多少可用资源</li><li>n * m矩阵Max表示各进程对资源的最大需求数</li><li>n*m矩阵Allocation表示已经给各进程分配了多少资源</li><li>Max-Allocation&#x3D;Need矩阵表示各进程最多还需要多少资源</li><li>用长度为m的一位数组Request表示进程此次申请的各种资源数</li></ul></li><li>银行家算法步骤：<br>①检查此次申请是否超过了之前声明的最大需求数<br>②检查此时系统剩余的可用资源是否还能满足这次请求<br>③试探着分配，更改各数据结构<br>④用安全性算法检查此次分配是否会导致系统进入不安全状态</li><li>安全性算法步骤：<br>检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。<br>不断重复上述过程，看最终是否能让所有进程都加入安全序列。</li></ul></li><li><p>系统处于不安全状态未必死锁，但死锁时一定处于不安全状态。系统处于安全状态一定不会死锁。</p></li></ul><h3 id="2-3-检测和解除"><a href="#2-3-检测和解除" class="headerlink" title="2.3 检测和解除"></a>2.3 <strong>检测和解除</strong></h3><ul><li>如果系统中既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很可能发生死锁。在这种情况下，系统应当提供两个算法：<ul><li><strong>死锁检测算法</strong>: 用于检测系统状态，以确定系统中是否发生了死锁</li><li><strong>死锁解除算法</strong>: 当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来</li></ul></li></ul><h4 id="2-3-1-死锁的检测"><a href="#2-3-1-死锁的检测" class="headerlink" title="2.3.1 死锁的检测"></a>2.3.1 <strong>死锁的检测</strong></h4><ul><li>为了能对系统是否已发生了死锁进行检测，必须:<ul><li>用某种数据结构来保存资源的请求和分配信息</li><li>提供一种算法，利用上述信息来检测系统是否已进入死锁状态</li></ul></li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-4-%E6%AD%BB%E9%94%81/image-20241121093444179.png"></p><ul><li><p>如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去</p></li><li><p>如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程…</p></li><li><p>如果按上述过程分析，最终能消除所有边，就称这个图是<strong>可完全简化的</strong>。此时一定没有发生死锁（相当于能找到一个安全序列）</p></li><li><p>如果最终不能消除所有边，那么此时就是发生了死锁</p></li><li><p><strong>检测死锁的算法</strong></p><ul><li>1）在资源分配图中，找出既不阻塞又不是孤点的进程 Pi（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。如下图中，R1没有空闲资源，R2有一个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。消去它所有的请求边和分配变，使之称为孤立的结点。在下图中P1 是满足这一条件的进程结点，于是将P1的所有边消去</li><li>2）进程 Pi 所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在下图中，P2 就满足这样的条件。根据 1）中的方法进行一系列简化后，若能消去途中所有的边，则称该图是可完全简化的</li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-4-%E6%AD%BB%E9%94%81/image-20241121093708353.png"></p><ul><li><strong>死锁定理</strong>：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁</li></ul></li></ul><h4 id="2-3-2-死锁的解除"><a href="#2-3-2-死锁的解除" class="headerlink" title="2.3.2 死锁的解除"></a>2.3.2 <strong>死锁的解除</strong></h4><ul><li>一旦检测出死锁的发生，就应该立即<strong>解除死锁</strong><ul><li>补充：并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程</li></ul></li><li><strong>解除死锁的主要方法</strong><ul><li>资源剥夺法。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿</li><li>撤销进程法（或称终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来</li><li>进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点</li></ul></li><li>如何决定“对谁动手”<ul><li>进程优先级</li><li>已执行多长时间</li><li>还要多久能完成</li><li>进程已经使用了多少资源</li><li>进程是交互式的还是批处理式的</li></ul></li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-4-%E6%AD%BB%E9%94%81/image-20241121094256016.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.3 同步与互斥</title>
    <link href="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/"/>
    <url>/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="2-3-进程的同步与互斥"><a href="#2-3-进程的同步与互斥" class="headerlink" title="2.3 进程的同步与互斥"></a><strong>2.3 进程的同步与互斥</strong></h1><h2 id="1-进程同步、进程互斥"><a href="#1-进程同步、进程互斥" class="headerlink" title="1. 进程同步、进程互斥"></a><strong>1. 进程同步、进程互斥</strong></h2><h3 id="1-1-什么是进程同步"><a href="#1-1-什么是进程同步" class="headerlink" title="1.1 什么是进程同步?"></a>1.1 <strong>什么是进程同步?</strong></h3><ul><li>进程具有<strong>异步性</strong>的特征<ul><li>异步性: 各并发执行的进程以各自独立的、不可预知的速度向前推进</li></ul></li><li>如何解决这种异步问题，就是“<strong>进程同步</strong>”所讨论的内容<ul><li><strong>同步</strong>亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上<strong>协调它们的工作次序</strong>而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作</li></ul></li></ul><h3 id="1-2-什么是进程互斥"><a href="#1-2-什么是进程互斥" class="headerlink" title="1.2 什么是进程互斥?"></a>1.2 <strong>什么是进程互斥?</strong></h3><ul><li><p>进程的”<strong>并发</strong>“需要”共享”的支持。各个并发执行的进程不可避免的需要共享一些系统资源(比如内存，又比如打印机、摄像头这样的I&#x2F;O设备)</p></li><li><p>我们把<strong>一个时间段内只允许一个进程使用(互斥共享方式)<strong>的资源称为</strong>临界资源</strong>。许多物理设备(比如摄像头、打印机)都属于临界资源。此外还有很多变量、数据、内存缓冲区等都属于临界资源，对临界资源的访问，必须<strong>互斥</strong>地进行</p></li><li><p><strong>互斥</strong>亦称间接制约关系，<strong>进程互斥</strong>指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待，当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源</p></li><li><p>对临界资源的互斥访问，可以在逻辑上分为如下四个部分:</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span> &#123;<br>    entry section;    <span class="hljs-comment">/* 进入区: 负责检查是否可进入临界区，若可进入，</span><br><span class="hljs-comment">    则应设置正在访问临界资源的标志(可理解为“上锁”)，以组织其他进程同时进入临界区 */</span><br>    critical section; <span class="hljs-comment">/* 临界区: 访问临界资源的那段代码 */</span><br>    <span class="hljs-built_in">exit</span> section; <span class="hljs-comment">/* 退出区: 负责解除 正在访问临界资源的标志 (可理解为“解锁”) */</span><br>    remainder section; <span class="hljs-comment">/* 剩余区: 做其他处理 */</span><br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure><ul><li><p>注意:</p><ul><li><strong>临界区</strong>是进程中<strong>访问临界资源</strong>的代码段</li><li><strong>进入区</strong>和<strong>退出区</strong>是<strong>负责实现互斥</strong>的代码段</li><li>临界区也可称为”<strong>临界段</strong>“</li></ul></li><li><p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则:</p><ul><li><strong>空闲让进</strong>: 临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</li><li><strong>忙则等待</strong>: 当已有进程进入临界区时，其他试图进入临界区的进程必须等待</li><li><strong>有限等待</strong>: 对请求访问的进程，应保证能在有限时间内进入临界区(保证不会饥饿)</li><li><strong>让权等待</strong>: 当进程不能进入临界区时，应立即释放处理机，防止进程忙等待</li></ul></li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-20241120151439304.png"></p><h2 id="2-进程互斥的软件实现方法"><a href="#2-进程互斥的软件实现方法" class="headerlink" title="2. 进程互斥的软件实现方法"></a><strong>2. 进程互斥的软件实现方法</strong></h2><h3 id="2-1-学习提示"><a href="#2-1-学习提示" class="headerlink" title="2.1 学习提示:"></a>2.1 <strong>学习提示</strong>:</h3><p>1. 理解各个算法的思想、原理</p><p>2. 结合上小节学习的“实现互斥的四个逻辑部分”，重点理解各算法在<strong>进入区</strong>、<strong>退出区</strong>都做了什么</p><p>3. 分析各算法存在的缺陷(结合”实现互斥要遵循的四个原则”进行分析)</p><h3 id="2-2-单标志法"><a href="#2-2-单标志法" class="headerlink" title="2.2 单标志法"></a>2.2 <strong>单标志法</strong></h3><ul><li>算法思想: 两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> turn = <span class="hljs-number">0</span>; <span class="hljs-comment">// turn 表示当前允许进入临界区的进程号</span><br><span class="hljs-comment">// P0进程:                            //P1进程:</span><br><span class="hljs-keyword">while</span> (turn != <span class="hljs-number">0</span>);  ①                <span class="hljs-keyword">while</span> (turn != <span class="hljs-number">1</span>); ⑤   <span class="hljs-comment">// 进入区</span><br>critical section;   ②                critical section;  ⑥   <span class="hljs-comment">// 临界区</span><br>turn = <span class="hljs-number">1</span>;           ③                turn = <span class="hljs-number">0</span>;          ⑦   <span class="hljs-comment">// 退出区</span><br>remainder section;  ④                remainder section; ⑧   <span class="hljs-comment">// 剩余区</span><br></code></pre></td></tr></table></figure><ul><li>turn的初值为0，即刚开始只允许0号进程进入临界区</li><li>若P1先上处理机运行，则会一直卡在⑤，直到P1的时间片用完，发生调度，切换P0上处理机运行。若代码①不会卡住P0，P0可以正常访问临界区，则P0访问临界区期间即使切换回P1，P1依然会卡在⑤<ul><li>因此，该算法可以实现“同一时刻最多只允许一个进程访问临界区”</li></ul></li><li>只能按P0 → P1 → P0 → P1 → …… 这样轮流访问。这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问<ul><li>因此，<strong>单标志法</strong>存在的主要问题是: <strong>违背“空闲让进”原则</strong></li></ul></li></ul><h3 id="2-3-双标志先检查"><a href="#2-3-双标志先检查" class="headerlink" title="2.3 双标志先检查"></a>2.3 <strong>双标志先检查</strong></h3><ul><li>算法思想: 设置一个布尔型数组flag[]，数组中各个元素用来<strong>标记各进程想进入临界区的意愿</strong>，比如“flag[0]&#x3D;true”意味着0号进程P0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[i]设为true，之后开始访问临界区</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> flag[<span class="hljs-number">2</span>]; <span class="hljs-comment">// 表示进入临界区意愿的数组</span><br>flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// P0进程://P1进程:</span><br><span class="hljs-keyword">while</span> (flag[<span class="hljs-number">1</span>]);①<span class="hljs-keyword">while</span> (flag[<span class="hljs-number">0</span>]); ⑤ <span class="hljs-comment">// 进入区，如果此时P0想进入临界区，P1就一直循环等待</span><br>flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>; ②flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>; ⑥ <span class="hljs-comment">// 进入区，标记为P1 进程想要进入临界区</span><br>critical section;③critical section; ⑦ <span class="hljs-comment">// 访问临界区</span><br>flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;④flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>; ⑧ <span class="hljs-comment">// 访问完临界区，修改标记为 P1 不想使用临界区</span><br>remainder section;remainder section;<br></code></pre></td></tr></table></figure><ul><li><p>若按照①⑤②⑥③⑦……的顺序执行，P0和P1将会同时访问临界区</p></li><li><p>因此，<strong>双标志先检查法</strong>的主要问题是: <strong>违反“忙则等待”原则</strong></p><ul><li>原因在于，进入区的“检查”和“上锁”两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换</li></ul></li></ul><h3 id="2-4-双标志后检查"><a href="#2-4-双标志后检查" class="headerlink" title="2.4 双标志后检查"></a>2.4 <strong>双标志后检查</strong></h3><ul><li>算法思想: 双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> flag[<span class="hljs-number">2</span>];   <span class="hljs-comment">// 表示进入临界区意愿的数组</span><br>flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// P0进程:    //P1进程:</span><br>flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;     ①flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>; ⑤<span class="hljs-comment">// 进入区，标记为P1进程想要进入临界区</span><br><span class="hljs-keyword">while</span> (flag[<span class="hljs-number">1</span>]);    ② <span class="hljs-keyword">while</span> (flag[<span class="hljs-number">0</span>]);⑥<span class="hljs-comment">// 进入区，如果此时P0想进入临界区，P1就一直循环等待</span><br>critical section;   ③critical section;  ⑦<span class="hljs-comment">// 访问临界区</span><br>flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;    ④flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;   ⑧<span class="hljs-comment">// 访问完临界区，修改标记为 P1 不想使用临界区  </span><br>remainder section;remainder section;  <br></code></pre></td></tr></table></figure><ul><li>若按照①⑤②⑥……的顺序执行，P0和P1将都无法进入临界区</li><li>因此，<strong>双标志后检查法</strong>虽然<strong>解决了“忙则等待”</strong>的问题，但是又<strong>违背了“空闲让进”和“有限等待”原则</strong>，会因各进程都长期无法访问临界资源而产生“饥饿”现象，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区</li></ul><h3 id="2-5-Peterson算法"><a href="#2-5-Peterson算法" class="headerlink" title="2.5 Peterson算法"></a>2.5 <strong>Peterson算法</strong></h3><ul><li>算法思想：结合双标志法、单标志法的思想，如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”(谦让)，做一个有礼貌的进程</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> flag[<span class="hljs-number">2</span>]; <span class="hljs-comment">// 表示进入临界区意愿的数组, 初始值都是false</span><br><br><span class="hljs-type">int</span> turn = <span class="hljs-number">0</span>; <span class="hljs-comment">// turn 表示优先让哪个进程进入临界区</span><br><br><span class="hljs-comment">// P0进程://P1进程:</span><br>flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>; ①flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>; ⑥ <span class="hljs-comment">// 进入区, 表示自己想进入临界区</span><br>turn = <span class="hljs-number">1</span>;②turn = <span class="hljs-number">0</span>;⑦ <span class="hljs-comment">// 进入区, 可以优先让对方进入临界区</span><br><br><span class="hljs-keyword">while</span> (flag[<span class="hljs-number">1</span>] &amp;&amp;<span class="hljs-keyword">while</span> (flag[<span class="hljs-number">0</span>] &amp;&amp;<br>       turn == <span class="hljs-number">1</span>);③ turn == <span class="hljs-number">0</span>); ⑧ <span class="hljs-comment">//进入区，对方想进, 且最后一次是自己&quot;让梨&quot;, 那自己就循环等待</span><br><br>critical section;④ critical section; ⑨ <span class="hljs-comment">// 访问临界区</span><br>flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;⑤flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>; ⑩ <span class="hljs-comment">// 访问完临界区，表示自己已经不想访问临界区了</span><br>remainder section;remainder section;<br></code></pre></td></tr></table></figure><ul><li>进入区:<ul><li>主动争取</li><li>主动谦让</li><li>检查对方是否也想使用，且最后一次是不是自己说了“客气话”</li></ul></li><li><strong>Peterson算法</strong>用软件方法解决了进程互斥问题，<strong>遵循了空闲让进、忙则等待、有限等待三个原则</strong>，但是依然<strong>未遵循让权等待的原则</strong></li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-20241120161559889.png"></p><h2 id="3-进程互斥的硬件实现方法"><a href="#3-进程互斥的硬件实现方法" class="headerlink" title="3. 进程互斥的硬件实现方法"></a><strong>3. 进程互斥的硬件实现方法</strong></h2><h3 id="3-1-中断屏蔽方法"><a href="#3-1-中断屏蔽方法" class="headerlink" title="3.1 中断屏蔽方法"></a>3.1 <strong>中断屏蔽方法</strong></h3><ul><li>利用“<strong>开&#x2F;关中断指令</strong>”实现(与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">关中断; <span class="hljs-comment">// 关中断后即不允许当前进程被中断，也必然不会发生进程切换</span><br>临界区;<br>开中断; <span class="hljs-comment">// 直到当前进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区</span><br></code></pre></td></tr></table></figure><ul><li><p>优点: 简单、高效</p></li><li><p>缺点: 不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程(因为开&#x2F;关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险)</p><ul><li>因为关中断只针对单个处理机，其他处理机上的进程还是能够访问临界区</li></ul></li></ul><h3 id="3-2-TestAndSet指令"><a href="#3-2-TestAndSet指令" class="headerlink" title="3.2 TestAndSet指令"></a>3.2 <strong>TestAndSet指令</strong></h3><ul><li><p>简称 <strong>TS 指令</strong>，也有地方称为 <strong>TestAndSetLock 指令</strong>，或 <strong>TSL 指令</strong></p></li><li><p>TSL 指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成</p></li><li><p>以下是用C语言描述的逻辑:</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 布尔型共享变量 lock 表示当前临界区是否被加锁</span><br><span class="hljs-comment">// true表示已加锁, false表示未加锁</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">TestAndSet</span><span class="hljs-params">(<span class="hljs-type">bool</span> *lock)</span> &#123;<br>    <span class="hljs-type">bool</span> old;<br>    old = *lock;<span class="hljs-comment">// old用来存放lock原来的值</span><br>    *lock = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 无论之前是否已加锁, 都将lock设为true</span><br>    <span class="hljs-keyword">return</span> old; <span class="hljs-comment">// 返回lock原来的值</span><br>&#125;<br><br><span class="hljs-comment">// 以下是使用 TSL 指令实现互斥的算法逻辑</span><br><span class="hljs-keyword">while</span> (TestAndSet(&amp;lock)); <span class="hljs-comment">// &quot;上锁&quot;并&quot;检查&quot;</span><br>临界区代码段...<br>lock = <span class="hljs-literal">false</span>;<span class="hljs-comment">// &quot;解锁&quot;</span><br>剩余区代码段...<br></code></pre></td></tr></table></figure><ul><li><p>原理:</p><ul><li>若刚开始 lock 是 false，则 TSL 返回的 old 值为 false，while 循环条件不满足，直接跳过循环，进入临界区</li><li>若刚开始 lock 是 true，则执行 TLS 后 old 返回的值为 true，while 循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”</li><li>相比软件实现方法，TSL 指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作</li></ul></li><li><p>优点: 实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</p></li><li><p>缺点: 不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而致“忙等”</p></li></ul><h3 id="3-3-Swap指令"><a href="#3-3-Swap指令" class="headerlink" title="3.3 Swap指令"></a>3.3 <strong>Swap指令</strong></h3><ul><li><p>有的地方也叫 <strong>Exchange 指令</strong>，或简称 <strong>XCHG 指令</strong></p></li><li><p>Swap 指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成</p></li><li><p>以下是用C语言描述的逻辑:</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Swap指令的作用是交换两个变量的值</span><br>Swap (<span class="hljs-type">bool</span> *a, <span class="hljs-type">bool</span> *b) &#123;<br>    <span class="hljs-type">bool</span> temp;<br>    temp = *a;<br>    *a = *b;<br>    *b = temp;<br>&#125;<br><br><span class="hljs-comment">// 以下是用Swap指令实现互斥的算法逻辑</span><br><span class="hljs-comment">// lock表示当前临界区是否被加锁</span><br><br><span class="hljs-type">bool</span> old = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span> (old == <span class="hljs-literal">true</span>)<br>    Swap(&amp;lock, &amp;old);<br>临界区代码段...<br>lock = <span class="hljs-literal">false</span>;<br>剩余区代码段...<br></code></pre></td></tr></table></figure><ul><li><p>原理:</p><ul><li>逻辑上来看 Swap 和 TSL 并无太大区别，都是先记录下此时临界区是否已经被上锁(记录在 old变量上)，再将上锁标记 lock 设置为 true，最后检查 old，如果 old 为 false 则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。</li></ul></li><li><p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</p></li><li><p>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。</p></li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-20241120162657761.png"></p><h2 id="4-互斥锁"><a href="#4-互斥锁" class="headerlink" title="4. 互斥锁"></a><strong>4. 互斥锁</strong></h2><ul><li>解决临界区最简单的工具就是互斥锁(mutex lock)。<ul><li>一个进程在进入临界区时应获得锁;在退出临界区时释放锁。</li><li>函数acquire()获得锁，而函数release()释放锁。</li></ul></li><li>每个互斥锁有一个布尔变量available,表示锁是否可用。如果锁是可用的，调用acqiure()会<br>成功，且锁不再可用。当一个进程试图获取不可用的锁时，会被阻塞，直到锁被释放。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">acquire()&#123;<br><span class="hljs-keyword">while</span>(!available)<br>        ;<span class="hljs-comment">//忙等待</span><br>available <span class="hljs-literal">false</span>;<span class="hljs-comment">//获得锁</span><br>&#125;<br>release()&#123;<br>available <span class="hljs-literal">true</span>; <span class="hljs-comment">//释放锁</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>acquire(或release()的执行必须是原子操作，因此互斥锁通常采用硬件机制来实现。</p></li><li><p>互斥锁的主要缺点是忙等待，当有一个进程在临界区中，任何其他进程在进入临界区时必须<br>连续循环调用acquire()。当多个进程共享同一CPU时，就浪费了CPU周期。因此，互斥锁通常<br>用于多处理器系统，一个线程可以在一个处理器上等待，不影响其他线程的执行。</p></li><li><p>需要连续循环忙等的互斥锁，都可称为自旋锁(spin lock),如TSL指令、swap指令、单标志法</p></li><li><p>特性：</p><ul><li>需忙等，进程时间片用完才下处理机，违反“让权等待”</li><li>优点：等待期间不用切换进程上下文，多处理器系统中，若上锁的时间短，则等待代价很低常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区</li><li>不太适用于单处理机系统，忙等的过程中不可能解锁</li></ul></li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-20241120163426848.png"></p><h2 id="5-信号量机制"><a href="#5-信号量机制" class="headerlink" title="5. 信号量机制"></a><strong>5. 信号量机制</strong></h2><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-20241120171150120.png"></p><h3 id="5-1-之前学习的这些进程互斥的解决方案分别存在哪些问题"><a href="#5-1-之前学习的这些进程互斥的解决方案分别存在哪些问题" class="headerlink" title="5.1 之前学习的这些进程互斥的解决方案分别存在哪些问题?"></a>5.1 <strong>之前学习的这些进程互斥的解决方案分别存在哪些问题?</strong></h3><ul><li><p>进程互斥的四种软件实现方式（单标志法、双标志先检查、双标志后检查、Peterson算法）</p></li><li><p>进程互斥的三种硬件实现方式（中断屏蔽方法、TS&#x2F;TSL指令、Swap&#x2F;XCHG指令）</p><ul><li>在双标志先检查法中，进入区的“检查”、“上锁” 操作无法一气呵成，从而导致了两个进程有可能同时进入临界区的问题</li><li>所有的解决方案都无法实现“让权等待”</li></ul></li><li><p>1965年，荷兰学者Dijkstra提出了一种卓有成效的实现进程互斥、同步的方法 – <strong>信号量机制</strong></p></li></ul><h3 id="5-2-信号量机制"><a href="#5-2-信号量机制" class="headerlink" title="5.2 信号量机制"></a>5.2 <strong>信号量机制</strong></h3><ul><li><p>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对<strong>信号量</strong>进行操作，从而很方便的实现了进程互斥、进程同步</p></li><li><p><strong>信号量</strong>其实就是一个变量 （可以是一个<strong>整数</strong>，也可以是更复杂的<strong>记录型变量</strong>），可以用一个信号量来<strong>表示系统中某种资源的数量</strong>，比如：系统中只有一台打印机，就可以设置一个初值为 1 的信号量</p></li><li><p>原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断&#x2F;开中断指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题</p></li><li><p>一对原语：<strong>wait(S) 原语</strong>和 <strong>signal(S) 原语</strong>，可以把原语理解为我们自己写的函数，函数名分别为wait和 signal，括号里的信号量 S 其实就是函数调用时传入的一个参数</p></li><li><p>wait、signal 原语常简称为 <strong>P、V操作</strong>（来自荷兰语 proberen 和 verhogen）。因此，做题的时候常把wait(S)、signal(S) 两个操作分别写为 <strong>P(S)、V(S)</strong></p></li></ul><h3 id="5-3-整型信号量"><a href="#5-3-整型信号量" class="headerlink" title="5.3 整型信号量"></a>5.3 <strong>整型信号量</strong></h3><ul><li>用一个<strong>整数型的变量</strong>作为信号量，用来<strong>表示系统中某种资源的数量</strong><ul><li>与普通整数变量的区别：对信号量的操作只有三种，即 <strong>初始化、P操作、V操作</strong></li></ul></li><li>检查”和“上锁”一气呵成，避免了并发、异步导致的问题</li><li>存在的问题：不满足“让权等待”原则，会发生“忙等”</li><li>Eg ：某计算机系统中有一台打印机:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> S=<span class="hljs-number">1</span>；<span class="hljs-comment">//初始化整型信号量s,表示当前系统中可用的打印机资源数</span><br><span class="hljs-type">void</span> wait(<span class="hljs-type">int</span> S)&#123;<span class="hljs-comment">//wait原语，相当于&quot;进入区&quot;</span><br>    <span class="hljs-keyword">while</span> (S &lt; <span class="hljs-number">0</span>);  <span class="hljs-comment">//如果资源数不够，就一直循环等待</span><br>    S = S<span class="hljs-number">-1</span>;    <span class="hljs-comment">//如果资源数够，则占用一个资源</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">(<span class="hljs-type">int</span> S)</span>&#123;<span class="hljs-comment">//signal原语，相当于“退出区&quot;</span><br>S=S+<span class="hljs-number">1</span>; <span class="hljs-comment">//使用完资源后，在退出区释放资源</span><br>&#125;<br><br>进程P0:<br>wait(S);<span class="hljs-comment">//进入区，申请资源</span><br>使用打印机资源，，，<span class="hljs-comment">//临界区，访问资源</span><br>signal(S);<span class="hljs-comment">//退出区，释放资源</span><br><br>.....<br>进程Pn:<br>wait(S);<span class="hljs-comment">//进入区，申请资源</span><br>使用打印机资源，，，<span class="hljs-comment">//临界区，访问资源</span><br>signal(S);<span class="hljs-comment">//退出区，释放资源</span><br></code></pre></td></tr></table></figure><h3 id="5-4-记录型信号量"><a href="#5-4-记录型信号量" class="headerlink" title="5.4 记录型信号量"></a>5.4 <strong>记录型信号量</strong></h3><ul><li>整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。</li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-20241120164732446.png"></p><ul><li><p>在考研题目中 wait(S)、signal(S) 也可以记为 P(S)、V(S)，这对原语可用于实现系统资源的“<strong>申请</strong>”和“<strong>释放</strong>”</p></li><li><p>S.value 的初值表示系统中某种资源的数目</p></li><li><p>对信号量 S 的一次 P 操作意味着进程请求一个单位的该类资源，因此需要执行 S.value–，表示资源数减1，当S.value &lt; 0 时表示该类资源已分配完毕，因此进程应调用 <strong>block 原语</strong>进行自我阻塞（当前运行的进程从运行态→阻塞态），主动放弃处理机，并插入该类资源的等待队列 S.L 中。可见，该机制遵循了“让权等待”原则，不会出现“忙等”现象</p></li><li><p>对信号量 S 的一次 V 操作意味着进程释放一个单位的该类资源，因此需要执行 S.value++，表示资源数加1，若加1后仍是 S.value &lt;&#x3D; 0，表示依然有进程在等待该类资源，因此应调用 <strong>wakeup 原语</strong>唤醒等待队列中的第一个进程（被唤醒进程从阻塞态→就绪态）</p></li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-20241120165255539.png"></p><h2 id="6-用信号量实现进程互斥、同步、前驱关系"><a href="#6-用信号量实现进程互斥、同步、前驱关系" class="headerlink" title="6. 用信号量实现进程互斥、同步、前驱关系"></a><strong>6. 用信号量实现进程互斥、同步、前驱关系</strong></h2><h3 id="6-1-Tips"><a href="#6-1-Tips" class="headerlink" title="6.1 Tips:"></a>6.1 <strong>Tips</strong>:</h3><ul><li><p>不要一头钻到代码里，要注意理解信号量背后的含义，<strong>一个信号量对应一种资源</strong></p></li><li><p>信号量的值 &#x3D; 这种资源的剩余数量（信号量的值如果小于0，说明此时有进程在等待这种资源）</p></li><li><p>P( S ) – 申请一个资源S，如果资源不够就阻塞等待</p></li><li><p>V( S ) – 释放一个资源S，如果有进程在等待该资源，则唤醒一个进程</p></li></ul><h3 id="6-2-信号量机制实现进程互斥"><a href="#6-2-信号量机制实现进程互斥" class="headerlink" title="6.2 信号量机制实现进程互斥"></a>6.2 <strong>信号量机制实现进程互斥</strong></h3><ul><li>分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区)</li><li>设置互斥信号量mutex,.初值为1<ul><li>在进入区P(mutex)一一申请资源</li><li>在退出区V(mutex)一一释放资源</li></ul></li><li>注意：对不同的临界资源需要设置不同的互斥信号量。</li><li>P、V操作必须成对出现。<ul><li>缺少P(nutex)就不能保证临界资源的互斥访问。</li><li>缺少V(mutex)会导致资源永不被释放，等待进程永不被唤醒。</li></ul></li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-20241120170055669.png"></p><h3 id="6-3-信号量机制实现进程同步"><a href="#6-3-信号量机制实现进程同步" class="headerlink" title="6.3 信号量机制实现进程同步"></a>6.3 <strong>信号量机制实现进程同步</strong></h3><ul><li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码)</li><li>设置同步信号量S,初始为0</li><li>在“前操作”之后执行V(S)</li><li>在“后操作”之前执行P(S)<ul><li>技巧口诀：前V后P</li></ul></li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-20241120170744768.png"></p><h3 id="6-4-信号量机制实现前驱关系"><a href="#6-4-信号量机制实现前驱关系" class="headerlink" title="6.4 信号量机制实现前驱关系"></a>6.4 <strong>信号量机制实现前驱关系</strong></h3><ul><li>其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作）因此，<ul><li>要为每一对前驱关系各设置一个同步信号量</li><li>在“前操作”之后对相应的同步信号量执行V操作</li><li>在“后操作”之前对相应的同步信号量执行P操作</li></ul></li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-20241120171047840.png"></p><h2 id="7-生产者-消费者问题"><a href="#7-生产者-消费者问题" class="headerlink" title="7. 生产者-消费者问题"></a><strong>7. 生产者-消费者问题</strong></h2><h3 id="7-1-问题描述"><a href="#7-1-问题描述" class="headerlink" title="7.1 问题描述:"></a>7.1 <strong>问题描述</strong>:</h3><ul><li><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用（注：这里的“产品”理解为某种数据）</p></li><li><p>生产者、消费者共享一个初始为空、大小为n的缓冲区。</p></li><li><p>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待</p><ul><li>缓冲区没满→生产者生产，缓冲区满时，生产者必须等待</li></ul></li><li><p>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待</p><ul><li>缓冲区没空→消费者消费，缓冲区空时，消费者必须等待</li></ul></li><li><p>缓冲区是临界资源，各进程必须互斥地访问</p><ul><li>互斥关系</li></ul></li></ul><h3 id="7-2-PV操作题目分析步骤"><a href="#7-2-PV操作题目分析步骤" class="headerlink" title="7.2 PV操作题目分析步骤:"></a>7.2 <strong>PV操作题目分析步骤</strong>:</h3><ul><li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系</li><li>整理思路。根据各进程的操作流程确定P、V操作的大致顺序</li><li>设置信号量。并根据题目条件确定信号量初值。（互斥信号量初值一般为1，同步信号量的初</li></ul><p>始值要看对应资源的初始值是多少）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore mutex = <span class="hljs-number">1</span>; <span class="hljs-comment">// 互斥信号量，实现对缓冲区的互斥访问</span><br>semaphore empty = n; <span class="hljs-comment">// 同步信号量，表示空闲缓冲区的数量</span><br>semaphore full = <span class="hljs-number">0</span>; <span class="hljs-comment">// 同步信号量，表示产品的数量，也即非空缓冲区的数量</span><br><br>producer ()&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        生产一个产品;<br>        P(empty); <span class="hljs-comment">// 消耗一个空闲缓冲区 ①</span><br>        P(mutex); <span class="hljs-comment">// ②</span><br>        把产品放入缓冲区; <span class="hljs-comment">// ③</span><br>        V(mutex); <span class="hljs-comment">// ④</span><br>        V(full); <span class="hljs-comment">// 增加一个产品 ⑤</span><br>    &#125;<br>&#125;<br><br>consumer ()&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        P(full); <span class="hljs-comment">// 消耗一个产品（非空缓冲区）⑥</span><br>        P(mutex); <span class="hljs-comment">// ⑦</span><br>        从缓冲区取出一个产品;<br>        V(mutex);<br>        V(empty); <span class="hljs-comment">// 增加一个空闲缓冲区</span><br>        使用产品;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>②③④: 实现互斥是在同一进程中进行一对PV操作</p></li><li><p>⑤⑥: 实现两进程的同步关系，是在其中一个进程中执行P，另一进程中执行V</p></li><li><p><strong>实现互斥的P操作一定要在实现同步的P操作之后</strong></p><ul><li>若将该题中producer和consumer内的两个P操作交换，刚开始时若按⑦→⑥(此时由于full&#x3D;&#x3D;0，消费者进程阻塞)→②(此时由于消费者消费了mutex，mutex&#x3D;&#x3D;0，生产者进程阻塞)，导致<strong>死锁</strong>的发生</li></ul></li><li><p><strong>V操作不会导致进程阻塞，因此两个V操作顺序可以交换</strong></p></li></ul><h2 id="8-多生产者-多消费者问题"><a href="#8-多生产者-多消费者问题" class="headerlink" title="8. 多生产者-多消费者问题"></a><strong>8. 多生产者-多消费者问题</strong></h2><h3 id="8-1-问题描述"><a href="#8-1-问题描述" class="headerlink" title="8.1 问题描述:"></a>8.1 <strong>问题描述</strong>:</h3><ul><li><p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果</p></li><li><p>互斥关系（mutex &#x3D; 1）:</p><ul><li>对缓冲区（盘子）的访问要互斥地进行</li></ul></li><li><p>同步关系（一前一后）:</p><ul><li>父亲将苹果放入盘子后，女儿才能取苹果</li><li>母亲将橘子放入盘子后，儿子才能取橘子</li><li>只有盘子为空时，父亲或母亲才能放入水果<ul><li>“盘子为空”这个事件可以由儿子或女儿触发，事件发生后才允许父亲或母亲放水果</li></ul></li></ul></li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-20241120183700095.png"></p><ul><li><p>此题中可以删去mutex，即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象，原因在于：<strong>本题中的缓冲区大小为1</strong>，在任何时刻，apple、orange、plate 三个同步信号量中最多只有一个是1。因此在任何时刻， 最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区…</p></li><li><p>总结:</p><ul><li>在生产者-消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，这不是绝对的，要具体问题具体分析</li></ul></li><li><p>建议:</p><ul><li>在考试中如果来不及仔细分析，可以加上互斥信号量，保证各进程一定会互斥地访问缓冲区但需要注意的是，实现互斥的P操作一定要在实现同步的P操作之后，否则可能引起“死锁”</li></ul></li></ul><h2 id="9-吸烟者问题"><a href="#9-吸烟者问题" class="headerlink" title="9. 吸烟者问题"></a><strong>9. 吸烟者问题</strong></h2><p><strong>问题描述</strong>:</p><ul><li>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复（让三个抽烟者轮流地抽烟）<ul><li>组合一：纸+胶水</li><li>组合二：烟草+胶水</li><li>组合三：烟草+纸</li></ul></li><li>互斥关系:<ul><li>桌子可以抽象为容量为1的缓冲区，要互斥访问</li></ul></li><li>同步关系（从事件的角度来分析）:<ul><li>桌上有组合一 → 第一个抽烟者取走东西</li><li>桌上有组合二 → 第二个抽烟者取走东西</li><li>桌上有组合三 → 第三个抽烟者取走东西</li><li>发出完成信号 → 供应者将下一个组合放到桌上</li></ul></li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-20241120190459259.png"></p><p>注：将finish改为1， P(finish) 放在 provider 中 while(1){ 下一行也是可行的</p><h2 id="10-读者写者问题"><a href="#10-读者写者问题" class="headerlink" title="10. 读者写者问题"></a><strong>10. 读者写者问题</strong></h2><p><strong>问题描述</strong>:</p><ul><li><p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。</p></li><li><p>因此要求:</p><ul><li>允许多个读者可以同时对文件执行读操作；</li><li>只允许一个写者往文件中写信息；</li><li>任一写者在完成写操作之前不允许其他读者或写者工作；④写者执行写操作前，应让已有的读者和写者全部退出</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore rw=<span class="hljs-number">1</span>; <span class="hljs-comment">// 用于实现对共享文件的互斥访问</span><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录当前有几个读进程在访问文件</span><br>semaphore mutex = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用于保证对count变量的互斥访问</span><br>semaphore w = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用于保证写进程不会饥饿，实现读写公平</span><br><br>writer() &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        P(w);<br>        P(rw); <span class="hljs-comment">// 写之前“加锁”</span><br>        写文件…<br>        V(rw); <span class="hljs-comment">// 写完了“解锁”</span><br>        V(w);<br>    &#125;<br>&#125;<br><br>reader ()&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        P(w);<br>        P(mutex);<span class="hljs-comment">// 各读进程互斥访问count</span><br>        <span class="hljs-keyword">if</span>(count==<span class="hljs-number">0</span>) <span class="hljs-comment">// 由第一个读进程负责</span><br>        P(rw);<span class="hljs-comment">// 读之前“加锁”</span><br>        count++;<span class="hljs-comment">// 访问文件的读进程数+1</span><br>        V(mutex);<br>        V(w);<br>        读文件…<br>        P(mutex);<span class="hljs-comment">// 各读进程互斥访问count</span><br>        count--;<span class="hljs-comment">// 访问文件的读进程数-1        </span><br>        <br>        <span class="hljs-keyword">if</span>(count==<span class="hljs-number">0</span>)  <span class="hljs-comment">// 由最后一个读进程负责</span><br>        V(rw);<span class="hljs-comment">// 读完了“解锁”</span><br>        V(mutex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>如果不加P(w)也可以完成功能，但当读进程源源不断进入时将会导致写进程“饥饿”</p></li><li><p>P(mutex)保证各读进程对count 的访问是互斥的，对count 变量的检查和赋值能够一气呵成</p></li><li><p>总结:</p><ul><li>读者-写者问题为我们解决复杂的互斥问题提供了一个参考思路</li><li>其<strong>核心思想</strong>在于设置了一个<strong>计数器 count</strong> 用来记录当前正在访问共享文件的读进程数</li><li>我们可以用count 的值来判断当前进入的进程是否是第一个&#x2F;最后一个读进程，从而做出不同的处理</li><li>另外，对 count 变量的检查和赋值不能一气呵成导致了一些错误，如果<strong>需要实现“一气呵成”，自然应该想到用互斥信号量</strong></li><li>最后，还要认真体会我们是如何解决“写进程饥饿”问题的</li></ul></li></ul><h2 id="11-哲学家进餐问题"><a href="#11-哲学家进餐问题" class="headerlink" title="11. 哲学家进餐问题"></a><strong>11. 哲学家进餐问题</strong></h2><p><strong>问题描述</strong>:</p><ul><li>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，共5根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考</li></ul><p><strong>分析</strong>:</p><ul><li><p>关系分析。系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系</p></li><li><p>整理思路。这个问题中只有互斥关系，但与之前遇到的问题不同的事，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓</p></li><li><p>信号量设置。定义互斥信号量数组chopstick[5]&#x3D;{1,1,1,1,1} 用于实现对5个筷子的互斥访问。并对哲学家按0~4编号，哲学家 i 左边的筷子编号为 i，右边的筷子编号为 (i+1)%5</p></li></ul><p><strong>解</strong>:</p><p><strong>误解</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 如果5个哲学家并发地拿起了自己左手边的筷子, 每位哲学家循环等待右边的人放下筷子（阻塞）, 会发生“死锁”</span><br>semaphore chopstick[<span class="hljs-number">5</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;;<br>Pi ()&#123; <span class="hljs-comment">// i号哲学家的进程</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        P(chopstick[i]); <span class="hljs-comment">// 拿左</span><br>        P(chopstick[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">5</span>]); <span class="hljs-comment">// 拿右</span><br>        吃饭…<br>        V(chopstick[i]); <span class="hljs-comment">// 放左</span><br>        V(chopstick[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">5</span>]); <span class="hljs-comment">// 放右</span><br>        思考…<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如何防止死锁的发生呢?</strong></p><ul><li><p>可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的</p></li><li><p>要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况</p></li><li><p>仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子更准确的说法应该是: 各哲学家拿筷子这件事必须互斥的执行。这就保证了即使一个哲学家在拿筷子拿到一半时被阻塞，也不会有别的哲学家会继续尝试拿筷子。这样的话，当前正在吃饭的哲学家放下筷子后，被阻塞的哲学家就可以获得等待的筷子了</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore chopstick[<span class="hljs-number">5</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;;<br>semaphore mutex = <span class="hljs-number">1</span>; <span class="hljs-comment">// 互斥地取筷子</span><br><span class="hljs-comment">// 这种方法并不能保证只有两边的筷子都可用时，才允许哲学家拿起筷子</span><br>Pi ()&#123; <span class="hljs-comment">// i号哲学家的进程</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        P(mutex);<br>        P(chopstick[i]); <span class="hljs-comment">// 拿左</span><br>        P(chopstick[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">5</span>]); <span class="hljs-comment">// 拿右</span><br>        V(mutex);<br>        吃饭…<br>        V(chopstick[i]); <span class="hljs-comment">// 放左</span><br>        V(chopstick[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">5</span>]); <span class="hljs-comment">// 放右</span><br>        思考…<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结:</p><ul><li>哲学家进餐问题的关键在于解决<strong>进程死锁</strong>。这些进程之间只存在互斥关系，但是与之前接触到的互斥关系不同的是，每个进程都需要同时持有两个临界资源，因此就有“死锁”问题的隐患</li></ul><h2 id="12-管程"><a href="#12-管程" class="headerlink" title="12. 管程"></a><strong>12. 管程</strong></h2><h3 id="12-1-为什么要引入管程"><a href="#12-1-为什么要引入管程" class="headerlink" title="12.1 为什么要引入管程?"></a>12.1 <strong>为什么要引入管程?</strong></h3><ul><li><p>信号量机制存在的问题: 编写程序困难、易出错</p></li><li><p>能不能设计一种机制，让程序员写程序时不需要再关注复杂的PV操作，让写代码更轻松呢?</p></li><li><p>1973年，Brinch Hansen 首次在程序设计语言 (Pascal)中引入了“<strong>管程</strong>”成分 – <strong>一种高级同步机制</strong></p></li></ul><h3 id="12-2-管程的组成和基本特征"><a href="#12-2-管程的组成和基本特征" class="headerlink" title="12.2 管程的组成和基本特征"></a>12.2 <strong>管程的组成和基本特征</strong></h3><ul><li><strong>管程是一种特殊的软件模块</strong>，有这些部分组成:<ul><li>局部于管程的共享数据结构说明</li><li>该数据结构进行操作的一组过程<ul><li>跨考Tips: “过程”其实就是“函数”</li></ul></li><li>对局部于管程的共享数据设置初始值的语句</li><li>管程有一个名字</li></ul></li><li><strong>管程的基本特征</strong>:<ul><li>局部于管程的数据只能被局部于管程的过程所访问</li><li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</li><li>每次仅允许一个进程在管程内执行某个内部过程<ul><li>由编译器负责实现各进程<strong>互斥</strong>地进入管程中的过程</li><li>管程中设置条件变量和等待&#x2F;唤醒操作，以解决<strong>同步</strong>问题</li></ul></li></ul></li><li><strong>如何理解?</strong><ul><li>可以把管程比作Java中的类，管程中的共享数据结构为类中的属性，管程中的一组过程是类中的一组方法</li><li>管程中的方法可以看作是静态同步(static synchronized)方法，所以每次仅允许一个进程在管程内执行某个内部过程</li><li>进程只能通过方法对属性进行操作，体现了类的封装思想</li></ul></li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-20241120195614131.png"></p><ul><li>引入管程的目的无非就是要更方便地实现进程互斥和同步。<ul><li>需要在管程中定义共享数据（如生产者消费者问题的缓冲区）</li><li>需要在管程中定义用于访问这些共享数据的“入口”一一其实就是一些函数（如生产者消费者问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品)</li><li>只有通过这些特定的“入口”才能访问共享数据</li><li>管程中有很多“入口”，但是每次只能开放其中一个“入口”，并且只能让一个进程或线程进<br>入（如生产者消费者问题中，各进程需要互斥地访问共享缓冲区。管程的这种特性即可保证一个时间段内最多只会有一个进程在访问缓冲区。注意：这种互斥特性是由编译器负责实现的，程序员不用关心)</li><li>可在管程中设置条件变量及等待&#x2F;唤醒操作以解决同步问题。可以让一个进程或线程在条件变量上等待（此时，该进程应先释放管程的使用权，也就是让出“入口”）；可以通过唤醒操作将等待在条件变量上的进程或线程唤醒。</li><li>程序员可以用某种特殊的语法定义一个管程（比如：monitor ProducerConsumer.end monitor;),之后其他程序员就可以使用这个管程提供的特定“入口”很方便地使用实现进程同步&#x2F;互斥了。</li></ul></li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-20241120200148151.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.2 处理机调度</title>
    <link href="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-2-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/"/>
    <url>/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-2-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="2-2-处理机的调度"><a href="#2-2-处理机的调度" class="headerlink" title="2.2 处理机的调度"></a><strong>2.2 处理机的调度</strong></h1><h2 id="1-调度的概念、层次"><a href="#1-调度的概念、层次" class="headerlink" title="1. 调度的概念、层次"></a><strong>1. 调度的概念、层次</strong></h2><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-2-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/image-20241119220317802.png"></p><h3 id="1-1-调度的基本概念"><a href="#1-1-调度的基本概念" class="headerlink" title="1.1 调度的基本概念"></a>1.1 <strong>调度的基本概念</strong></h3><ul><li><p>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理，这些任务的顺序，这就是“调度”研究的问题</p></li><li><p>在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程</p></li><li><p><strong>处理机调度</strong>，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行</p></li></ul><h3 id="1-2-调度的三个层次"><a href="#1-2-调度的三个层次" class="headerlink" title="1.2 调度的三个层次"></a>1.2 <strong>调度的三个层次</strong></h3><ul><li><strong>作业</strong>: 一个具体的任务, 用户向系统提交一个作业≈用户让操作系统启动一个程序(来处理一个具体的任务)</li><li><strong>高级调度(作业调度)</strong>: 外存<sub>作业</sub> → 内存<sub>进程</sub><ul><li>按一定的原则从<strong>外存</strong>的作业后备队列中挑选一个作业调入内存, 并创建进程, 每个作业只调入一次, 调出一次, 作业调入时会建立PCB, 调出时才撤销PCB<ul><li>由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序</li><li>高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出</li></ul></li></ul></li><li><strong>中级调度(内存调度)</strong>: 外存<sub>挂起进程</sub> → 内存<sub>进程</sub><ul><li>按照某种策略决定将哪个处于<strong>挂起状态</strong>的进程重新调入内存<ul><li>内存不够时, 可将某些进程的数据调出到外存, 等内存空闲或者进程需要运行时再重新调入内存, 这么做的目的是为了提高内存利用率和系统吞吐量</li><li>暂时调到外存等待的进程状态称为<strong>挂起状态</strong>, 被挂起的进程PCB会被组织成<strong>挂起队列</strong><ul><li>值得注意的是，<strong>PCB并不会一起调到外存</strong>，而是会常驻内存</li><li>PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的</li><li>PCB来保持对各个进程的监控、管理</li></ul></li><li>一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高</li></ul></li></ul></li><li><strong>低级调度(进程调度&#x2F;处理机调度)</strong>: 内存<sub>进程</sub> → 分配处理机<sub>进程</sub><ul><li>按照某种策略从就绪队列中选取一个进程，将处理机分配给它<ul><li>进程调度是操作系统中<strong>最基本的一种调度</strong>，在一般的操作系统中都必须配置进程调度</li><li>进程调度的频率很高，一般几十毫秒一次</li></ul></li></ul></li></ul><h3 id="1-3-三层调度的联系、对比"><a href="#1-3-三层调度的联系、对比" class="headerlink" title="1.3 三层调度的联系、对比"></a>1.3 <strong>三层调度的联系、对比</strong></h3><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-2-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/image-20241119220037965.png"></p><h3 id="1-4-进程的挂起态与七状态模型"><a href="#1-4-进程的挂起态与七状态模型" class="headerlink" title="1.4 进程的挂起态与七状态模型"></a>1.4 <strong>进程的挂起态与七状态模型</strong></h3><ul><li><p>暂时调到外存等待的进程状态为<strong>挂起状态(挂起态，suspend)</strong></p></li><li><p>挂起态又可以进一步细分为<strong>就绪挂起</strong>、<strong>阻塞挂起</strong>两种状态</p></li><li><p><strong>七状态模型</strong></p></li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-2-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/image-20241119220113000.png"></p><h2 id="2-进程调度的时机、切换与过程、方式"><a href="#2-进程调度的时机、切换与过程、方式" class="headerlink" title="2. 进程调度的时机、切换与过程、方式"></a><strong>2. 进程调度的时机、切换与过程、方式</strong></h2><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-2-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/image-20241119221723926.png"></p><h3 id="2-1-进程调度的时机"><a href="#2-1-进程调度的时机" class="headerlink" title="2.1 进程调度的时机"></a>2.1 <strong>进程调度的时机</strong></h3><ul><li>**进程调度(低级调度)**，就是按照某种算法从就绪队列中选择一个进程为其分配处理机</li><li><strong>需要进行进程调度与切换的情况</strong><ul><li>当前运行的进程<strong>主动放弃</strong>处理机<ul><li>进程正常终止</li><li>运行过程中发生异常而终止</li><li>进程主动请求阻塞(如等待I&#x2F;O)</li></ul></li><li>当前运行的进程<strong>被动放弃</strong>处理机<ul><li>分给进程的时间片用完</li><li>有更紧急的事需要处理(如I&#x2F;O中断)</li><li>有更高优先级的进程进入就绪队列</li></ul></li></ul></li><li><strong>不能进行进程调度与切换的情况</strong><ul><li>在处理中断的过程中: 中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换</li><li>进程在操作系统<strong>内核程序临界区</strong>中，但是进程在普通临界区时是可以进行调度、切换的<ul><li><strong>临界资源</strong>: 一个时间段内只允许一个进程使用的资源, 各进程需要<strong>互斥</strong>地访问临界资源</li><li><strong>临界区</strong>: 访问临界资源的那段代码<ul><li>普通临界区访问的临界资源不会直接影响操作系统内核的管理工作</li><li>因此在访问普通临界区时可以进行调度与切换</li></ul></li><li><strong>内核程序临界区</strong>: 一般是用来访问某种内核数据结构的，比如进程的就绪队列(由各就绪进程的PCB组成)<ul><li>内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作</li><li>因此在访问内核程序临界区期间不能进行调度与切换</li></ul></li></ul></li><li>在原子操作过程中(原语): 原子操作不可中断，要一气呵成(如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列)</li></ul></li></ul><h3 id="2-2-进程调度的方式"><a href="#2-2-进程调度的方式" class="headerlink" title="2.2 进程调度的方式"></a>2.2 <strong>进程调度的方式</strong></h3><ul><li><strong>非剥夺调度方式(非抢占式方式)</strong><ul><li>只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态<ul><li>实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统</li></ul></li></ul></li><li><strong>剥夺调度方式(抢占式方式)</strong><ul><li>当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程<ul><li>可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统</li></ul></li></ul></li></ul><h3 id="2-3-“狭义的进程调度”与”进程切换”的区别"><a href="#2-3-“狭义的进程调度”与”进程切换”的区别" class="headerlink" title="2.3 “狭义的进程调度”与”进程切换”的区别"></a>2.3 <strong>“狭义的进程调度”与”进程切换”的区别</strong></h3><ul><li><strong>狭义的进程调度</strong>指的是从就绪队列中选中一个要运行的进程（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要<strong>进程切换</strong>）</li><li><strong>进程切换</strong>是指一个进程让出处理机，由另一个进程占用处理机的过程<ul><li>对原来运行进程各种数据的保存</li><li>对新的进程各种数据的恢复(如: 程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块PCB中)</li><li><strong>注意</strong>:<ul><li>进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少</li></ul></li></ul></li><li><strong>广义的进程调度</strong>包含了选择一个进程和进程切换两个步骤</li></ul><h2 id="3-调度器和闲逛进程"><a href="#3-调度器和闲逛进程" class="headerlink" title="3. 调度器和闲逛进程"></a><strong>3. 调度器和闲逛进程</strong></h2><h3 id="3-1-调度器-调度程序-scheduler"><a href="#3-1-调度器-调度程序-scheduler" class="headerlink" title="3.1 调度器&#x2F;调度程序(scheduler)"></a>3.1 <strong>调度器&#x2F;调度程序(scheduler)</strong></h3><ul><li>支持内核级线程的操作系统, 调度程序的处理对象是<strong>内核级线程</strong></li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-2-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/image-20241119221810753.png"></p><h3 id="3-2-闲逛进程"><a href="#3-2-闲逛进程" class="headerlink" title="3.2 闲逛进程"></a>3.2 <strong>闲逛进程</strong></h3><ul><li><p>调度程序永远的备胎, 没有其他就绪进程时, 运行闲逛进程(idle)</p></li><li><p>特性:</p><ul><li>优先级最低</li><li>可以是0地址指令, 占一个完整的指令周期(指令周期末尾例行检查中断)</li><li>能耗低</li></ul></li></ul><h2 id="4-调度算法的评价指标"><a href="#4-调度算法的评价指标" class="headerlink" title="4. 调度算法的评价指标"></a><strong>4. 调度算法的评价指标</strong></h2><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-2-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/image-20241120105220114.png"></p><h2 id="5-调度算法（1）"><a href="#5-调度算法（1）" class="headerlink" title="5. 调度算法（1）"></a><strong>5. 调度算法（1）</strong></h2><h3 id="5-1-各种调度算法的学习思路"><a href="#5-1-各种调度算法的学习思路" class="headerlink" title="5.1 各种调度算法的学习思路"></a>5.1 <strong>各种调度算法的学习思路</strong></h3><ol><li><p>算法思想</p></li><li><p>算法规则</p></li><li><p>这种调度算法是用于 作业调度 还是 进程调度？</p></li><li><p>抢占式？非抢占式？</p></li><li><p>优点和缺点</p></li><li><p>是否会导致饥饿</p></li></ol><ul><li><strong>饥饿</strong>: 某进程&#x2F;作业长期得不到服务</li></ul><h3 id="5-2-先来先服务（FCFS-First-Come-First-Serve）"><a href="#5-2-先来先服务（FCFS-First-Come-First-Serve）" class="headerlink" title="5.2 先来先服务（FCFS, First Come First Serve）"></a>5.2 <strong>先来先服务（FCFS, First Come First Serve）</strong></h3><ul><li><p>算法思想: 主要从“公平”的角度考虑（类似于我们生活中排队买东西的例子）</p></li><li><p>算法规则: 按照作业&#x2F;进程到达的先后顺序进行服务</p></li><li><p>用于作业&#x2F;进程调度: 用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列</p></li><li><p>是否可抢占: 非抢占式的算法</p></li><li><p>优缺点</p><ul><li>优点：公平、算法实现简单</li><li>缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即，FCFS算法对长作业有利，对短作业不利</li></ul></li><li><p>是否会导致饥饿: 不会</p></li></ul><h3 id="5-3-短作业优先（SJF-Shortest-Job-First）"><a href="#5-3-短作业优先（SJF-Shortest-Job-First）" class="headerlink" title="5.3 短作业优先（SJF, Shortest Job First）"></a>5.3 <strong>短作业优先（SJF, Shortest Job First）</strong></h3><ul><li><p>算法思想: 追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间</p></li><li><p>算法规则: 最短的作业&#x2F;进程优先得到服务（所谓“最短”，是指要求服务时间最短）</p></li><li><p>用于作业&#x2F;进程调度: 既可用于作业调度，也可用于进程调度。用于进程调度时称为“<strong>短进程优先（SPF, Shortest Process First）</strong>算法”</p></li><li><p>是否可抢占: SJF和SPF是非抢占式的算法。但是也有抢占式的版本 – <strong>最短剩余时间优先算法（SRTN, Shortest Remaining Time Next）</strong></p><ul><li>最短剩余时间优先算法：每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度</li></ul></li><li><p>优缺点</p><ul><li>优点：“最短的”平均等待时间、平均周转时间<ul><li>1. 如果题目中未特别说明，所提到的“短作业&#x2F;进程优先算法”默认是非抢占式的</li><li>2. 很多书上都会说“SJF 调度算法的平均等待时间、平均周转时间最少”，严格来说，这个表述是错误的，不严谨的。<strong>最短剩余时间优先算法得到的平均等待时间、平均周转时间还要更少</strong></li><li>应该加上一个条件“<strong>在所有进程同时可运行时</strong>，采用SJF调度算法的平均等待时间、平均周转时间最少”</li><li>或者说“<strong>在所有进程都几乎同时到达时</strong>，采用SJF调度算法的平均等待时间、平均周转时间最少”</li><li>如果不加上述前提条件，则应该说“抢占式的短作业&#x2F;进程优先调度算法（最短剩余时间优先, SRNT算法）的平均等待时间、平均周转时间最少”</li><li>3. 虽然严格来说，SJF的平均等待时间、平均周转时间并不一定最少，但相比于其他算法（如 FCFS），SJF依然可以获得较少的平均等待时间、平均周转时间</li><li>4. 如果选择题中遇到“SJF 算法的平均等待时间、平均周转时间最少”的选项，那最好判断其他选项是不是有很明显的错误，如果没有更合适的选项，那也应该选择该选项</li></ul></li><li>缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业&#x2F;进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先</li></ul></li><li><p>是否会导致饥饿: 会，如果源源不断地有短作业&#x2F;进程到来，可能使长作业&#x2F;进程长时间得不到服务，产生“饥饿”现象。如果一直得不到服务，则称为“饿死”</p></li><li><p>FCFS算法是在每次调度的时候选择一个等待时间最长的作业（进程）为其服务。但是没有考虑到作业的运行时间，因此导致了对短作业不友好的间题</p></li><li><p>SJF算法是选择一个执行时间最短的作业为其服务。但是又完全不考虑各个作业的等待时间，因<br>此导致了对长作业不友好的问题，甚至还会造成饥饿问题</p></li></ul><h3 id="5-4-高响应比优先（HRRN-Highest-Response-Ratio-Next）"><a href="#5-4-高响应比优先（HRRN-Highest-Response-Ratio-Next）" class="headerlink" title="5.4 高响应比优先（HRRN, Highest Response Ratio Next）"></a>5.4 <strong>高响应比优先（HRRN, Highest Response Ratio Next）</strong></h3><ul><li><p>算法思想: 要综合考虑作业&#x2F;进程的等待时间和要求服务的时间</p></li><li><p>算法规则: 在每次调度时先计算各个作业&#x2F;进程的<strong>响应比</strong>，选择响应比最高的作业&#x2F;进程为其服务</p><ul><li>$$<br>响应比&#x3D;\frac{等待时间+要求服务时间}{要求服务时间}\geq 1<br>$$</li></ul></li><li><p>用于作业&#x2F;进程调度: 即可用于作业调度，也可用于进程调度</p></li><li><p>是否可抢占: 非抢占式的算法。因此只有当前运行的作业&#x2F;进程主动放弃处理机时，才需要调度，才需要计算响应比</p></li><li><p>优缺点</p><ul><li>综合考虑了等待时间和运行时间（要求服务时间）</li><li>等待时间相同时，要求服务时间短的优先（SJF 的优点）</li><li>要求服务时间相同时，等待时间长的优先（FCFS 的优点）</li><li>对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的</li><li>问题</li></ul></li><li><p>是否会导致饥饿: 不会</p></li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-2-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/image-20241120123533015.png"></p><h2 id="6-调度算法（适合交互式系统）"><a href="#6-调度算法（适合交互式系统）" class="headerlink" title="6. 调度算法（适合交互式系统）"></a><strong>6. 调度算法（适合交互式系统）</strong></h2><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-2-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/image-20241120145812395.png"></p><h3 id="6-1-时间片轮转（RR-Round-Robin）"><a href="#6-1-时间片轮转（RR-Round-Robin）" class="headerlink" title="6.1 时间片轮转（RR, Round-Robin）"></a>6.1 <strong>时间片轮转（RR, Round-Robin）</strong></h3><ul><li><p>算法思想: 公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</p></li><li><p>算法规则: 按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片(如100ms)。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队</p></li><li><p>用于作业&#x2F;进程调度: 用于进程调度(只有作业放入内存建立了相应的进程后，才能被分配处理机时间片)</p></li><li><p>是否可抢占: 若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出<strong>时钟中断</strong>来通知CPU时间片已到</p></li><li><p>优缺点</p><ul><li>优点：公平、响应快，适用于分时操作系统</li><li>缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度</li></ul></li><li><p>是否会导致饥饿: 不会</p></li><li><p>补充: 时间片太大或太小分别有什么影响?</p><ul><li>如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大</li><li>另一方面，进程调度、切换是有时间代价的(保存、恢复运行环境)，因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小</li><li>一般来说，设计时间片时要让切换进程的开销占比不超过1%</li></ul></li></ul><h3 id="6-2-优先级调度算法"><a href="#6-2-优先级调度算法" class="headerlink" title="6.2 优先级调度算法"></a>6.2 <strong>优先级调度算法</strong></h3><ul><li><p>算法思想: 随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序</p></li><li><p>算法规则: 调度时选择优先级最高的作业&#x2F;进程</p></li><li><p>用于作业&#x2F;进程调度: 既可以用于作业调度，也可用于进程调度。甚至，还会用于在之后会学习的<strong>I&#x2F;O调度</strong>中</p></li><li><p>是否可抢占: <strong>抢占式、非抢占式都有</strong>。做题时的区别在于: 非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占</p></li><li><p>优缺点</p><ul><li>优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业&#x2F;进程的偏好程度</li><li>缺点：若源源不断地有高优先级进程到来，则可能导致饥饿</li></ul></li><li><p>是否会导致饥饿: 会</p></li><li><p>补充:</p><ul><li>就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置</li><li>根据优先级是否可以动态改变，可将优先级分为<strong>静态优先级</strong>和<strong>动态优先级</strong>两种<ul><li>静态优先级: 创建进程时确定，之后一直不变</li><li>动态优先级: 创建进程时有一个初始值，之后会根据情况动态地调整优先级</li></ul></li><li><strong>如何合理地设置各类进程的优先级?</strong><ul><li>系统进程优先级 高于 用户进程</li><li>前台进程优先级 高于 后台进程</li><li>操作系统更偏好<strong>I&#x2F;O型进程</strong>(或称<strong>I&#x2F;O繁忙型进程</strong>)<ul><li>I&#x2F;O设备和CPU可以并行工作。如果优先让I&#x2F;O繁忙型进程优先运行的话，则越有可能让I&#x2F;O设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升</li><li>注: 与I&#x2F;O型进程相对的是<strong>计算型进程</strong>(或称<strong>CPU繁忙型进程</strong>)</li></ul></li></ul></li><li><strong>如果采用的是动态优先级，什么时候应该调整?</strong><ul><li>可以从追求公平、提升资源利用率等角度考虑</li><li>如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级</li><li>如果某进程占用处理机运行了很长时间，则可以适当降低其优先级</li><li>如果发现一个进程频繁地进行I&#x2F;O操作，则可适当提升其优先级</li></ul></li></ul></li></ul><h3 id="6-3-多级反馈队列调度算法"><a href="#6-3-多级反馈队列调度算法" class="headerlink" title="6.3 多级反馈队列调度算法"></a>6.3 <strong>多级反馈队列调度算法</strong></h3><ul><li><p>算法思想: 对其他调度算法的折中权衡</p></li><li><p>算法规则:</p><ul><li>设置多级就绪队列，各级队列优先级从高到底，时间片从小到大</li><li>新进程到达时先进入第1级队列，按FCFS原则排队等待分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾</li><li>只有第k级队列为空时，才会为k+1级队头的进程分配时间片。当高优先级队列有新进程到达时，会剥夺正在运行的低优先级队列中的进程，并将被剥夺的进程重新放回其所在的低优先级队列的队尾，之后当算法调度到该被剥夺的进程时再重新分配其所在队列对应的时间片</li></ul></li><li><p>用于作业&#x2F;进程调度: 用于进程调度</p></li><li><p>是否可抢占: 抢占式的算法。在k级队列的进程运行过程中，若更上级的队列(1~k-1级)中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾</p></li><li><p>优缺点</p><ul><li>对各类型进程相对公平(FCFS的优点)；</li><li>每个新到达的进程都可以很快就得到响应(RR的优点)；</li><li>短进程只用较少的时间就可完成(SPF的优点)；</li><li>不必实现估计进程的运行时间(避免用户作假)；</li><li>可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I&#x2F;O密集型进程(拓展: 可以将因I&#x2F;O阻塞的进程重新放回原队列，这样I&#x2F;O型进程就可以保持较高优先级)</li></ul></li><li><p>是否会导致饥饿: 会</p></li><li><p>注：比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括分时操作系统、实时操作系统等)更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也能较好地满足交互式系统的需求。因此这三种算法适合用于交互式系统。（比如UNIX使用的就是多级反馈队列调度算法)</p></li></ul><h2 id="7-调度算法（3）"><a href="#7-调度算法（3）" class="headerlink" title="7. 调度算法（3）"></a><strong>7. 调度算法（3）</strong></h2><ol><li>多级队列调度算法</li></ol><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-2-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/image-20241120150022201.png" alt="多级队列调度算法"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第二章 进程管理-2.1 进程与线程</title>
    <link href="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <url>/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="2-1-进程与线程"><a href="#2-1-进程与线程" class="headerlink" title="2.1 进程与线程"></a><strong>2.1 进程与线程</strong></h1><h2 id="1-进程的概念、组成、特征"><a href="#1-进程的概念、组成、特征" class="headerlink" title="1.  进程的概念、组成、特征"></a><strong>1.  进程的概念、组成、特征</strong></h2><h3 id="1-1-进程的概念"><a href="#1-1-进程的概念" class="headerlink" title="1.1 进程的概念"></a>1.1 <strong>进程的概念</strong></h3><ol><li><strong>程序</strong></li></ol><ul><li>是静态的，就是存放在磁盘里的可执行文件，就是一系列的指令集合</li></ul><ol start="2"><li><strong>进程</strong></li></ol><ul><li><strong>是动态的，是程序的一次执行过程, 是系统进行资源分配和调度的一个独立单位</strong>, 同一个程序多次执行会对应多个进程<ul><li>确切来说, 是<strong>进程实体</strong>的执行过程</li><li><strong>调度</strong>: 一个进程被“调度”，就是指操作系统决定让这个进程上CPU运行</li><li>当引入<strong>线程</strong>后, 进程不再是CPU调度的基本单位, 仅仅是资源分配的基本单位</li></ul></li></ul><h3 id="1-2-进程-进程实体-的组成"><a href="#1-2-进程-进程实体-的组成" class="headerlink" title="1.2 进程(进程实体)的组成"></a>1.2 <strong>进程(进程实体)的组成</strong></h3><ul><li><p><strong>PCB(Process Control Block, 进程控制块)</strong></p><ul><li><strong>组成</strong>:<ul><li>当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的“身份证号” – <strong>PID</strong> （Process ID，进程ID）</li><li>记录PID、进程所属用户UID<ul><li>基本的进程描述信息，可以让操作系统区分各个进程</li></ul></li><li>记录给进程分配了哪些资源（如：分配了多少内存、正在使用哪些I&#x2F;O设备、正在使用哪些文件）<ul><li>可用于实现操作系统对资源的管理</li></ul></li><li>记录进程的运行情况（如：CPU使用时间、磁盘使用情况、网络流量使用情况、进程当前状态[就绪&#x2F;运行&#x2F;阻塞…]等）<ul><li>可用于实现操作系统对进程的控制、调度</li></ul></li><li>记录处理机相关信息（如：PSW、PC等各种寄存器的值）<ul><li>可用于实现进程切换</li></ul></li></ul></li><li>这些信息都被保存在一个数据结构PCB中, 操作系统需要对各个并发运行的进程进行管理，操作系统对进程进行管理工作所需的信息都存在PCB中</li><li><strong>PCB是进程存在的唯一标志</strong>，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB</li></ul></li><li><p><strong>程序段</strong></p><ul><li>程序代码被编译之后产生的机器指令序列</li></ul></li><li><p><strong>数据段</strong></p><ul><li>进程运行过程中产生的各种数据</li></ul></li><li><p>PCB是给操作系统用的；程序段、数据段是给进程自己用的，与进程自身的运行逻辑有关</p></li><li><p>一个<strong>进程实体（进程映像）</strong>由PCB、程序段、数据段组成。 进程是动态的，进程实体（进程映像）是静态的，进程实体反应了进程在某一时刻的状态</p></li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119185534404.png"></p><h3 id="1-3-进程的特征"><a href="#1-3-进程的特征" class="headerlink" title="1.3 进程的特征"></a>1.3 <strong>进程的特征</strong></h3><ul><li><p>动态性: 进程是程序的一次执行过程, 是动态地产生、变化和消亡的</p><ul><li><strong>动态性是进程最基本的特征</strong></li></ul></li><li><p>并发性: 内存中有多个进程实体, 各进程可并发执行</p></li><li><p>独立性: 进程是能独立运行、独立获得资源、独立接受调度的基本单位</p></li><li><p>异步性: 各进程按各自独立的、不可预知的速度向前推推进, 操作系统要提供”<strong>进程同步机制</strong>“来解决异步问题</p><ul><li>异步性会导致并发程序执行结果的不确定性</li></ul></li><li><p>结构性: 每个进程都会配置一个PCB, 结构上看, 进程由PCB、程序段、数据段组成</p></li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119185730743.png"></p><h2 id="2-进程的状态与转换、进程的组织"><a href="#2-进程的状态与转换、进程的组织" class="headerlink" title="2. 进程的状态与转换、进程的组织"></a><strong>2. 进程的状态与转换、进程的组织</strong></h2><h3 id="2-1-进程的状态"><a href="#2-1-进程的状态" class="headerlink" title="2.1 进程的状态"></a>2.1 <strong>进程的状态</strong></h3><ul><li><p><strong>创建态</strong>(New, 又称: 新建态)</p><ul><li>进程正在被创建时, 它的状态是”创建态”, 在这个阶段操作系统会为进程分配资源、初始化PCB</li></ul></li><li><p><strong>就绪态</strong>(Ready)</p><ul><li>当进程创建完成后, 便进入”就绪态”, 处于就绪态的进程已经具备运行条件, 但由于没有空闲CPU,就暂时不能运行</li></ul></li><li><p><strong>运行态</strong>(Running)</p><ul><li>当CPU空闲时, 操作系统就会选择一个就绪进程, 让它上处理机运行</li><li>如果一个进程此时在CPU上运行, 那么这个进程处于”运行态”, CPU会执行该进程对应的程序(指令序列)</li><li>单CPU情况下, 同一时刻只会有一个进程处于运行态, 多核CPU情况下, 可能有多个进程处于运行态</li></ul></li><li><p><strong>阻塞态</strong>(Blocked&#x2F;Waiting, 又称: 等待态)</p><ul><li>在进程运行的过程中, 可能会请求等待某个事件的发生(如等待某种系统资源的分配, 或者等待其他进程的响应)</li><li>在这个事件发生之前, 进程无法继续往下执行, 此时操作系统会让这个进程下CPU, 并让它进入”阻塞态”</li><li>当CPU空闲时, 又会选择另一个”就绪态”进程上CPU运行</li></ul></li><li><p><strong>终止态</strong>(Terminated, 又称: 结束态)</p><ul><li><p>一个进程可以执行exit系统调用, 请求操作系统终止该进程, 此时该进程会进入”终止态”, 操作系统会让这个进程下CPU, 并回收内存空间等资源, 最后还要回收该进程的PCB</p></li><li><p>进程的整个生命周期中, 大部分时间都处于运行态、就绪态、阻塞态</p></li><li><p>进程PCB中, 会有一个变量state来表示进程的当前状态</p></li></ul></li></ul><h3 id="2-2-进程状态的转化"><a href="#2-2-进程状态的转化" class="headerlink" title="2.2 进程状态的转化"></a>2.2 <strong>进程状态的转化</strong></h3><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119190821500.png"></p><p>注意：不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态（因为进入阻塞态是进程主动请求的，必然需要<br>进程在运行时才能发出这种请求)</p><h3 id="2-3-进程的组织"><a href="#2-3-进程的组织" class="headerlink" title="2.3 进程的组织"></a>2.3 <strong>进程的组织</strong></h3><ul><li><p>为了对同一个状态下的各个进程进行统一的管理, 操作系统会将各个进程的PCB组织起来</p></li><li><p><strong>链接方式</strong></p><ul><li>操作系统根据进程状态的不同, 将相同状态的PCB放入同一个队列之中, 很多操作系统还会根据阻塞原因的不同, 再分为多个阻塞队列, 优先级较高的就绪进程会被放入就绪队列的队头<ul><li>执行指针 → PCB</li><li>就绪队列指针 → PCB → PCB</li><li>阻塞队列指针 → PCB → PCB</li></ul></li></ul></li><li><p><strong>索引方式</strong></p><ul><li>操作系统根据进程状态的不同, 创建几张索引表, 操作系统持有指向各个索引表的指针, 通过索引表找到对应的PCB</li></ul></li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119191200075.png"></p><h2 id="3-进程控制"><a href="#3-进程控制" class="headerlink" title="3. 进程控制"></a><strong>3. 进程控制</strong></h2><h3 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 <strong>基本概念</strong></h3><ul><li><strong>进程控制</strong><ul><li>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能<ul><li>简化理解：反正<strong>进程控制就是要实现进程状态转换</strong></li></ul></li></ul></li><li><strong>如何实现进程控制?</strong><ul><li>用”<strong>原语</strong>“实现<ul><li>原语是一种特殊的程序， 它的执行具有原子性。 也就是说，这段程序的运行必须一气呵成，不可中断</li><li>如果不能“一气呵成”，就有可能导致操作系统中的某些关键数据结构信息不统一的情况， 这会影响操作系统进行别的管理工作</li></ul></li></ul></li><li><strong>如何实现原语的原子性?</strong><ul><li>可以用 “<strong>关中断指令</strong>”和“<strong>开中断指令</strong>”这两个<strong>特权指令</strong>实现原子性<ul><li>正常情况下，CPU每执行完一条指令都会例行检查是否有中断信号需要处理，如果有， 则暂停运行当前这段程序，转而执行相应的中断处理程序。CPU执行了关中断指令之后，就不再例行检查中断信号，直到执行开中断指令之后才会恢复检查。 这样，关中断、开中断之间的这些指令序列就是不可被中断的，这就实现了“原子性“</li></ul></li></ul></li></ul><h3 id="3-2-进程控制相关的原语"><a href="#3-2-进程控制相关的原语" class="headerlink" title="3.2 进程控制相关的原语"></a>3.2 <strong>进程控制相关的原语</strong></h3><ul><li><p>无论哪个进程控制原语，要做的无非三类事情：</p><ul><li>更新PCB中的信息</li><li>将PCB插入合适的队列</li><li>分配&#x2F;回收资源</li></ul></li><li><p><strong>创建原语</strong></p></li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119193358264.png" alt="创建原语"></p><ul><li><strong>撤销原语</strong></li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119194153849.png"></p><ul><li><strong>阻塞原语 &amp; 唤醒原语</strong></li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119194433458.png"></p><ul><li><strong>切换原语</strong></li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119195359883.png"></p><ul><li>指令顺序执行的过程中，很多中间结果是放在各种寄存器中的，CPU中会设置很多 “寄存器（PSW、PC、IR、通用寄存器）”，用来存放程序运行过程中所需的某些数据，在<strong>进程切换</strong>时先在PCB中保存这个进程的运行环境 （保存一些必要的寄存器信息），当原来的进程再次投入运行时，可以通过PCB恢复它的运行环境</li></ul><h2 id="4-进程通信"><a href="#4-进程通信" class="headerlink" title="4. 进程通信"></a><strong>4. 进程通信</strong></h2><h3 id="4-1-什么是进程通信"><a href="#4-1-什么是进程通信" class="headerlink" title="4.1 什么是进程通信?"></a>4.1 <strong>什么是进程通信?</strong></h3><ul><li>**进程间通信(Inter-Process Communication, IPC)**是指两个进程之间产生数据交互<ul><li>如b站分享视频到qq群中, 就需要不同进程之间的通信</li></ul></li></ul><h3 id="4-2-为什么进程通信需要操作系统支持"><a href="#4-2-为什么进程通信需要操作系统支持" class="headerlink" title="4.2 为什么进程通信需要操作系统支持?"></a>4.2 <strong>为什么进程通信需要操作系统支持?</strong></h3><ul><li><p>进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立（<strong>进程的独立性</strong>）</p></li><li><p>为了保证安全，一个进程不能直接访问另一个进程的地址空间，但是进程之间的信息交换又是必须实现的，为了保证进程间的安全通信，操作系统提供了一些方法:</p><ul><li>共享存储</li><li>消息传递</li><li>管道通信</li></ul></li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119202143646.png"></p><h3 id="4-3-共享存储"><a href="#4-3-共享存储" class="headerlink" title="4.3 共享存储"></a>4.3 <strong>共享存储</strong></h3><ul><li><p>设置一个<strong>共享区</strong>, 将共享内存区映射到进程自己的地址空间中</p><ul><li>通过”<strong>增加页表项&#x2F;段表项</strong>“即可将同一片共享内存区映射到各个进程的地址空间中</li></ul></li><li><p>为避免出错, 各个进程对共享空间的访问应该是<strong>互斥</strong>的, 操作系统只负责提供共享空间和同步互斥工具（如<strong>P、V操作</strong>）</p></li><li><p><strong>两种方式</strong>:</p><ul><li><strong>基于存储区的共享</strong>:<ul><li>在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制， 而不是操作系统。</li><li>相比之下，这种共享方式速度更快，是一种高级通信方式</li></ul></li><li><strong>基于数据结构的共享</strong>:<ul><li>比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、 限制多，是一种低级通信方式</li></ul></li></ul></li></ul><h3 id="4-4-消息传递"><a href="#4-4-消息传递" class="headerlink" title="4.4 消息传递"></a>4.4 <strong>消息传递</strong></h3><ul><li>进程间的数据交换以<strong>格式化的消息（Message）</strong>为单位。进程通过操作系统提供的“<strong>发送消息&#x2F;接****收消息</strong>”两个<strong>原语</strong>进行数据交换<ul><li>格式化的消息: 包含<strong>消息头</strong>、<strong>消息体</strong><ul><li>消息头：包括发送进程ID、接受进程ID、消息类型、消息长度等格式化的信息（计算机网络中发送的“报文”其实就是一种格式化的消息）</li><li>消息体：进程间具体传递的信息</li></ul></li></ul></li><li><strong>两种方式</strong>:<ul><li><strong>直接通信方式</strong><ul><li>消息发送进程要指明接收进程的id, 消息直接挂到接收进程的消息缓冲队列上</li></ul></li><li><strong>间接通信方式</strong><ul><li>通过”<strong>信箱</strong>“间接地通信, 消息要先发送到中间实体（信箱）中, 因此又被称为”<strong>信箱通信方式</strong>“</li></ul></li></ul></li></ul><h3 id="4-5-管道通信"><a href="#4-5-管道通信" class="headerlink" title="4.5 管道通信"></a>4.5 <strong>管道通信</strong></h3><ul><li><p>“<strong>管道</strong>”是指用于连接读写进程的一个共享文件，又名pipe文件，其实就是在内存中开辟一个大小固定的缓冲区</p></li><li><p>数据在管道中以数据流的方式进行传输，遵循先进先出的原则</p></li><li><p><strong>管道通信</strong></p><ul><li>管道只能采用<strong>半双工通信</strong>，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道</li><li>各进程要<strong>互斥</strong>地访问管道(由操作系统实现)</li><li>当<strong>管道写满</strong>时，<strong>写进程将阻塞</strong>，直到读进程将管道中的数据取走，即可唤醒写进程<ul><li><strong>只要管道没满，写进程就可以往管道写数据</strong></li></ul></li><li>当<strong>管道读空</strong>时，<strong>读进程将阻塞</strong>，直到写进程往管道中写入数据，即可唤醒读进程<ul><li><strong>只要管道没空，读进程就可以从管道读数据</strong></li></ul></li><li>管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案:<ul><li>一个管道允许多个写进程，一个读进程（官方答案）</li><li>一个管道允许多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据（Linux方案）</li></ul></li></ul></li></ul><h2 id="5-线程的概念"><a href="#5-线程的概念" class="headerlink" title="5. 线程的概念"></a><strong>5. 线程的概念</strong></h2><h3 id="5-1-什么是线程-为什么要引入线程"><a href="#5-1-什么是线程-为什么要引入线程" class="headerlink" title="5.1 什么是线程, 为什么要引入线程?"></a>5.1 <strong>什么是线程, 为什么要引入线程?</strong></h3><ul><li>进程是程序的一次执行过程, 传统的进程是程序执行流的最小单位, 有的进程可能需要”同时”做很多事, 而传统的进程只能串行地执行一系列程序。为此, 引入了”<strong>线程</strong>“, 来增加并发度, 引入线程后, <strong>线程成为了程序执行流的最小单位</strong><ul><li>线程是一个基本的CPU执行单元, 引入线程之后, 不仅是进程之间可以并发, 进程内的各线程之间也可以并发, 从而进一步提升了系统的并发度, 使得一个进程内也可以并发处理各种任务</li><li>引入线程后, <strong>进程只作为除CPU之外的系统资源的分配单位</strong></li></ul></li></ul><h3 id="5-2-引入线程机制后-有什么变化"><a href="#5-2-引入线程机制后-有什么变化" class="headerlink" title="5.2 引入线程机制后, 有什么变化?"></a>5.2 <strong>引入线程机制后, 有什么变化?</strong></h3><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119205846943.png"></p><h3 id="5-3-线程的属性"><a href="#5-3-线程的属性" class="headerlink" title="5.3 线程的属性"></a>5.3 <strong>线程的属性</strong></h3><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119211033315.png"></p><h2 id="6-线程的实现方式和多线程模型"><a href="#6-线程的实现方式和多线程模型" class="headerlink" title="6. 线程的实现方式和多线程模型"></a><strong>6. 线程的实现方式和多线程模型</strong></h2><h3 id="6-1-线程的实现方式"><a href="#6-1-线程的实现方式" class="headerlink" title="6.1 线程的实现方式"></a>6.1 <strong>线程的实现方式</strong></h3><ul><li><p><strong>用户级线程(User-Level Thread, ULT)</strong></p><ul><li>历史背景：早期的操作系统（如: 早期Unix）只支持进程，不支持线程。当时的“线程”是由线程库实现的，很多编程语言提供了强大的线程库，可以实现线程的创建、销毁、调度等功能</li><li>用户级线程是“代码逻辑”的载体</li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119212407927.png"></p><ul><li><strong>用户级线程的管理工作由谁来完成?</strong><ul><li>用户级线程由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责（包括线程切换），并不是由操作系统完成</li></ul></li><li><strong>用户级线程切换是否需要CPU变态?</strong><ul><li>用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预</li></ul></li><li><strong>操作系统是否能意识到用户级线程的存在?</strong><ul><li>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在，操作系统只能看到包含着多个用户级线程的程序执行的进程</li><li>“用户级线程”就是“从用户视角看能看到的线程”</li></ul></li><li><strong>优缺点</strong><ul><li>优点: 用户级线程的切换在用户态即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</li><li>缺点: 当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高，多个线程不可在多核处理机上并行运行</li></ul></li></ul></li><li><p><strong>内核级线程(Kernel-Level Thread, KLT, 又称“内核支持的线程”)</strong></p><ul><li>由操作系统支持的线程, 大多数现代操作系统都实现了内核级线程, 如Windows、Linux</li><li>操作系统只“看得见”内核级线程，因此只有<strong>内核级线程才是处理机分配的单位</strong></li><li>内核级线程是“运行机会”的载体</li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119213816126.png"></p><ul><li><strong>内核级线程的管理工作由谁来完成?</strong><ul><li>内核级线程的管理工作由操作系统内核完成</li></ul></li><li><strong>内核级线程切换是否需要CPU变态?</strong><ul><li>线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成</li></ul></li><li><strong>操作系统是否能意识到内核级线程的存在?</strong><ul><li>操作系统会为每个内核级线程建立相应的<strong>TCB</strong>(Thread Control Block，线程控制块)，通过TCB对线程进行管理。“内核级线程”就是“从操作系统内核视角看能看到的线程”</li></ul></li><li><strong>优缺点</strong><ul><li>优点: 当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行</li><li>缺点: 一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大</li></ul></li></ul></li></ul><h3 id="6-2-多线程模型"><a href="#6-2-多线程模型" class="headerlink" title="6.2 多线程模型"></a>6.2 <strong>多线程模型</strong></h3><ul><li><p>在支持内核级线程的系统中，根据<strong>用户级线程</strong>和<strong>内核级线程</strong>的<strong>映射关系</strong>，可以划分为几种多线程模型</p></li><li><p><strong>一对一模型</strong></p><ul><li>一个用户级线程映射到一个内核级线程，每个用户进程有与用户级线程同数量的内核级线程</li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119213900964.png"></p><ul><li>优点: 当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</li><li>缺点: 一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大</li></ul></li><li><p><strong>多对一模型</strong></p><ul><li>多个用户级线程映射到一个内核级线程，且一个进程只被分配一个内核级线程</li><li>退化为纯粹的用户级线程管理方式</li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119213936402.png"></p><ul><li>优点: 用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</li><li>缺点: 当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高，多个线程不可在多核处理机上并行运行</li></ul></li><li><p><strong>多对多模型</strong></p><ul><li>n 用户及线程映射到 m 个内核级线程(n &gt;&#x3D; m)， 每个用户进程对应 m 个内核级线程</li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119214026494.png"></p><ul><li>克服了多对一模型并发度不高的缺点(一个阻塞全体阻塞)，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点, 内核级线程中可以运行任意一个有映射关系的用户级线程代码, 只有m个内核级线程中正在运行的代码逻辑都阻塞时, 这个进程才会阻塞</li></ul></li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119214325834.png"></p><h2 id="7-线程的状态与转换"><a href="#7-线程的状态与转换" class="headerlink" title="7. 线程的状态与转换"></a><strong>7. 线程的状态与转换</strong></h2><h3 id="7-1-线程的状态与转换"><a href="#7-1-线程的状态与转换" class="headerlink" title="7.1 线程的状态与转换"></a>7.1 <strong>线程的状态与转换</strong></h3><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119214437515.png"></p><h3 id="7-2-线程的组织与控制"><a href="#7-2-线程的组织与控制" class="headerlink" title="7.2 线程的组织与控制"></a>7.2 <strong>线程的组织与控制</strong></h3><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119214535741.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.6 虚拟机</title>
    <link href="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-6-%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <url>/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-6-%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="1-6-虚拟机"><a href="#1-6-虚拟机" class="headerlink" title="1.6 虚拟机"></a><strong>1.6 虚拟机</strong></h1><h2 id="1-虚拟机"><a href="#1-虚拟机" class="headerlink" title="1. 虚拟机"></a>1. <strong>虚拟机</strong></h2><ul><li><p>使用虚拟化技术, 将一台物理机器虚拟化为多台虚拟机器(Virtual Machine, VM), 每个虚拟机器都可以独立运行一个操作系统</p></li><li><p>同义术语: 虚拟机管理程序&#x2F;虚拟机监控程序&#x2F;Virtual Machine Monitor&#x2F;Hypervisor</p></li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-6-%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20241119165138528.png" alt="两类虚拟机"></p><ul><li>支持虚拟化的CPU通常分更多指令等级<ul><li>Ring 3: 最低权限的一些指令 → Ring 0: 最高权限的一些指令</li><li>VMware、VirtualBox就属于第二轮VMM</li></ul></li></ul><h2 id="2-两类虚拟机管理程序的对比"><a href="#2-两类虚拟机管理程序的对比" class="headerlink" title="2. 两类虚拟机管理程序的对比"></a>2. <strong>两类虚拟机管理程序的对比</strong></h2><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-6-%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20241119165622367.png" alt="对比"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.5 操作系统引导</title>
    <link href="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-5-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC/"/>
    <url>/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-5-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="1-5-操作系统引导"><a href="#1-5-操作系统引导" class="headerlink" title="1.5 操作系统引导"></a><strong>1.5 操作系统引导</strong></h1><h2 id="1-什么是操作系统引导"><a href="#1-什么是操作系统引导" class="headerlink" title="1. 什么是操作系统引导?"></a>1. <strong>什么是操作系统引导?</strong></h2><ul><li>开机的时候, 怎么让操作系统运行起来?</li></ul><h2 id="2-磁盘里边有哪些相关数据"><a href="#2-磁盘里边有哪些相关数据" class="headerlink" title="2. 磁盘里边有哪些相关数据?"></a>2. <strong>磁盘里边有哪些相关数据?</strong></h2><ul><li><strong>主引导记录(MBR)</strong><ul><li>包含<strong>磁盘引导程序</strong>和<strong>分区表</strong></li><li>分区表: 说明了每个磁盘分区占据多少空间、地址范围</li></ul></li><li>C:盘<ul><li>是这个磁盘的<strong>活动分区</strong>, 安装了操作系统</li><li><strong>引导记录(PBR)</strong><ul><li>负责找到”启动管理器”, “启动管理器”是完整的操作系统初始化程序, 其存放在根目录中的某个位置</li><li>Windows中”启动管理器”存放在 根目录\Windows\Boot 下</li></ul></li><li>根目录</li><li>其他</li></ul></li><li>其他盘</li></ul><h2 id="3-操作系统引导过程"><a href="#3-操作系统引导过程" class="headerlink" title="3. 操作系统引导过程"></a>3. <strong>操作系统引导过程</strong></h2><ul><li><strong>主存(内存)</strong><ul><li><strong>RAM</strong><ul><li>日常用语电脑内存、手机内存通常就是指代RAM</li></ul></li><li><strong>ROM</strong><ul><li>存储了基本输入输出系统<strong>BIOS</strong>, 其内部包含了ROM引导程序, 即自举程序</li></ul></li></ul></li><li><strong>引导过程</strong>:<ul><li>CPU从一个特定主存地址开始, 取指令, 执行ROM中的引导程序(先进行硬件自检, 再开机)</li><li>将磁盘的第一块 – 主引导记录读入内存, 执行磁盘引导程序, 扫描分区表</li><li>从活动分区(又称主分区, 即安装了操作系统的分区)读入分区引导记录, 执行其中的程序</li><li>从根目录下找到完整的操作系统初始化程序(即 启动管理器 )并执行, 完成”开机”的一系列动作</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.4 操作系统结构</title>
    <link href="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
    <url>/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="1-4-操作系统体系结构"><a href="#1-4-操作系统体系结构" class="headerlink" title="1.4 操作系统体系结构"></a>1.4 操作系统体系结构</h1><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20241119160018312.png" alt="计算机系统的层次结构"></p><h2 id="1-操作系统的内核"><a href="#1-操作系统的内核" class="headerlink" title="1. 操作系统的内核"></a>1. <strong>操作系统的内核</strong></h2><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20241119160322830.png" alt="操作系统内核"></p><ul><li><strong>内核</strong>是操作系统最基本、最核心的部分</li><li>实现操作系统内核功能的那些程序就是<strong>内核程序</strong></li></ul><h3 id="1-1-大内核"><a href="#1-1-大内核" class="headerlink" title="1.1 大内核"></a>1.1 <strong>大内核</strong></h3><ul><li><p>内核中包含了时钟管理、中断处理、原语以及进程管理、存储器管理、设备管理等功能</p></li><li><p>由于大内核中包含的功能多, CPU只需进行少量的状态切换便可完成应用程序请求的系统调用, 但同时也导致了大内核代码庞大, 不方便管理的问题</p></li></ul><h3 id="1-2-微内核"><a href="#1-2-微内核" class="headerlink" title="1.2 微内核"></a>1.2 <strong>微内核</strong></h3><ul><li><p>只包含了与硬件关联较紧密的模块, 如时钟管理、中断处理、原语等</p></li><li><p>微内核内部功能少, 结构清晰, 方便维护, 但也要求CPU需要进行多次的状态切换来满足应用程序请求的进程、存储器、设备等服务</p></li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20241119160746125.png" alt="大内核与微内核"></p><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20241119160818121.png" alt="操作系统的体系结构"></p><h2 id="2-外核"><a href="#2-外核" class="headerlink" title="2. 外核"></a>2. 外核</h2><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20241119161000144.png" alt="操作系统结构"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.3 操作系统运行环境</title>
    <link href="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/"/>
    <url>/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h1 id="1-3-操作系统运行环境"><a href="#1-3-操作系统运行环境" class="headerlink" title="1.3 操作系统运行环境"></a>1.3 操作系统运行环境</h1><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/image-20241119150939015.png"></p><h2 id="1-操作系统的运行机制"><a href="#1-操作系统的运行机制" class="headerlink" title="1. 操作系统的运行机制"></a>1. <strong>操作系统的运行机制</strong></h2><h3 id="1-1-程序是如何运行的"><a href="#1-1-程序是如何运行的" class="headerlink" title="1.1 程序是如何运行的?"></a>1.1 <strong>程序是如何运行的?</strong></h3><ul><li>一条高级语言的代码翻译过来可能会对应多条二进制机器指令</li><li>程序运行的过程其实是CPU执行一条一条的机器指令的过程<ul><li>“指令”就是处理机(CPU)能识别、执行的最基本命令</li></ul></li></ul><h3 id="1-2-内核程序-vs-应用程序"><a href="#1-2-内核程序-vs-应用程序" class="headerlink" title="1.2 内核程序 vs 应用程序"></a>1.2 <strong>内核程序 vs 应用程序</strong></h3><ul><li><strong>应用程序</strong><ul><li>普通程序员写的程序就是”应用程序”</li></ul></li><li><strong>内核程序</strong><ul><li>微软、苹果有一帮人负责实现操作系统, 他们写的是”内核程序”</li><li>由很多内核程序组成了”<strong>操作系统内核</strong>“, 或简称”<strong>内核(Kernel)</strong>“</li><li>内核是操作系统最重要最核心的部分, 也是最接近硬件的部分, 甚至可以说, 一个操作系统只要有内核就够了(eg: Docker→ 仅需Linux内核)</li></ul></li></ul><h3 id="1-3-特权指令-vs-非特权指令"><a href="#1-3-特权指令-vs-非特权指令" class="headerlink" title="1.3 特权指令 vs 非特权指令"></a>1.3 <strong>特权指令 vs 非特权指令</strong></h3><ul><li><strong>特权指令</strong><ul><li>操作系统内核作为”管理者”, 有时会让CPU执行一些”特权指令”, 如: 内存清零指令, 这些指令影响重大, 只允许”管理者” – 即操作系统内核来使用</li></ul></li><li><strong>非特权指令</strong><ul><li>应用程序只能使用”非特权指令”, 如: 加法指令、减法指令</li><li>在CPU设计和生产的时候就划分了特权指令和非特权指令， 因此CPU执行一条指令前就能判断出其类型</li></ul></li></ul><h3 id="1-4-用户态-vs-内核态"><a href="#1-4-用户态-vs-内核态" class="headerlink" title="1.4 用户态 vs 内核态"></a>1.4 <strong>用户态 vs 内核态</strong></h3><ul><li>CPU有两种状态: “<strong>内核态</strong>“ 和 “<strong>用户态</strong>“<ul><li>CPU中有一个寄存器叫<strong>程序状态字寄存器(PSW)</strong>, 其中有一个二进制位能够表示CPU为用户态还是内核态</li><li>内核态&#x3D;核心态&#x3D;<strong>管态</strong>; 用户态&#x3D;<strong>目态</strong></li></ul></li><li><strong>用户态</strong><ul><li>处于用户态时, 说明此时正在运行的是应用程序, 此时只能执行非特权指令</li></ul></li><li><strong>核心态</strong><ul><li>处于核心态时, 说明此时正在运行的是内核程序, 此时可以执行特权指令</li></ul></li><li><strong>两种状态的切换</strong><ul><li><strong>内核态 → 用户态</strong><ul><li>执行一条特权指令 – 修改PSW的标志位为”用户态”, 这个动作意味着操作系统将主动让出CPU特权</li></ul></li><li><strong>用户态 → 内核态</strong><ul><li>由”<strong>中断</strong>“引发, 硬件自动完成变态过程, 触发中断信号意味着操作系统将强行夺回CPU的使用权</li><li>除了非法使用特权指令之外, 还有很多事件会触发中断信号。一个共性是: 但凡需要操作系统介入的地方, 都会触发中断信号</li></ul></li><li><strong>示例</strong>:<ol><li>刚开机时, CPU为”内核态”, 操作系统内核程序先上CPU运行</li><li>开机完成后, 用户可以启动某个应用程序</li><li>操作系统内核程序在合适的时候主动让出CPU, 让该应用程序上CPU运行<ul><li>操作系统内核在让出CPU之前, 会用一条特权指令把PSW的标志位设置为”用户态”</li></ul></li><li>应用程序运行在”用户态”</li><li>此时黑客在应用程序中植入了一条特权指令, 企图破坏系统</li><li>CPU发现接下来要执行的这条指令是特权指令, 但是自己又处于”用户态”</li><li>这个非法事件会引发一个<strong>中断信号</strong><ul><li>CPU检测到中断信号后, 会立即变为”内核态”, 并停止运行当前的应用程序, 转而运行处理中断信号的内核程序</li></ul></li><li>“中断”使操作系统再次夺回CPU的控制权</li><li>操作系统会对引发中断的事件进行处理, 处理完了再把CPU使用权交给应用程序</li></ol></li></ul></li></ul><h2 id="2-中断和异常"><a href="#2-中断和异常" class="headerlink" title="2. 中断和异常"></a><strong>2. 中断和异常</strong></h2><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/image-20241119154048407.png"></p><ul><li>“<strong>中断</strong>”是让操作系统内核夺回CPU使用权的唯一途径</li></ul><h3 id="2-1-内中断-异常"><a href="#2-1-内中断-异常" class="headerlink" title="2.1 内中断(异常)"></a>2.1 内中断(异常)</h3><ul><li>与当前执行的指令有关，中断信号来源于CPU内部</li><li><strong>示例</strong>:<ol><li>试图在用户态下执行特权指令</li><li>执行除法指令时发现除数为 0<ul><li>若当前执行的指令是非法的，则会引发一个中断信号</li></ul></li><li>有时候应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令 – <strong>陷入指令</strong><ul><li>**(访管指令)**，该指令会引发一个内部中断信号</li><li>执行“陷入指令”，意味着应用程序主动地将CPU控制权还给操作系统内核</li><li>“<strong>系统调用</strong>”就是通过陷入指令完成的</li></ul></li></ol></li><li><strong>分类</strong>:<ul><li><strong>陷阱、陷入(trap)</strong><ul><li>由陷入指令引发，是应用程序故意引发的</li></ul></li><li><strong>故障(fault)</strong><ul><li>由错误条件引起的，可能被内核程序修复</li><li>内核程序修复故障后会把CPU使用权还给应用程序，让它继续执行下去</li><li>如：<strong>缺页故障(缺页中断)</strong></li></ul></li><li><strong>终止(abort)</strong><ul><li>由致命错误引起，内核程序无法修复该错误</li><li>因此一般不再将CPU使用权还给引发终止的应用程序，而是直接终止该应用程序</li><li>如： 整数除0、非法使用特权指令</li></ul></li></ul></li></ul><h3 id="2-2-外中断-中断"><a href="#2-2-外中断-中断" class="headerlink" title="2.2 外中断(中断)"></a>2.2 <strong>外中断(中断)</strong></h3><ul><li><p>与当前执行的指令无关，中断信号来源于CPU外部</p></li><li><p>每一条指令执行结束时，CPU都会例行检查是否有外中断信号</p></li><li><p><strong>示例</strong>:</p><ul><li>时钟中断 – 由时钟部件发来的中断信号<ul><li>时钟部件每隔一个时间片（如 50ms）会给CPU发送一个时钟中断信号</li></ul></li><li>I&#x2F;O中断 – 由输入&#x2F;输出设备发来的中断信号<ul><li>如打印机打印完成后, 向CPU发送中断信号, CPU根据中断信号执行对应的<strong>中断处理程序</strong></li></ul></li></ul></li><li><p><strong>注意</strong>：</p><ul><li>大多数的教材、试卷中，“<strong>中断</strong>”特指狭义的中断，即<strong>外中断</strong>。而<strong>内中断</strong>一般称为“<strong>异常</strong>”</li></ul></li><li><p><strong>中断机制的基本原理</strong></p><ul><li>不同的中断信号，需要用不同的<strong>中断处理程序</strong>来处理</li><li>当CPU检测到中断信号后，会根据中断信号的类型去查询“<strong>中断向量表</strong>”，以此来找到相应的中断处理程序在内存中的存放位置</li></ul></li></ul><h2 id="3-系统调用"><a href="#3-系统调用" class="headerlink" title="3. 系统调用"></a><strong>3. 系统调用</strong></h2><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/image-20241119155457023.png"></p><h3 id="3-1-什么是系统调用"><a href="#3-1-什么是系统调用" class="headerlink" title="3.1 什么是系统调用?"></a>3.1 <strong>什么是系统调用?</strong></h3><ul><li><p>操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括<strong>命令接口</strong>和<strong>程序接口</strong>，其中，程序接口由一组<strong>系统调用</strong>组成</p></li><li><p>“系统调用”是操作系统提供给应用程序（程序员&#x2F;编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求获得操作系统内核的服务</p></li></ul><h3 id="3-2-系统调用与库函数的区别"><a href="#3-2-系统调用与库函数的区别" class="headerlink" title="3.2 系统调用与库函数的区别"></a>3.2 <strong>系统调用与库函数的区别</strong></h3><table><thead><tr><th align="center">普通应用程序</th><th align="center">可直接进行系统调用，也可使用库函数。有的库函数涉及系统调用，有的不涉及</th></tr></thead><tbody><tr><td align="center">编程语言</td><td align="center">向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使程序员编程更加方便</td></tr><tr><td align="center">操作系统</td><td align="center">向上提供系统调用，使得上层程序能请求内核的服务</td></tr><tr><td align="center">裸机</td><td align="center"></td></tr></tbody></table><ul><li><p>不涉及系统调用的库函数：如的“取绝对值”的函数</p></li><li><p>涉及系统调用的库函数：如“创建一个新文件”的函数</p></li><li><p>总之，部分库函数是对系统调用的进一步封装，应用程序可以使用库函数进行间接系统调用，也可以进行直接系统调用</p></li></ul><h3 id="3-3-为什么系统调用是必须的"><a href="#3-3-为什么系统调用是必须的" class="headerlink" title="3.3 为什么系统调用是必须的?"></a>3.3 <strong>为什么系统调用是必须的?</strong></h3><ul><li><strong>生活场景</strong>:<ul><li>去学校打印店打印论文，你按下了 WPS 的“打印”选项，打印机开始工作。 你的论文打印到一半时，另一位同学按下了 Word 的“打印”按钮，开始打印他自己的论文。</li></ul></li><li><strong>思考</strong>:<ul><li>如果两个进程可以随意地、并发地共享打印机资源(<strong>同时共享</strong>)，会发生什么情况？<ul><li>两个进程并发运行，打印机设备交替地收到 WPS 和 Word 两个进程发来的打印请求，结果两篇论文的内容混杂在一起了</li></ul></li></ul></li><li><strong>解决方法</strong>:<ul><li>由操作系统内核对共享资源进行统一的管理，并向上提供 “系统调用” ，用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求，以此来实现不同的进程对打印机资源的<strong>互斥共享</strong>，内核会对各个请求进行协调处理</li></ul></li></ul><h3 id="3-4-什么功能要用系统调用实现"><a href="#3-4-什么功能要用系统调用实现" class="headerlink" title="3.4 什么功能要用系统调用实现?"></a>3.4 <strong>什么功能要用系统调用实现?</strong></h3><ul><li><p>应用程序通过系统调用请求操作系统的服务。而系统中的各种<strong>共享资源</strong>都由操作系统内核统一掌管，因此凡是<strong>与共享资源有关的操作</strong>（如存储分配、I&#x2F;O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作</p></li><li><p><strong>功能分类(了解即可)</strong>:</p><ul><li>设备控制: 完成设备的 请求&#x2F;释放&#x2F;启动 等功能</li><li>文件管理: 完成文件的 读&#x2F;写&#x2F;创建&#x2F;删除 等功能</li><li>进程控制: 完成进程的 创建&#x2F;撤销&#x2F;阻塞&#x2F;唤醒 等功能</li><li>进程通信: 完成进程之间的 消息传递&#x2F;信号传递 等功能</li><li>内存管理: 完成内存的 分配&#x2F;回收 等功能</li></ul></li></ul><h3 id="3-5-系统调用的过程"><a href="#3-5-系统调用的过程" class="headerlink" title="3.5 系统调用的过程"></a>3.5 <strong>系统调用的过程</strong></h3><ul><li><p>传递系统调用参数（将系统调用需要的参数放到某些通用寄存器中） → 执行陷入指令（用户态）→ 执行相应的内核程序（根据寄存器中的参数判断用户需要哪种系统调用服务）处理系统调用（核心态）→ 返回应用程序</p></li><li><p><strong>注意</strong>:</p><ul><li><strong>陷入指令</strong>是在<strong>用户态</strong>执行的，执行陷入指令之后立即引发一个内中断，使CPU进入核心态</li><li><strong>发出系统调用请求</strong>是在<strong>用户态</strong>，而<strong>对系统调用的相应处理</strong>在<strong>核心态</strong>下进行</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.2 操作系统发展历程</title>
    <link href="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/"/>
    <url>/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-2-操作系统发展历程"><a href="#1-2-操作系统发展历程" class="headerlink" title="1.2 操作系统发展历程"></a>1.2 操作系统发展历程</h1><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/image-20241119125703536.png"></p><h2 id="1-手工操作阶段"><a href="#1-手工操作阶段" class="headerlink" title="1. 手工操作阶段"></a>1. <strong>手工操作阶段</strong></h2><ul><li><p>程序员将程序放入纸带机上(慢) → 计算机读取纸带(慢) → 计算机计算(快) → 输出纸带(慢) → 程序员获取计算结果(慢)</p></li><li><p><strong>主要缺点</strong>:</p><ul><li>用户独占全机、人机速度矛盾导致资源利用率低</li></ul></li></ul><h2 id="2-批处理阶段"><a href="#2-批处理阶段" class="headerlink" title="2. 批处理阶段"></a>2. <strong>批处理阶段</strong></h2><h3 id="2-1-单道批处理系统"><a href="#2-1-单道批处理系统" class="headerlink" title="2.1 单道批处理系统"></a>2.1 <strong>单道批处理系统</strong></h3><ol><li><p>引入<strong>脱机输入&#x2F;输出技术</strong>（用<strong>外围机</strong>+<strong>磁带</strong>完成），并由监督程序(操作系统雏形)负责控制作业的输入、输出</p></li><li><p><strong>为什么称为”脱机”?</strong></p><ol><li>脱离主机的控制进行的输入&#x2F;输出操作</li><li>程序员将程序放入纸带机上 → 外围机将纸带数据放入磁带中 → 计算机读取磁带(磁带读写速度比纸带机快很多) → 计算机计算 → 输出计算结果到磁带</li></ol></li><li><p><strong>主要优点</strong>:</p><ol><li>缓解了一定程度的人机速度矛盾，资源利用率有所提升</li></ol></li><li><p><strong>主要缺点</strong>:</p><ol><li>内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序。 CPU有大量的时间是在空闲等待I&#x2F;O完成。资源利用率依然很低</li></ol></li></ol><h3 id="2-2-多道批处理系统"><a href="#2-2-多道批处理系统" class="headerlink" title="2.2 多道批处理系统"></a>2.2 <strong>多道批处理系统</strong></h3><ol><li><p>操作系统正式诞生，用于支持多道程序并发运行，每次往内存中读入多道程序</p></li><li><p><strong>主要优点</strong>：</p><ol><li>多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大</li></ol></li><li><p><strong>主要缺点</strong>:</p><ol><li>用户响应时间长，没有人机交互功能（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行 eg：无法调试程序&#x2F;无法在程序运行过程中输入一些参数）</li></ol></li></ol><h2 id="3-分时操作系统"><a href="#3-分时操作系统" class="headerlink" title="3. 分时操作系统"></a>3. <strong>分时操作系统</strong></h2><ol><li><p>计算机以时间片为单位轮流为各个用户&#x2F;作业服务，各个用户可通过终端与计算机进行交互</p></li><li><p><strong>主要优点</strong>:</p><ol><li>用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在</li></ol></li><li><p><strong>主要缺点</strong>:</p><ol><li>不能优先处理一些紧急任务。操作系统对各个用户&#x2F;作业都是完全公平的，循环地为每个用户&#x2F;作业服务一个时间片，不区分任务的紧急性</li></ol></li></ol><h2 id="4-实时操作系统"><a href="#4-实时操作系统" class="headerlink" title="4. 实时操作系统"></a>4. <strong>实时操作系统</strong></h2><ol><li><p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件</p></li><li><p>实时操作系统的主要特点是<strong>及时性</strong>和<strong>可靠性</strong></p></li><li><p><strong>硬实时系统</strong></p><ol><li>必须在绝对严格的规定时间内完成处理</li></ol></li><li><p><strong>软实时系统</strong></p><ol><li>能接受偶尔违反时间规定</li></ol></li><li><p><strong>主要优点</strong>:</p><ol><li>能够优先响应一些紧急任务，某些紧急任务不需时间片排队</li></ol></li></ol><h2 id="5-其他操作系统"><a href="#5-其他操作系统" class="headerlink" title="5. 其他操作系统"></a>5. <strong>其他操作系统</strong></h2><ol><li>网络操作系统<ol><li>是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信（如：WindowsNT 就是 一种典型的网络操作系统，网站服务器就可以使用）</li></ol></li><li>分布式操作系统<ol><li>主要特点是分布性和并行性</li><li>系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务</li></ol></li><li>个人计算机操作系统<ol><li>如 Windows XP、MacOS，方便个人使用</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.1 操作系统的基本概念</title>
    <link href="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="1-1-操作系统的基本概念"><a href="#1-1-操作系统的基本概念" class="headerlink" title="1.1 操作系统的基本概念"></a>1.1 操作系统的基本概念</h1><h2 id="1-OS概念"><a href="#1-OS概念" class="headerlink" title="1. OS概念"></a>1. OS概念</h2><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20241119123556782.png"></p><h3 id="1-1-计算机系统的层次结构"><a href="#1-1-计算机系统的层次结构" class="headerlink" title="1.1 计算机系统的层次结构"></a>1.1 计算机系统的层次结构</h3><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20241119121839269.png"></p><ul><li>用户可以通过调用命令接口的方式以及使用GUI与操作系统进行直接交互</li><li>应用程序通过调用程序接口的方式与操作系统进行直接交互 </li><li>裸机(纯硬件)包括CPU、内存、硬盘、主板等</li></ul><h3 id="1-2-操作系统概念"><a href="#1-2-操作系统概念" class="headerlink" title="1.2 操作系统概念"></a>1.2 操作系统概念</h3><ul><li>操作系统(Operating System,OS)是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配；</li><li>以提供给用户和其他软件方便的接口和环境；</li><li>它是计算机系统中最基本的系统软件。</li></ul><ol><li>操作系统是系统资源的管理者<ol><li>以提供给用户和其他软件方便的接口和环境</li></ol></li><li>向上层提供方便易用的服务 <ol><li>它是计算机系统中最基本的系统软件</li></ol></li><li>是最接近硬件的一层软件</li></ol><h2 id="2-OS功能和目标"><a href="#2-OS功能和目标" class="headerlink" title="2. OS功能和目标"></a>2. OS功能和目标</h2><h3 id="2-1-系统资源的管理者"><a href="#2-1-系统资源的管理者" class="headerlink" title="2.1 系统资源的管理者"></a>2.1 系统资源的管理者</h3><ul><li>用QQ和朋友视频聊天的过程： <ul><li>Step 1：在各个文件夹中找到 QQ 安装的位置（如 D:&#x2F;Tencent&#x2F;QQ&#x2F;Bin）<ul><li>逐层打开文件夹， 找到QQ.exe 这个程序（可执行文件）的存放位置 </li><li>文件管理</li></ul></li><li>Step 2：双击打开 QQ.exe <ul><li>需要把该程序相关数据放入内存 </li><li>存储器管理, 执行一个程序前需要将该程序放到内存中，才能被CPU处理</li></ul></li><li>Step 3：QQ 程序正常运行 <ul><li>对应的进程被处理机（CPU）处理 </li><li>处理机管理</li></ul></li><li>Step 4：开始和朋友视频聊天 <ul><li>需要将摄像头设备分配给进程 </li><li>设备管理</li></ul></li></ul></li></ul><h3 id="2-2-向上层提供方便易用的服务"><a href="#2-2-向上层提供方便易用的服务" class="headerlink" title="2.2 向上层提供方便易用的服务"></a>2.2 <strong>向上层提供方便易用的服务</strong></h3><ul><li><p><strong>封装思想</strong></p><ul><li>操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可</li></ul></li><li><p><strong>提供的服务</strong></p><ul><li>GUI：图形化用户接口（Graphical User Interface）</li><li><strong>联机命令接口</strong> &#x3D; <strong>交互式命令接口</strong><ul><li>如Windows命令行指令</li><li>特点: 用户说一句, 系统跟着做一句</li></ul></li><li><strong>脱机命令接口</strong> &#x3D; <strong>批处理命令接口</strong><ul><li>如执行Windows中的*.bat文件</li><li>特定: 用户说一堆, 系统跟着做一堆</li></ul></li><li><strong>程序接口</strong>(由一系列系统调用组成)<ul><li>可以在程序中进行**系统调用(广义指令)**来使用程序接口, 普通用户不能直接使用程序接口, 只能通过程序代码间接使用</li><li>系统调用类似于函数调用，是应用程序请求操作系统服务的唯一方式</li></ul></li></ul></li></ul><h3 id="2-3-作为最接近硬件的层次"><a href="#2-3-作为最接近硬件的层次" class="headerlink" title="2.3 作为最接近硬件的层次"></a>2.3 <strong>作为最接近硬件的层次</strong></h3><ol><li><p>需要实现对硬件机器的拓展</p></li><li><p>没有任何软件支持的计算机称为<strong>裸机</strong></p><ol><li>在裸机上安装的操作系统， 可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器</li></ol></li><li><p>通常把覆盖了软件的机器称为<strong>扩充机器</strong>，又称之为<strong>虚拟机</strong></p></li><li><p><strong>操作系统对硬件机器的拓展</strong></p><ol><li>将CPU、内存、磁盘、显示器、键盘等硬件合理地组织起来，让各种硬件能够相互协调配合，实现更多更复杂的功能</li><li>普通用户无需关心这些硬件在底层是怎么组织起来工作的，只需直接使用操作系统提供的接口即可</li></ol></li></ol><h2 id="3-操作系统的特征"><a href="#3-操作系统的特征" class="headerlink" title="3. 操作系统的特征"></a>3. 操作系统的特征</h2><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20241119125617317.png"></p><h3 id="3-1-并发"><a href="#3-1-并发" class="headerlink" title="3.1 并发"></a>3.1 <strong>并发</strong></h3><ul><li>两个或多个事件在同一时间间隔内发生。这些事情宏观上是同时发生的, 但微观上是交替发生的</li></ul><ol><li><p><strong>并行</strong></p><ol><li>指两个或多个事件在同一时刻同时发生</li></ol></li><li><p><strong>操作系统的并发性</strong></p><ol><li>是指计算机系统中“同时”运行着多个程序, 这些程序宏观上看是同时运行着, 而微观上看是交替运行的</li><li>操作系统就是伴随着“多道程序技术”而出现的。因此，操作系统和程序并发是一起诞生的</li></ol></li><li><p><strong>注意</strong></p><ol><li><strong>单核CPU</strong>同一时刻只能执行一个程序，各个程序只能并发地执行</li><li><strong>多核CPU</strong>同一时刻可以同时执行多个程序，多个程序可以并行地执行</li></ol></li></ol><h3 id="3-2-共享"><a href="#3-2-共享" class="headerlink" title="3.2 共享"></a>3.2 <strong>共享</strong></h3><ul><li><p>并发与共享是两个最基本的特征, 二者互为存在条件</p><ul><li>如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义</li><li>如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发</li></ul></li><li><p><strong>共享</strong>即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用</p><ul><li><strong>互斥共享</strong><ul><li>系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源</li></ul></li><li><strong>同时共享</strong><ul><li>系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问</li><li>所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享）</li></ul></li></ul></li></ul><h3 id="3-3-虚拟"><a href="#3-3-虚拟" class="headerlink" title="3.3 虚拟"></a>3.3 <strong>虚拟</strong></h3><p>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体是实际存在的, 逻辑上的对应物是用户感受到的</p><ul><li><strong>空分复用技术</strong><ul><li>虚拟存储器运行着远大于实际存储器内存大小的程序</li></ul></li><li><strong>时分复用技术</strong><ul><li>微观上处理机在各个微小的时间段内交替着为各个进程服务</li></ul></li><li>显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，没有并发性，就谈不上虚拟性</li></ul><h3 id="3-4-异步"><a href="#3-4-异步" class="headerlink" title="3.4 异步"></a>3.4 <strong>异步</strong></h3><ul><li>在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性</li><li>只有系统拥有并发性，才有可能导致异步性</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.7 万维网WWW</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-7-%E4%B8%87%E7%BB%B4%E7%BD%91WWW/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-7-%E4%B8%87%E7%BB%B4%E7%BD%91WWW/</url>
    
    <content type="html"><![CDATA[<h1 id="6-7-万维网WWW"><a href="#6-7-万维网WWW" class="headerlink" title="6.7 万维网WWW"></a>6.7 万维网WWW</h1><blockquote><p>即 World Wide Web，是一个大规模的、联机式的信息储藏所，是运行在因特网上的一个分布式应用。</p></blockquote><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-7-%E4%B8%87%E7%BB%B4%E7%BD%91WWW/image-20241118192932067.png" alt="万维网文档"></p><ol><li><p>统一资源定位符URL</p><blockquote><p>万维网使用统一资源定位符URL来指明因特网上任何种类“资源”的位置。</p><p>其一般形式为：<code>&lt;协议&gt;：/∥&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;</code></p></blockquote></li><li><p>超文本传输协议HTTP</p><blockquote><p>超文本传输协议 HTTP (HyperText Transfer Protocol) 定义了浏览器（即万维网客户进程）<br>怎样向万维网服务器请求万维网文档以及万维网服务器怎样把万维网文档传送给浏览器。</p></blockquote><ol><li><p>HTTP1.0</p><blockquote><p>采用非持续连接方式。每次浏览器要请求一个文件都要与服务器建立TCP连接(80端口)，当收到响应后就立即关闭连接。</p><p>每请求一个文档就要有两倍的TT的开销。若一个网页上有很多引用对象（例如图片等），那么请求每一个对象都需要花费2RTT的时间。<br>为了减小时延，浏览器通常会建立多个并行的TCP连接同时请求多个对象。但是，这会大量占用万维网服务器的资源，特别是万维网服务器往往要同时服务于大量客户的请求，这会使其负担很重。</p></blockquote></li><li><p>HTTP1.1</p><blockquote><ol><li><p>采用持续连接方式。万维网服务器在发送响应后仍然保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。</p></li><li><p>为了进一步提高效率，还可采用流水线方式，即浏览器在收到HTTP的响应报文之前<br>就能够连续发送多个请求报文。</p></li></ol></blockquote></li></ol></li><li><p>HTTP两种报文——请求报文和响应报文</p><blockquote><p>报文中的每一个字段都是一些ASCII码串，并且每个字段的长度都是不确定的。</p></blockquote><ol><li><p>请求报文格式<br><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-7-%E4%B8%87%E7%BB%B4%E7%BD%91WWW/image-20241118222527016.png"></p></li><li><p>响应报文格式<br><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-7-%E4%B8%87%E7%BB%B4%E7%BD%91WWW/1689763996008.png" alt="1689763996008"></p></li></ol></li><li><p>Cookie技术</p><blockquote><p>Cookie提供了一种机制使得万维网服务器能够“记住”用户，而无需用户主动提供用户标识信息。<br>也就是说，Cookie是一种<strong>对无状态的HTTP进行状态化</strong>的技术。</p></blockquote><p><img src="https://raw.githubusercontent.com/Ag-epiphany/typora_Pictures/main/image-20230719184205348.png" alt="image-20230719184205348"></p></li><li><p>万维网缓存（Web缓存）</p><blockquote><p>在万维网中还可以使用缓存机制以提高万维网的效率。<br>可位于客户机，也可位于中间系统上，位于中间系统上的Web缓存又称为代理服务器。</p></blockquote><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-7-%E4%B8%87%E7%BB%B4%E7%BD%91WWW/image-20230719183530450.png" alt="image-20230719183530450"></p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>Last-Modified</td><td>最后修改时间</td></tr><tr><td>Expires</td><td>有效期</td></tr></tbody></table><ol><li>若过了最后有效期，则在客户机发来请求时，代理服务器向原始服务器发送请求得到新的数据<ol><li>若原始服务器的数据也未更改，则发回一个不带实体数据的响应报文，<br>代理服务器收到后更新有效期，将数据发给客户机</li><li>若原始服务器的数据更改，那么发回新数据的响应报文，代理服务器更新数据以及两个字段并将新数据发给客户机</li></ol></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.6 电子邮件</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-6-%E7%94%B5%E5%AD%90%E5%8D%8F%E8%AE%AE/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-6-%E7%94%B5%E5%AD%90%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="6-6-电子邮件"><a href="#6-6-电子邮件" class="headerlink" title="6.6 电子邮件"></a>6.6 电子邮件</h1><h2 id="1-电子邮件系统"><a href="#1-电子邮件系统" class="headerlink" title="1. 电子邮件系统"></a>1. 电子邮件系统</h2><blockquote><p>电子邮件系统采用客户&#x2F;服务器方式。三个主要组成构件：用户代理，邮件服务器以及电子邮件所需的协议</p></blockquote><ol><li>用户代理是用户与电子邮件系统的接口，又称为电子邮件客户端软件</li><li>邮件服务器是电子邮件系统的基础设施。因特网上所有的SP都有邮件服务器，其功能是发送和接收邮件，同时还要负责维护用户的邮箱。</li><li>协议包括邮件发送协议（例如SMTP)和邮件读取协议（例如POP3)。</li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-6-%E7%94%B5%E5%AD%90%E5%8D%8F%E8%AE%AE/image-20241118190659564.png"></p><h2 id="2-简单邮件传送协议SMTP"><a href="#2-简单邮件传送协议SMTP" class="headerlink" title="2. 简单邮件传送协议SMTP"></a>2. 简单邮件传送协议SMTP</h2><ol><li><p>基本工作原理</p><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-6-%E7%94%B5%E5%AD%90%E5%8D%8F%E8%AE%AE/image-20241118191131692.png"></p></li><li><p>SMTP协议只能传送ASCII码文本数据，不能传送可执行文件或其他的二进制对象。</p></li><li><p>SMTP不能满足传送多媒体邮件（例如带有图片、音频或视频数据）的需要。并且许多其他非英语国家的文字(例如中文、俄文、甚至带有重音符号的法文或德文)也无法用SMTP传送。</p></li><li><p>为解决SMTP传送非ASCII码文本的问题，提出了多用途因特网邮件扩展MIME</p><ol><li>增加了5个新的邮件首部字段，这些字段提供了有关邮件主体的信息。</li><li>定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。</li><li>定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变。</li></ol></li><li><p>实际上，MIME不仅仅用于SMTP,也用于后来的同样面向ASCII字符的HTTP。</p></li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-6-%E7%94%B5%E5%AD%90%E5%8D%8F%E8%AE%AE/image-20241118191715497.png"></p><h2 id="3-电子邮件的格式"><a href="#3-电子邮件的格式" class="headerlink" title="3. 电子邮件的格式"></a>3. 电子邮件的格式</h2><ul><li>一个电子邮件有信封和内容两部分。而内容又由首部和主体两部分构成。</li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-6-%E7%94%B5%E5%AD%90%E5%8D%8F%E8%AE%AE/image-20241118191547061.png"></p><ol><li>高亮部分为比较重要的部分，为必填项。</li></ol><h2 id="4-邮件读取协议"><a href="#4-邮件读取协议" class="headerlink" title="4. 邮件读取协议"></a>4. 邮件读取协议</h2><ol><li><p>邮局协议POP3</p><blockquote><p>非常简单、功能有限的邮件读取协议。用户只能以下载并删除方式或下载并保留方式从邮件服务器下载邮件到用户方计算机。不允许用户在邮件服务器上管理自己的邮件。</p></blockquote></li><li><p>因特网邮件访问协议IMAP</p><blockquote><p>功能比POP3强大的邮件读取协议。用户在自己的计算机上就可以操控邮件服务器中的邮箱，就像在本地操控一样，因此IMAP是一个联机协议。</p></blockquote></li><li><p>POP3和IMAP4都采用基于TCP连接的客户&#x2F;服务器方式。</p><ol><li>POP3使用端口110 </li><li>IMAP4使用端口143</li></ol></li></ol><h2 id="5-基于万维网的电子邮件"><a href="#5-基于万维网的电子邮件" class="headerlink" title="5. 基于万维网的电子邮件"></a>5. 基于万维网的电子邮件</h2><ul><li>通过浏览器登录（提供用户名和口令）邮件服务器万维网网站就可以撰写、收发、阅读和管理电子邮件。这种工作模式与IMAP很类似，不同的是用户计算机无需安装专门的用户代理程序，只需要使用通用的万维网浏览器。</li><li>这种工作摸式在用户浏览器与邮件服务器网站之间使用HTTP协议，而邮件服务器之间使用SMTP协议。</li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-6-%E7%94%B5%E5%AD%90%E5%8D%8F%E8%AE%AE/image-20241118192409368.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.5 文件传送协议FTP</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-5-%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AEFTP/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-5-%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AEFTP/</url>
    
    <content type="html"><![CDATA[<h2 id="6-5-文件传送协议FTP"><a href="#6-5-文件传送协议FTP" class="headerlink" title="6.5 文件传送协议FTP"></a>6.5 文件传送协议FTP</h2><ol><li>FTP提供交互式的访问，允许客户指明文件的类型与格式（如指明是否使用ASCII码），并允许文件具有存取权限（如访问文件的用户必须经过授权，并输入有效的口令）</li><li>FTP屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件</li></ol><h2 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1. 基本原理"></a>1. 基本原理</h2><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-5-%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AEFTP/image-20230719151544230.png"></p><ol><li>FTP客户和服务器之间要建立以下两个并行的TCP连接<ol><li>控制连接，在<strong>整个会话期间一直保持打开</strong>，用于传送FTP相关<strong>控制命令</strong></li><li>数据连接，用于文件传输，在<strong>每次文件传输时才建立</strong>，<strong>传输结束就关闭</strong></li></ol></li><li>默认情况下，FTP使用TCP 21端口进行控制连接，TCP 20端口进行数据连接。<br>但是，是否使用TCP20端口建立数据连接与传输模式有关，主动方式使用TCP 20端口<br>被动方式由服务器和客户端自行协商决定。</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.4 域名系统DNS</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-4-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-4-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS/</url>
    
    <content type="html"><![CDATA[<h1 id="6-4-域名系统DNS"><a href="#6-4-域名系统DNS" class="headerlink" title="6.4 域名系统DNS"></a>6.4 域名系统DNS</h1><h2 id="1-DNS介绍"><a href="#1-DNS介绍" class="headerlink" title="1. DNS介绍"></a>1. DNS介绍</h2><ol><li>域名系统DNS是因特网使用的命名系统，用来把便于人们记忆的具有特定含义的主机名（例如<a href="http://www.hust.cn),转换为便于机器处理的ip地址./">www.hust.cn),转换为便于机器处理的IP地址。</a></li><li>因特网是否可以只使用1台DNS服务器？<ol><li>这种做法并不可取。因为因特网的规摸很大，这样的域名服务器肯定会因为超负荷而无法正常工作，而且一旦域名服务器出现故障，整个因特网就会瘫痪。</li><li>早在1983年，因特网就开始采用层次结构的命名树作为主机的名字(即域名)，并使用分布式的域名系统DNS</li><li>DNS使大多数域名都在本地解析，仅少量解折需要在因特网上通信，因此系统效率很高。</li><li>由于DNS是分布式系统，即使单个计算机出了故障，也不会妨碍整个系统的正常运行</li></ol></li><li>域名和IP地址的映射关系必须保存在域名服务器中，供所有其他应用查询。显然不能将所有信息都储存在一台域名服务器中。DNS使用分布在各地的域名服务器来实现域名到IP地址的转换。</li><li>DNS报文使用运输层的UDP协议进行封装，运输层端口号为53</li></ol><h2 id="2-层次树状域名结构"><a href="#2-层次树状域名结构" class="headerlink" title="2. 层次树状域名结构"></a>2. 层次树状域名结构</h2><ol><li>因特网采用层次树状结构的域名结构…三级域名.二级域名.顶级域名<ol><li>每一级的域名都由英文字母和数字组成，不超过63个字符，不区分大小写字母。</li><li>级别最低的域名写在最左边，而级别最高的顶级域名写在最右边。</li><li>完整的域名不超过255个字符。</li></ol></li><li>域名系统既不规定一个域名需要包含多少个下级域名，也不规定每一级的域名代表什么意思。</li><li>各级域名由其上一级的域名管理机构管理，而最高的顶级域名则由因特网名称与数字地址分配机构CANN进行管理。</li></ol><h3 id="2-1-域名层次划分"><a href="#2-1-域名层次划分" class="headerlink" title="2.1 域名层次划分"></a>2.1 域名层次划分</h3><ol><li>顶级域名TLD（Top Level Domain）<ol><li>国家顶级域名nTLD<ol><li>采用IS03166的规定。如cn表示中国，us表示美国，uk表示英国、等等。</li></ol></li><li>通用顶级域名<ol><li>最常见的通用顶级域名有七个，即：com(公司企业)、net(网络服务机构)、org(非营利性组织)、int(国际组织)、edu(美国教育结构)、gov(美国政府部门)、mil(美国军事部门)。</li></ol></li><li>反向域（arpa）<ol><li>用于反向域名解析，即IP地址反向解析为域名。</li></ol></li></ol></li><li>在国家顶级域名下注册的二级域名均由该国家自行确定。例如，顶级域名为j的日本，将其教育和企业机构的二级域名定为ac和co,而不用edu和com。</li><li>我国则将二级域名划分为以下两类：<ol><li>类别域名<ol><li>共七个：ac(科研机构)、com(工、商、金融等企业)、edu(教育机构)、gov(政府部门)、net(提供网络服务的机构)、mil(军事机构)和org(非营利性组织)。</li></ol></li><li>行政区域名<ol><li>共34个，适用于我国的各省、自治区、直辖市。例如：b为北京市、sh为上海市、js为江苏省，等等。</li></ol></li></ol></li><li>顶级域名由ICANN管理，顶级域名以下的二级域名，三级域名等，都由其上一级域名管理机构自行管理。</li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-4-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS/image-20241118165949003.png"></p><h3 id="2-2-域名服务器类型"><a href="#2-2-域名服务器类型" class="headerlink" title="2.2 域名服务器类型"></a>2.2 域名服务器类型</h3><ul><li>域名和IP地址的映射关系必须保存在域名服务器中，供所有其他应用查询。显然不能将所有信息都储存在一台域名服务器中。DNS使用分布在各地的域名服务器来实现域名到IP地址的转换。</li></ul><ol><li>根域名服务器<ol><li>根域名服务器是最高层次的域名服务器。<br>每个根域名服务器都知道所有的顶级域名服务器的域名及其IP地址。<br>因特网上共有13个不同IP地址的根域名服务器。</li><li>尽管我们将这13个根域名服务器中的每一个都视为单个的服务器，但“每台服务器”实际上是由许多分布在世界各地的计算机构成的服务器群集。当本地域名服务器向根域名服务器发出查询请求时，路由器就把查询请求报文转发到离这个DNS客户最近的一个根域名服务器。<br>这就加快了DNS的查询过程，同时也更合理地利用了因特网的资源。</li><li>根域名服务器通常并不直接对域名进行解析，而是返回该域名所属顶级域名的顶级域名服务器的IP地址。</li></ol></li><li>顶级域名服务器<ol><li>这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名。<br>当收到DNS查询请求时就给出相应的回答（可能是最后的结果，也可能是下一级权限域名服务器的P地址)。</li></ol></li><li>权限域名服务器<ol><li>这些域名服务器负责管理某个区的域名。<br>每一个主机的域名都必须在某个权限域名服务器处注册登记。<br>因此权限域名服务器知道其管辖的域名与IP地址的映射关系。</li><li>另外，权限域名服务器还知道其下级域名服务器的地址</li></ol></li><li>本地域名服务器<ol><li>本地域名服务器不属于上述的域名服务器的等级结构。<br>当一个主机发出DNS请求报文时，这个报文就首先被送往该主机的本地域名服务器。</li><li>本地域名服务器起着代理的作用，会将该报文转发到上述的域名服务器的等级结构中。</li><li>每一个因特网服务提供者ISP，一个大学一个大学里的学院，都可以拥有一个本地域名服务器，它有时也称为默认域名服务器。本地域名服务器离用户较近，一般不超过几个路由器<br>的距离，也有可能就在同一个局域网中。</li><li>本地域名服务器的IP地址需要直接配置在需要域名解析的主机中，</li></ol></li></ol><h2 id="3-DNS域名解析两种方式"><a href="#3-DNS域名解析两种方式" class="headerlink" title="3. DNS域名解析两种方式"></a>3. DNS域名解析两种方式</h2><ul><li>递归解析和迭代解析</li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-4-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS/image-20230718233234205.png"></p><ol><li>为了提高DNS的查询效率，并减轻根域名服务器的负荷和减少因特网上的DNS查询报文数量，在域名服务器和主机中广泛地使用了高速缓存。</li><li>DNS报文使用运输层的UDP协议进行封装，运输层端口号为53</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.3 动态主机配置协议DHCP</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-3-%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AEDHCP/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-3-%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AEDHCP/</url>
    
    <content type="html"><![CDATA[<h1 id="6-3-动态主机配置协议DHCP"><a href="#6-3-动态主机配置协议DHCP" class="headerlink" title="6.3 动态主机配置协议DHCP"></a>6.3 动态主机配置协议DHCP</h1><ul><li>动态主机配置协议DHCP(Dynamic Host Configuration Protocol))提供了一种机制，称为即插即用连网。</li><li>这种机制允许一台计算机加入新网络时可自动获取P地址等网络配置信息而不用手工参与。</li></ul><ol><li><p>DHCP报文在运输层使用UDP协议封装</p><ol><li>DHCP客户使用的UDP端口号为68</li><li>DHCP服务器使用的UDP端口号为67</li></ol></li><li><p>客户端向DHCP服务器申请IP的全过程</p></li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-3-%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AEDHCP/image-20241118164104548.png"></p><ul><li><p>使用ARP检测所分配到的IP地址是否已被网络中其他主机占用：</p><ul><li>若被占用：给DHCP服务器发送“DHCP DECLINE”报文敬销IP地址租约，并重新发送“DHCP DISCOVER”报文；</li><li>若未被占用：可以使用租约中的P地址与网络中其他主机通信了。</li></ul></li><li><p>使用ARP确保所选IP地址未被网络中其他主机占用</p></li></ul><table><thead><tr><th>报文</th><th>包含字段</th></tr></thead><tbody><tr><td>DHCP DISCOVER</td><td>事务ID，DHCP的MAC地址</td></tr><tr><td>DHCP OFFER</td><td>事务ID，配置信息：IP地址，子网掩码，地址租期，默认网关，DNS服务器</td></tr><tr><td>DHCP REQUEST</td><td>事务ID，DHCP的MAC地址，接受的租约中的IP地址，提供此租约的DHCP服务器的IP地址</td></tr></tbody></table><ol start="3"><li>DHCP中继代理</li></ol><blockquote><p>路由器不会转发普通的广播分组，并且我们也不希望在每个网络中都配置一台DHCP服务器，所以DHCP中继代理出现了。</p></blockquote><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-3-%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AEDHCP/image-20241118164332043.png"></p><ul><li>DHCP DISCOVER:DHCP发现报文</li><li>DHCP OFFER:DHCP提供报文</li><li>DHCP REQUEST:DHCP请求报文</li><li>DHCP ACK:DHCP确认报文</li><li>DHCP NACK:DHCP否认报文</li><li>DHCP RELEASE:DHCP释放报文</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.2 客户服务器方式和对等方式</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-2-%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%B9%E5%BC%8F%E5%92%8C%E5%AF%B9%E7%AD%89%E6%96%B9%E5%BC%8F/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-2-%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%B9%E5%BC%8F%E5%92%8C%E5%AF%B9%E7%AD%89%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="6-2-客户-服务器方式（C-S）和对等方式（P2P方式）"><a href="#6-2-客户-服务器方式（C-S）和对等方式（P2P方式）" class="headerlink" title="6.2 客户&#x2F;服务器方式（C&#x2F;S）和对等方式（P2P方式）"></a>6.2 客户&#x2F;服务器方式（C&#x2F;S）和对等方式（P2P方式）</h1><ul><li>网络应用程序运行在处于网络边缘的不同的端系统上，通过彼此间的通信来共同完成某项任务。</li><li>开发一种新的网络应用首先要考虑的问题就是网络应用程序在各种端系统上的组织方式和它们之间的关系。目前流行的主要有以下两种：<ul><li>客户&#x2F;服务器(Client&#x2F;Server,C&#x2F;S)方式</li><li>对等(Peer-to-Peer,P2P)方式</li></ul></li></ul><h2 id="1-客户-服务器-Client-Server-C-S-方式"><a href="#1-客户-服务器-Client-Server-C-S-方式" class="headerlink" title="1. 客户&#x2F;服务器(Client&#x2F;Server,C&#x2F;S)方式"></a>1. 客户&#x2F;服务器(Client&#x2F;Server,C&#x2F;S)方式</h2><ul><li><p>C&#x2F;S方式</p><ul><li>客户和服务器是指通信中所涉及的两个应用进程。</li><li>客户&#x2F;服务器方式所描述的是进程之间服务和被服务的关系。</li><li>客户是服务请求方，服务器是服务提供方。</li><li>服务器总是处于运行状态，并等待客户的服务请求。服务器具有固定端口号（例如HTTP服务器的默认端口号为80)，而运行服务器的主机也具有固定的P地址。</li></ul></li><li><p>C&#x2F;S方式是因特网上传统的、同时也是最成熟的方式，很多我们熟悉的网络应用采用的都是C&#x2F;S方式。包括万维网WWW、电子邮件、文件传输FTP等。</p></li><li><p>基于C&#x2F;S方式的应用服务通常是服务集中型的，即应用服务集中在网络中比客户计算机少得多的服务<br>器计算机上。</p><ul><li>由于一台服务器计算机要为多个客户机提供服务，在C&#x2F;S应用中，常会出现服务器计算机跟不上众多客户机请求的情况。</li><li>为此，在C&#x2F;S应用中，常用计算机群集（或服务器场）构建一个强大的虚拟服务器。</li></ul></li></ul><h2 id="2-对等方式（P2P方式）"><a href="#2-对等方式（P2P方式）" class="headerlink" title="2. 对等方式（P2P方式）"></a>2. 对等方式（P2P方式）</h2><ul><li><p>P2P方式</p><ul><li>在P2P方式中，没有固定的服务请求者和服务提供者，分布在网络边缘各端系统中的应用进程是对等的，被称为对等方。</li><li>对等方相互之间直接通信，每个对等方既是服务的请求者，又是服务的提供者。</li></ul></li><li><p>目前，在因特网上流行的P2P应用主要包括P2P文件共享、即时通信、P2P流媒体、分布式存储等。</p></li><li><p>基于P2P的应用是服务分散型的，因为服务不是集中在少数几个服务器计算机中，而是分散在大量对等计算机中，这些计算机并不为服务提供商所有，而是为个人控制的桌面计算机和笔记本电脑，它们通常位于住宅、校园和办公室中。</p></li><li><p>P2P方式的最突出特性之一就是它的可扩展性。因为系统每增加一个对等方，不仅增加的是服务的请求者，同时也增加了服务的提供者，系统性能不会因规摸的增大而降低。</p></li><li><p>P2P方式具有成本上的优势，因为它通常不需要庞大的服务器设施和服务器带宽。为了降低成本，服务提供商对于将P2P方式用于应用的兴趣越来越大。</p></li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-2-%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%B9%E5%BC%8F%E5%92%8C%E5%AF%B9%E7%AD%89%E6%96%B9%E5%BC%8F/image-20241118162748601.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.1 应用层概述</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-1-%E5%BA%94%E7%94%A8%E5%B1%82%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-1-%E5%BA%94%E7%94%A8%E5%B1%82%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="6-1-应用层"><a href="#6-1-应用层" class="headerlink" title="6.1 应用层"></a>6.1 应用层</h1><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-1-%E5%BA%94%E7%94%A8%E5%B1%82%E6%A6%82%E8%BF%B0/image-20241118161627816.png"></p><ul><li>应用层是计算机网络体系结构的最顶层，是设计和建立计算机网络的最终目的，也是计算机网络中发展最快的部分。<ul><li>早期基于文本的应用（电子邮件、远程登绿、文件传输、新闻组）<ul><li>20世纪90年代将因特网带入干家万户的万维网WWW</li></ul></li><li>当今流行的即时通信、P2P文件共享及各种音视频应用计算设备的小型化和“无处不在”，宽带住宅接入和无线接入的日益普及和迅速发展，为未来更多的新型应用提供了广阔的舞台。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.9 TCP报文段的首部格式</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-9-TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-9-TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="5-9-TCP报文段的首部格式"><a href="#5-9-TCP报文段的首部格式" class="headerlink" title="5.9 TCP报文段的首部格式"></a>5.9 TCP报文段的首部格式</h1><ul><li>为了实现可靠传输，TCP采用了面向字节流的方式。</li><li>但TCP在发送数据时，是从发送缓存取出一部分或全部字节并给其添加一个首部使之成为TCP报文段后进行发送。<ul><li>一个TCP报文段由首部和数据载荷两部分构成；</li><li>TCP的全部功能都体现在它首部中各字段的作用。</li></ul></li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-9-TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F/image-20241118153709722.png"></p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>源端口</td><td>占16比特，写入源端口号，用来标识发送该TCP报文段的应用进程</td></tr><tr><td>目的端口</td><td>占16比特，写入目的端口号，用来标识接收该TCP报文段的应用进程</td></tr><tr><td>序号</td><td>占32比特，取值范围[0,2^32^-1]，序号增加到最后一个后，下一个序号就又回到0。<br>指出本TCP报文段数据载荷的第一个字节的序号。</td></tr><tr><td>确认号</td><td>占32比特，取值范围[0,2^32^-1]，确认号增加到最后一个后，下一个确认号就又回到0。<br>指出期望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，同时也是对之前收到的所有数据的确认。</td></tr><tr><td>确认标志位ACK</td><td>取值为1时确认号字段才有效：取值为0时确认号字段无效</td></tr><tr><td>数据偏移</td><td>占4比特，并以4字节为单位。<br>用来指出TCP报文段的数据载荷部分的起始处距离TCP报文段的起始处有多远。</td></tr><tr><td>保留</td><td>占6比特，保留为今后使用，但目前应置为0。</td></tr><tr><td>窗口</td><td>占16比特，以字节为单位。指出发送本报文段的一方的接收窗口。<br>窗口值作为接收方让发送方设置其发送窗口的依据。<br>这是以接收方的接收能力来控制发送方的发送能力，称为流量控制。</td></tr><tr><td>校验和</td><td>占16比特，检查范围包括TCP报文段的首部和数据载荷两部分。<br>在计算校验和时，要在TCP报文段的前面加上12字节的伪首部。</td></tr><tr><td>同步标志位SYN</td><td>在TCP连接建立时用来同步序号</td></tr><tr><td>终止标志位FIN</td><td>用来释放TCP连接。</td></tr><tr><td>复位标志位RST</td><td>用来复位TCP连接。<br>当RST&#x3D;1时，表明TCP连接出现了异常，必须释放连接，然后再重新建立连接。<br>RST置1还用来拒绝一个非法的报文段或拒绝打开一个TCP连接。</td></tr><tr><td>推送标志位PSH</td><td>接收方的TCP收到该标志位为1的报文段会尽快上交应用进程。<br>而不必等到接收缓存都填满后再向上交付。</td></tr><tr><td>紧急标志位URG</td><td>取值为1时紧急指针字段有效：取值为0时紧急指针字段无效。</td></tr><tr><td>紧急指针</td><td>占16比特，以字节为单位，用来指明紧急数据的长度。</td></tr><tr><td>选项</td><td>1. 最大报文段长度MSS选项：TCP报文段数据载荷部分的最大长度。<br>2. 窗口扩大选项：为了扩大窗口（提高吞吐率）<br>3. 时间戳选项：<br>     a. 用来计算往返时间RTT<br>     b. 用于处理序号超范围的情况，又称为防止序号绕回PAWS。<br>4. 选择确认选项<br>选项的作用是为了扩展TCP报文段首部的功能</td></tr><tr><td>填充</td><td>由于选项的长度可变，因此使用填充来确保报文段首部能被4整除<br>(因为数据偏移字段，也就是首部长度字段，是以4字节为单位的)</td></tr></tbody></table><ul><li>紧急数据：<ul><li>当发送方有紧急数据时，可将紧急数据插队到发送缓存的最前面，并立刻封装到一个TCP报文段中进行发送。</li><li>紧急指针会指出本报文段数据载荷部分包含了多长的紧急数据，紧急数据之后是普通数据。</li><li>接收方将紧急数据部分取出，并直接上交应用程序，而不必在接受缓存中排队。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.8 TCP的运输连接管理</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-8-TCP%E7%9A%84%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-8-TCP%E7%9A%84%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="5-8-TCP的运输连接管理"><a href="#5-8-TCP的运输连接管理" class="headerlink" title="5.8 TCP的运输连接管理"></a>5.8 TCP的运输连接管理</h1><ul><li>TCP是面向连接的协议，它基于运输连接来传送TCP报文段。</li><li>TCP运输连接的建立和释放是每一次面向连接的通信中必不可少的过程。</li><li>TCP运输连接有以下三个阶段：<ul><li>建立TCP连接</li><li>数据传送</li><li>释放TCP连接</li></ul></li><li>TCP的运输连接管理就是使运输连接的建立和释放都能正常地进行。</li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-8-TCP%E7%9A%84%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/image-20241118150137225.png"></p><h2 id="1-TCP的连接建立（三次握手）"><a href="#1-TCP的连接建立（三次握手）" class="headerlink" title="1. TCP的连接建立（三次握手）"></a>1. TCP的连接建立（三次握手）</h2><blockquote><p>TCP的连接建立要解决以下三个问题：</p><ol><li>使TCP双方能够确知对方的存在</li><li>使TCP双方能够协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）</li><li>使TCP双方能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。</li></ol></blockquote><ol><li><p>三次握手建立连接的过程</p><blockquote><p>也就是使用三个TCP报文建立连接</p><ul><li>传输控制块<ul><li>TCP连接表</li><li>指向发送和接收缓存的指针</li><li>指向重传队列的指针</li><li>当前的发送和接收序号</li></ul></li></ul></blockquote><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-8-TCP%E7%9A%84%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/image-20230718175005023.png" alt="image-20230718175005023"></p></li><li><p>两报文建立连接会发生以下问题<br><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-8-TCP%E7%9A%84%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/image-20230718175045894.png" alt="image-20230718175045894"></p></li><li><p>注意<br>(1)TCP的标准规定，SYN&#x3D;1的报文段不能携带数据，但要消耗掉一个序号。<br>(2)TCP的标准规定，普通的确认报文段如果不携带数据，则不消耗序号。</p></li></ol><h2 id="2-TCP的连接释放（四次挥手）"><a href="#2-TCP的连接释放（四次挥手）" class="headerlink" title="2. TCP的连接释放（四次挥手）"></a>2. TCP的连接释放（四次挥手）</h2><ol><li><p>四报文挥手过程<br><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-8-TCP%E7%9A%84%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/image-20230718182458129.png" alt="image-20230718182458129"></p></li><li><p>若不等待2MSL则有可能发生以下情况</p><blockquote><p>最后一个确认报文丢失，导致服务器进程陷入最后确定状态，无法进入关闭状态</p></blockquote><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-8-TCP%E7%9A%84%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/image-20230718182524772.png" alt="image-20230718182524772"></p></li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-8-TCP%E7%9A%84%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/image-20241118153322909.png"></p><ul><li>TCP服务器进程每收到一次TCP客户进程的数据，就重新设置并启动保活计时器(2小时定时)</li><li>若保活计时器定时周期内未收到TCP客户进程发来的数据，则当保活计时器到时后，TCP服务器进程就向TP客户进程发送一个探测报文段，以后则每隔75秒钟发送一次。若一连发送10个探测报文段后仍无TCP客户进程的响应，TCP服务器进程就认为TCP客户进程所在主机出了故障，接着就关闭这个连接。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.7 TCP可靠传输的实现</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-7-TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-7-TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="5-7-TCP可靠传输的实现"><a href="#5-7-TCP可靠传输的实现" class="headerlink" title="5.7 TCP可靠传输的实现"></a>5.7 TCP可靠传输的实现</h1><ol><li><p>TCP基于以<strong>字节为单位的滑动窗口</strong>来实现可靠传输。</p><ol><li><p>发送方在未收到接收方的确认时，可将发送窗口内还未发送的数据全部发送出去</p></li><li><p>接收方只接收序号落入发送窗口内的数据</p><blockquote><p>虽然发送方的发送窗口是根据接收方的接收窗口设置的，<br>但在同一时刻，发送方的发送窗口并不总是和接收方的接收窗口一样大。</p></blockquote></li><li><p>网络传送窗口值需要经历一定的时间滞后，井且这个时间还是不确定的。</p></li><li><p>发送方还可能根据网络当时的拥塞情况适当减小自己的发送窗口尺寸</p></li></ol></li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-7-TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20241118144647353.png"></p><ol start="2"><li><p>对于不按序到达的数据应如何处理，TCP并无明确规定</p><ol><li>如果接收方把不按序到达的数据一律丢弃，那么接收窗口的管理将会比较简单，<br>但这样做对网络资源的利用不利，因为发送方会重复传送较多的数据。</li><li>TCP通常对不按序到达的数据是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程</li><li>TCP要求接收方必须有累积确认和捎带确认机制，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。<ol><li>接收方不应过分推迟发送确认，否则会导致发送方不必要的超时重传，这反而浪费了网络的资源。</li><li>TCP标准规定，确认推迟的时间不应超过0.5秒。若收到一连串具有最大长度的报文段，则必须每隔一个报文段就发送一个确认</li><li>梢带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。</li></ol></li></ol></li><li><p>TCP的通信是全双工通信。</p><blockquote><p>通信中的每一方都在发送和接收报文段。<br>因此，每一方都有自己的发送窗口和接收窗口。在谈到这些窗口时，一定要弄清楚是哪一方的窗口。</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.6 TCP超时重传时间的选择</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-6-TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4%E7%9A%84%E9%87%8D%E4%BC%A0/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-6-TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4%E7%9A%84%E9%87%8D%E4%BC%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="5-6-TCP超时重传的时间的选择（RTO）"><a href="#5-6-TCP超时重传的时间的选择（RTO）" class="headerlink" title="5.6 TCP超时重传的时间的选择（RTO）"></a>5.6 TCP超时重传的时间的选择（RTO）</h1><ul><li>利用每次测量得到的RTT样本，计算加权平均往返时间RTTs(又称为平滑的往返时间)。</li><li>超时重传的时间应略大于RTTs的值。</li></ul><ol><li><p>计算RTT<del>S</del><br>$$<br>初始RTT_S &#x3D; 测得的第一个RTT<br>$$<br>$$<br> RTTs &#x3D; (1-\alpha)\times 旧的RTTs + \alpha \times 新的RTT样本<br>$$<br>建议 $\alpha$ &#x3D; 0.125</p></li><li><p>计算RTT<del>D</del><br>$$<br>初始RTT_D &#x3D; \frac{RTT_1}{2}\<br>RTT_D &#x3D; (1 - \beta) \times 旧的RTT_D + \beta \times \vert RTT_S - 新的RTT样本 \vert<br>$$<br>建议$\beta$ &#x3D; 0.25</p></li><li><p>针对出现超时重传时无法测准往返时间RTT的问题，Kan提出了一个算法：在计算<br>加权平均往返时间RTTs时，只要报文段重传了，就不采用其往返时间RTT样本。也<br>就是出现重传时，不重新计算RTTs,进而超时重传时间RTO也不会重新计算。</p></li><li><p>这又引起了新的问题。设想出现这样的情况：报文段的时延突然增大了很多，并目<br>之后很长一段时间都会保持这种时延。因此在原来得出的重传时间内，不会收到确<br>认报文段。于是就重传报文段。但根据Kar算法，不考虑重传的报文段的往返时间<br>样本。这样，超时重传时间就无法更新。这会导致报文段反复被重传。</p></li><li><p>因此，要对Kan算法进行修正。方法是：报文段每重传一次，就把超时重传时间<br>RTO增大一些。典型的做法是将新RTO的值取为旧RTO值的2倍。</p></li><li><p>计算超时重传时间<br>$$<br>RTO &#x3D; RTT_S + 4 \times RTT_D<br>$$<br>只要某报文段超时重传，就将RTO设为原来的两倍，而不是按照上述公式计算</p></li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-6-TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4%E7%9A%84%E9%87%8D%E4%BC%A0/image-20241118125512601.png"></p><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-6-TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4%E7%9A%84%E9%87%8D%E4%BC%A0/image-20241118125933926.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.5 TCP的拥塞控制</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-5-TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-5-TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="5-5-TCP拥塞控制"><a href="#5-5-TCP拥塞控制" class="headerlink" title="5.5 TCP拥塞控制"></a>5.5 TCP拥塞控制</h1><ol><li>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏。这种情况就叫做拥塞(congestion)。</li><li>在计算机网络中的链路容量（即带宽）、交换结点中的缓存和处理机等，都是网络的资源。</li><li>若出现拥塞而不进行控制，整个网络的吞吐量将随输入负荷的增大而下降。</li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-5-TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/image-20241118122339061.png"></p><h2 id="1-拥塞避免算法"><a href="#1-拥塞避免算法" class="headerlink" title="1. 拥塞避免算法"></a>1. 拥塞避免算法</h2><ul><li>下面介绍这四种拥塞控制算法的基本原理，假定如下条件：<ul><li>数据是单方向传送，而另一个方向只传送确认。</li><li>接收方总是有足够大的缓存空间，因而发送方发送窗口的大小由网络的拥塞程度来决定。</li><li>以最大报文段MSS的个数为讨论问题的单位，而不是以字节为单位。</li></ul></li></ul><h3 id="1-1-慢开始与拥塞避免算法"><a href="#1-1-慢开始与拥塞避免算法" class="headerlink" title="1.1 慢开始与拥塞避免算法"></a>1.1 慢开始与拥塞避免算法</h3><ol><li><p>发送方维护一个叫做拥塞窗口cwd的状态变量，其值取决于网络的拥塞程度，并且动态变化。</p><ol><li><p>拥塞窗口cwd的维护原则</p><ol><li>只要网络没有出现拥塞，拥塞窗口就再增大一些；</li><li>但只要网络出现拥塞，拥塞窗口就减少一些。</li><li>具体做法<ol><li>发生超时重传后，将门限ssthresh设为拥塞窗口的一半，并将当前拥塞窗口设为1</li><li>重新运行开始慢开始算法</li></ol></li></ol></li><li><p>判断出现网络拥塞的依据</p><blockquote><p>没有按时收到应当到达的确认报文（即发生超时重传）。</p></blockquote></li></ol></li><li><p>发送方将拥塞窗口作为发送窗口swnd,即 swnd&#x3D;cwnd。</p></li><li><p>维护一个慢开始门限ssthresh状态变量</p><ol><li>当cwnd&lt;ssthresh时，使用慢开始算法</li><li>当cwnd&gt;ssthresh时，停止使用慢开始算法而改用拥塞避免算法：</li><li>当cwnd&#x3D;ssthresh时，既可使用慢开始算法，也可使用拥塞避免算法。</li></ol></li><li><p>慢开始指数增长，从1开始，每次×2</p></li><li><p>拥塞避免，拥塞窗口每次加1</p></li><li><p>出现拥塞，ssthresh值更新为cwnd的一半</p></li><li><p>cwnd值置为1，再重新开始慢开始算法</p></li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-5-TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/image-20241118123625970.png"></p><ul><li><p>“慢开始”是指一开始向网络注入的报文段少，并不是指拥塞窗口cwd增长速度慢；</p></li><li><p>“拥塞避免”并非指完全能够避免拥塞，而是指在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞</p></li><li><p>慢开始和拥塞避免算法是1988年提出的TCP拥塞控制算法(TCP Tahoe版本)</p></li><li><p>1990年又增加了两个新的拥塞控制算法（改进TCP的性能），这就是快重传和快恢复(TCP Reno.版本)。</p><ul><li>有时，个别报文段会在网络中丢失，但实际上网络并未发生拥塞。<ul><li>这将导致发送方超时重传，并误认为网络发生了拥塞；</li><li>发送方把拥塞窗口cwd又设置为最小值1，并错误地启动慢开始算法，因而降低了传输效率</li></ul></li></ul></li><li><p>采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。</p></li><li><p>所谓快重传，就是使发送方尽快进行重传，而不是等超时重传计时器超时再重传。</p></li></ul><h3 id="1-2-快重传与快恢复"><a href="#1-2-快重传与快恢复" class="headerlink" title="1.2 快重传与快恢复"></a>1.2 快重传与快恢复</h3><ol><li>要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认</li><li>即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。</li><li>发送方一旦<strong>收到3个连续的重复确认</strong>，就将相应的报文段立即重传，<br>而不是等该报文段的超时重传计时器超时再重传。</li><li>对于个别丢失的报文段，发送方不会出现超时重传，也就不会误认为出现了拥塞（进而降低拥塞窗口cwd为1）。使用快重传可以使整个网络的吞吐量提高约20%。</li><li>发送方一旦收到3个重复确认，就知道现在只是丢失了个别的报文段。<br>于是不启动慢开始算法，而执行<strong>快恢复算法</strong><ol><li>发送方将慢开始<strong>门限ssthresh值</strong>和<strong>拥塞窗口cwnd值</strong>调整为<strong>当前窗口的一半</strong></li><li>开始执行拥塞避免算法。</li><li>也有的快恢复实现是把快恢复开始时的拥塞窗口cwnd值再增大一些，即等于新的ssthresh+3。<ol><li>既然发送方收到3个重复的确认，就表明有3个数据报文段已经离开了网络，这3个报文段不再消耗网络资源而是停留在接收方的接收缓存中，可见现在网络中不是堆积了报文段而是减少了3个报文段。因此可以适当把拥塞窗口扩大些。</li></ol></li></ol></li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-5-TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/image-20241118124545558.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.4 TCP的流量控制</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-4-TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-4-TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><ul><li><p>所谓流量控制 ( flow control )就是让发送方的发送速率不要太快，要让接收方来得及接收。</p></li><li><p>TCP接收方利用自己的接收窗口的大小来限制发送方发送窗口的大小。</p></li></ul><p>$$<br>发送窗口 &#x3D; Min(发送方拥塞窗口，接受方接收窗口)<br>$$</p><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-4-TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/image-20241118120929780.png" alt="image-20241118120929780"></p><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-4-TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/image-20241118121512615.png"></p><p>注意</p><ol><li>TCP发送方收到接收方的零窗口通知后，应启动持续计时器。持续计时器超时后，向接收方发送零窗口探测报文。</li></ol><blockquote><p>若是零窗口探测报文传输过程中丢失，则在其重发计数器超时后重发该报文</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.3 UDP和TCP的对比</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-3-UDP%E5%92%8CTCP%E7%9A%84%E5%AF%B9%E6%AF%94/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-3-UDP%E5%92%8CTCP%E7%9A%84%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<h1 id="5-3-UDP和TCP的对比"><a href="#5-3-UDP和TCP的对比" class="headerlink" title="5.3 UDP和TCP的对比"></a>5.3 UDP和TCP的对比</h1><ul><li>用户数据报协议UDP:(User Datagram Protocol)<ul><li>无连接</li></ul></li><li>传输控制协议TCP：Transmission Control Protocol<ul><li>面向连接</li></ul></li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-3-UDP%E5%92%8CTCP%E7%9A%84%E5%AF%B9%E6%AF%94/image-20241118111939771.png"></p><ul><li>UDP支持单播、多播以及广播</li><li>TCP仅支持单播</li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-3-UDP%E5%92%8CTCP%E7%9A%84%E5%AF%B9%E6%AF%94/image-20241118112226603.png"></p><ul><li>UDP是面向应用报文的</li><li>TCP是面向字节流的</li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-3-UDP%E5%92%8CTCP%E7%9A%84%E5%AF%B9%E6%AF%94/image-20241118112458492.png"></p><ul><li>UDP向上层提供无连接不可靠传输服务(适用于IP电话、视频会议等实时应用)</li><li>TCP向上层提供面向连接的可靠传输服务(适用于要求可靠传输的应用，例如文件传输)</li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-3-UDP%E5%92%8CTCP%E7%9A%84%E5%AF%B9%E6%AF%94/image-20241118112750466.png"></p><ul><li>UDP用户数据报首部仅8字节</li><li>TCP报文段首部最小20字节，最大60字节</li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-3-UDP%E5%92%8CTCP%E7%9A%84%E5%AF%B9%E6%AF%94/image-20241118112843761.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.2 运输层端口号、复用与分用的概念</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-2-%E8%BF%90%E8%BE%93%E5%B1%82%E7%AB%AF%E5%8F%A3%E5%8F%B7-%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%88%86%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-2-%E8%BF%90%E8%BE%93%E5%B1%82%E7%AB%AF%E5%8F%A3%E5%8F%B7-%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%88%86%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="5-2-运输层端口号，复用，分用"><a href="#5-2-运输层端口号，复用，分用" class="headerlink" title="5.2 运输层端口号，复用，分用"></a>5.2 运输层端口号，复用，分用</h1><h2 id="1-端口号"><a href="#1-端口号" class="headerlink" title="1. 端口号"></a>1. 端口号</h2><ol><li><p>因为因特网上的计算机并不是使用统一的操作系统，不同的操作系统又使用不同格式的进程标识符，为了使运行不同操作系统的计算机的应用进程之间能够进行网络通信，就必须使用统一的方法对TCP&#x2F;IP体系的应用进程进行标识。</p></li><li><p>TCP&#x2F;IP体系的运输层使用端口号来区分应用层的不同应用进程，端口号使用16比特表示，取值范围 [0,65535]。</p></li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-2-%E8%BF%90%E8%BE%93%E5%B1%82%E7%AB%AF%E5%8F%A3%E5%8F%B7-%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%88%86%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5/image-20241118110803598.png" alt="端口号的划分"></p><ol start="3"><li>端口号只具有本地意义，即端口号只是为了标识本计算机应用层中的各进程，在因特网中，不同计算机中的相同端口号是没有联系的。</li></ol><h2 id="2-发送方的复用和接收方的分用"><a href="#2-发送方的复用和接收方的分用" class="headerlink" title="2. 发送方的复用和接收方的分用"></a>2. 发送方的复用和接收方的分用</h2><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-2-%E8%BF%90%E8%BE%93%E5%B1%82%E7%AB%AF%E5%8F%A3%E5%8F%B7-%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%88%86%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5/image-20241118111045703.png"></p><ol><li>TCP&#x2F;IP体系的应用层常用协议所使用运输层的熟知端口号</li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-2-%E8%BF%90%E8%BE%93%E5%B1%82%E7%AB%AF%E5%8F%A3%E5%8F%B7-%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%88%86%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5/image-20241118111132310.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.1 运输层概述</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-1-%E8%BF%90%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-1-%E8%BF%90%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="5-1-运输层概述"><a href="#5-1-运输层概述" class="headerlink" title="5.1 运输层概述"></a>5.1 运输层概述</h1><ul><li><p>实际上在计算机网络中进行通信的真正实体是位于通信两端主机中的进程</p></li><li><p>如何为运行在不同主机上的应用进程提供直接的通信服务是运输层的任务，运输层协议又称为端到端协议。</p></li><li><p>运输层向高层用户屏蔽了下面网络核心的细节（如网络拓扑、所采用的路由选择协议等)，它使应用进程看见的就好像是在两个运输层实体之间有一条端到端的逻辑通信信道。</p></li><li><p>根据应用需求的不同，因特网的运输层为应用层提供了两种不同的运输协议，即面向连接的TCP和无连接的UDP,这两种协议就是本章要讨论的主要内容。</p></li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-1-%E8%BF%90%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0/image-20241118110058782.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.9 虚拟专用网VPN与网络地址转换NAT</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-9-%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91VPN%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2NAT/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-9-%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91VPN%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2NAT/</url>
    
    <content type="html"><![CDATA[<h1 id="4-9-虚拟专用网络VPN与网络地址转换NAT"><a href="#4-9-虚拟专用网络VPN与网络地址转换NAT" class="headerlink" title="4.9 虚拟专用网络VPN与网络地址转换NAT"></a>4.9 虚拟专用网络VPN与网络地址转换NAT</h1><h2 id="1-VPN"><a href="#1-VPN" class="headerlink" title="1. VPN"></a>1. VPN</h2><ul><li>利用公用的因特网作为本机构各专用网之间的通信载体，这样的专用网又称为虚拟专用网。</li><li>VPN要保证传输数据的安全性，会将原始的内部数据报进行加密，然后再将其封装成为在因特网上发送到的外部数据报。</li></ul><ol><li>VPN类型<ol><li>同一机构内不同部门的内部网络所构成的虚拟专用网VPN又称为内联网VPN</li><li>有时一个机构的VPN需要有某些外部机构（通常就是合作伙伴）参加进来。这样的VPN就称为外联网VPN</li><li>在外地工作的员工需要访问公司内部的专用网络时，只要在任何地点接入到因特网，运行驻留在员工PC中的VPN软件，在员工的PC和公司的主机之间建立VPN隧道，即可访问专用网络中的资源。这种VPN称为远程接入VPN。</li></ol></li></ol><h2 id="2-NAT"><a href="#2-NAT" class="headerlink" title="2. NAT"></a>2. NAT</h2><ul><li>NAT能使大量使用内部专用地址的专用网络用户共享少量外部全球地址来访问因特网上的主机和资源。</li><li>传统NAT是将每个本地IP转换为一个公有IP，意味着路由器中NAT映射表记录N个全球IP，则对应的子网最多只能有N台主机，这不符预期。</li></ul><ol><li>由于绝大多数的网络应用都是使用运输层协议TCP或UDP来传送数据，因此可以利用运输层的端口号和IP地址一起进行转换。<ol><li>这样用一个全球P地址就可以使多个拥有本地地址的主机同时和因特网上的主机进行通信。这种将端口号和P地址一起进行转换的技术叫作网络地址与端口号转换NAPT (Network Address and Port Translation)。</li></ol></li><li>收到来自外网的IP数据报后，在NAPT转换表中找不到相应的记录！</li><li>对于一些P2P网络应用，需要外网主机主动与内网主机进行通信，在通过NAT时会遇到问题，需要网络应用自己使用一些特殊的NAT穿越技术来解决问题。</li><li>由于NAT对外网屏蔽了内网主机的网络地址，能为内网的主机提供一定的安全保护。</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-9-%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91VPN%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2NAT/image-20241118104142578.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.8 网际控制报文协议</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-8-%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-8-%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="4-8-网际控制报文协议ICMP"><a href="#4-8-网际控制报文协议ICMP" class="headerlink" title="4.8 网际控制报文协议ICMP"></a>4.8 网际控制报文协议ICMP</h1><ul><li>为了更有效地转发P数据报和提高交付成功的机会，在网际层使用了网际控制报文协议<ul><li>主机或路由器使用ICMP来发送差错报告报文和询问报文</li><li>ICMP报文被封装在IP数据报中发送</li></ul></li></ul><h2 id="1-五种差错报告报文"><a href="#1-五种差错报告报文" class="headerlink" title="1. 五种差错报告报文"></a>1. 五种差错报告报文</h2><h3 id="1-1-终点不可达"><a href="#1-1-终点不可达" class="headerlink" title="1.1 终点不可达"></a>1.1 终点不可达</h3><ol><li>当路由器或主机不能交付数据报时，就向源点发送终点不可达报文。</li><li>具体可再根据ICMP的代码字段细分为目的网络不可达、目的主机不可达、目的协议不可达、目的端口不可达、目的网络未知、目的主机未知等13种错误。</li></ol><h3 id="1-2-源点抑制"><a href="#1-2-源点抑制" class="headerlink" title="1.2 源点抑制"></a>1.2 源点抑制</h3><ol><li>当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢。</li></ol><h3 id="1-3-时间超过"><a href="#1-3-时间超过" class="headerlink" title="1.3 时间超过"></a>1.3 时间超过</h3><ol><li>当路由器收到一个目的1P地址不是自己的P数据报，会将其生存时间TTL字段的值减1。</li><li>若结果不为0，则将该P数据报转发出去；若结果为0，除丢弃该P数据报外，还要向源点发送时间超过报文。</li></ol><h3 id="1-4-参数问题"><a href="#1-4-参数问题" class="headerlink" title="1.4 参数问题"></a>1.4 参数问题</h3><ol><li>当路由器或目的主机收到P数据报后，根据其首部中的检验和字段发现首部在传输过程中出现了误码，就丢弃该数据报，并向源点发送参数问题报文。</li></ol><h3 id="1-5-改变路由-重定向"><a href="#1-5-改变路由-重定向" class="headerlink" title="1.5 改变路由(重定向)"></a>1.5 改变路由(重定向)</h3><ol><li>路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）。</li></ol><h2 id="2-当发生以下情况时不应该发送IMCP差错报告报文"><a href="#2-当发生以下情况时不应该发送IMCP差错报告报文" class="headerlink" title="2. 当发生以下情况时不应该发送IMCP差错报告报文"></a>2. 当发生以下情况时不应该发送IMCP差错报告报文</h2><ol><li>对ICMP差错报告报文不再发送ICMP差错报告报文</li><li>对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文</li><li>对具有多播地址的数据报都不发送ICMP差错报告报文</li><li>对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送ICMP差错报告报文</li></ol><h2 id="3-常用的ICMP询问报文"><a href="#3-常用的ICMP询问报文" class="headerlink" title="3. 常用的ICMP询问报文"></a>3. 常用的ICMP询问报文</h2><ol><li>回送请求和回答</li><li>ICMP回送请求报文是由主机回或路由器向一个特定的目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。<ol start="2"><li>这种询问报文用来测试目的站是否可达及了解其有关状态。</li></ol></li><li>时间戳请求和回答<ol><li>ICMP时间戳请求报文是请某个主机或路由器回答当前的日期和时间。</li><li>在ICMP时间戳回答报文中有一个32位的字段，其中写入的整数代表从1900年1月1日起到当前时刻一共有多少秒。</li><li>这种询问报文用来进行时钟同步和测量时间</li></ol></li></ol><h2 id="4-ICMP应用"><a href="#4-ICMP应用" class="headerlink" title="4. ICMP应用"></a>4. ICMP应用</h2><h3 id="4-1-分组网间探测（PING）"><a href="#4-1-分组网间探测（PING）" class="headerlink" title="4.1 分组网间探测（PING）"></a>4.1 分组网间探测（PING）</h3><blockquote><p>Packet Internet Groper</p></blockquote><ol><li>用来测试主机或路由器间的连通性</li><li>应用层直接使用网际层的ICMP(没有通过运输层的TCP或UDP)</li><li>使用ICMP回送请求和回答报文</li></ol><h3 id="4-2-跟踪路由"><a href="#4-2-跟踪路由" class="headerlink" title="4.2 跟踪路由"></a>4.2 跟踪路由</h3><blockquote><p>traceroute</p><p>用来测试P数据报从源主机到达目的主机要经过哪些路由器</p></blockquote><ol><li><p>Windows版本</p><blockquote><p>tracert命令<br>应用层直接使用网际层ICMP<br>使用了ICMP回送请求和回答报文以及差错报告报文</p></blockquote></li><li><p>Unix版本</p><blockquote><p>traceroute命令<br>在运输层使用UDP协议<br>仅使用ICMP差错报告报文</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.7 IPv4数据报的首部格式</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-7-IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-7-IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="4-7-IP数据报的首部格式"><a href="#4-7-IP数据报的首部格式" class="headerlink" title="4.7 IP数据报的首部格式"></a>4.7 IP数据报的首部格式</h1><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-7-IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F/image-20230717175105117.png"></p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>版本</td><td>占4比特，表示IP协议的版本。<br>通信双方使用的P协议的版本必须一致。<br>目前广泛使用的IP协议版本号为4（即IPv4)<br></td></tr><tr><td>首部长度<br></td><td>占4比特，表示IP数据报首部的长度。<br>该字段的取值以4字节为单位。<br>最小十进制取值为5，表示P数据报首部只有20字节固定部分；<br>量大十进制取值为15，表示1P数据报首部包含20字节固定部分和最大40字节可变部分。<br></td></tr><tr><td>区分服务</td><td>占8比特，用来获得更好的服务。利用该字段的不同数值可提供不同等级的服务质量。<br>只有在使用区分服务时，该字段才起作用。一般情况下都不使用该字段。</td></tr><tr><td>总长度</td><td>占16比特，表示IP数据报的总长度（首部+数据载荷），最大取值为十进制的65535，以字节为单位。</td></tr><tr><td>标识</td><td>占16比特，属于同一个数据报的各分片数据报应该具有相同的标识。<br>IP软件维持一个计数器，每产生一个数据报，计数器值加1，并将此值赋给标识字段。</td></tr><tr><td>标志</td><td>占3比特，各比特含义如下：<br>DF位：1表示不允许分片：0表示允许分片；<br>MF位：1表示 后面还有分片：0表示 这是最后一个分片；<br>保留位：必须为0</td></tr><tr><td>片偏移</td><td>占13比特，指出分片数据报的数据载荷部分偏移其在原数据报的位置有多少个单位。<br>片偏移以8个字节为单位。</td></tr><tr><td>生存时间TTL</td><td>占8比特，表示P数据报的生存时间。<br>现在以“跳数”为单位，路由器转发P数据报时，将1P数据报首部中的该字段的值减1，若不为0就转发。否则就丢弃</td></tr><tr><td>首部校验和</td><td>1P数据报每经过一个路由器，路由器都要重新计算首部检验和，因为某些字段<br>（生存时间，标志，片偏移等）的取值可能发生变化</td></tr><tr><td>源IP地址和目的IP地址</td><td>略</td></tr><tr><td>填充</td><td>IP数据报首部大小必须为4字节的整数倍</td></tr><tr><td>可选字段长度</td><td>从1个字节到40个字节不等。用来支持排错、测量及安全等措施<br>但一般不使用</td></tr><tr><td>协议</td><td>占8比特，指明IPV4数据报的数据部分是何种协议数据单元。<br>常用的一些协议和相应的协议字段值如下。<br><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-7-IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F/image-20241117220627692.png" alt="image-20241117220627692"></td></tr></tbody></table><h2 id="1-IPV4分片"><a href="#1-IPV4分片" class="headerlink" title="1. IPV4分片"></a>1. IPV4分片</h2><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-7-IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F/image-20241117215341102.png"></p><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-7-IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F/image-20241117220158751.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.6 路由选择协议</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="4-6-路由选择协议"><a href="#4-6-路由选择协议" class="headerlink" title="4.6 路由选择协议"></a>4.6 路由选择协议</h1><h2 id="1-路由选择协议"><a href="#1-路由选择协议" class="headerlink" title="1. 路由选择协议"></a>1. 路由选择协议</h2><blockquote><p>早期RFC文档中，使用“网关”这个词指代路由器，现代使用“路由器”指代路由器，两者为同一设备的不同名称</p></blockquote><h3 id="1-1-静态路由选择"><a href="#1-1-静态路由选择" class="headerlink" title="1.1 静态路由选择"></a>1.1 静态路由选择</h3><ol><li>由人工配置的网络路由、默认路由、特定主机路由，黑洞路由等都属于静态路由。</li><li>这种人工配置方式简单、开销小，但不能及时适应网络状态（流量、拓扑等）的变化</li><li>一般只在小规模网络中采用。</li></ol><h3 id="1-2-动态路由选择"><a href="#1-2-动态路由选择" class="headerlink" title="1.2 动态路由选择"></a>1.2 动态路由选择</h3><ol><li>路由器通过路由选择协议自动获取路由信息比较复杂、开销比较大，</li><li>能较好地适应网络状态的变化</li><li>适用于大规模网络</li></ol><h3 id="1-3-因特网所采用的路由选择协议的主要特点"><a href="#1-3-因特网所采用的路由选择协议的主要特点" class="headerlink" title="1.3 因特网所采用的路由选择协议的主要特点"></a>1.3 因特网所采用的路由选择协议的主要特点</h3><ol><li>自适应<ol><li>动态路由选择，能较好地适应网络状态的变化</li></ol></li><li>分布式<ol><li>路由器之间交换路由信息</li></ol></li><li>分层次<ol><li>将整个因特网划分为许多较小的自治系统AS(Autonomous System）</li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117204127866.png"></p><h3 id="1-4-因特网采用分层次的路由选择协议"><a href="#1-4-因特网采用分层次的路由选择协议" class="headerlink" title="1.4 因特网采用分层次的路由选择协议"></a>1.4 因特网采用分层次的路由选择协议</h3><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117204721689.png"></p><ol><li><p>一般一个ISP负责的所有网络作为一个自治系统</p><ol><li>内部网关协议（IGP）和外部网关协议（EGP）是协议分类的总称，不是具体的协议名</li></ol></li><li><p>路由选择协议</p></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117204849446.png"></p><ol start="3"><li>路由器的基本结构</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117204931573.png"></p><ol start="4"><li>路由表一般仅包含从目的网络到下一跳的映射</li><li>路由表需要对网络拓扑变化的计算最优化<ol><li>转发表是从路由表得出的</li><li>转发表的结构应当使查找过程最优化</li></ol></li></ol><h2 id="2-路由信息RIP协议工作原理"><a href="#2-路由信息RIP协议工作原理" class="headerlink" title="2. 路由信息RIP协议工作原理"></a>2. 路由信息RIP协议工作原理</h2><ol><li>路由信息协议RIP(Routing Information Protocol)是内部网关协议IGP中最先得到广泛使用的协议之一，其相关标准文档为RFC1058。</li><li>RIP要求自治系统AS内的每一个路由器都要维护从它自己到AS内其他每一个网络的距离记录。这是一组距离，称为“距离向量”。</li><li>RIP使用跳数(Hop Count)作为度量(Metric)来衡量到达目的网络的距离。<ol><li>路由器到直连网络的距离定义为1。路由器到非直连网络的距离定义为所经过的路由器数加1。</li><li>允许一条路径最多只能包含15个路由器。“距离”等于16时相当于不可达。因此，RIP只适用于小型互联网。</li></ol></li><li>RIP认为好的路由就是“距离短”的路由，也就是所通过路由器数量最少的路由</li><li>当到达同一目的网络有多条“距离相等”的路由时，可以进行等价负载均衡</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117205628647.png"></p><h3 id="2-1-特点"><a href="#2-1-特点" class="headerlink" title="2.1 特点"></a>2.1 特点</h3><ol><li>仅和相邻路由器交换信息</li><li>交换的信息是自己的路由表</li><li>周期性交换该信息</li></ol><h3 id="2-2-RP的基本工作流程"><a href="#2-2-RP的基本工作流程" class="headerlink" title="2.2 RP的基本工作流程"></a>2.2 RP的基本工作流程</h3><ol><li>路由器刚开始工作时，只知道自己到直连网络的距离为1。</li><li>每个路由器仅和相邻路由器周期性地交换并更新路由信息。</li><li>若干次交换和更新后，每个路由器都知道到达本AS内各网络的最短距离和下一跳地址，称为收敛。</li></ol><h3 id="2-3-更新规则"><a href="#2-3-更新规则" class="headerlink" title="2.3 更新规则"></a>2.3 更新规则</h3><ol><li>发现了新的网络，添加</li><li>到达目的网络，相同下一跳，最新消息，更新</li><li>到达目的网络，不同下一跳，新路由优势，更新</li><li>到达目的网络，不同下一跳，新路由劣势，不更新</li><li>到达目的网络，不同下一跳，等价负载均衡</li></ol><ul><li>RIP存在“坏消息传播得慢”的问题</li></ul><blockquote><p>坏消息传播得慢”又称为路由环路或距离无穷计数问题，这是距离向量算法的一个固有问题。</p></blockquote><ul><li>可以采取多种措施减少出现该问题的概率或减小该问题带来的危害。<ul><li>限制最大路径距离为15(16表示不可达)</li><li>当路由表发生变化时就立即发送更新报文（即“触发更新”），而不仅是周期性发送</li><li>让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向传送（即“水平分割”）</li></ul></li></ul><h2 id="3-开放最短路径OSPF协议的工作原理"><a href="#3-开放最短路径OSPF协议的工作原理" class="headerlink" title="3. 开放最短路径OSPF协议的工作原理"></a>3. 开放最短路径OSPF协议的工作原理</h2><h3 id="3-1-OSPF协议"><a href="#3-1-OSPF协议" class="headerlink" title="3.1 OSPF协议"></a>3.1 OSPF协议</h3><ol><li>开放最短路径优先OSPF(Open Shortest Path First),是为克服RIP的缺点在1989年开发出来的。</li><li>“开放”表明OSPF协议不是受某一家厂商控制，而是公开发表的。</li><li>“最短路径优先”是因为使用了Dijkstra提出的最短路径算法SPF。</li><li>OSPF是基于链路状态的，而不像RIP那样是基于距离向量的。</li><li>OSPF采用SPF算法计算路由，从算法上保证了不会产生路由环路。</li><li>OSPF不限制网络规模，更新效率高，收敛速度快。</li></ol><h3 id="3-2-链路"><a href="#3-2-链路" class="headerlink" title="3.2 链路"></a>3.2 链路</h3><ol><li>链路状态是指本路由器都和哪些路由器相邻，以及相应链路的“代价”(cost)。</li><li>“代价”用来表示费用、距离、时延、带宽，等等。这些都由网络管理人员来决定。</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117211227799.png"></p><ol><li>OSPF相邻路由器之间通过交互问候(Hllo)分组，建立和维护邻居关系。<ol><li>Hello分组封装在IP数据报中，发往组播地址224.0.0.5；</li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117211306170.png"></p><ol start="2"><li>发送周期为10秒<ol><li>40秒未收到来自邻居路由器的Hlo分组，则认为该邻居路由器不可达。</li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117211527755.png"></p><h3 id="3-3-链路状态通告"><a href="#3-3-链路状态通告" class="headerlink" title="3.3 链路状态通告"></a>3.3 链路状态通告</h3><blockquote><p>使用OSPF的每个路由器都会产生链路状态通告 LSA  (Link State Advertisement)。</p></blockquote><ol><li>LSA中包含以下内容：<ol><li>直连网络的链路状态信息</li><li>邻居路由器的链路状态信息</li></ol></li><li>LSA被封装在链路状态更新分组LSU中，采用洪泛法发送。<br>使用OSPF的每个路由器都有一个链路状态数据库LSDB，用于存储LSA。</li><li>通过各路由器洪泛发送封装有自己LSA的LSU分组，各路由器的LSDB最终将达到一致。</li><li>使用OSPF的各路由器基于LSDB进行最短路径优先SPF计算，构建出各自到达其他各路由器的最短路径，即构建各自的路由表。</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117211848406.png"></p><h3 id="3-4-OSPF共有五种分组类型"><a href="#3-4-OSPF共有五种分组类型" class="headerlink" title="3.4 OSPF共有五种分组类型"></a>3.4 OSPF共有五种分组类型</h3><ol><li>问候分组（Hello）<ol><li>用来发现和维护邻居路由器的可达性。</li></ol></li><li>数据库描述分组（DD）<ol><li>向邻居路由器给出自己的链路状态数据库中的所有链路状态项目的摘要信息</li></ol></li><li>链路状态请求分组（LSR）<ol><li>向邻居路由器请求发送某些链路状态项目的详细信息。</li></ol></li><li>链路状态更新分组（LSU）<ol><li>路由器使用这种分组将其链路状态进行洪泛发送，即用洪泛法对全网更新链路状态。</li></ol></li><li>链路确认分组（LSA）<ol><li>这是对链路状态更新分组的确认分组。</li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20230717155343654.png"></p><h3 id="3-5-OSPF的基本工作过程"><a href="#3-5-OSPF的基本工作过程" class="headerlink" title="3.5 OSPF的基本工作过程"></a>3.5 OSPF的基本工作过程</h3><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20230717155522453.png"></p><ol><li>OSPF在多点接入的网络中路由器邻里关系的建立<ol><li>选举指定路由器DR(designated router)和备用的指定路由器BDR(backup designated router)</li><li>所有的非DR&#x2F;BDR只与DR&#x2F;BDR建立邻居关系，即非DR&#x2F;BDR之间通过DR&#x2F;BDR交换信息</li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20230717155708575.png"></p><ol start="2"><li>为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统再划分为若干个更小的范围，叫做区域(Area)<ol><li>划分区域的好处就是把利用洪泛法交换链路状体信息的范围局限于每一个区域而不是整个自治系统，这就减少了整个网络上的通信量。</li><li>每个区域不大于200个路由器</li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117213232150.png"></p><h2 id="4-边界网关协议BGP的基本工作原理"><a href="#4-边界网关协议BGP的基本工作原理" class="headerlink" title="4. 边界网关协议BGP的基本工作原理"></a>4. 边界网关协议BGP的基本工作原理</h2><h3 id="4-1-BGP原理"><a href="#4-1-BGP原理" class="headerlink" title="4.1 BGP原理"></a>4.1 BGP原理</h3><ol><li>BGP只能是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由</li><li>BGP要解决的问题<ol><li>在不同自治系统内，度量路由的“代价”（距离，带宽，费用等)可能不同。因此，对于自治系统之间的路由选择，使用“代价”作为度量来寻找最佳路由是不行的。</li><li>自治系统之间的路由选择必须考虑相关策略（政治，经济，安全等）</li></ol></li></ol><h3 id="4-2-交换路由的过程"><a href="#4-2-交换路由的过程" class="headerlink" title="4.2 交换路由的过程"></a>4.2 交换路由的过程</h3><ol><li><p>在配置BGP时，每个自治系统的管理员要选择至少一个路由器作为该自治系统的“BGP发言人”，不同自治系统的BGP发言人要交换路由信息，首先必须建立TCP连接，端口号为179</p></li><li><p>在此TCP连接上交换BGP报文以建立BGP会话</p></li><li><p>利用BGP会话交换路由信息（例如，增加新的路由，或撤销过时的路由，以及报告出错的情况等）</p><blockquote><p>使用TCP连接交换路由信息的两个BGP发言人，彼此称为对方的邻站(neighbor)或对等站(peer)</p></blockquote></li><li><p>BGP发言人除了运行BGP外，还必须运行自己所在自治系统所使用的内部网关协议IGP,例如OSPF或RIP。</p></li><li><p>当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各自治系统的较好的路由。也就是构造出树形结构、不存在回路的自治系统连通图。</p></li></ol><h3 id="4-3-BGP适用于多级结构的因特网"><a href="#4-3-BGP适用于多级结构的因特网" class="headerlink" title="4.3 BGP适用于多级结构的因特网"></a>4.3 BGP适用于多级结构的因特网</h3><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117214100280.png"></p><h3 id="4-4-BGP-4四种报文类型"><a href="#4-4-BGP-4四种报文类型" class="headerlink" title="4.4 BGP-4四种报文类型"></a>4.4 BGP-4四种报文类型</h3><table><thead><tr><th align="center">报文</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">OPEN(打开)报文</td><td align="left">用来与相邻的另一个BGP发言人建立关系，使通信初始化</td></tr><tr><td align="center">UPDATE(更新)报文</td><td align="left">用来通告某一路由的信息，以及列出要撤销的多条路由</td></tr><tr><td align="center">KEEPALIVE(保活)报文</td><td align="left">用来周期性地证实邻站的连通性。</td></tr><tr><td align="center">NOTIFICATION(通知)报文</td><td align="left">用来发送检测到的差错。</td></tr></tbody></table><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117214318616.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.5 静态路由配置及其可能产生的路由环路问题</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-5-%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%B6%E5%8F%AF%E8%83%BD%E4%BA%A7%E7%94%9F%E7%9A%84%E8%B7%AF%E7%94%B1%E7%8E%AF%E8%B7%AF%E9%97%AE%E9%A2%98/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-5-%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%B6%E5%8F%AF%E8%83%BD%E4%BA%A7%E7%94%9F%E7%9A%84%E8%B7%AF%E7%94%B1%E7%8E%AF%E8%B7%AF%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="4-5-静态路由配置及其可能产生的路由环路问题"><a href="#4-5-静态路由配置及其可能产生的路由环路问题" class="headerlink" title="4.5 静态路由配置及其可能产生的路由环路问题"></a>4.5 静态路由配置及其可能产生的路由环路问题</h1><ul><li>静态路由配置是指用户或网络管理员使用路由器的相关命令给路由器人工配置路由表。<ul><li>这种人工配置方式简单、开销小。但不能及时适应网络状态（流量、拓扑等）的变化。</li><li>一般只在小规模网络中采用。</li></ul></li></ul><h2 id="1-使用静态路由配置可能出现以下导致产生路由环路的错误"><a href="#1-使用静态路由配置可能出现以下导致产生路由环路的错误" class="headerlink" title="1. 使用静态路由配置可能出现以下导致产生路由环路的错误"></a>1. 使用静态路由配置可能出现以下导致产生路由环路的错误</h2><h3 id="1-1-配置错误"><a href="#1-1-配置错误" class="headerlink" title="1.1 配置错误"></a>1.1 配置错误</h3><ul><li>解决方法：<ul><li>IP数据报头部设置一个生存期，每经过一次路由转发，其值减一，当其值小于等于0时被丢弃</li><li>为了防止P数据报在路由环路中永久兜圈，在IP数据报首部设有生存时间TTL字段。</li><li>IP数据报进入路由器后，TTL字段的值减1。若TTL的值不等于0，则被路由器转发，否则被丢弃。</li></ul></li></ul><h3 id="1-2-聚合了不存在的网络"><a href="#1-2-聚合了不存在的网络" class="headerlink" title="1.2 聚合了不存在的网络"></a>1.2 聚合了不存在的网络</h3><ul><li>静态配置不存在的IP网络为黑洞路由</li></ul><h3 id="1-3-网络故障"><a href="#1-3-网络故障" class="headerlink" title="1.3 网络故障"></a>1.3 网络故障</h3><ul><li>静态配置故障的IP网络为黑洞路由，当其故障修复后，再自动添加回来并设置黑洞路由无效，若再故障，则删除并设置之前的黑洞路由有效</li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-5-%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%B6%E5%8F%AF%E8%83%BD%E4%BA%A7%E7%94%9F%E7%9A%84%E8%B7%AF%E7%94%B1%E7%8E%AF%E8%B7%AF%E9%97%AE%E9%A2%98/image-20241117203152226.png"></p><h2 id="2-路由条目的类型"><a href="#2-路由条目的类型" class="headerlink" title="2. 路由条目的类型"></a>2. 路由条目的类型</h2><ol><li>直连网络</li><li>静态路由（人工配置）</li><li>动态路由（路由选择协议）</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-5-%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%B6%E5%8F%AF%E8%83%BD%E4%BA%A7%E7%94%9F%E7%9A%84%E8%B7%AF%E7%94%B1%E7%8E%AF%E8%B7%AF%E9%97%AE%E9%A2%98/image-20241117202703876.png"></p><ol start="4"><li>特定主机路由<ol><li><p>特殊的静态路由条目</p></li><li><p>默认路由（目的网络为0.0.0.0，地址掩码为0.0.0.0）</p><blockquote><p>当路由表查找不到目标网络时，使用该路由</p></blockquote></li><li><p>特定主机路由（目的网络为特定主机的1P地址，地址掩码为255.255.255.255）</p></li><li><p>黑洞路由（下一跳为null0)</p></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.4 IP数据包的发送和转发过程</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-4-IP%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E5%8F%91%E9%80%81%E5%92%8C%E8%BD%AC%E5%8F%91%E8%BF%87%E7%A8%8B/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-4-IP%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E5%8F%91%E9%80%81%E5%92%8C%E8%BD%AC%E5%8F%91%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="4-4-IP数据报发送和转发过程"><a href="#4-4-IP数据报发送和转发过程" class="headerlink" title="4.4 IP数据报发送和转发过程"></a>4.4 IP数据报发送和转发过程</h1><ul><li>分为两部分<ul><li>主机发送IP数据报</li><li>路由器发送IP数据报</li></ul></li></ul><h2 id="1-主机发送数据报"><a href="#1-主机发送数据报" class="headerlink" title="1. 主机发送数据报"></a>1. 主机发送数据报</h2><ul><li>判断目的主机是否与自己在同一个网络（判断方法请参看本节课相关示例）<ul><li>若在同一个网络，则属于直接交付：</li><li>若不在同一个网络，则属于间接交付，传输给主机所在网络的默认网关(路由器)，由默认网关帮忙转发；</li></ul></li></ul><h2 id="2-路由器转发数据报"><a href="#2-路由器转发数据报" class="headerlink" title="2. 路由器转发数据报"></a>2. 路由器转发数据报</h2><ul><li>检查IP数据报首部是否出错：<ul><li>若出错，则直接丢弃该P数据报并通告源主机；</li><li>若没有出错，则进行转发；</li></ul></li><li>根据IP数据报的目的地址在路由表中查找匹配的条目(查找方法请参看本节课相关示例)：<ul><li>若找到匹配的条目，则转发给条目中指示的下一跳；</li><li>若找不到，则丢弃该P数据报并通告源主机；</li></ul></li></ul><h2 id="3-隔离"><a href="#3-隔离" class="headerlink" title="3. 隔离"></a>3. 隔离</h2><ul><li>中继器和集线器工作在物理层，既不隔离冲突域也不隔离广播域。</li><li>网桥和交换机（多端口网桥）工作在数据链路层，可以隔离冲突域，不能隔离广播域。</li><li>路由器工作在网络层，既隔离冲突域，也隔离广播域。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.3 IPv4</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/</url>
    
    <content type="html"><![CDATA[<h1 id="4-3-IPv4"><a href="#4-3-IPv4" class="headerlink" title="4.3 IPv4"></a>4.3 IPv4</h1><h2 id="1-IPv4地址概述"><a href="#1-IPv4地址概述" class="headerlink" title="1. IPv4地址概述"></a>1. IPv4地址概述</h2><blockquote><p>给因特网上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的32比特的标识符。</p></blockquote><ol><li>在TCP&#x2F;IP体系中，IP地址是一个最基本的概念，我们必须把它弄清楚。</li><li>IPv4地址就是给因特网(Internet)上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的32比特的标识符。</li><li>IP地址由因特网名字和数字分配机构ICANN(Internet Corporation for Assigned Names and Numbers)进行分配.</li><li>我国用户可向亚太网络信息中心APNIC(Asia Pacific Network Information Center)申请IP地址，需要缴费。</li><li>2011年2月3日，互联网号码分配管理局IANA(由ICANN行使职能)宣布，IPV4地址已经分配完毕。</li><li>我国在2014至2015年也逐步停止了向新用户和应用分配IPv4地址。同时全面开展商用部署IPv6。</li></ol><h3 id="1-1-十进制表示"><a href="#1-1-十进制表示" class="headerlink" title="1.1 十进制表示"></a>1.1 十进制表示</h3><blockquote><p> 32比特的1Pv4地址不方便阅读、记录以及输入等，因此IPv4地址采用点分十进制表示方法以方便用户使用。</p><p> 八位一组，中间用  <code>. </code> 隔开</p></blockquote><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/image-20230716135419296.png"></p><h2 id="2-分类编址的IPv4地址"><a href="#2-分类编址的IPv4地址" class="headerlink" title="2. 分类编址的IPv4地址"></a>2. 分类编址的IPv4地址</h2><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/image-20230716142505440.png"></p><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/image-20230716142540603.png"></p><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/image-20241117190912535.png"></p><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/image-20230716142559662.png"></p><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/image-20230716141719165.png"></p><h2 id="3-划分子网的IPv4地址"><a href="#3-划分子网的IPv4地址" class="headerlink" title="3. 划分子网的IPv4地址"></a>3. 划分子网的IPv4地址</h2><ol><li>从主机号中借用一部分比特来作为子网号</li><li>子网掩码<ol><li>子网掩码使用连续的比特1来对应网络号和子网号</li><li>子网掩码使用连续的比特0来对应主机号</li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/image-20230716165915602.png"></p><ol start="3"><li><p>为新增网络申请新的网络号会带来以下弊端：</p><ol><li>需要等待时间和花费更多的费用</li><li>会增加其他路由器中路由表记录的数量</li><li>浪费原有网络号中剩余的大量IP地址</li></ol></li><li><p>默认子网掩码</p></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/image-20230716170001375.png" alt="默认子网掩码"></p><h2 id="4-无分类编址的IPv4地址"><a href="#4-无分类编址的IPv4地址" class="headerlink" title="4. 无分类编址的IPv4地址"></a>4. 无分类编址的IPv4地址</h2><ol><li>无分类域间路由选择（CIDR）消除了传统的A类、B类和C类地址，以及划分子网的概念。</li><li>为此，因特网工程任务组ETF又提出了采用无分类编址的方法来解决P地址紧张的问题，同时还专门成立Pv6工作组负责研究新版本P以彻底解决P地址耗尽问题。</li><li>1993年，IETF发布了无分类域间路由选择CIDR(Classless Inter-Domain Routing)的RFC文档：RFC1517~1519和1520。</li><li>CIDR消除了传统的A类、B类和C类地址，以及划分子网的概念：</li><li>CIDR可以更加有效地分配IPv4的地址空间，并且可以在新的PV6使用之前允许因特网的规模继续增长。</li><li>CIDR可以更加有效地分配IPV4的地址空间，并且可以在新的PV6使用之前允许因特网的规模继续增长。如：192.8.32.3&#x2F; 20</li><li>CIDR实际上是将网络前缀都相同的连续的1P地址组成一个“CIDR地址块”。</li></ol><h2 id="4-1-路由聚合"><a href="#4-1-路由聚合" class="headerlink" title="4.1 路由聚合"></a>4.1 路由聚合</h2><ul><li>构造超网，找到相同接口的多个地址的最长公共前缀，其余位归0，将该地址记录下来，那些地址删除即将它们合并成一个地址</li><li>网络前缀越长，地址块越小，路由越具体</li><li>若路由器查表转发分组时发现有多条路由可选，则选择网络前缀最长的那条，这称为最长前缀匹配。因为这样的路由更具体</li></ul><h2 id="5-IPv4地址的应用规划"><a href="#5-IPv4地址的应用规划" class="headerlink" title="5. IPv4地址的应用规划"></a>5. IPv4地址的应用规划</h2><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/image-20230716214234227.png"></p><ul><li>变长的子网掩码是CIDR技术的应用</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.2 网络层提供的两种服务</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-2-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-2-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="4-2-网络层提供的两种服务"><a href="#4-2-网络层提供的两种服务" class="headerlink" title="4.2 网络层提供的两种服务"></a>4.2 网络层提供的两种服务</h1><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-2-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1/image-20230716133452655.png"></p><h2 id="1-虚电路服务"><a href="#1-虚电路服务" class="headerlink" title="1. 虚电路服务"></a>1. 虚电路服务</h2><ol><li>可靠通信由网络来保证</li><li>必须建立网络层的连接</li><li>虚电路VC(Virtual Circuit) 通信双方沿着已建立的虚电路发送分组，目的主机的地址仅在连接建立阶段使用，之后每个分组的首部只需携带一条虚电路的编号（构成虚电路的每一段链路都有一个虚电路编号)。这种通信方式如果再使用可靠传输的网络协议，就可使所发送的分组最终正确到达接收方（无差错按序到达、不丢失、不重复)。</li><li>通信结束后，需要释放之前所建立的虚电路。</li><li>很多广域分组交换网都使用面向连接的虚电路服务。<ol><li>例如，曾经的X.25和逐渐过时的帧中继FR、异步传输模式ATM等。</li></ol></li></ol><h2 id="2-数据报服务"><a href="#2-数据报服务" class="headerlink" title="2. 数据报服务"></a>2. 数据报服务</h2><ol><li>无连接的数据报服务</li><li>可靠通信应当由用户主机来保证</li><li>不需要建立网络层连接</li><li>每个分组可走不同的路径</li><li>每个分组的首部必须携带目的主机的完整地址这种通信方式所传送的分组可能误码、丢失、重复和失序。</li><li>由于网络本身不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价格低廉（与电信网的交换机相比较）。</li><li>因特网采用了这种设计思想，也就是将复杂的网络处理功能置于因特网的边缘（用户主机和其内部的运输层)，而将相对简单的尽最大努力的分组交付功能置于因特网核心。</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.1 网络层概述</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-1-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-1-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="4-1-网络层"><a href="#4-1-网络层" class="headerlink" title="4.1 网络层"></a>4.1 网络层</h1><h2 id="1-网络层"><a href="#1-网络层" class="headerlink" title="1. 网络层"></a>1. 网络层</h2><ol><li><p>网络层的主要任务是实现网络互连，进而实现数据包在各网络之间的传输</p></li><li><p>要实现网络层任务，需要解决以下主要问题：</p><ol><li>网络层向运输层提供怎样的服务（可靠传输 还是 不可靠传输）<ol><li>如果网络层对传输错误（分组丢失，分组失序等）不采取任何措施，那么就是不可靠服务</li><li>TCP&#x2F;IP网络体系结构提供的就是无连接，不可靠的传输服务（IP协议）</li></ol></li><li>网络层寻址问题</li><li>路由选择问题</li></ol></li><li><p>因特网(Internet)是目前全世界用户数量最多的互联网，它使用TCP&#x2F;IP协议栈。</p></li><li><p>由于TCP&#x2F;IP协议栈的网络层使用网际协议IP,它是整个协议栈的核心协议，因此在TCP&#x2F;IP协议栈中网络层常称为网际层。</p></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-1-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0/image-20241117185613994.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.11 虚拟局域网VLAN</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-11-%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91VLAN%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-11-%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91VLAN%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="3-11-虚拟局域网（VLAN）"><a href="#3-11-虚拟局域网（VLAN）" class="headerlink" title="3.11 虚拟局域网（VLAN）"></a>3.11 虚拟局域网（VLAN）</h1><ol><li><p>以太网交换机工作在数据链路层（也包括物理层）</p></li><li><p>使用一个或多个以太网交换机互连起来的交换式以太网，其所有站点都属于同一个广播域。随着交换式以太网规模的扩大，广播域相应扩大。</p></li><li><p>巨大的广播域会带来很多弊端：</p><ol><li>广播风暴</li><li>难以管理和维护</li><li>潜在的安全问题</li></ol></li><li><p>广播风暴会浪费网络资源和各主机的CPU资源！网络中会频繁出现广播信息</p><ol><li>TCP&#x2F;IP协议栈中的很多协议都会使用广播：<ol><li>地址解析协议ARP(已知IP地址，找出其相应的MAC地址)</li><li>路由信息协议RIP(一种小型的内部路由协议)</li><li>动态主机配置协议DHCP(用于自动配置IP地址)</li><li>NetBEUI: Windows下使用的广播型协议</li><li>IPX&#x2F;SPX: Novell网络的协议栈</li><li>Apple Talk: Apple公司的网络协议栈</li></ol></li></ol></li></ol><h2 id="1-分割广播域的方法"><a href="#1-分割广播域的方法" class="headerlink" title="1. 分割广播域的方法"></a>1. 分割广播域的方法</h2><ul><li><p>使用路由器可以隔离广播域</p></li><li><p>虚拟局域网VLAN(Virtual Local Area Network)是一种将局域网内的设备划分成与物理位置无关的逻辑组的技术，这些逻辑组具有某些共同的需求。</p></li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-11-%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91VLAN%E6%A6%82%E8%BF%B0/image-20241117181858889.png"></p><blockquote><p>虚拟局域网是一种将局域网内的设备划分成与物理位置无关的逻辑组的技术，这些逻辑组具有某些共同的需求。即作用是像路由器一样分割广播域。</p></blockquote><ol><li><p>802.1Q帧对以太网帧进行了扩展，插入了4字节的VLAN标记<br><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-11-%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91VLAN%E6%A6%82%E8%BF%B0/image-20241117182055735.png"></p></li><li><p>VLAN标记的最后12比特称为VLAN标识符VID,它唯一地标志了以太网帧属于哪一个VLAN.</p><ol><li>V1D的取值范围是0~4095 ( 0 ~ 2^12^-1 )</li><li>0和4095都不用来表示VLAN，因此用于表示VLAN的V1D的有效取值范围是1~4094</li></ol></li><li><p>802.1Q帧是由交换机来处理的，而不是用户主机来处理的。</p><ol><li>当交换机收到普通的以太网帧时，会将其<strong>插入4字节的VLAN标记</strong>转变为802.1Q帧，简称“打标签”</li><li>当交换机转发802.1Q帧时，可能会<strong>删除其4字节VLAN标记</strong>转变为普通以太网帧，简称“去标签”</li></ol></li></ol><h2 id="2-交换机端口类型"><a href="#2-交换机端口类型" class="headerlink" title="2. 交换机端口类型"></a>2. 交换机端口类型</h2><ol><li><p>交换机有三种端口类型</p><ol><li>Access</li><li>Trunk</li><li>Hybrid</li></ol></li><li><p>Access端口一般用于连接用户计算机</p><ol><li>Access端口只能属于一个VLAN</li><li>Access端口的PVID值与端口所属VLAN的ID相同（默认为1）</li><li>Access端口接收处理方法：<ol><li>一般只接受“未打标签”的普通以太网MAC帧。</li><li>根据接收帧的端口的PVID给帧“打标签”，即插入4字节VLAN标记字段，字段中的VID取值与端口的PVID取值相等。</li></ol></li></ol></li><li><p>Trunk端口一般用于交换机之间或交换机与路由器之间的互连</p><ol><li>Trunk端口可以属于多个VLAN</li><li>用户可以设置Trunk端口的PVID值。默认情况下，Trunki端口的PVID值为1。</li><li>Trunk端口发送处理方法：<ol><li>对VID等于PVID的帧，“去标签”再转发；</li><li>Trunk端口接收处理方法：接收“未打标签”的帧，根据接收帧的端口的PVID给帧“打标签”，即插入4字节</li><li>VLAN标记字段，字段中的VID取值与端口的PVID取值相等。</li></ol></li></ol></li><li><p>Hybrid端口</p><ol><li>既可用于交换机之间或交换机，与路由器之间的互连（同Trunk端口），也可用于交换机与用户计算机之间的互连（同Access端口）</li><li>Hybrid端口可以属于多个VLAN(同Trunk端口)</li><li>用户可以设置Hybrid端口的PVID值。默认情况下，Hybrid端口的PVID值为1（同Trunk端口）</li><li>Hybrid端口发送处理方法（与Trunk端口不同）<ol><li>查看帧的VID是否在端口的“去标签”列表中：</li><li>若存在，则“去标签”后再转发；</li><li>若不存在，则直接转发；</li></ol></li><li>Hybrid端口接收处理方法（同Trunk端口）<ol><li>接收“未打标签”的帧，根据接收帧的端口的PVID给帧”打标签”，即插入4字节VLAN标记字段，字段中的VID取值与端口的PVID取值相等。</li><li>接收“已打标签的帧”：</li></ol></li></ol></li></ol><ul><li>交换机各端口的缺省VLAN ID,在思科交换机上称为Native VLAN,即本征VLAN。</li><li>在华为交换机上称为Port VLAN ID,即端口VLAN ID,简记为PVID。</li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-11-%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91VLAN%E6%A6%82%E8%BF%B0/image-20241117184056860.png" alt="image-20241117184056860"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.10 以太网交换机的生成树协议STP</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-10-%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AESTP/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-10-%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AESTP/</url>
    
    <content type="html"><![CDATA[<h2 id="3-10-以太网交换机的生成树协议STP"><a href="#3-10-以太网交换机的生成树协议STP" class="headerlink" title="3.10 以太网交换机的生成树协议STP"></a>3.10 以太网交换机的生成树协议STP</h2><ul><li>为提高以太网的可靠性，需要添加冗余链路，但添加冗余链路会形成网络环路，网络环路会造成很多问题：<ul><li>广播风暴<ul><li>大量消耗网络资源，使得网络无法正常转发其他数据帧：</li></ul></li><li>主机收到重复的广播帧<ul><li>大量消耗主机资源</li></ul></li><li>交换机的帧交换表震荡（漂移）<ul><li>某记录在错误的记录之间来回震荡</li></ul></li></ul></li><li>STP正是为了解决这一问题而出现。<ul><li>不论交换机之间采用怎样的物理连接，交换机都能够自动计算并构建一个逻辑上没有环路的网络，其逻辑拓扑结构必须是树型的（无逻辑环路）</li><li>最终生成的树型逻辑拓扑要确保连通整个网络。</li><li>当首次连接交换机或网络物理拓扑发生变化时（有可能是人为改变或故障），交换机都将进行生成树的重新计算。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.9 以太网交换机自学习和转发帧的流程</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-9-%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA%E8%87%AA%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%BD%AC%E5%8F%91%E5%B8%A7%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-9-%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA%E8%87%AA%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%BD%AC%E5%8F%91%E5%B8%A7%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="3-9-以太网自学习和转发帧"><a href="#3-9-以太网自学习和转发帧" class="headerlink" title="3.9 以太网自学习和转发帧"></a>3.9 以太网自学习和转发帧</h1><ul><li>以太网交换机工作在数据链路层（也包括物理层）<ul><li>以太网交换机收到帧后，在帧交换表中查找帧的目的MAC地址所对应的接口号，然后通过该接口转发帧。</li></ul></li><li>以太网交换机是一种即插即用设备，刚上电启动时其内部的帧交换表是空的。随着网络中各主机间的通信，<ul><li>以太网交换机通过自学习算法自动逐渐建立起帧交换表。</li></ul></li></ul><ol><li>收到帧后进行登记。登记的内容为帧的源MAC地址及进入交换机的接口号</li><li>根据帧的目的MAC地址和交换机的帧交换表对帧进行转发，有以下三种情况：<ol><li>明确转发：交换机知道应当从哪个（回或哪些）接口转发该帧（单播，多播，广播）</li><li>盲目转发：交换机不知道应当从哪个端口转发帧，只能将其通过除进入交换机的接口外的其他所有接口转发（也称为泛洪）</li><li>明确丢弃：交换机知道不应该转发该帧，将其丢弃。比如：源MAC地址和目的MAC地址在表中记录为同一个端口</li></ol></li><li>帧交换表中的每条记录都有自己的有效时间，到期删除。原因如下：<ol><li>交换机的接口改接了另一台主机</li><li>主机更换了网卡</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.8 集线器与交换机的区别</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-8-%E9%9B%86%E7%BA%BF%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-8-%E9%9B%86%E7%BA%BF%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="3-8-集线器（HUB）和交换机（SWITCH）的区别"><a href="#3-8-集线器（HUB）和交换机（SWITCH）的区别" class="headerlink" title="3.8 集线器（HUB）和交换机（SWITCH）的区别"></a>3.8 集线器（HUB）和交换机（SWITCH）的区别</h1><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-8-%E9%9B%86%E7%BA%BF%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB/image-20241117174351414.png"></p><h2 id="1-集线器HUB"><a href="#1-集线器HUB" class="headerlink" title="1. 集线器HUB"></a>1. 集线器HUB</h2><ol><li>使用集线器的以太网在逻辑上仍是一个总线网，各站共享总线资源，使用的还是CSMA&#x2F;CD协议：</li><li>集线器只工作在物理层，它的每个接口仅简单地转发比特，不进行碰撞检测（由各站的网卡检测）：<ol><li>集线器一般都有少量的容错能力和网络管理功能。例如，若网络中某个网卡出了故障，不停地发送帧。此时，集线器可以检测到这个问题，在内部断开与出故障网卡的连线，使整个以太网仍然能正常工作。</li></ol></li><li>使用集线器HUB在物理层扩展以太网</li></ol><h2 id="2-交换机"><a href="#2-交换机" class="headerlink" title="2. 交换机"></a>2. 交换机</h2><blockquote><p>前提：交换机已完成自学习</p></blockquote><ol><li>以太网交换机通常都有多个接口。每个接口都可以直接与一台主机回或另一个以太网交换机相连。一般都工作在全双工方式。</li><li>以太网交换机具有并行性，能同时连通多对接口，使多对主机能同时通信，无碰撞（不使用CSMA&#x2F;CD协议）。</li><li>以太网交换机一般都具有多种速率的接口，例如：10Mb&#x2F;s、100Mb&#x2F;s、1Gb&#x2F;s、10Gb&#x2F;s接口的多种组合。<ol><li>以太网交换机工作在数据链路层（也包括物理层），它收到帧后，在帧交换表中查找帧的目的MAC地址所对应的接口号，然后通过该接口转发帧。</li><li>以太网交换机是一种即插即用设备，其内部的帧交换表是通过自学习算法自动地逐渐建立起来的。</li></ol></li><li>帧的两种转发方式：<ol><li>存储转发</li><li>直通交换：采用基于硬件的交叉矩阵（交换时延非常小，但不检查帧是否右差错)</li></ol></li></ol><h2 id="3-比较"><a href="#3-比较" class="headerlink" title="3. 比较"></a>3. 比较</h2><ol><li>交换机性能远超集线器，而且价格不高，所以市场上集线器已被淘汰</li><li>交换机不会改变源目MAC地址</li><li>交换机全双工传输</li><li>交换机即插即用</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-8-%E9%9B%86%E7%BA%BF%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB/image-20241117175352287.png"></p><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-8-%E9%9B%86%E7%BA%BF%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB/image-20241117175440399.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.7 MAC地址 IP地址以及ARP协议</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-7-MAC%E5%9C%B0%E5%9D%80-IP%E5%9C%B0%E5%9D%80-ARP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-7-MAC%E5%9C%B0%E5%9D%80-IP%E5%9C%B0%E5%9D%80-ARP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="3-7-MAC地址，IP地址，ARP地址"><a href="#3-7-MAC地址，IP地址，ARP地址" class="headerlink" title="3.7 MAC地址，IP地址，ARP地址"></a>3.7 MAC地址，IP地址，ARP地址</h1><ul><li>MAC地址是以太网的MAC子层所使用的地址</li><li>IP地址是TCP&#x2F;小P体系结构网际层所使用的地址</li><li>ARP协议属于TCP&#x2F;IP体系结构的网际层，其作用是已知设备所分配到的1P地址，使用ARP协议可以通过该P地址获取到设备的MAC地址；</li><li>尽管IP地址和ARP协议属于TCP&#x2F;IP体系结构的网际层（而不属于数据链路层)，但是它们与MAC地址存在一定的关系，并且我们日常的网络应用都离不开MAC地址、IP地址以及ARP协议。</li></ul><h2 id="1-MAC地址"><a href="#1-MAC地址" class="headerlink" title="1. MAC地址"></a>1. MAC地址</h2><ul><li>又称硬件地址，物理地址，属于数据链路层范畴</li><li>当多个主机连接在同一个广播信道上，要想实现两个主机之间的通信，则每个主机都必须有一个唯一的标识，即一个数据链路层地址</li></ul><ol><li>一般情况下，用户主机会包含两个网络适配器：有线局域网适配器（有线网卡）和无线局域网适配器（无线网卡)。</li><li>每个网络适配器都有一个全球唯一的MAC地址。而交换机和路由器往往拥有更多的网络接口，所以会拥有更多的MAC地址。综上所述，严格来说，MAC地址是对网络上各接口的唯一标识，而不是对网络上各设备的唯一标识。</li><li>在每个主机发送的帧中必须携带标识发送主机和接收主机的地址。由于这类地址是用于媒体接入控制MAC(Media Access Control),因此这类地址被称为MAC地址：<ol><li>MAC地址一般被固化在网卡（网络适配器）的电可擦可编程只读存储器EEPROM中，因此MAC地址也被称为硬件地址；</li><li>MAC地址有时也被称为物理地址。请注意：这并不意味着MAC地址属于网络体系结构中的物理层！</li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-7-MAC%E5%9C%B0%E5%9D%80-IP%E5%9C%B0%E5%9D%80-ARP%E5%8D%8F%E8%AE%AE/image-20241117152902875.png"></p><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-7-MAC%E5%9C%B0%E5%9D%80-IP%E5%9C%B0%E5%9D%80-ARP%E5%8D%8F%E8%AE%AE/image-20241117153926503.png"></p><h2 id="2-IP地址"><a href="#2-IP地址" class="headerlink" title="2. IP地址"></a>2. IP地址</h2><blockquote><p>IP地址是因特网(Internet)上的主机和路由器所使用的地址，属于网络层范畴</p><p>用于标识两部分信息：</p><ol><li>网络编号：标识因特网上数以百万计的网络</li><li>主机编号：标识同一网络上不同主机（或路由器各接口）</li></ol></blockquote><ol><li>数据包转发过程中，源IP地址和目的IP地址不变源MAC地址和目的MAC地址逐个链路改变</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-7-MAC%E5%9C%B0%E5%9D%80-IP%E5%9C%B0%E5%9D%80-ARP%E5%8D%8F%E8%AE%AE/image-20241117154839729.png"></p><h2 id="3-ARP协议"><a href="#3-ARP协议" class="headerlink" title="3. ARP协议"></a>3. ARP协议</h2><blockquote><p>解析IP地址 得到相应的MAC地址，属于网络层范畴</p></blockquote><ul><li><p>内容步骤</p><ol><li>源主机在自己的ARP高速缓存表中查找目的主机的1P地址所对应的MAC地址，若找到了，则可以封装MAC帧进行发送；若找不到，则发送ARP请求（封装在广播MAC帧中）</li><li>目的主机收到ARP请求后，将源主机的IP地址与MAC地址记录到自己的ARP高速缓存表中，然后给源主机发送ARP响应（封装在单播MAC帧中)，ARP响应中包含有目的主机的IP地址和MAC地址</li></ol></li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-7-MAC%E5%9C%B0%E5%9D%80-IP%E5%9C%B0%E5%9D%80-ARP%E5%8D%8F%E8%AE%AE/image-20241117173649451.png"></p><ol><li><p>作用范围</p></li><li><p>逐段链路或逐段网络使用</p></li><li><p>ARP高速缓存表中记录了每个IP地址对应的MAC地址，以及这个地址对的类型类型分为静态类型和动态类型</p><ol><li>静态类型手动配置，可设置系统重启后这些静态类型的地址对是否仍然有效</li><li>动态类型是通过上述ARP请求以及ARP相应得到的，有效时间很短，2分钟左右</li></ol></li><li><p>ARP协议不能跨网络使用</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.6 媒体接入控制</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="3-6-媒体接入控制（MAC）"><a href="#3-6-媒体接入控制（MAC）" class="headerlink" title="3.6 媒体接入控制（MAC）"></a>3.6 媒体接入控制（MAC）</h1><ul><li>共享信道要着重考虑的一个问题就是如何协调多个发送和接收站点对一个共享传输媒体的占用，即媒体接入控制MAC(Medium Access Control)。</li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117135016262.png"></p><ul><li>随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局<br>域网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术。</li></ul><h2 id="1-静态划分信道"><a href="#1-静态划分信道" class="headerlink" title="1. 静态划分信道"></a>1. 静态划分信道</h2><ul><li>信道复用技术<ul><li>复用(Multiplexing)是通信技术中的一个重要概念。复用就是通过一条物理线路同时传输多路用户的信号。</li><li>当网络中传输媒体的传输容量大于多条单一信道传输的总通信量时，可利用复用技术在一条物理线路上建立多条通信信道来充分利用传输媒体的带宽。</li></ul></li></ul><h3 id="1-1-频分复用（FDM）"><a href="#1-1-频分复用（FDM）" class="headerlink" title="1.1 频分复用（FDM）"></a>1.1 频分复用（FDM）</h3><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117135153544.png"></p><ul><li>频分复用的所有用户同时占用不同的频带资源并行通信。</li></ul><h3 id="1-2-时分复用（TDM）"><a href="#1-2-时分复用（TDM）" class="headerlink" title="1.2 时分复用（TDM）"></a>1.2 时分复用（TDM）</h3><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117135256698.png"></p><ul><li>时分复用的所有用户在不同的时间占用同样的频带宽度。</li></ul><h3 id="1-3-波分复用（WDM）"><a href="#1-3-波分复用（WDM）" class="headerlink" title="1.3 波分复用（WDM）"></a>1.3 波分复用（WDM）</h3><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117135344436.png"></p><h3 id="1-4-码分复用"><a href="#1-4-码分复用" class="headerlink" title="1.4 码分复用"></a>1.4 码分复用</h3><ol><li>CDM的每一个用户可以在同样的时间使用同样的频带进行通信。</li><li>由于各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。</li><li>CDM最初是用于军事通信的，因为这种系统所发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li><li>在CDMA中，每一个比特时间再划分为m个短的间隔，称为码片(Chip)。通常m的值是64或128</li><li>使用CDMA的每一个站被指派一个唯一的码片码片序列<ol><li>一个站如果要发送比特1，则发送它自己的码片码片序列；</li><li>一个站如果要发送比特0，则发送它自己的码片序列的二进制反码</li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117140108915.png"></p><ol start="6"><li>码片序列挑选原则</li></ol><ul><li>分配给每个站的码片序列必须各不相同，实际常采用伪随机码序列。</li><li>分配给每个站的码片序列必须相互正交（规格化内积为0）</li></ul><p>$$<br>A \bullet B &#x3D; \frac{1}{m} \times \sum_{i&#x3D;1}^{m}A_i \times B_i<br>$$</p><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117140433653.png"></p><h2 id="2-动态接入控制——随机接入"><a href="#2-动态接入控制——随机接入" class="headerlink" title="2. 动态接入控制——随机接入"></a>2. 动态接入控制——随机接入</h2><h3 id="2-1-CSMA-CD协议"><a href="#2-1-CSMA-CD协议" class="headerlink" title="2.1 CSMA&#x2F;CD协议"></a>2.1 CSMA&#x2F;CD协议</h3><ul><li>载波监听 多址接入 &#x2F; 碰撞检测</li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117142251276.png"></p><ul><li>以太网还采取一种叫做强化碰撞的措施。这就是当发送帧的站点一旦检测到碰撞，除了立即停止发送帧外，还要再继续发送32比特或48比特的人为干扰信号(Jamming Signal),以便有足够多的碰撞信号使所有站点都能检测出碰撞。</li></ul><h3 id="2-2-工作原理"><a href="#2-2-工作原理" class="headerlink" title="2.2 工作原理"></a>2.2 工作原理</h3><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117142509113.png"></p><ol start="2"><li><p>争用期（碰撞窗口）</p><ol><li>发送帧的主机最多经过以太网端到端往返传播时延2τ这么长时间，就可检测到本次传输是否发生了碰撞，2τ称为争用期：</li><li>经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</li><li>以太网规定2τ的取值为512比特时间（即发送512比特所耗费的时间），对于10Mbps的以太网，2τ 即为51.2 μs。</li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117142629341.png"></p><ol start="3"><li>最小帧长</li></ol><p>$$<br>最小帧长 &#x3D; 争用期 \times 数据传输速率（带宽）<br>$$</p><ul><li>最小帧长的设置是因为源主机将帧发送完毕以后，便不会再管这个帧，此时发生碰撞导致目标主机丢弃该帧，不会重发。</li><li>以太网规定最小帧长为64字节，即512比特(512比特时间即为争用期)：<ul><li>如果要发送的数据非常少，那么必须加入一些填充字节，使帧长不小于64字节。</li><li>以太网的最小帧长确保了主机可在帧发送完成之前就检测到该帧的发送过程中是否遭遇了碰撞：</li><li>如果在争用期（共发送64字节）没有检测到碰撞，那么后续发送的数据就一定不会发生碰撞；</li><li>如果在争用期内检测到碰撞，就立即中止发送，这时已经发送出去的数据一定小于64字节，因此凡长度小于64字节的帧都是由于碰撞而异常中止的无效帧。</li></ul></li></ul><ol start="4"><li>最大帧长</li></ol><ul><li>最大帧长的设置是因为不能使某个主机长时间独占共享媒介，否则过于影响其它主机的数据发送</li></ul><ol start="5"><li>截断二进制指数退避算法</li></ol><p>$$<br>随机退避时间&#x3D;争用期\times 随机数r,\其中r从离散的整数集合0,1，…，(2k.1)中随机取出一个，<br>$$</p><p>$$<br>k &#x3D; Min(重传次数，10)<br>$$</p><ul><li>若连续多次发生碰撞，就表明可能有较多的主机参与竞争信道。但使用上述退避算法可使重传需要推迟的平均时间随重传次数而增大（这也称为动态退避），因而减)小发生碰撞的概率，有利于整个系统的稳定。</li><li>当重传达16次仍不能成功时，这表明同时打算发送数据的主机太多以至于连续发生碰撞，则丢弃该帧并向高层报告。</li></ul><ol start="6"><li>以太网信道利用率</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117143437511.png"></p><ol start="7"><li>考虑以下这种理想情况：<ol><li>各主机发送帧都不会产生碰撞，总线一旦空闲就有某个主机立即发送帧：</li><li>发送一帧占用总线的时间为T0+T，而帧本身的发送时间是T0,</li><li>理想情况公式：</li></ol></li></ol><p>$$<br>S_{max} &#x3D; \frac{T_0}{T_0 + \tau} &#x3D; \frac{1}{1+\frac{\tau}{T_0}}<br>$$</p><ul><li>信道利用率受传播时延限制，所以以太网端到端的距离收到限制，以太网帧的长度最好尽量长些</li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117143601933.png"></p><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117143649489.png"></p><h2 id="3-CSMA-CA协议"><a href="#3-CSMA-CA协议" class="headerlink" title="3. CSMA&#x2F;CA协议"></a>3. CSMA&#x2F;CA协议</h2><ul><li><p>载波监听 多址接入  &#x2F; 碰撞避免 </p></li><li><p>载波监听多址接入&#x2F;碰撞避免CSMA&#x2F;CA(Carrier Sense Multiple Access&#x2F;Collision Avoidance)</p></li></ul><ol><li><p>既然CSMA&#x2F;CD协议已经成功地应用于使用广播信道的有线局域网，那么同样使用广播信道的无线局域网能不能也使用CSMA&#x2F;CD协议呢？</p></li><li><p>在无线局域网中，仍然可以使用载波监听多址接入CSMA,即在发送帧之前先对传输媒体进行载波监听。若发现有其他站在发送帧，就推迟发送以免发生碰撞。</p></li><li><p>在无线局域网中，不能使用碰撞检测CD,原因如下：</p><ol><li>由于无线信道的传输条件特殊，其信号强度的动态范围非常大，无线网卡上接收到的信号强度往往会远远小于发送信号的强度（可能相差百万倍）。如果要在无线网卡上实现碰撞检测CD,对硬件的要求非常高。</li><li>即使能够在硬件上实现无线局域网的碰撞检测功能，但由于无线电波传播的特殊性（存在隐蔽站问题)，进行碰撞检测的意义也不大。</li></ol></li><li><p>802.11无线局域网使用CSMA&#x2F;CA协议，在CSMA的基础上增加了一个碰撞避免CA功能，而不再实现碰撞检测功能。</p></li><li><p>由于不可能避免所有的碰撞，并且无线信道误码率较高，802.11标准还使用了数据链路层确认机制（停止-等待协议）来保证数据被正确接收。</p></li><li><p>802.11的MAC层标准定义了两种不同的媒体接入控制方式：</p><ol><li>分布式协调功能DCF(Distributed Coordination Function)。在DCF方式下，没有中心控制站点，每个站点使用CSMA&#x2F;CA协议通过争用信道来获取发送权，这是802.11定义的默认方式。</li><li>点协调功能PCF(Point Coordination Function)。PCF方式使用集中控制的接入算法 (一般在接入点AP实现集中控制)，是802.11定义的可选方式，在实际中较少使用。</li></ol></li></ol><h3 id="3-1-帧间间隔IFS-InterFrame-Space"><a href="#3-1-帧间间隔IFS-InterFrame-Space" class="headerlink" title="3.1 帧间间隔IFS(InterFrame Space)"></a>3.1 帧间间隔IFS(InterFrame Space)</h3><ol><li><p>802.11标准规定，所有的站点必须在持续检测到信道空闲一段指定时间后才能发送帧，这段时间称为帧间间隔FS。</p></li><li><p>帧间间隔的长短取决于该站点要发送的帧的类型：</p><ol><li>高优先级帧需要等待的时间较短，因此可优先获得发送权：</li><li>低优先级帧需要等待的时间较长。若某个站的低优先级帧还没来得及发送，而其他站的高优先级帧已发送到信道上，则信道变为忙态，因而低优先级帧就只能再推迟发送了。这样就减少了发生碰撞的机会。</li></ol><blockquote><p>无法在无线局域网中使用碰撞检测，所以还使用了停止-等待协议来实现可靠传输</p></blockquote></li><li><p>短帧间间隔（SIFS）和 长时间间隔（DIFS），常用的两种帧间间隔如下：</p><ol><li>短帧间间隔SIFS(28μs),是最短的帧间间隔，用来分隔开属于一次对话的各帧。一个站点应当能够在这段时间内从发送方式切换到接收方式。使用SIFS的帧类型有ACK帧、CTS帧、由过长的MAC帧分片后的数据帧、以及所有回答AP探询的帧和在PCF方式中接入点AP发送出的任何帧。</li><li>DCF帧间间隔DIFS(128μS),它比短帧间间隔SIFS要长得多，在DCF方式中用来发送数据帧和管理帧。</li></ol></li></ol><h3 id="3-2-退避算法"><a href="#3-2-退避算法" class="headerlink" title="3.2 退避算法"></a>3.2 退避算法</h3><ol><li>在执行退避算法时，站点为退避计时器设置一个随机的退避时间<ol><li>当退避计时器的时间减小到零时，就开始发送数据；</li><li>当退避计时器的时间还未减小到零时而信道又转变为忙状态，这时就冻结退避计时器的数值，重新等待信道变为空闲，再经过时间DIFS后，继续启动退避计时器。</li></ol></li><li>在进行第i次退避时，退避时间在时隙编号0,1,……,2^i+2^ -1中随机选择一个，然后乘以基本退避时间（也就是一个时隙的长度）就可以得到随机的退避时间。这样做是为了使不同站点选择相同退避时间的概率减少。当时隙编号达到255时（对应于第6次退避)就不再增加了。</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117150202751.png"></p><ol start="3"><li><p>何时执行退避算法</p><ol><li>在发送数据帧之前检测到信道处于忙状态时</li><li>在每一次重传一个数据帧时</li><li>在每一次成功发送后要连续发送下一个帧时（这是为了避免一个站点长时间占用信道）</li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117145612604.png" alt="image-20241117145612604"></p><ol start="4"><li><p>信道预约</p><ol><li>为了尽可能减少碰撞的概率和降低碰撞的影响，802.11标准允许要发送数据的站点对信道进行预约。</li><li>802.11标准允许要发送数据的站点对信道进行预约，即在发送数据帧之前先发送请求发送RTS帧。在收到响应允许发送CTS帧后，就可发送数据帧。<ol><li>源站在发送数据帧之前先发送一个短的控制帧，称为请求发送RTS(Request To Send),它包括源地址、目的地址以及这次通信（包括相应的确认帧)所需的持续时间。</li><li>若目的站正确收到源站发来的RTS顿，且媒体空闲，就发送一个响应控制帧，称为允许发送CTS(Clear To Send),它也包括这次通信所需的持续时间（从RTS帧中将此持续时间复制到CTS帧中）。</li><li>源站收到CTS帧后，再等待一段时间S1FS后，就可发送其数据帧。</li><li>若目的站正确收到了源站发来的数据帧，在等待时间SFS后，就向源站发送确认帧ACK。</li></ol></li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117150514559.png"></p><ul><li>除源站和目的站以外的其他各站，在收到CTS帧（或数据帧）后就推迟接入到无线局域网中。这样就保证了源站和目的站之间的通信不会受到其他站的干扰。</li><li>如果RTS帧发生碰撞，源站就收不到CTS帧，<strong>需执行退避算法重传RTS帧。</strong></li><li>由于RTS帧和CTS帧很短，发送碰撞的概率、碰撞产生的开销及本身的开销都很小。而对于一般的数据帧，其<strong>发送时延往往大于传播时延</strong>（因为是局域网），碰撞的概率很大，且一旦发生碰撞而导致数据帧重发，则浪费的时间就很多，因此用很小的代价对信道进行预约往往是值得的。802.11标准规定了3种情况供用户选择：<ol><li>使用RTS帧和CTS帧</li><li>不使用RTS帧和CTS帧</li><li>只有当数据帧的长度超过某一数值时才使用RTS帧和CTS帧</li></ol></li></ul><ol start="5"><li>虚拟载波监听<ol><li>除RTS帧和CTS帧会携带通信需要持续的时间，数据帧也能携带通信需要持续的时间，这称为802.11的虚拟载波监听机制。</li></ol></li><li>由于利用虚拟载波监听机制，站点只要监听到RTS帧、CTS帧或数据帧中的任何一个，就能知道信道被占用的持续时间，而不需要真正监听到信道上的信号，因此虚拟载波监听机制能减少隐蔽站带来的碰撞问题。</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117150646126.png" alt="image-20241117150646126"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.5 点对点协议PPP</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-5-%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-5-%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/</url>
    
    <content type="html"><![CDATA[<h1 id="3-5-点对点协议（PPP）"><a href="#3-5-点对点协议（PPP）" class="headerlink" title="3.5 点对点协议（PPP）"></a>3.5 点对点协议（PPP）</h1><h2 id="1-PPP"><a href="#1-PPP" class="headerlink" title="1. PPP"></a>1. PPP</h2><ol><li>点对点协议PPP(Point-to-Point Protocol)是目前使用最广泛的点对点数据链路层协议。</li><li>PPP协议是因特网工程任务组IETF在1992年制定的。经过1993年和1994年的修订，现在的PPP协议已成为因特网的正式标准[RFC1661,RFC1662]。</li><li>PPP协议为在点对点链路传输各种协议数据报提供了一个标准方法，主要由以下三部分构成：<ol><li>对各种协议数据报的封装方法（封装成帧）</li><li>链路控制协议LCP<ol><li>用于建立、配置以及测试数据链路的连接</li></ol></li><li>一套网络控制协议NCPs<ol><li>其中的每一个协议支持不同的网络层协议</li></ol></li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-5-%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/image-20241117132354632.png" alt="image-20241117132354632"></p><h2 id="2-帧格式"><a href="#2-帧格式" class="headerlink" title="2. 帧格式"></a>2. 帧格式</h2><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-5-%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/image-20241117132538280.png"></p><h2 id="3-透明传输"><a href="#3-透明传输" class="headerlink" title="3. 透明传输"></a>3. 透明传输</h2><h3 id="3-1-面向字节的异步链路采用插入转义字符的字节填充法"><a href="#3-1-面向字节的异步链路采用插入转义字符的字节填充法" class="headerlink" title="3.1 面向字节的异步链路采用插入转义字符的字节填充法"></a>3.1 面向字节的异步链路采用插入转义字符的字节填充法</h3><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-5-%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/image-20241117132827308.png"></p><h3 id="3-2-面向比特的同步链路采用插入比特0的比特填充法"><a href="#3-2-面向比特的同步链路采用插入比特0的比特填充法" class="headerlink" title="3.2 面向比特的同步链路采用插入比特0的比特填充法"></a>3.2 面向比特的同步链路采用插入比特0的比特填充法</h3><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-5-%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/image-20241117132942711.png"></p><h2 id="4-差错检测"><a href="#4-差错检测" class="headerlink" title="4. 差错检测"></a>4. 差错检测</h2><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-5-%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/image-20241117133033065.png"></p><h2 id="5-工作状态"><a href="#5-工作状态" class="headerlink" title="5. 工作状态"></a>5. 工作状态</h2><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-5-%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/image-20241117133237492.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.4 可靠传输</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-4-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-4-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/</url>
    
    <content type="html"><![CDATA[<h1 id="3-4-可靠传输"><a href="#3-4-可靠传输" class="headerlink" title="3.4 可靠传输"></a>3.4 可靠传输</h1><h2 id="1-可靠传输的基本概念"><a href="#1-可靠传输的基本概念" class="headerlink" title="1. 可靠传输的基本概念"></a>1. 可靠传输的基本概念</h2><ol><li>使用差错检测技术（例如循环冗余校验CRC)，接收方的数据链路层就可检测出帧在传输过程中是否产生了误码（比特错误）。</li></ol><h3 id="1-1-数据链路层向上层提供的服务类型"><a href="#1-1-数据链路层向上层提供的服务类型" class="headerlink" title="1.1 数据链路层向上层提供的服务类型"></a>1.1 数据链路层向上层提供的服务类型</h3><ol><li><p>不可靠传输服务：</p><ul><li>仅仅丢弃有误码的帧，其他什么也不做</li></ul></li><li><p>可靠传输服务：</p><ul><li>想办法实现发送端发送什么，接收端就收到什么。</li></ul></li><li><p>一般情况下，有线链路的误码率比较低，为了减小开销，并不要求数据链路层向上提供可靠传输服务。即使出现了误码，可靠传输的问题由其上层处理。</p></li><li><p>无线链路易受干扰，误码率比较高，因此要求数据链路层必须向上层提供可靠传输服务。</p></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-4-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/image-20241117101000494.png"></p><h3 id="1-2-传输差错"><a href="#1-2-传输差错" class="headerlink" title="1.2 传输差错"></a>1.2 传输差错</h3><ul><li>比特差错只是传输差错中的一种。</li><li>从整个计算机网络体系结构来看，传输差错还包括分组丢失、分组失序以及分组重复。</li><li>分组丢失、分组失序以及分组重复这些传输差错，一般不会出现在数据链路层，而会出现在其上层。</li><li>可靠传输服务并不仅局限于数据链路层，其他各层均可选择实现可靠传输。</li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-4-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/image-20241117101226369.png"></p><h2 id="2-可靠传输的实现机制"><a href="#2-可靠传输的实现机制" class="headerlink" title="2. 可靠传输的实现机制"></a>2. 可靠传输的实现机制</h2><h3 id="2-1-停止-等待协议（SW）"><a href="#2-1-停止-等待协议（SW）" class="headerlink" title="2.1 停止-等待协议（SW）"></a>2.1 停止-等待协议（SW）</h3><ul><li>属于自动请求重传协议（ARQ）</li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-4-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/image-20230714151117181.png"></p><ol><li><p>接收端检测到数据分组有误码时，将其丢弃并等待发送方的超时重传。但对于误码率较高的点对点链路，为使发送方尽早重传，也可给发送方发送NAK分组。</p></li><li><p>为了让接收方能够判断所收到的数据分组是否是重复的，需要给数据分组编号。由于停止-等待协议的停等特性，只需1个比特编号就够了，即编号0和1</p></li><li><p>为了让发送方能够判断所收到的ACK分组是否是重复的，需要给ACK分组编号，所用比特数量与数据分组编号所用比特数量一样。数据链路层一般不会出现ACK分组迟到的情况，因此在数据链路层实现停止-等待协议可以不用给ACK分组编号。</p></li><li><p>超时计时器设置的重传时间应仔细选择。一般可将重传时间选为略大于“从发送方到接收方的平均往返时间”</p><ol><li>在数据链路层点对点的往返时间比较确定，重传时间比较好设定。</li><li>然而在运输层，由于端到端往返时间非常不确定，设置合适的重传时间有时并不容易。</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-4-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/image-20241117102422301.png"></p></li><li><p>当往返时延RTT远大于数据帧发送时延TD时（例如使用卫星链路），信道利用率非常低。若出现重传，则对于传送有用的数据信息来说，信道利用率还要降低。</p></li><li><p>为了克服停止-等待协议信道利用率很低的缺点，就产生了另外两种协议，即后退N帧协议GBN和选择重传协议SR。</p></li></ol><h3 id="2-2-回退N帧协议（GBN）"><a href="#2-2-回退N帧协议（GBN）" class="headerlink" title="2.2 回退N帧协议（GBN）"></a>2.2 回退N帧协议（GBN）</h3><ul><li>是一种滑动窗口协议</li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-4-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/image-20230714153916944.png"></p><ol><li>可退N帧协议在流水线传输的基础上利用发送窗回来限制发送方连续发送数据分组的数量，是一种连续ARQ协议。</li><li>在协议的工作过程中发送窗口和接收窗口不断向前滑动，因此这类协议又称为滑动窗回协议。</li><li>由于回退N帧协议的特性，当通信线路质量不好时。其信道利用率并不比停止等待协议高，</li></ol><h3 id="2-3-选择重传协议SR"><a href="#2-3-选择重传协议SR" class="headerlink" title="2.3 选择重传协议SR"></a>2.3 选择重传协议SR</h3><ol><li>回退N帧协议的接收窗口尺寸W只能等于1，因此接收方只能按序接收正确到达的数据分组。</li><li>一个数据分组的误码就会导致其后续多个数据分组不能被接收方按序接收而丢弃（尽管它们无乱序和误码)。这必然会造成发送方对这些数据分组的超时重传，显然这是对通信资源的极大浪费。</li><li>为了进一步提高性能，可设法只重传出现误码的数据分组。因此，接收窗口的尺寸W不应再等于1（而应大于1），以便接收方先收下失序到达但无误码并且序号落在接收窗口内的那些数据分组，等到所缺分组收齐后再一并送交上层。这就是选择重传协议。</li></ol><ul><li>注意：<ul><li>选择重传协议为了使发送方仅重传出现差错的分组，接收方不能再采用累积确认，而需要对每个正确接收到的数据分组进行逐一确认！</li></ul></li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-4-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/image-20230714174218114.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.3 差错检测</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-3-%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-3-%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="3-3-差错检测"><a href="#3-3-差错检测" class="headerlink" title="3.3 差错检测"></a>3.3 差错检测</h1><ul><li>实际的通信链路都不是理想的，比特在传输过程中可能会产生差错；1可能会变成0，而0也可能变成1。这称为比特差错。</li></ul><h2 id="1-误码率"><a href="#1-误码率" class="headerlink" title="1. 误码率"></a>1. 误码率</h2><ul><li><p>在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率BER(Bit Error Rate)。</p></li><li><p>使用<strong>差错检测码</strong>来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一。</p></li></ul><h2 id="2-奇偶校验"><a href="#2-奇偶校验" class="headerlink" title="2. 奇偶校验"></a>2. 奇偶校验</h2><ul><li>在待发送的数据后面添加1位奇偶校验位，使整个数据（包括所添加的校验位在内）中”1”的个数为奇数（奇校验）或偶数（偶校验）。</li></ul><ol><li>如果有奇数个位发生误码，则奇偶性发生变化，可以检查出误码；</li><li>如果有偶数个位发生误码，则奇偶性不发生变化，不能检查出误码</li></ol><ul><li>缺陷：漏检率较高</li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-3-%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B/image-20241117100050296.png"></p><h2 id="3-循环冗余校验CRC-Cyclic-Redundancy-Check"><a href="#3-循环冗余校验CRC-Cyclic-Redundancy-Check" class="headerlink" title="3. 循环冗余校验CRC(Cyclic Redundancy Check)"></a>3. 循环冗余校验CRC(Cyclic Redundancy Check)</h2><ol><li>收发双方约定好一个生成多项式G(x)</li><li>发送方基于待发送的数据和生成多项式计算出差错检测码（冗余码），将其添加到待传输数据的后面一起传输</li><li>接收方通过生成多项式来计算收到的数据是否产生了误码</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-3-%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B/image-20241117100258487.png" alt="CRC"></p><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-3-%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B/image-20241117100334787.png" alt="生成多项式"></p><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-3-%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B/image-20241117100543010.png"></p><ul><li><strong>做除法的意思是，做异或运算</strong></li></ul><ol><li>检错码只能检测出帧在传输过程中出现了差错，但并不能定位错误，因此无法纠正错误。</li><li>要想纠正传输中的差错，可以使用冗余信息更多的纠错码进行前向纠错。但纠错码的开销比较大，在计算机网络中较少使用。</li><li>循环冗余校验CRC有很好的检错能力（漏检率非常低），虽然计算比较复杂，但非常易于用硬件实现，因此被广泛应用于数据链路层。</li><li>在计算机网络中通常采用我们后续课程中将要讨论的检错重传方式来纠正传输中的差错，或者仅仅是丢弃检测到差错的帧，这取决于数据链路层向其上层提供的是可靠传输服务还是不可靠传输服务。</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.2 封装成帧</title>
    <link href="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-2-%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7/"/>
    <url>/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-2-%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="3-2-封装成帧"><a href="#3-2-封装成帧" class="headerlink" title="3.2 封装成帧"></a>3.2 封装成帧</h1><h2 id="1-帧"><a href="#1-帧" class="headerlink" title="1. 帧"></a>1. 帧</h2><ul><li><p>封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧。</p></li><li><p>帧头和帧尾的作用之一就是帧定界.</p></li></ul><p><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-2-%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7/image-20241117092740511.png" alt="帧"></p><h2 id="2-透明传输"><a href="#2-透明传输" class="headerlink" title="2. 透明传输"></a>2. 透明传输</h2><ul><li>数据链路层对上层交付的传输数据没有任何限制，就好像数据链路层不存在一样。</li></ul><ol><li>面向字节的物理链路使用字节填充（或称字符填充）的方法实现透明传输</li><li>面向比特的物理链路使用比特填充的方法实现透明传输。</li><li>为了提高帧的传输效率，应当使帧的数据部分的长度尽可能大些。</li></ol><p><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-2-%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7/image-20241117093119688.png" alt="透明传输"></p><ul><li>考虑到差错控制等多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即最大传送单元MTU (Maximum Transfer Unit)</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.1 数据链路层概述</title>
    <link href="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-1-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-1-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="3-1-数据链路层概述"><a href="#3-1-数据链路层概述" class="headerlink" title="3.1 数据链路层概述"></a>3.1 数据链路层概述</h1><ul><li>数据链路层以帧为单位传输和处理数据。</li></ul><ol><li>链路 (Link)</li></ol><ul><li>就是从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换结点。</li></ul><ol start="2"><li>数据链路(Data Link)</li></ol><ul><li>是指把实现通信协议的硬件和软件加到链路上，就构成了数据链路。</li></ul><h2 id="1-使用点对点信道的数据链路层三个重要问题"><a href="#1-使用点对点信道的数据链路层三个重要问题" class="headerlink" title="1. 使用点对点信道的数据链路层三个重要问题"></a>1. 使用点对点信道的数据链路层三个重要问题</h2><ol><li>封装成帧</li><li>差错检测</li><li>可靠传输<ol><li>尽管误码是不能完全避免的，但若能实现发送方发送什么接收方就能收到什么，就称为可靠传输。</li></ol></li></ol><h2 id="2-使用广播信道的数据链路层"><a href="#2-使用广播信道的数据链路层" class="headerlink" title="2. 使用广播信道的数据链路层"></a>2. 使用广播信道的数据链路层</h2><ol><li>共享式以太网的媒体接入控制协议CSMA&#x2F;CD</li><li>802.11局域网的媒体接入控制协议CSMA&#x2F;CA</li></ol><h2 id="3-数据链路层的互连设备"><a href="#3-数据链路层的互连设备" class="headerlink" title="3. 数据链路层的互连设备"></a>3. 数据链路层的互连设备</h2><ol><li>网桥和交换机的工作原理</li><li>集线器(物理连接设备)与交换机的区别</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.5 信道的极限容量</title>
    <link href="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-5-%E4%BF%A1%E9%81%93%E7%9A%84%E6%9E%81%E9%99%90%E5%AE%B9%E9%87%8F/"/>
    <url>/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-5-%E4%BF%A1%E9%81%93%E7%9A%84%E6%9E%81%E9%99%90%E5%AE%B9%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="2-5-信道极限容量"><a href="#2-5-信道极限容量" class="headerlink" title="2.5 信道极限容量"></a>2.5 信道极限容量</h1><ul><li>在信道带宽一定的情况下，根据奈氏准则和香农公式，要想提高信息的传输速率就必须采用多元制（更好的调制方法）和努力提高信道中的信噪比。</li></ul><h2 id="1-奈式准则"><a href="#1-奈式准则" class="headerlink" title="1. 奈式准则"></a>1. 奈式准则</h2><ul><li>理想低通信道的最高码元传输速率&#x3D;2W Baud&#x3D;2W(单位：码元&#x2F;秒)</li><li>理想带通信道的最高码元传输速率&#x3D;W Baud&#x3D;W(单位：码元&#x2F;秒)</li></ul><h2 id="2-香农公式-单位-bit-s"><a href="#2-香农公式-单位-bit-s" class="headerlink" title="2. 香农公式 单位:bit&#x2F;s"></a>2. 香农公式 单位:bit&#x2F;s</h2><p>$$<br>c &#x3D; W \times log_2(1 + \frac{S}{N})\<br>$$</p><p><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-5-%E4%BF%A1%E9%81%93%E7%9A%84%E6%9E%81%E9%99%90%E5%AE%B9%E9%87%8F/image-20241116162248949.png"></p><p><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-5-%E4%BF%A1%E9%81%93%E7%9A%84%E6%9E%81%E9%99%90%E5%AE%B9%E9%87%8F/image-20241116162436085.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.4 编码与调制</title>
    <link href="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-4-%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6/"/>
    <url>/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-4-%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="2-4-编码与调制"><a href="#2-4-编码与调制" class="headerlink" title="2.4 编码与调制"></a>2.4 编码与调制</h1><p><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-4-%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6/image-20241116160902949.png"></p><h2 id="1-常用编码"><a href="#1-常用编码" class="headerlink" title="1. 常用编码"></a>1. 常用编码</h2><ul><li>码元：在使用时间域的波形表示数字信号时代表不同离散数值的基本波形。</li></ul><ol><li><p>不归零编码（存在同步问题）</p><ul><li>需要额外一根传输线来传输时钟信号使发送方和接收方同步</li></ul></li><li><p>归零编码（自同步，编码效率低）</p></li><li><p>曼彻斯特编码（传统以太网）</p></li></ol><p><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-4-%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6/image-20241116161158338.png"></p><h2 id="2-编码与调制"><a href="#2-编码与调制" class="headerlink" title="2. 编码与调制"></a>2. 编码与调制</h2><h3 id="2-1-基本调制方法"><a href="#2-1-基本调制方法" class="headerlink" title="2.1 基本调制方法"></a>2.1 基本调制方法</h3><p><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-4-%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6/image-20241116161357102.png"></p><ol><li>调幅、调频、调相</li><li>混合调制</li></ol><p><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-4-%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6/image-20241116161941515.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.3 传输方式</title>
    <link href="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-3-%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F/"/>
    <url>/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-3-%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="2-3-传输方式"><a href="#2-3-传输方式" class="headerlink" title="2.3 传输方式"></a>2.3 传输方式</h1><h2 id="1-串并行"><a href="#1-串并行" class="headerlink" title="1. 串并行"></a>1. 串并行</h2><ol><li><p>串行传输</p></li><li><p>并行传输</p></li></ol><h2 id="2-同步异步"><a href="#2-同步异步" class="headerlink" title="2. 同步异步"></a>2. 同步异步</h2><ol><li><p>同步传输</p></li><li><p>异步传输</p></li><li><p>收发双方时钟同步的方法</p></li></ol><p></p><ul><li>外同步：在收发双方之间添加一条单独的时钟信号线</li><li>内同步：发送端将时钟同步信号编码到发送数据中一起传输 (例如曼彻斯特编码)</li></ul><p><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-3-%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F/image-20241116160018725.png" alt="image-20241116160018725"></p><h2 id="3-单双工"><a href="#3-单双工" class="headerlink" title="3.  单双工"></a>3.  单双工</h2><ul><li>单向通信（单工）广播</li><li>双向交替通信（半双工） 对讲机</li><li>双向同时通信（全双工）电话</li></ul><p><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-3-%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F/image-20241116160356202.png" alt="image-20241116160356202"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.2 物理层下面的传输媒体</title>
    <link href="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-2-%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93/"/>
    <url>/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-2-%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<h1 id="2-2-物理层下面的传输媒体"><a href="#2-2-物理层下面的传输媒体" class="headerlink" title="2.2 物理层下面的传输媒体"></a>2.2 物理层下面的传输媒体</h1><h2 id="1-传输媒体"><a href="#1-传输媒体" class="headerlink" title="1. 传输媒体"></a>1. 传输媒体</h2><h3 id="1-1-导引型传输媒体"><a href="#1-1-导引型传输媒体" class="headerlink" title="1.1 导引型传输媒体"></a>1.1 导引型传输媒体</h3><ol><li><p>双绞线</p><ol><li>绞合的作用<ul><li>抵御部分来自外界的电磁波干扰</li><li>减少相邻导线的电磁干扰</li></ul></li><li><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-2-%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93/image-20241116144027376.png" alt="image-20241116144027376"></li></ol></li><li><p>同轴电缆</p><ul><li>基带同轴电缆(50Ω) 数字传输，过去用于局域网</li></ul></li></ol><ul><li>宽带同轴电缆(75Ω)，模拟传输，目前主要用于有线电视<ul><li>同轴电缆价格较贵且布线不够灵活和方便，随着集线器的出现，在局域网领域基本上都是采用双绞线作为传输媒体。</li></ul></li></ul><ol start="3"><li><p>光纤</p><ol><li><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-2-%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93/image-20241116144053439.png" alt="image-20241116144053439"></li><li>纤芯直径<ul><li>多模光纤：50微米，62.5微米</li><li>单模光纤：9微米，包层直径125微米</li></ul></li><li>工作波长<ul><li>0.85微米（衰减较大）</li><li>1.30微米（衰减较小）</li><li>1.55微米（衰减较小）</li></ul></li><li>光纤的优点<ul><li>通信容量大 (25000~30000GHz的带宽)</li><li>传输损耗小，远距离传输时更加经济。</li><li>抗雷电和电磁干扰性能好。这在大电流脉冲干扰的环境下尤为重要</li><li>无串音干扰，保密性好，不易被窃听。</li><li>体积小，重量轻。</li></ul></li><li>光纤的缺点<ul><li>割接需要专用设备</li><li>光电接口价格较贵</li></ul></li><li><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-2-%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93/image-20241116144351388.png" alt="image-20241116144351388"></li><li><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-2-%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93/image-20241116144534158.png" alt="image-20241116144534158"></li></ol></li><li><p>电力线</p></li></ol><h3 id="1-2-非导引型传输媒体"><a href="#1-2-非导引型传输媒体" class="headerlink" title="1.2 非导引型传输媒体"></a>1.2 非导引型传输媒体</h3><ol><li>微波通信（2~40GHz）</li><li>红外线</li><li>可见光</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.1 物理层的基本概念</title>
    <link href="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-1-%E7%89%A9%E7%90%86%E5%B1%82%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-1-%E7%89%A9%E7%90%86%E5%B1%82%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="2-1-物理层的基本概念"><a href="#2-1-物理层的基本概念" class="headerlink" title="2.1 物理层的基本概念"></a>2.1 物理层的基本概念</h1><h2 id="1-传输媒体"><a href="#1-传输媒体" class="headerlink" title="1. 传输媒体"></a>1. 传输媒体</h2><ol><li>导引型传输媒体<ul><li>双绞线</li><li>同轴电缆</li><li>光纤</li><li>电力线</li></ul></li><li>非导引型传输媒体<ul><li>微波通信（2~40GHz）</li><li>红外线</li><li>可见光</li></ul></li></ol><h2 id="2-主要任务"><a href="#2-主要任务" class="headerlink" title="2. 主要任务"></a>2. 主要任务</h2><blockquote><ol><li>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流。</li><li>物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体是什么。</li></ol></blockquote><ol><li><p>机械特性</p><blockquote><p> 指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置</p></blockquote></li><li><p>电气特性</p><blockquote><p>指明在接口电缆的各条 线上出现的电压的范围。</p></blockquote></li><li><p>功能特性</p><blockquote><p>指明某条线上出现的某一电平的电压表示何种意义。</p></blockquote></li><li><p>过程特性</p><blockquote><p>指明对于不同功能的各种可能事件的出现顺序。</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.6 计算机体系结构</title>
    <link href="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <url>/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="1-6-计算机网络体系结构"><a href="#1-6-计算机网络体系结构" class="headerlink" title="1.6 计算机网络体系结构"></a>1.6 计算机网络体系结构</h1><h2 id="1-常见的计算机网络体系结构"><a href="#1-常见的计算机网络体系结构" class="headerlink" title="1. 常见的计算机网络体系结构"></a>1. 常见的计算机网络体系结构</h2><ol><li><p>OSI体系结构（开放系统互连参考模型）</p></li><li><p>TCP&#x2F;IP体系结构</p></li></ol><p><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20241115214722039.png"></p><p><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20241115214533994.png"></p><ul><li>IP协议可以为各种网络应用提供服务 (Everything over IP)</li><li>使用IP协议互连不同的网络接口 (IP over everything)</li></ul><h2 id="2-计算机网络体系结构分层的必要性"><a href="#2-计算机网络体系结构分层的必要性" class="headerlink" title="2. 计算机网络体系结构分层的必要性"></a>2. 计算机网络体系结构分层的必要性</h2><p>总线型网络</p><ul><li>如何标识网络中的各主机（主机编址问题，例如MAC地址）</li><li>如何从信号所表示的一连串比特流中区分出地址和数据</li><li>如何协调各主机争用总线</li></ul><blockquote><p>“分层“可将庞大而复杂的问题，转化为若干较小的局部问题，而这些较小的局部问题就比较易于研究和处理。</p></blockquote><table><thead><tr><th align="center">体系结构</th><th align="center">解决问题</th></tr></thead><tbody><tr><td align="center">应用层</td><td align="center">解决通过应用进程的交互来实现特定网络应用的问题</td></tr><tr><td align="center">表示层</td><td align="center">解决通信双方交换信息的表示问题</td></tr><tr><td align="center">会话层</td><td align="center">解决进程之间进行会话问题</td></tr><tr><td align="center">运输层</td><td align="center">解决进程之间基于网络的通信问题</td></tr><tr><td align="center">网络层</td><td align="center">解决分组在多个网络上传输（路由）问题</td></tr><tr><td align="center">数据链路层</td><td align="center">解决分组在一个网络（或一段链路）上传输的问题</td></tr><tr><td align="center">物理层</td><td align="center">解决使用何种信号来传输比特的问题</td></tr></tbody></table><ul><li>表示层的任务是实现与数据表示相关的功能，主要包括数据字符集的转换、数据格式化、文本压缩、数据加密以及解密等工作。</li></ul><h2 id="3-计算机网络体系结构中的专用术语"><a href="#3-计算机网络体系结构中的专用术语" class="headerlink" title="3. 计算机网络体系结构中的专用术语"></a>3. 计算机网络体系结构中的专用术语</h2><table><thead><tr><th align="center">术语</th><th align="left">解释</th></tr></thead><tbody><tr><td align="center">实体</td><td align="left">任何可发送或接收信息的硬件或软件进程</td></tr><tr><td align="center">对等实体</td><td align="left">收发双方相同层次中的实体</td></tr><tr><td align="center">协议</td><td align="left">控制两个对等实体进行逻辑通信的规则的集合</td></tr><tr><td align="center">协议三要素</td><td align="left">语法，语义，同步</td></tr><tr><td align="center">语法</td><td align="left">定义所交换信息的格式</td></tr><tr><td align="center">语义</td><td align="left">定义收发双方所要完成的操作</td></tr><tr><td align="center">同步</td><td align="left">定义收发双方的时序关系<br><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20241115225450275.png" alt="image-20241115225450275"></td></tr><tr><td align="center">服务</td><td align="left">在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务<br><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20241115225634091.png" alt="image-20241115225634091"></td></tr><tr><td align="center">服务访问点</td><td align="left">在同一系统中相邻两层的实体交换信息的逻辑接口，用于区分不同的服务类型<br>1. 数据链路层的服务访问点为帧的“类型”字段。<br>2. 网络层的服务访问点为IP数据报首部中的“协议字段”。<br>3. 运输层的服务访问点为“端口号”</td></tr><tr><td align="center">服务原语</td><td align="left">上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令称为服务原语</td></tr><tr><td align="center">协议数据单元PDU</td><td align="left">对等层次之间传送的数据包称为该层的协议数据单元</td></tr><tr><td align="center">服务数据单元SDU</td><td align="left">同一系统内，层与层之间交换的数据包称为服务数据单元<br>多个SDU可以合成为一个PDU；一个SDU也可划分为几个PDU</td></tr></tbody></table><p><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20241115225112571.png" alt="实体"></p><p><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20241115225152230.png" alt="协议"></p><ol><li>协议是“水平的”，服务是“垂直的</li><li>实体看得见相邻下层所提供的服务，但并不知道实现该服务的具体协议。也就是说，下面的协议对上面的实体是”透明”的。</li></ol><p><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20241115225809482.png" alt="SDU PDU"></p><h2 id="练习题："><a href="#练习题：" class="headerlink" title="练习题："></a>练习题：</h2><ol><li><p>在OSI参考模型中，自下而上第一个提供端到端服务的层次是：（B）<br>A.数据链路层 B.传输层 C.会话层 D.应用层</p><ul><li><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20241115230545942.png" alt="image-20241115230545942"></li></ul></li><li><p>下列选项中，不属于网络体系结构所描述的内容是 C<br>A.网络的层次 B.每一层使用的协议 C.协议的内部实现细节 D.每一层必须完成的功能</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.5 计算机网络的性能指标</title>
    <link href="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-5-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/"/>
    <url>/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-5-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<h1 id="1-5-计算机网络的性能指标"><a href="#1-5-计算机网络的性能指标" class="headerlink" title="1.5 计算机网络的性能指标"></a>1.5 计算机网络的性能指标</h1><table><thead><tr><th align="center">指标</th><th align="left">评测</th></tr></thead><tbody><tr><td align="center">速率</td><td align="left">连接在计算机网络上的主机在数字信道上传送比特的速率，也称为比特率或数据率<br>bit&#x2F;s（b&#x2F;s，bps)，kb&#x2F;s，Mb&#x2F;s，Gb&#x2F;s</td></tr><tr><td align="center">带宽</td><td align="left">用来表示网络的通信线路所能传送数据的能力，单位为Hz<br>因此网络带宽表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据量”<br>与速率指标相同</td></tr><tr><td align="center">吞吐量</td><td align="left">吞吐量表示在单位时间内通过某个网络（或信道、接口）的数据量。<br>吞吐量被经常用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。<br>吞吐量受网络的带宽或额定速率的限制。</td></tr><tr><td align="center">时延</td><td align="left">网络时延由三部分组成，分别为发送时延，传播时延，处理时延<br>网卡的发送速率，信道带宽，交换机的接口速率共同决定了发送时延<br><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-5-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/image-20241115211453147.png"></td></tr><tr><td align="center">时延带宽积</td><td align="left">1. 若发送端连续发送数据，则在所发送的第一个比特即将到达终点时，<br>     发送端就已经发送了时延带宽积个比特。<br>2. 链路的时延带宽积又称为以比特为单位的链路长度。</td></tr><tr><td align="center">往返时间（RTT）</td><td align="left">双向交互一次所需的时间<br>从源主机发送分组开始，直到源主机收到来自目的主机的确认分组为止</td></tr><tr><td align="center">利用率</td><td align="left">分为信道利用率，网络利用率<br>信道利用率：表示某信道有百分之几的时间是被利用的<br>网络利用率：全网络的信道利用率加权平均<br>信道利用率并非越高越好，高利用率会引发高时延</td></tr><tr><td align="center">丢包率</td><td align="left">丢包率即分组丢失率，是指在一定的时间范围内，传输过程中丢失的分组数量与总分组数量的比率。<br>丢包率具体可分为接口丢包率、结点丢包率、链路丢包率、路径丢包率、网络丢包率等<br></td></tr></tbody></table><ol><li><p>补充</p><ol><li>时延计算公式</li></ol></li></ol><p>$$<br>发送时延 &#x3D; \frac{分组长度}{发送速率}\\<br>$$</p><p>$$<br>发送时延 &#x3D; \frac{信道长度}{电磁波传播速率}<br>$$</p><ol start="2"><li>时延带宽积</li></ol><p>$$<br>时延带宽积 &#x3D; 传播时延 \times 带宽<br>$$</p><ul><li>处理时延一般不计算</li></ul><ol start="3"><li><p>网络当前时延与信道利用率之间的关系<br>$$<br>D为网络当前时延，D_0为网络空闲时的时延，U为信道利用率\<br>$$</p></li><li><p>丢包率计算公式<br>$$<br>丢包率 &#x3D; \frac{一定时间范围内丢失的分组数量}{总分组数量}<br>$$</p><p>$$<br>D &#x3D; \frac{D_0}{1-U}<br>$$</p></li><li><p>分组丢失的两种情况</p><ol><li>分组在传输过程中出现误码，被结点丢弃</li><li>分组到达一台队列已满的分组交换机时被丢弃，在通信量较大时就可能造成网络拥塞。</li></ol></li><li><p>丢包率反映了网络的拥塞情况</p><ol><li>无拥塞时路径丢包率为0</li><li>轻度拥塞时路径丢包率为1%~4%</li><li>严重拥塞时路径丢包率为5%~15%</li></ol></li><li><p>n个分组，m段链路，忽略处理时延，总时延的计算（假设分组等长，各链路长度相同，带宽相同）<br>$$<br>总时延 &#x3D; n个分组的发送时延 + 1个分组的发送时延 \times (m-1) + 1段链路的传播时延 \times m<br>$$</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.4 计算机网络的定义和分类</title>
    <link href="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%86%E7%B1%BB/"/>
    <url>/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-4-计算机网络的定义和分类"><a href="#1-4-计算机网络的定义和分类" class="headerlink" title="1.4 计算机网络的定义和分类"></a>1.4 计算机网络的定义和分类</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><ol><li><p>简单定义：一些<strong>互相连接</strong>的，<strong>自治</strong>的计算机的<strong>集合</strong></p><blockquote><p>互连：是指计算机之间可以通过有线或无线的方式进行数据通信；<br>自治：是指独立的计算机，它有自己的硬件和软件，可以单独运行使用；<br>集合：是指至少需要两台计算机。</p></blockquote></li><li><p>计算机网络的较好的定义</p><blockquote><p>计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号)。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</p></blockquote><ol><li>计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机等智能硬件</li><li>计算机网络并非专门用来传送数据，而是能够支持很多种的应用（包括今后可能出现的名种应用)</li></ol></li></ol><h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h2><h3 id="2-1-按交换技术分类"><a href="#2-1-按交换技术分类" class="headerlink" title="2.1 按交换技术分类"></a>2.1 按交换技术分类</h3><ol><li>电路交换网路</li><li>报文交换网络</li><li>分组交换网络</li></ol><h3 id="2-2-按使用者分类"><a href="#2-2-按使用者分类" class="headerlink" title="2.2 按使用者分类"></a>2.2 按使用者分类</h3><ol><li><p>公用网</p><blockquote><p>电信公司出资建造,给电信公司缴纳费用即可使用</p></blockquote></li><li><p>专用网</p><blockquote><p>不向外人提供服务</p></blockquote></li></ol><h3 id="2-3-按传输介质分类"><a href="#2-3-按传输介质分类" class="headerlink" title="2.3 按传输介质分类"></a>2.3 按传输介质分类</h3><ol><li><p>有线网路</p><blockquote><p>包括双绞线网络,光纤网络等</p></blockquote></li><li><p>无线网络</p><blockquote><p>WIFI应用普遍</p></blockquote></li></ol><h3 id="2-4-按覆盖范围分类"><a href="#2-4-按覆盖范围分类" class="headerlink" title="2.4 按覆盖范围分类"></a>2.4 按覆盖范围分类</h3><ol><li><p>广域网(WAN)</p><blockquote><p>可以覆盖一个国家,地区甚至几个洲</p><p>WAN是因特网的核心部分,为核心路由器提供远距离高速连接</p></blockquote></li><li><p>城域网(MAN)</p><blockquote><p>覆盖一个街区,或几个城市</p><p>通常作为城市骨干网,互连学校,企业,机构的局域网</p></blockquote></li><li><p>局域网(LAN)</p><blockquote><p>覆盖一个实验室,一幢楼,一个校园等</p></blockquote></li><li><p>个域网(PAN)</p><blockquote><p>即无线个人区域网(WPAN),在各人工作的地方,将属于个人使用的电子设备用无线技术连接起来的网络</p></blockquote></li></ol><h3 id="2-5-按拓扑结构分类"><a href="#2-5-按拓扑结构分类" class="headerlink" title="2.5 按拓扑结构分类"></a>2.5 按拓扑结构分类</h3><ol><li>总线型网络</li></ol><p><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%86%E7%B1%BB/image-20230712140101315.png"></p><ol start="2"><li>星型网络</li></ol><p><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%86%E7%B1%BB/image-20230712140145867.png"></p><ol start="3"><li>环型网络</li></ol><p><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%86%E7%B1%BB/image-20230712140251758.png"></p><ol start="4"><li>网状型网络</li></ol><p><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%86%E7%B1%BB/image-20230712140454142.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.3 三种交换方式</title>
    <link href="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-3-%E4%B8%89%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F/"/>
    <url>/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-3-%E4%B8%89%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-3-三种交换方式"><a href="#1-3-三种交换方式" class="headerlink" title="1.3 三种交换方式"></a>1.3 三种交换方式</h1><h2 id="1-电路交换-Circuit-Switching"><a href="#1-电路交换-Circuit-Switching" class="headerlink" title="1. 电路交换(Circuit Switching)"></a>1. 电路交换(Circuit Switching)</h2><ul><li>电话交换机接通电话线的方式称为电路交换，中间设备是电话交换机</li><li>从通信资源的分配角度来看，交换(Switching)就是按照某种方式动态地分配传输线路的资源；</li><li>当使用电路交换来传送计算机数据时，其线路的传输效率往往很低。</li><li>不适合计算机传输数据，因为占用通信资源，却迟迟不使用，造成通信资源的浪费</li></ul><p><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-3-%E4%B8%89%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F/image-20241115203653573.png" alt="电话交换机"></p><ol><li>电话交换的三个步骤<ol><li>建立连接（分配通信资源）</li><li>通话（一直占用通信资源）</li><li>释放连接（归还通信资源）</li></ol></li><li>优点<ol><li>通信时延小</li><li>有序传输</li><li>没有冲突</li><li>适用范围广</li><li>实时性强</li><li>控制简单</li></ol></li><li>缺点<ol><li>建立连接时间长</li><li>线路独占，使用效率低</li><li>灵活性差</li><li>难以规格化</li></ol></li></ol><h2 id="2-分组交换-Packet-Switching-※"><a href="#2-分组交换-Packet-Switching-※" class="headerlink" title="2. 分组交换(Packet Switching)※"></a>2. 分组交换(Packet Switching)※</h2><p><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-3-%E4%B8%89%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F/image-20241115204514266.png"></p><blockquote><p>通常把表示消息的整块数据称为一个报文</p></blockquote><ol><li><p>步骤</p><ol><li><p>发送方：构造分组，发送分组</p></li><li><p>路由器：缓存分组，转发分组</p></li><li><p>接收方：接收分组，还原报文</p></li></ol></li><li><p>优点</p><ol><li>无需建立连接</li><li>线路利用率高</li><li>简化了存储管理</li><li>加速传输</li><li>减少出错概率和重发数据量</li></ol></li><li><p>缺点</p><ol><li><p>引起了转发时延</p></li><li><p>需要传输额外的信息量</p></li><li><p>对于数据报服务，存在失序、丢失或重复分组的问题;</p><p>对于虚电路服务存在呼叫建立、数据传输和虚电路释放三个过程</p></li></ol></li></ol><h2 id="3-报文交换-Message-Switching"><a href="#3-报文交换-Message-Switching" class="headerlink" title="3. 报文交换(Message Switching)"></a>3. 报文交换(Message Switching)</h2><blockquote><p>与分组交换类似，但对报文大小没有限制，也不分组，现代已很少使用该方法</p></blockquote><ol><li><p>优点</p><ol><li>无需建立连接</li><li>动态分配线路</li><li>提高线路可靠性</li><li>提高线路利用率</li><li>提供多目标服务</li></ol></li><li><p>缺点</p><ol><li>引起了转发时延</li><li>需要较大存储缓存空间</li><li>需要传输额外的信息量</li></ol></li></ol><p><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-3-%E4%B8%89%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F/image-20241115204815895.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HCTA：多智能体强化学习中的分层合作任务分配</title>
    <link href="/2024/11/15/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/HCTA%EF%BC%9A%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%88%86%E5%B1%82%E5%90%88%E4%BD%9C%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/"/>
    <url>/2024/11/15/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/HCTA%EF%BC%9A%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%88%86%E5%B1%82%E5%90%88%E4%BD%9C%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="HCTA-Hierarchical-Cooperative-Task-Allocation-in-Multi-Agent-Reinforcement-Learning"><a href="#HCTA-Hierarchical-Cooperative-Task-Allocation-in-Multi-Agent-Reinforcement-Learning" class="headerlink" title="HCTA:Hierarchical Cooperative Task Allocation in Multi-Agent Reinforcement Learning"></a>HCTA:Hierarchical Cooperative Task Allocation in Multi-Agent Reinforcement Learning</h1><h2 id="1-主要内容"><a href="#1-主要内容" class="headerlink" title="1. 主要内容"></a>1. 主要内容</h2><ol><li><strong>子任务选择</strong>：</li></ol><ul><li>基于行动链的长期行为特征动态选择每个智能体适合的子任务。</li></ul><ol start="2"><li><strong>层次化策略学习</strong>：</li></ol><ul><li>结合上述子任务分解和选择，形成层次化合作策略学习框架。在上层动态选择子任务，并在下层根据上层的任务分配结果指导具体决策策略的学习。</li></ul><ol start="3"><li><strong>双时序分辨率框架</strong>：</li></ol><ul><li>HCTA使用双时序分辨率框架，在低时序分辨率的时标上进行任务选择，然后在高时序分辨率的时标上进行策略学习。</li></ul><ol start="4"><li><strong>实验验证</strong>：</li></ol><ul><li>在StarCraft II环境中进行广泛的实验，以评估HCTA框架在不同难度级别上的表现，并与其他基线算法进行比较。</li></ul><p>这些方法共同构成了文章提出的HCTA框架，旨在通过层次化和动态的任务分配来提高多智能体系统在复杂任务中的合作效率和学习效果。</p><ul><li>在本文中，我们的目标是使<strong>个体的子组能够通过人类在处理复杂任务时使用的分解思想来学习解决不同的子任务。</strong></li></ul><h2 id="2-子任务分解"><a href="#2-子任务分解" class="headerlink" title="2. 子任务分解"></a>2. 子任务分解</h2><p>在文章中提到的HCTA（Hierarchical Cooperative Task Allocation）框架中，子任务的分解是通过以下步骤实现的：</p><ol><li><strong>行动表示学习（Action Representation Learning）</strong>：</li></ol><ul><li>首先，框架通过行动表示学习来实现子任务的分解。这是通过创建一个能够反映行动对环境和其他智能体影响的表示（即<code>za = fθ(a; θe)</code>）来完成的，其中<code>za</code>是行动的表示，<code>a</code>是行动本身，<code>θ</code>是学习到的参数。</li></ul><ol start="2"><li><strong>行动空间聚类（Action Space Clustering）</strong>：</li></ol><ul><li>基于行动表示的结果，整个行动空间被聚类分解为多个子行动空间，每个子行动空间对应一个子任务。这样的分解减少了每个子任务的行动空间维度，使得相应的智能体在具有相似效果的行动空间中搜索。</li></ul><ol start="3"><li><strong>行动链模型（Action Chain Model）</strong>：</li></ol><ul><li>使用行动链模型来学习行动编码器。每个智能体选择多个时间步的行动表示作为行动链编码器的输入。通过自注意力机制，智能体学习与自身属性相关的多步行动的累积效应。</li></ul><ol start="4"><li><strong>子任务定义（Subtask Definition）</strong>：</li></ol><ul><li>文章中对子任务的定义是：对于一个给定的合作多智能体任务<code>G</code>，一个角色<code>ρi</code>是一个包含子任务<code>ϕi</code>的元组，<code>ϕi</code>由<code>⟨Ai, Ii, S, P, R, Ωi, O, γ⟩</code>组成，其中<code>Ai</code>是子任务的行动空间，<code>Ii</code>是智能体的子集，且满足<code>Ii ⊂ I</code>，<code>∪iIi = I</code>，<code>Ii ∩ Ij = ∅</code>（对于<code>i ≠ j</code>）。</li></ul><ol start="5"><li><strong>长期行为链（Long-term Behavior Chain）</strong>：</li></ol><ul><li>基于行动链的结果，生成反映智能体行为特征的长期行动链。这个长期行为链用于动态选择适合每个智能体的子任务。</li></ul><p>通过这些步骤，HCTA框架能够将复杂的多智能体任务分解为更小、更易于管理的子任务，每个子任务都涉及一个较小的行动观察空间，从而使智能体能够更有效地专注于特定的子任务。这种分解方法不仅提高了任务分配的效率，还降低了计算复杂度，并使得智能体能够更好地协作以完成复杂的任务。</p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
      <category>多智能体强化学习任务分配</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
      <tag>科研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向兵棋推演的强化学习分层任务优化技术研究</title>
    <link href="/2024/11/15/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E9%9D%A2%E5%90%91%E5%85%B5%E6%A3%8B%E6%8E%A8%E6%BC%94%E7%9A%84%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%88%86%E5%B1%82%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    <url>/2024/11/15/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E9%9D%A2%E5%90%91%E5%85%B5%E6%A3%8B%E6%8E%A8%E6%BC%94%E7%9A%84%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%88%86%E5%B1%82%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="1-主要内容"><a href="#1-主要内容" class="headerlink" title="1. 主要内容"></a>1. 主要内容</h2><p>论文深入探讨了分层控制结构的多智能体强化学习算法在兵棋推演环境中的应用，旨在优化复杂和不确定环境下的任务分配和多智能体任务的执行过程。主要研究内容包括：</p><ol><li>针对实时兵棋推演环境，设计了兵棋AI的状态空间和动作空间，并生成了敌我对抗态势的关键特征信息。通过离散化连续动作的操作优化了原始动作空间，简化了多智能体的交互过程，加快了网络学习速度。</li><li>提出了一种融合注意力机制的DQN算法（ADQN），通过嵌入网络和注意力对输入进行向量化处理后输入DQN网络，将环境分解为独立的子环境，并重新定义特定于子任务的动作-价值函数，有效提高了在复杂环境中进行任务分配的质量和效率。</li><li>基于深度强化学习的多级控制结构，提出了多智能体分层自主决策算法（ADQN-MAPPO），结合了多智能体近端策略优化算法与ADQN算法，通过将复杂任务划分成子任务进行分配后再执行，增强了智能体自主决策的能力，提高了算法模型的训练速度和决策能力。</li></ol><p>论文通过在山地3v3和水田3v3的兵棋推演环境中的实验，验证了ADQN-MAPPO算法在得分能力、胜率、步均推理时间以及模型的泛化能力等方面的优越性能。研究结果对进一步提升分层控制结构的多智能体强化学习算法在兵棋推演以及其他复杂应用环境中的性能和应用范围提供了参考意义。</p><h2 id="2-分层决策框架"><a href="#2-分层决策框架" class="headerlink" title="2. 分层决策框架"></a>2. 分层决策框架</h2><p>这篇论文中提出的分层决策框架是为了解决兵棋推演环境中的多智能体任务分配和执行问题。分层决策框架包括两个主要层次：任务分配层和智能体决策层。以下是这两个层次的详细介绍：</p><h3 id="2-1-任务分配层"><a href="#2-1-任务分配层" class="headerlink" title="2.1 任务分配层"></a>2.1 任务分配层</h3><p>任务分配层的目的是将全局任务分解为多个子任务，并将这些子任务分配给不同的智能体。这一层主要关注如何在多智能体系统中高效地分配任务，以便每个智能体可以专注于自己的子任务，从而提高整体任务执行的效率和效果。</p><ul><li><strong>状态空间和动作空间设计</strong>：在这一层中，状态空间包括了整个环境的总体状态，如战场上的地形、敌我双方的兵力部署等。动作空间则由子任务的编号集合构成，意味着每个智能体的动作是选择一个子任务来执行。</li><li><strong>子任务设计</strong>：根据兵棋推演游戏的特性，将总体任务细分为行军、进攻、防御、支援、夺控等子任务。每个子任务由任务名称、编号、类型、关系、目标等元素组成。</li><li><strong>ADQN算法</strong>：提出了一种融合注意力机制的DQN算法（ADQN），用于处理任务分配问题。ADQN算法通过智能体对子任务的执行，将环境分解为独立的子环境，并重新定义特定于子任务的动作-价值函数。</li></ul><h3 id="2-2-智能体决策层"><a href="#2-2-智能体决策层" class="headerlink" title="2.2 智能体决策层"></a>2.2 智能体决策层</h3><p>智能体决策层根据任务分配层分配的子任务，每个智能体需要做出具体的行动决策来完成任务。这一层主要关注智能体如何在局部环境中做出最优决策。</p><ul><li><strong>MAPPO算法</strong>：在这一层中，使用了多智能体近端策略优化算法（MAPPO），它是一种适用于多智能体环境的强化学习算法，可以处理分布式部分可观察马尔可夫决策过程（DEC-POMDP）。</li><li><strong>策略网络和评价网络</strong>：每个智能体都有自己的策略网络，根据局部观测信息产生动作。同时，有一个全局评价网络根据全局环境信息生成状态价值，用于指导策略网络的更新。</li><li><strong>分层架构的优势</strong>：通过分层架构，上层任务分配网络可以在更大的时间尺度上运行，而下层智能体策略网络则在更细的尺度上做出决策。这种分层方法有助于提高智能体在兵棋推演环境中的决策效率和效果。</li></ul><h3 id="2-3-ADQN-MAPPO算法"><a href="#2-3-ADQN-MAPPO算法" class="headerlink" title="2.3 ADQN-MAPPO算法"></a>2.3 ADQN-MAPPO算法</h3><p>ADQN-MAPPO算法是将ADQN算法和MAPPO算法结合的分层决策框架。这种框架通过将复杂任务分解为子任务，并在不同的抽象层次上学习策略，解决了大规模复杂环境下的决策问题。ADQN-MAPPO算法在实验中表现出了优越的性能，包括更高的得分能力、胜率以及更快的收敛速度。</p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
      <category>多智能体强化学习任务分配</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
      <tag>科研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于分层强化学习的多智能体博弈对抗策略</title>
    <link href="/2024/11/15/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E5%9F%BA%E4%BA%8E%E5%88%86%E5%B1%82%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%8D%9A%E5%BC%88%E5%AF%B9%E6%8A%97%E7%AD%96%E7%95%A5/"/>
    <url>/2024/11/15/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E5%9F%BA%E4%BA%8E%E5%88%86%E5%B1%82%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%8D%9A%E5%BC%88%E5%AF%B9%E6%8A%97%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="1-主要内容"><a href="#1-主要内容" class="headerlink" title="1. 主要内容"></a>1. 主要内容</h2><h3 id="1-1-研究内容"><a href="#1-1-研究内容" class="headerlink" title="1.1 研究内容"></a>1.1 研究内容</h3><ul><li>提出了一种结合任务可解释性的指挥官-集群多智能体分层强化学习算法，提高算法在复杂博弈场景中的收敛速度。</li><li>设计了一种结合软决策树的多智能体分层强化学习算法，增强了策略的解释性。</li><li>基于模糊决策树建立了博弈对抗策略，通过挖掘战法规则，模拟人的决策过程。</li><li>在联合作战实验平台上设计了空战博弈场景和海空联合作战场景，验证了所提算法的有效性。</li></ul><h3 id="1-2-算法设计与实验验证"><a href="#1-2-算法设计与实验验证" class="headerlink" title="1.2 算法设计与实验验证"></a>1.2 算法设计与实验验证</h3><ul><li>设计了指挥官-集群分层强化学习算法，并通过实验验证了其在收敛性、解释性与作战效能方面的优势。</li><li>设计了结合软决策树的分层强化学习算法，验证了其在策略解释性和算法收敛性方面的优势。</li><li>提出了基于模糊决策树的博弈对抗策略，并通过实验验证了其分类效果和战法规则提取效果。</li></ul><h3 id="1-3-实验环境与设置"><a href="#1-3-实验环境与设置" class="headerlink" title="1.3 实验环境与设置"></a>1.3 实验环境与设置</h3><ul><li>使用了“StarCraft2”作为实验平台，设计了多种博弈场景，包括简单同构智能体控制场景、复杂同构智能体控制场景和复杂异构智能体控制场景。</li></ul><h3 id="1-4-结论与展望"><a href="#1-4-结论与展望" class="headerlink" title="1.4 结论与展望"></a>1.4 结论与展望</h3><ul><li>论文提出的分层强化学习算法在多智能体博弈对抗中具有实际应用价值和潜力，尤其在提高指挥部快速决策能力和军队快速反应打击能力上。</li><li>论文还指出了研究的局限性，并对未来的研究方向提出了展望，包括消除上层智能体学习训练结果对模型性能的负面影响，以及针对模糊环境下多层次、多目标的决策问题开展研究。</li></ul><h2 id="2-研究方法"><a href="#2-研究方法" class="headerlink" title="2. 研究方法"></a>2. 研究方法</h2><ul><li><strong>分层强化学习（HRL）</strong>：文章采用分层强化学习方法来处理多智能体复杂博弈场景中的策略优化问题。这种方法通过将复杂的决策问题分解为多个层次，使得学习过程更加高效和可解释。</li><li><strong>结合任务可解释性</strong>：文章提出了结合任务可解释性的指挥官-集群分层强化学习算法，通过模仿学习设计可解释的子任务，引入专家经验，提高算法的收敛速度。</li><li><strong>软决策树</strong>：为了增强策略的解释性，文章设计了结合软决策树的分层强化学习算法，通过引入线性权重表示状态特征与决策结果之间的因果逻辑。</li><li><strong>模糊决策树</strong>：文章进一步挖掘战法规则，建立基于模糊决策树的博弈对抗策略，模拟人的决策过程，并提取模糊决策树中隐藏的战术规则。</li></ul><h2 id="3-算法实现"><a href="#3-算法实现" class="headerlink" title="3. 算法实现"></a>3. 算法实现</h2><ul><li><strong>指挥官-集群分层强化学习算法（HES）</strong>：文章实现了一种指挥官-集群分层强化学习算法，该算法包含上层指挥官决策模型和下层集群作战模型，通过可解释子任务实现信息传递。</li><li><strong>结合软决策树的分层强化学习算法（HEE）</strong>：文章实现了一种结合软决策树的分层强化学习算法，该算法在HES算法框架基础上，将软决策树结构融入宏观决策过程中。</li><li><strong>基于模糊决策树的博弈对抗策略（FDTGAS）</strong>：文章实现了一种基于模糊决策树的博弈对抗策略，通过预处理对抗数据，构建模糊决策树，并从中提取战法规则。</li></ul><h2 id="4-上层决策模型的主要特点和实现细节："><a href="#4-上层决策模型的主要特点和实现细节：" class="headerlink" title="4. 上层决策模型的主要特点和实现细节："></a>4. 上层决策模型的主要特点和实现细节：</h2><h3 id="4-1-指挥官-集群分层强化学习算法（HES）中的上层决策模型"><a href="#4-1-指挥官-集群分层强化学习算法（HES）中的上层决策模型" class="headerlink" title="4.1 指挥官-集群分层强化学习算法（HES）中的上层决策模型"></a>4.1 指挥官-集群分层强化学习算法（HES）中的上层决策模型</h3><ul><li><strong>指挥官决策模型</strong>：模拟战争中高级指挥官的决策过程，基于战争总体形势的变化制定总体作战规划，并将战斗子任务分配给下层战斗单位。</li><li><strong>任务可解释性</strong>：结合任务可解释性思想，设计可解释的子任务，将专家经验引入到分层框架中，引导智能体进行定向学习，提高算法的收敛速度。</li></ul><h3 id="4-2-结合软决策树的分层强化学习算法（HEE）中的上层决策模型"><a href="#4-2-结合软决策树的分层强化学习算法（HEE）中的上层决策模型" class="headerlink" title="4.2 结合软决策树的分层强化学习算法（HEE）中的上层决策模型"></a>4.2 结合软决策树的分层强化学习算法（HEE）中的上层决策模型</h3><ul><li><strong>软决策树（SDT）</strong>：引入软决策树结构，改进传统的决策树模型，使其可以替代神经网络拟合动作价值函数，增强模型的可解释性。</li><li><strong>线性权重</strong>：在软决策树的叶子节点引入线性模型，通过线性权重表示状态特征与决策结果之间的因果逻辑，增强策略的解释性。</li></ul><h3 id="4-3-基于模糊决策树的博弈对抗策略中的上层决策模型"><a href="#4-3-基于模糊决策树的博弈对抗策略中的上层决策模型" class="headerlink" title="4.3 基于模糊决策树的博弈对抗策略中的上层决策模型"></a>4.3 基于模糊决策树的博弈对抗策略中的上层决策模型</h3><ul><li><strong>模糊决策树</strong>：构建模糊决策树模拟人的决策过程，处理高维度数据集中的模糊性和不确定性，提高分类的准确率和模型的泛化能力。</li><li><strong>战法规则提取</strong>：从模糊决策树中提取隐含的战法规则，建立以IF-THEN规则形式表示的博弈对抗策略。</li></ul><h3 id="4-4-实现细节"><a href="#4-4-实现细节" class="headerlink" title="4.4 实现细节"></a>4.4 实现细节</h3><ul><li><strong>神经网络建模</strong>：上层决策模型通常采用神经网络进行建模，使用深度学习技术来处理高维数据和复杂的决策问题。</li><li><strong>参数更新</strong>：上层决策模型的参数通过梯度下降法进行更新，利用经验回放机制和策略梯度方法来优化模型性能。</li><li><strong>目标分解</strong>：上层智能体学习目标的分解策略，将复杂的任务分解为多个子目标，通过子目标的实现逐步达成最终目标。</li></ul><h3 id="4-5-应用场景"><a href="#4-5-应用场景" class="headerlink" title="4.5 应用场景"></a>4.5 应用场景</h3><ul><li><strong>联合作战实验平台</strong>：在空战博弈场景和海空联合作战场景中，上层决策模型负责制定整体作战策略，指导下层作战单元执行具体的作战任务。</li></ul><h2 id="5-上层决策模型的具体实现细节"><a href="#5-上层决策模型的具体实现细节" class="headerlink" title="5. 上层决策模型的具体实现细节"></a>5. 上层决策模型的具体实现细节</h2><h3 id="5-1-指挥官-集群分层强化学习算法（HES）的上层决策模型"><a href="#5-1-指挥官-集群分层强化学习算法（HES）的上层决策模型" class="headerlink" title="5.1 指挥官-集群分层强化学习算法（HES）的上层决策模型"></a>5.1 指挥官-集群分层强化学习算法（HES）的上层决策模型</h3><h4 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h4><ul><li><strong>指挥官角色</strong>：模拟高级指挥官的决策过程，负责在战争或博弈的宏观层面上制定战略。</li><li><strong>任务分解</strong>：将复杂的任务分解为可解释的子任务，这些子任务对下层集群作战模型来说是具体的战术目标。</li></ul><h4 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h4><ul><li><strong>神经网络架构</strong>：使用神经网络来拟合指挥官的决策策略，该网络输入全局观测状态，输出子任务或战术目标。</li><li><strong>模仿学习</strong>：基于专家经验设计可解释的子任务，通过模仿学习将专家知识整合到神经网络的训练过程中。</li><li><strong>参数更新</strong>：利用梯度下降方法更新神经网络参数，以最小化损失函数，提高决策质量。</li></ul><h3 id="5-2-结合软决策树的分层强化学习算法（HEE）的上层决策模型"><a href="#5-2-结合软决策树的分层强化学习算法（HEE）的上层决策模型" class="headerlink" title="5.2 结合软决策树的分层强化学习算法（HEE）的上层决策模型"></a>5.2 结合软决策树的分层强化学习算法（HEE）的上层决策模型</h3><h4 id="设计理念-1"><a href="#设计理念-1" class="headerlink" title="设计理念"></a>设计理念</h4><ul><li><strong>软决策树（SDT）</strong>：引入软决策树来增强策略的解释性，SDT 结合了神经网络的非线性建模能力和决策树的可解释性。</li></ul><h4 id="实现细节-1"><a href="#实现细节-1" class="headerlink" title="实现细节"></a>实现细节</h4><ul><li><strong>树结构优化</strong>：对传统的软决策树结构进行改进，引入线性权重来表示状态特征与决策结果之间的因果逻辑。</li><li><strong>线性叶子节点</strong>：在SDT的叶子节点使用线性模型，这些模型通过学习状态特征的权重来预测动作价值。</li><li><strong>在线学习</strong>：SDT模型支持在线学习，能够根据实时数据更新模型参数，增强模型对新态势的适应能力。</li></ul><h3 id="5-3-基于模糊决策树的博弈对抗策略的上层决策模型"><a href="#5-3-基于模糊决策树的博弈对抗策略的上层决策模型" class="headerlink" title="5.3 基于模糊决策树的博弈对抗策略的上层决策模型"></a>5.3 基于模糊决策树的博弈对抗策略的上层决策模型</h3><h4 id="设计理念-2"><a href="#设计理念-2" class="headerlink" title="设计理念"></a>设计理念</h4><ul><li><strong>模糊决策树</strong>：利用模糊决策树处理高维度数据集中的模糊性和不确定性，提高决策的准确性和泛化能力。</li></ul><h4 id="实现细节-2"><a href="#实现细节-2" class="headerlink" title="实现细节"></a>实现细节</h4><ul><li><strong>属性模糊化</strong>：将连续型属性转换为模糊集合，并通过隶属度函数计算属性值在模糊集合中的隶属度。</li><li><strong>分裂属性选择</strong>：基于分类不确定性选择分裂属性，以最小化节点的平均模糊信息熵。</li><li><strong>战法规则提取</strong>：从模糊决策树中提取IF-THEN形式的战法规则，为博弈对抗提供具体的策略指导。</li></ul><h3 id="5-4-通用实现细节"><a href="#5-4-通用实现细节" class="headerlink" title="5.4 通用实现细节"></a>5.4 通用实现细节</h3><h4 id="损失函数与优化"><a href="#损失函数与优化" class="headerlink" title="损失函数与优化"></a>损失函数与优化</h4><ul><li><strong>损失函数</strong>：设计损失函数以衡量模型预测与实际结果之间的差异，常用的损失函数包括均方误差等。</li><li><strong>优化算法</strong>：采用Adam优化器等高级优化算法来更新模型参数，提高训练效率和模型性能。</li></ul><h4 id="训练与验证"><a href="#训练与验证" class="headerlink" title="训练与验证"></a>训练与验证</h4><ul><li><strong>训练过程</strong>：通过与环境的交互不断收集数据，利用这些数据训练上层决策模型。</li><li><strong>验证与测试</strong>：在不同的博弈场景中验证上层决策模型的有效性，调整模型参数以适应不同的战术需求。</li></ul><p>这些实现细节共同构成了上层决策模型的核心，使其能够在多智能体博弈对抗中发挥关键作用。通过这些细节的实现，上层决策模型能够提供有效的战略指导，并与下层执行模型协同工作，实现整体任务目标。</p><p>[1]乔天润.基于分层强化学习的多智能体博弈对抗策略[D].东南大学,2023.DOI:10.27014&#x2F;d.cnki.gdnau.2023.001144.</p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
      <category>多智能体强化学习任务分配</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
      <tag>科研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于多智能体强化学习的分层决策优化方法</title>
    <link href="/2024/11/15/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%88%86%E5%B1%82%E5%86%B3%E7%AD%96%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"/>
    <url>/2024/11/15/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%88%86%E5%B1%82%E5%86%B3%E7%AD%96%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="1-主要内容"><a href="#1-主要内容" class="headerlink" title="1. 主要内容"></a>1. 主要内容</h1><ol><li><strong>背景与目的</strong>：<ul><li>随着信息技术和人工智能的发展，大数据驱动的辅助决策方法变得更加科学和准确。</li><li>强化学习在决策优化方面具有优势，但传统方法难以解决多层次、多目标的决策优化问题，尤其是在长周期决策优化问题中，学习奖励的滞后性限制了效率。</li></ul></li><li><strong>方法论</strong>：<ul><li>提出基于多智能体强化学习的分层决策优化方法，应用目标分解思想解决长期决策优化问题。</li><li>该方法基于强化学习理论，使具有层级关系的多智能体相互合作，上层智能体学习目标的分解策略，下层智能体学习完成目标的行动策略。</li></ul></li></ol><h1 id="2-研究方法"><a href="#2-研究方法" class="headerlink" title="2. 研究方法"></a>2. 研究方法</h1><p>文章中提到的分层决策优化方法（HDQ）算法的具体实现涉及以下几个关键步骤：</p><ol><li><p><strong>定义智能体和环境交互</strong>：</p><ul><li>强化学习基于马尔可夫决策过程（MDP），包含状态集合 ( S )，动作集合 ( A )，状态转移矩阵 ( P )，奖励集合 ( R )，以及折扣率 ( \gamma )。</li></ul></li><li><p><strong>目标分解与层级决策</strong>：</p><ul><li>将长期目标 ( G ) 分解为子目标 ( g_t )，并通过计算状态 ( s_t ) 与子目标 ( g_t ) 之间的距离 ( dis(gt, st) ) 来判断子目标是否完成。</li></ul></li><li><p><strong>智能体的层级结构</strong>：</p><ul><li>设计具有层级关系的上层智能体 ( \pi_1 ) 和下层智能体 ( \pi_2 )。</li><li>上层智能体学习目标的分解策略，下层智能体学习实现子目标的行动策略。</li></ul></li><li><p><strong>神经网络建模</strong>：</p><ul><li>使用深度Q网络（DQN）作为值函数逼近器，引入神经网络来估计动作价值 ( Q(s, a; \theta) )。</li><li>采用Dueling DQN来缓解高估Q值的问题，引入优势函数 ( A(s, a) )。</li></ul></li><li><p><strong>智能体的参数更新</strong>：</p><ul><li>智能体参数交替更新，共同学习完成团队任务的最佳策略。</li><li>使用梯度下降法更新神经网络参数 ( \theta )，学习率 ( \alpha )。</li></ul></li><li><p><strong>实验设计与数据预处理</strong>：</p><ul><li>从MIMIC-IV数据库中提取脓毒症患者数据，包括性别、年龄、体重、SOFA评分等45个特征。</li><li>使用均值插值方法处理缺失值，最大最小归一化方法消除特征量纲。</li></ul></li><li><p><strong>状态和动作空间的定义</strong>：</p><ul><li>状态空间通过K-means算法聚类降维，定义700个不同的状态类别。</li><li>子目标基于SOFA评分，动作空间定义为两种药物组成的二维矩阵。</li></ul></li><li><p><strong>奖励函数的设计</strong>：</p><ul><li>设计分段常数函数作为奖励函数，根据患者的生存状态和状态改善情况给予不同的奖励。</li></ul></li></ol><p>[1]张倩,李天皓,白春光.基于多智能体强化学习的分层决策优化方法[J].电子科技大学学报(社科版),2022,24(06):90-96.DOI:10.14071&#x2F;j.1008-8105(2022)-1056.</p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
      <category>多智能体强化学习任务分配</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
      <tag>科研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于层次控制的多智能体对抗研究</title>
    <link href="/2024/11/14/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E5%9F%BA%E4%BA%8E%E5%B1%82%E6%AC%A1%E6%8E%A7%E5%88%B6%E7%9A%84%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%AF%B9%E6%8A%97%E7%A0%94%E7%A9%B6/"/>
    <url>/2024/11/14/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E5%9F%BA%E4%BA%8E%E5%B1%82%E6%AC%A1%E6%8E%A7%E5%88%B6%E7%9A%84%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%AF%B9%E6%8A%97%E7%A0%94%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-主要内容"><a href="#1-主要内容" class="headerlink" title="1. 主要内容"></a>1. 主要内容</h1><ul><li>针对复杂动作状态空间场景下单智能体策略学习问题，提出了一种基于预训练模型的分层强化学习算法。该算法分为三个层次：<ul><li>首先，基于先验知识为每个子策略设计了适宜其相应时间的宏动作；</li><li>其次是子策略控制器，其核心是基于监督学习的方法，训练能够适应不同需要的子策略，基于随机的宏动作产生子策略监督学习的数据，并且子策略只学习胜利时的操作轨迹；</li><li>最后是智能体的高级策略控制器，基于策略梯度算法进行扩展，屏蔽了底层繁琐的动作，只对于下层的子策略进行选择，使得作为决策的神经网络参数能够做出更好的动作。</li></ul></li><li>针对复杂动作状态空间场景下多智能体策略学习问题，提出了一种基于双向协调网络的多智能体强化学习算法。该算法基于Actor-Critic框架，其特点是：<ul><li>基于全局信息训练Critic网络，用以解决场景中马尔可夫性缺失问题；</li><li>采用双向RNN网络结构，用以解决场景中多智能体信息通信问题；</li><li>使用动作映射算法，使得智能体选择收益最高的合法联合动作。</li></ul></li><li>基于上述研究成果和《星际争霸2》对抗学习环境，将单智能体强化学习算法和多智能体强化学习算法进行有机融合，设计实现了一个基于层次控制的多智能体强化学习原型系统，并进行实验验证。</li></ul><h1 id="2-研究方法"><a href="#2-研究方法" class="headerlink" title="2. 研究方法"></a>2. 研究方法</h1><p>这篇论文的主要研究方法和算法集中在解决复杂动作状态空间下的多智能体对抗问题，具体包括以下几个方面：</p><ol><li><p><strong>基于预训练模型的分层强化学习算法</strong>：</p><ul><li><strong>宏动作设计</strong>：将复杂的动作序列打包成宏动作，减少智能体需要学习的原子动作数量。</li><li><strong>子策略控制器</strong>：基于监督学习的方法训练子策略，每个子策略对应一个宏动作。</li><li><strong>高级策略控制器（APC）</strong>：基于策略梯度算法扩展，负责在子策略之间进行选择。</li></ul></li><li><p><strong>基于双向协调网络的多智能体强化学习算法（BiC-DDPG）</strong>：</p><ul><li><strong>集中训练分散执行</strong>：解决多智能体对抗场景下马尔可夫性缺失问题，提高算法收敛性。</li><li><strong>Bi-RNN网络结构</strong>：实现智能体合作时的信息通信。</li><li><strong>动作映射算法</strong>：将连续的原始联合动作映射到合法离散联合动作空间，解决复杂联合动作空间下的智能体决策问题。</li></ul></li><li><p><strong>深度学习和强化学习算法</strong>：</p><ul><li><strong>深度神经网络</strong>：使用深度神经网络结构（如ResNet50）作为子策略的神经网络结构。</li><li><strong>强化学习算法</strong>：包括Q学习、DQN、策略梯度、Actor-Critic算法等。</li></ul></li><li><p><strong>实验验证</strong>：</p><ul><li>在《星际争霸2》环境中进行实验验证，包括全流程对抗和微操作对抗环境。</li><li>设计了不同难度的对抗场景，以及不同的子策略训练和测试。</li></ul></li><li><p><strong>原型系统实现</strong>：</p><ul><li>将单智能体和多智能体强化学习算法融合，设计实现了一个基于层次控制的多智能体强化学习原型系统。</li><li>在Python-sc2接口上复现SMAC接口对于观察数据、奖励机制以及动作空间的设计，并部署BiC-DDPG算法。</li></ul></li><li><p><strong>算法优化和调整</strong>：</p><ul><li>对算法的参数进行调整，以适应不同的实验环境和场景。</li><li>通过实验结果分析算法的性能和有效性。</li></ul></li></ol><p>[1]王功举.基于层次控制的多智能体对抗研究[D].军事科学院,2021.DOI:10.27193&#x2F;d.cnki.gjsky.2021.000110.</p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
      <category>多智能体强化学习任务分配</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
      <tag>科研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.3 无监督学习-强化学习-吴恩达</title>
    <link href="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/"/>
    <url>/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h2><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013185527334.png"></p><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013185513926.png"></p><ul><li>状态、动作、奖励和下一个状态(s, a, R(s), s’)</li></ul><h3 id="1-回报"><a href="#1-回报" class="headerlink" title="1. 回报"></a>1. 回报</h3><ul><li>折扣因子</li></ul><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013191147456.png"></p><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013191515723.png"></p><h3 id="2-决策"><a href="#2-决策" class="headerlink" title="2. 决策"></a>2. 决策</h3><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013191936751.png"></p><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013192130503.png"></p><ul><li><p>马尔可夫决策过程 MDP</p></li><li><p>在马尔可夫决策过程中，未来只取决于你现在所处的位置，而不取决于你是如何到达这里的。</p></li></ul><h3 id="3-状态-动作价值函数"><a href="#3-状态-动作价值函数" class="headerlink" title="3. 状态-动作价值函数"></a>3. 状态-动作价值函数</h3><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013214059896.png"></p><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013214515098.png"></p><h4 id="3-1-贝尔曼方程"><a href="#3-1-贝尔曼方程" class="headerlink" title="3.1 贝尔曼方程"></a>3.1 贝尔曼方程</h4><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013220256063.png"></p><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013221245911.png"></p><ul><li>如果你从状态s 开始，你将采取行动a，然后在此之后采取最佳行动，那么你将随着时间的推移看到一些奖励序列。</li></ul><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013221652384.png"></p><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013221916868.png"></p><h3 id="4-随机强化学习"><a href="#4-随机强化学习" class="headerlink" title="4. 随机强化学习"></a>4. 随机强化学习</h3><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013222607911.png"></p><h3 id="5-连续状态"><a href="#5-连续状态" class="headerlink" title="5. 连续状态"></a>5. 连续状态</h3><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013222846102.png"></p><ul><li>连续马尔可夫 MTP</li></ul><h3 id="6-学习状态值函数"><a href="#6-学习状态值函数" class="headerlink" title="6. 学习状态值函数"></a>6. 学习状态值函数</h3><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013223922575.png"></p><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013224639866.png"></p><ul><li>不知道Q，随机猜测</li></ul><h3 id="7-DQN"><a href="#7-DQN" class="headerlink" title="7. DQN"></a>7. DQN</h3><ul><li>意思是神经网络里的参数随机初始化，然后(s’,a’)输入，得到maxQ的预测</li></ul><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013225256166.png"></p><ul><li>交给神经网络训练的参数y中一部分是随机初始化神经网络生成的，但还有一部分是包含了当前状态的信息的，所以当训练次数增多后，外部的输入信息会逐步冲刷掉初始化的随机信息，给出真正的Q函数估计。</li></ul><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013225733542.png"></p><h4 id="7-1-贪婪算法"><a href="#7-1-贪婪算法" class="headerlink" title="7.1 贪婪算法"></a>7.1 贪婪算法</h4><ul><li>使用高ε开始，逐步降低直到0.01</li></ul><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013230506858.png"></p><h4 id="7-2-小批量和软更新"><a href="#7-2-小批量和软更新" class="headerlink" title="7.2 小批量和软更新"></a>7.2 小批量和软更新</h4><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013230853479.png"></p><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013231149426.png"></p><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013231255361.png"></p><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013231653864.png"></p><h3 id="8-局限性"><a href="#8-局限性" class="headerlink" title="8. 局限性"></a>8. 局限性</h3><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013232030585.png"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>ML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.2 无监督学习-推荐系统-吴恩达</title>
    <link href="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/"/>
    <url>/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h2><h3 id="1-使用每个特征数据"><a href="#1-使用每个特征数据" class="headerlink" title="1. 使用每个特征数据"></a>1. 使用每个特征数据</h3><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013091417801.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013092525171.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013092709205.png"></p><h3 id="2-协同过滤算法"><a href="#2-协同过滤算法" class="headerlink" title="2. 协同过滤算法"></a>2. 协同过滤算法</h3><ul><li>假设已经有了w和b，猜测特征x</li></ul><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013093541589.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013094256436.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013094536963.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013095022269.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013095116749.png"></p><ul><li><p>这种协同过滤是从多个用户收集数据，用户之间的这种协作可帮助您预测未来甚至其他用户的评级。</p></li><li><p>推荐系统的一个非常常见的用例是当您有二进制标签时，例如用户喜欢、喜欢或与项目交互的标签。</p></li></ul><h3 id="3-二进制标签"><a href="#3-二进制标签" class="headerlink" title="3.二进制标签"></a>3.二进制标签</h3><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013095506383.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013095650568.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013095901608.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013100113430.png"></p><ul><li>分类不用正则化</li></ul><h3 id="4-均值归一化"><a href="#4-均值归一化" class="headerlink" title="4. 均值归一化"></a>4. 均值归一化</h3><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013143727458.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013144130791.png"></p><ul><li>对未知用户，预测评分为均值</li></ul><h3 id="5-协同过滤Tensorflow实现"><a href="#5-协同过滤Tensorflow实现" class="headerlink" title="5. 协同过滤Tensorflow实现"></a>5. 协同过滤Tensorflow实现</h3><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013144725579.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013144803015.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013145539351.png"></p><h3 id="6-寻找相关特征"><a href="#6-寻找相关特征" class="headerlink" title="6. 寻找相关特征"></a>6. 寻找相关特征</h3><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013145951931.png"></p><ul><li>协同过滤的局限性</li></ul><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013150021292.png"></p><ul><li><p>冷启动问题</p></li><li><p>边缘信息</p></li></ul><h3 id="7-基于内容的过滤算法"><a href="#7-基于内容的过滤算法" class="headerlink" title="7. 基于内容的过滤算法"></a>7. 基于内容的过滤算法</h3><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013150639264.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013150936617.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013151110932.png"></p><ul><li>如何计算V</li></ul><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013151407807.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013151905392.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013152534237.png"></p><h3 id="8-从大型目录中推荐"><a href="#8-从大型目录中推荐" class="headerlink" title="8. 从大型目录中推荐"></a>8. 从大型目录中推荐</h3><ul><li>两个步骤：检索和排名</li></ul><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013152823434.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013153036731.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013153343967.png"></p><h3 id="9-基于内容的Tensorflow实现"><a href="#9-基于内容的Tensorflow实现" class="headerlink" title="9. 基于内容的Tensorflow实现"></a>9. 基于内容的Tensorflow实现</h3><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013154612258.png"></p><h3 id="10-降低特征数量"><a href="#10-降低特征数量" class="headerlink" title="10. 降低特征数量"></a>10. 降低特征数量</h3><ul><li>PCA主成分分析法，特征降为二维或者三维，便于可视化</li></ul><h4 id="10-1-PCA算法"><a href="#10-1-PCA算法" class="headerlink" title="10.1 PCA算法"></a>10.1 PCA算法</h4><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013170727751.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013171217861.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013171447596.png"></p><ul><li><p>当使用线性回归来预测目标输出Y并且PCA试图获取大量特征并平等对待它们并减少很好地表示数据所需的轴数</p></li><li><p>因此，如果您尝试预测y的值，则应使用线性回归;如果您尝试减少数据集中的特征数量，例如将其可视化，则应使用PCA。</p></li></ul><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013172253829.png"></p><ul><li>每个特征的方差贡献率</li></ul><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013172530272.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013172923497.png"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>ML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.1 无监督学习-无监督学习-吴恩达</title>
    <link href="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/"/>
    <url>/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><h3 id="1-聚类"><a href="#1-聚类" class="headerlink" title="1. 聚类"></a>1. 聚类</h3><h4 id="1-1-k-means"><a href="#1-1-k-means" class="headerlink" title="1.1 k-means"></a>1.1 k-means</h4><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012125528206.png"></p><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012125536447.png"></p><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012130426099.png"></p><ul><li>如果一个集群训练样本为零，可以消除该集群，最终得到k-1；另一种方法是重新初始化该集群质心</li></ul><h4 id="1-2-优化目标"><a href="#1-2-优化目标" class="headerlink" title="1.2 优化目标"></a>1.2 优化目标</h4><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012145049473.png"></p><h4 id="1-3-初始化"><a href="#1-3-初始化" class="headerlink" title="1.3 初始化"></a>1.3 初始化</h4><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012150757199.png"></p><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012151542672.png"></p><h4 id="1-4-选择聚类数量"><a href="#1-4-选择聚类数量" class="headerlink" title="1.4 选择聚类数量"></a>1.4 选择聚类数量</h4><ul><li>肘法</li></ul><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012151925053.png"></p><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012152146445.png"></p><h3 id="2-异常检测"><a href="#2-异常检测" class="headerlink" title="2. 异常检测"></a>2. 异常检测</h3><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012152706177.png"></p><h4 id="2-1-密度估计"><a href="#2-1-密度估计" class="headerlink" title="2.1 密度估计"></a>2.1 密度估计</h4><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012152845235.png"></p><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012153346742.png"></p><h4 id="2-2-高斯正态分布"><a href="#2-2-高斯正态分布" class="headerlink" title="2.2 高斯正态分布"></a>2.2 高斯正态分布</h4><ul><li>最大似然估计</li></ul><h4 id="2-3-异常检测算法"><a href="#2-3-异常检测算法" class="headerlink" title="2.3 异常检测算法"></a>2.3 异常检测算法</h4><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012154133115.png"></p><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012154923207.png"></p><h4 id="2-4-开发与评估异常检测系统"><a href="#2-4-开发与评估异常检测系统" class="headerlink" title="2.4 开发与评估异常检测系统."></a>2.4 开发与评估异常检测系统.</h4><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012215712447.png"></p><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012220215931.png"></p><ul><li><p>这种替代方案的缺点是，在调整算法后，您没有公平的方法来判断它在未来示例中的实际效果如何，因为您没有测试集。</p></li><li><p>当你的数据集很小的时候，特别是当你有异常的数量时，你的数据集很小，这可能是你最好的选择。</p></li></ul><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013082659472.png"></p><h4 id="2-5-异常检测vs监督学习"><a href="#2-5-异常检测vs监督学习" class="headerlink" title="2.5 异常检测vs监督学习"></a>2.5 异常检测vs监督学习</h4><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013084827450.png"></p><ul><li>例子</li></ul><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013084924028.png"></p><h4 id="2-6-选择用什么特征"><a href="#2-6-选择用什么特征" class="headerlink" title="2.6 选择用什么特征"></a>2.6 选择用什么特征</h4><ul><li>特征改变为高斯分布</li></ul><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013085546244.png"></p><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013090207839.png"></p><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013090413780.png"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>ML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.4 深度学习-决策树-吴恩达</title>
    <link href="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/"/>
    <url>/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012075401986.png"></p><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012075410387.png"></p><ul><li><p>根节点 决策节点 叶节点</p></li><li><p>决策树学习算法的工作是，从所有可能的决策树中，尝试选择一个希望在训练集上表现良好的树，然后理想地泛化到新数据，例如交叉验证和测试集</p></li></ul><h3 id="1-学习过程"><a href="#1-学习过程" class="headerlink" title="1. 学习过程"></a>1. 学习过程</h3><ul><li>决策树学习的第一步是，我们必须决定在根节点使用什么特征。</li></ul><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012081611286.png"></p><ul><li><p>决策 2：何时停止分裂？</p><ul><li>当一个节点完全是一类时</li><li>当分裂一个节点会导致树超过最大深度时</li><li>当纯度分数的提高低于一个阈值时</li><li>当节点中的样本数量低于一个阈值时</li></ul></li><li><p>您可能想要限制决策树深度的一个原因是确保我们的树不会变得太大和笨重，其次，通过保持树小，它不太容易过度拟合。</p></li></ul><h3 id="2-纯度"><a href="#2-纯度" class="headerlink" title="2. 纯度"></a>2. 纯度</h3><h4 id="2-1-熵-entropy"><a href="#2-1-熵-entropy" class="headerlink" title="2.1 熵 entropy"></a>2.1 熵 entropy</h4><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012082638836.png"></p><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012082823450.png"></p><ul><li><p>选择拆分信息增益</p></li><li><p>减少熵</p></li><li><p>信息增益 分之前的熵减去分后熵的加权平均</p></li><li><p>停止标准，每次信息增益如果太小停止分类</p></li></ul><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012083632353.png"></p><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012083921344.png"></p><h4 id="2-2-整合"><a href="#2-2-整合" class="headerlink" title="2.2 整合"></a>2.2 整合</h4><ul><li>从根节点开始，包含所有样本</li><li>计算所有可能特征的信息增益，并选择信息增益最高的特征</li><li>根据选定的特征划分数据集，并创建树的左分支和右分支</li><li>持续重复分裂过程，直到满足停止条件：<ul><li>当一个节点完全是一类时</li><li>当分裂一个节点会导致树超过最大深度时</li><li>额外分裂的信息增益小于阈值时</li><li>当节点中的样本数量低于阈值时</li></ul></li></ul><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012084601880.png"></p><ul><li>递归分类</li></ul><h3 id="3-独热编码-one-hot"><a href="#3-独热编码-one-hot" class="headerlink" title="3. 独热编码 one-hot"></a>3. 独热编码 one-hot</h3><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012085239987.png"></p><ul><li><p>通过one-hot编码，您可以让决策树处理可以采用两个以上离散值的特征，您还可以将其应用于新网络或线性回归或逻辑回归训练。</p></li><li><p>连续值</p></li><li><p>尝试不同的阈值，计算纯度</p></li></ul><h3 id="4-回归树"><a href="#4-回归树" class="headerlink" title="4. 回归树"></a>4. 回归树</h3><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012090404205.png"></p><ul><li>尝试减少方差</li></ul><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012091154958.png"></p><h3 id="5-使用多个决策树"><a href="#5-使用多个决策树" class="headerlink" title="5. 使用多个决策树"></a>5. 使用多个决策树</h3><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012092643280.png"></p><h4 id="5-1-有放回的采样"><a href="#5-1-有放回的采样" class="headerlink" title="5.1 有放回的采样"></a>5.1 有放回的采样</h4><ul><li><p>构建新的数据集</p></li><li><p>随机森林算法 Random Forest Algorithm</p></li></ul><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012093230276.png"></p><ul><li><p>随机化特征选择</p><ul><li>在每个节点选择用于分裂的特征时，如果有n个特征可用，随机选择一个包含k个特征的子集（k &lt; n），并允许算法仅从这个特征子集中进行选择。</li></ul></li><li><p>k的选择（根号n，log2(n)）</p></li></ul><h4 id="5-2-XGBoost-extreme-Gradient-Boosting"><a href="#5-2-XGBoost-extreme-Gradient-Boosting" class="headerlink" title="5.2 XGBoost (extreme Gradient Boosting)"></a>5.2 XGBoost (extreme Gradient Boosting)</h4><ul><li>提升树的开源实现</li><li>快速高效的实现</li><li>默认分裂标准和停止分裂标准的好选择</li><li>内置正则化以防止过拟合</li><li>机器学习竞赛中极具竞争力的算法（例如：Kaggle竞赛）</li></ul><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012094738491.png"></p><h3 id="6-何时使用决策树"><a href="#6-何时使用决策树" class="headerlink" title="6. 何时使用决策树"></a>6. 何时使用决策树</h3><ul><li>表格数据</li></ul><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012095356821.png"></p><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012095814528.png"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>ML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.3 深度学习-在机器学习项目中下一步该做什么-吴恩达</title>
    <link href="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/"/>
    <url>/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="在机器学习项目中下一步该做什么"><a href="#在机器学习项目中下一步该做什么" class="headerlink" title="在机器学习项目中下一步该做什么"></a>在机器学习项目中下一步该做什么</h2><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011083027133.png"></p><h3 id="1-模型评估"><a href="#1-模型评估" class="headerlink" title="1. 模型评估"></a>1. 模型评估</h3><p>训练集分为两个子集</p><ul><li><p>training set</p></li><li><p>test set</p></li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011083802084.png"></p><p>不包含正则化项</p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011084012544.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011084442975.png" alt="image-20231011084442975"></p><p>就是相比于之前计算在测试集和训练集上误差的那两个公式，我们更常用模型分类错误的次数除以总的预测次数来表示误差</p><p>就是对于逻辑回归来说，可以通过计算误判占比的方法来代表成本函数，比如test set中误判的占比是10％，那么J test就是0.1</p><h4 id="1-1-分为三个子集，训练集、交叉验证集、测试集"><a href="#1-1-分为三个子集，训练集、交叉验证集、测试集" class="headerlink" title="1.1 分为三个子集，训练集、交叉验证集、测试集"></a>1.1 分为三个子集，训练集、交叉验证集、测试集</h4><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011091646019.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011091757791.png"></p><ul><li><p>选择最小的交叉验证集误差对应的模型</p></li><li><p>用测试集来评估泛化误差</p></li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011092256493.png"></p><h4 id="1-2-偏差和方差"><a href="#1-2-偏差和方差" class="headerlink" title="1.2 偏差和方差"></a>1.2 偏差和方差</h4><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011093159868.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011093401564.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011093433520.png"></p><ul><li>正则化如何影响偏差和方差，从而影响算法的性能</li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011093859951.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011094124259.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011094256539.png"></p><h4 id="1-3-指定一个用于性能评估的基准"><a href="#1-3-指定一个用于性能评估的基准" class="headerlink" title="1.3 指定一个用于性能评估的基准"></a>1.3 指定一个用于性能评估的基准</h4><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011103735186.png"></p><p>竞争算法</p><h4 id="1-4-学习曲线"><a href="#1-4-学习曲线" class="headerlink" title="1.4 学习曲线"></a>1.4 学习曲线</h4><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011104512509.png"></p><ul><li>训练集变大，误差增大</li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011104852894.png"></p><ul><li>这给出了这个结论，也许有点令人惊讶，如果学习算法具有高偏差，获得更多的训练数据本身就没有那么大的希望。</li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011105426342.png"></p><ul><li>所以在这种情况下，可能仅仅通过增加训练集的大小来降低交叉验证误差并让你的算法表现得越来越好，这与高偏差情况不同，在这种情况下你唯一要做的就是获得更多的训练数据，实际上并不能帮助您了解算法性能。</li></ul><h4 id="1-5-如何改进"><a href="#1-5-如何改进" class="headerlink" title="1.5 如何改进"></a>1.5 如何改进</h4><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011110222504.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011110708303.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011111707005.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011112028987.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011112250065.png"></p><h3 id="2-机器学习开发的迭代"><a href="#2-机器学习开发的迭代" class="headerlink" title="2. 机器学习开发的迭代"></a>2. 机器学习开发的迭代</h3><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011112605831.png"></p><ul><li>垃圾邮件分类</li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011112929003.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011113910756.png"></p><h4 id="2-1-误差分析"><a href="#2-1-误差分析" class="headerlink" title="2.1 误差分析"></a>2.1 误差分析</h4><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011114442995.png"></p><h4 id="2-2-数据增强"><a href="#2-2-数据增强" class="headerlink" title="2.2 数据增强"></a>2.2 数据增强</h4><ul><li>旋转图像扭曲放大缩小</li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011115040740.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011115116926.png"></p><ul><li>音频增强</li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011115211067.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011115324412.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011131113956.png"></p><h4 id="2-3-迁移学习-Transfer-learning"><a href="#2-3-迁移学习-Transfer-learning" class="headerlink" title="2.3 迁移学习 Transfer  learning"></a>2.3 迁移学习 Transfer  learning</h4><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011163140324.png"></p><ul><li><p>数据集小选择1，数据集大选择2</p></li><li><p>先在大的数据集训练（监督与训练），再在小的训练称为微调</p></li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011163230072.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011163351440.png"></p><h4 id="2-4-机器学习项目全周期"><a href="#2-4-机器学习项目全周期" class="headerlink" title="2.4 机器学习项目全周期"></a>2.4 机器学习项目全周期</h4><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011163931188.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011164414049.png"></p><h4 id="2-5-倾斜数据集的误差指标"><a href="#2-5-倾斜数据集的误差指标" class="headerlink" title="2.5 倾斜数据集的误差指标"></a>2.5 倾斜数据集的误差指标</h4><ul><li>精确度和召回率</li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011165618174.png"></p><ul><li>精度和召回率</li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011170439331.png"></p><ul><li>F1score 更强调P和R中较低的那个 调和平均值</li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011170740787.png"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>ML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.2 深度学习-Tenserflow实现-吴恩达</title>
    <link href="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/"/>
    <url>/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="Tenserflow实现"><a href="#Tenserflow实现" class="headerlink" title="Tenserflow实现"></a>Tenserflow实现</h2><h3 id="1-模型训练步骤"><a href="#1-模型训练步骤" class="headerlink" title="1. 模型训练步骤"></a>1. 模型训练步骤</h3><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010125603129.png" alt="模型训练步骤"></p><h4 id="1-1-Epochs-and-batches"><a href="#1-1-Epochs-and-batches" class="headerlink" title="1.1 Epochs and batches"></a>1.1 Epochs and batches</h4><p>在上述的 <code>compile</code> 语句中，<code>epochs</code> 的数量被设置为10。这指定了整个数据集在训练过程中应该被应用10次。在训练期间，你会看到描述训练进度的输出，看起来像这样：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Epoch</span> <span class="hljs-number">1</span>/<span class="hljs-number">10</span><br><span class="hljs-attribute">6250</span>/<span class="hljs-number">6250</span><span class="hljs-meta"> [==============================] - 6s 910us/step - loss: 0.1782</span><br></code></pre></td></tr></table></figure><p>第一行 <code>Epoch 1/10</code> 描述了模型当前正在运行的是哪个训练周期。为了提高效率，训练数据集被分成了“批次”。在Tensorflow中，默认的批次大小是32。我们的扩展数据集中有200000个样本，或者6250个批次。第二行的符号 <code>6250/6250 [====</code> 描述了已经执行了哪个批次。</p><h4 id="1-2-创建模型"><a href="#1-2-创建模型" class="headerlink" title="1.2 创建模型"></a>1.2 创建模型</h4><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010125701208.png"></p><h4 id="1-3-交叉熵损失函数"><a href="#1-3-交叉熵损失函数" class="headerlink" title="1.3 交叉熵损失函数"></a>1.3 交叉熵损失函数</h4><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010130715345.png"></p><ul><li>回归和分类使用不同的损失代价函数</li></ul><h4 id="1-4-梯度下降"><a href="#1-4-梯度下降" class="headerlink" title="1.4 梯度下降"></a>1.4 梯度下降</h4><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010130841602.png"></p><p>多层感知器：多层神经网路</p><h3 id="2-激活函数"><a href="#2-激活函数" class="headerlink" title="2. 激活函数"></a>2. 激活函数</h3><h4 id="2-1-ReLU-Activation"><a href="#2-1-ReLU-Activation" class="headerlink" title="2.1 ReLU Activation"></a>2.1 ReLU Activation</h4><p>This week, a new activation was introduced, the Rectified Linear Unit (ReLU).</p><p>𝑎&#x3D;𝑚𝑎𝑥(0,𝑧) </p><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010204558837.png" alt="ReLU"></p><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010204715345.png"></p><ul><li><p>二分类问题，sigmoid激活函数是最自然的选择，输出层使用</p></li><li><p>回归模型，输出有正有负，预测明天的股票价格，输出层使用线性激活函数</p></li><li><p>回归模型，输出为非负，预测房屋价格，非负，输出层选择ReLU函数</p></li><li><p>隐藏层选择Relu函数，ReLU计算速度更快，效率高，但事实证明更重要的第二个原因是ReLU函数仅在图形的一部分变平;左边这里<br>是完全平坦的，而sigmoid激活函数，它在两个地方变得平坦。梯度下降就会很慢，减慢学习速度</p></li><li><p>为什么要使用激活函数？</p><ul><li>若所有层都是用线性激活函数，那就变成了线性回归</li></ul></li></ul><h3 id="3-多分类问题"><a href="#3-多分类问题" class="headerlink" title="3. 多分类问题"></a>3. 多分类问题</h3><h4 id="3-1-Softmax函数"><a href="#3-1-Softmax函数" class="headerlink" title="3.1 Softmax函数"></a>3.1 Softmax函数</h4><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010212144511.png"></p><h4 id="3-2-代价函数"><a href="#3-2-代价函数" class="headerlink" title="3.2 代价函数"></a>3.2 代价函数</h4><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010212557352.png"></p><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010220105018.png"></p><h4 id="3-3-Tenserflow-实现"><a href="#3-3-Tenserflow-实现" class="headerlink" title="3.3 Tenserflow 实现"></a>3.3 Tenserflow 实现</h4><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010220327241.png"></p><h4 id="3-4-改进实现"><a href="#3-4-改进实现" class="headerlink" title="3.4 改进实现"></a>3.4 改进实现</h4><p>避免计算过程中出现过大或者过小值造成计算错误，改进方法在计算过程中进行了重新排列</p><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010221115720.png"></p><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010221418604.png"></p><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010221520301.png"></p><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010221537117.png"></p><h3 id="4-多标签分类"><a href="#4-多标签分类" class="headerlink" title="4. 多标签分类"></a>4. 多标签分类</h3><p>一个神经网络同时检测多个目标</p><h3 id="5-更快的训练方法"><a href="#5-更快的训练方法" class="headerlink" title="5. 更快的训练方法"></a>5. 更快的训练方法</h3><h4 id="5-1-Adam算法"><a href="#5-1-Adam算法" class="headerlink" title="5.1 Adam算法"></a>5.1 Adam算法</h4><p>自动调节α</p><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010231015869.png"></p><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010231157191.png"></p><h3 id="6-其他的网络层"><a href="#6-其他的网络层" class="headerlink" title="6. 其他的网络层"></a>6. 其他的网络层</h3><p>密集层</p><p>卷积层</p><ul><li><p>更快的计算</p></li><li><p>需要更少的训练数据，不太会过拟合</p></li></ul><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010231710233.png"></p><h3 id="7-计算图"><a href="#7-计算图" class="headerlink" title="7. 计算图"></a>7. 计算图</h3><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010235541548.png"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>ML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.1 深度学习-神经网络-吴恩达</title>
    <link href="/2024/11/13/ML/class2-week1-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E5%90%B4%E6%81%A9%E8%BE%BE/"/>
    <url>/2024/11/13/ML/class2-week1-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E5%90%B4%E6%81%A9%E8%BE%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><ul><li><p>输入层 输入为特征向量</p></li><li><p>隐藏层</p></li><li><p>输出层</p></li></ul><p><strong>Tensorflow and Keras</strong>  </p><ul><li>TensorFlow 是由谷歌开发的一个机器学习包。2019年，谷歌将 Keras 集成到 TensorFlow 中，并发布了 TensorFlow 2.0。Keras 是由 François Chollet 独立开发的框架，它为 TensorFlow 创建了一个简单、以层为中心的接口。本课程将使用 Keras 接口。</li></ul><h3 id="前向传播算法"><a href="#前向传播算法" class="headerlink" title="前向传播算法"></a>前向传播算法</h3><p><img src="/2024/11/13/ML/class2-week1-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231009222124079.png"></p><ul><li><p>从左到右向前计算，称为前向传播。</p></li><li><p>离输出层越近，隐藏层神经元越少。</p></li></ul><p><img src="/2024/11/13/ML/class2-week1-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231009222647437.png"></p><ul><li><p>两个特征，第一个隐藏层有三个神经元，激活函数为sigmoid，输出为a1，第二层同理；</p></li><li><p>输入向量要写成二维矩阵形式 x &#x3D; np.array([[200,17]])  1x2矩阵。</p></li></ul><p><img src="/2024/11/13/ML/class2-week1-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231009224920509.png"></p><p><img src="/2024/11/13/ML/class2-week1-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231009224946845.png"></p><ul><li>将权重拟合到数据（反向传播）如果数据被归一化，那么这个过程将会进行得更快。</li></ul>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>ML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.3 有监督机器学习回归和分类-逻辑回归-吴恩达</title>
    <link href="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    <url>/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<h2 id="Week3-逻辑回归"><a href="#Week3-逻辑回归" class="headerlink" title="Week3 逻辑回归"></a>Week3 逻辑回归</h2><h3 id="1-二元分类"><a href="#1-二元分类" class="headerlink" title="1. 二元分类"></a>1. 二元分类</h3><p>只有两种可能输出的分类问题称为二元分类。</p><h3 id="2-sigmoid-函数"><a href="#2-sigmoid-函数" class="headerlink" title="2. sigmoid 函数"></a>2. sigmoid 函数</h3><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008173829773.png"></p><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008173915794.png" alt="sigmoid"></p><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20241113221925070.png"></p><p>输入特征，输出0到1</p><h3 id="3-决策边界"><a href="#3-决策边界" class="headerlink" title="3. 决策边界"></a>3. 决策边界</h3><p>线性or非线性</p><h3 id="4-代价函数"><a href="#4-代价函数" class="headerlink" title="4. 代价函数"></a>4. 代价函数</h3><p>平方误差成本函数不是逻辑回归的理想成本函数，常用的是对数损失函数。</p><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008205513401.png" alt="squared error cost"></p><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008205613800.png" alt="凸和非凸"></p><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008205638121.png" alt="image-20231008205638121"></p><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008205807667.png" alt="logistic loss function"></p><p>请记住，损失函数衡量的是你在一个训练样例上的表现如何，它是通过总结你随后获得的所有训练样例的损失，成本函数衡量你在整个训练集上的表现。</p><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008210426343.png" alt="image-20231008210426343"></p><p>整体成本函数为凸函数，可以获得全局最小值</p><p>简化损失函数</p><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008211105952.png" alt="image-20231008211105952"></p><p>代价函数</p><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008211415275.png" alt="image-20231008211415275"></p><p>使用最大似然估计推导出来，是凸函数。</p><h3 id="5-梯度下降"><a href="#5-梯度下降" class="headerlink" title="5. 梯度下降"></a>5. 梯度下降</h3><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008211755913.png" alt="image-20231008211755913"></p><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008211932119.png" alt="image-20231008211932119"></p><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008211950319.png" alt="image-20231008211950319"></p><p>Same concepts:</p><ul><li>Monitor gradient descent(learning curve)</li><li>Vectorized implementation</li><li>Feature scaling</li></ul><h3 id="6-过拟合与欠拟合"><a href="#6-过拟合与欠拟合" class="headerlink" title="6. 过拟合与欠拟合"></a>6. 过拟合与欠拟合</h3><ul><li><p>欠拟合：高偏差 high bias  Does not fit thetraining set well</p></li><li><p>过拟合：高方差 high variance Fits the training setextremely well</p></li></ul><h3 id="7-解决过拟合"><a href="#7-解决过拟合" class="headerlink" title="7. 解决过拟合"></a>7. 解决过拟合</h3><ul><li><p>收集更多的训练样本</p></li><li><p>选择特征   select features to include&#x2F;exclude</p></li><li><p>正则化 Regularization 正则化是一种更温和地减少某些特征影响的方法，而不用像彻底消除它那样严厉。</p></li><li><p>那么正则化的作用是，它可以让你保留所有特征，但它们只是防止特征产生过大的影响，而这有时会导致过度拟合。</p></li></ul><h3 id="8-正则化-Regularization"><a href="#8-正则化-Regularization" class="headerlink" title="8. 正则化 Regularization"></a>8. 正则化 Regularization</h3><p>λ正则化参数</p><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008223908932.png" alt="image-20231008223908932"></p><p>正则化线性回归</p><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008224030737.png" alt="image-20231008224030737"></p><p>梯度下降</p><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008224109310.png" alt="image-20231008224109310"></p><p>正则化逻辑回归</p><h1 id><a href="#" class="headerlink" title></a><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008225551317.png" alt="image-20231008225551317"></h1>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>ML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于演员-评论家框架的层次化多智能体协同决策方法</title>
    <link href="/2024/11/12/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E5%9F%BA%E4%BA%8E%E6%BC%94%E5%91%98-%E8%AF%84%E8%AE%BA%E5%AE%B6%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B1%82%E6%AC%A1%E5%8C%96%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%8D%8F%E5%90%8C%E5%86%B3%E7%AD%96%E6%96%B9%E6%B3%95/"/>
    <url>/2024/11/12/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E5%9F%BA%E4%BA%8E%E6%BC%94%E5%91%98-%E8%AF%84%E8%AE%BA%E5%AE%B6%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B1%82%E6%AC%A1%E5%8C%96%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%8D%8F%E5%90%8C%E5%86%B3%E7%AD%96%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><p>这篇文章的主要内容是提出了一种基于演员-评论家（Actor-Critic，AC）框架的层次化多智能体协同决策方法，旨在解决复杂作战环境下多智能体协同决策中的任务分配不合理和决策一致性较差的问题。该方法通过将决策过程分为不同层次，并使用AC框架来实现智能体之间的信息交流和决策协同，以提高决策效率和战斗力。在高层次，顶层智能体制定任务决策，将总任务分解并分配给底层智能体。在低层次，底层智能体根据子任务进行动作决策，并将结果反馈给高层次。</p><h1 id="研究方法和算法实现："><a href="#研究方法和算法实现：" class="headerlink" title="研究方法和算法实现："></a>研究方法和算法实现：</h1><div align="center"><img src="/2024/11/12/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E5%9F%BA%E4%BA%8E%E6%BC%94%E5%91%98-%E8%AF%84%E8%AE%BA%E5%AE%B6%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B1%82%E6%AC%A1%E5%8C%96%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%8D%8F%E5%90%8C%E5%86%B3%E7%AD%96%E6%96%B9%E6%B3%95/image-20241112210938443.png" alt="image-20241112210938443" style="zoom:40%;" align="center"></div><ol><li><strong>决策层次划分：</strong><ul><li>高层次（High Level, HL）：顶层智能体负责制定任务决策，将总任务分解并分配给底层智能体。</li><li>低层次（Low Level, LL）：底层智能体根据子任务进行动作决策，并将结果反馈给高层次。</li></ul></li><li><strong>状态空间和动作空间的分割：</strong><ul><li>根据层级关系对状态空间和指令空间进行分割，HL决策针对全局作战态势信息下达宏观作战指令，LL决策对执行宏观作战指令的作战编组进行动作操控。</li></ul></li><li><strong>上层任务分解</strong><ul><li>给定总任务<em>M</em>，拆分成子任务集{𝑀0,𝑀1,⋯,𝑀𝑖}</li><li>每一个子任务有任务类型、任务时间、任务状态和作战单元类型，可用one-hot独热码<ul><li>任务类型：主要分为打击任务和巡逻任务，打击任务包含对空拦截、对陆打击，巡逻任务包含空战巡逻、反地面战巡逻</li><li>任务时间：做离散化处理，用时刻𝑇1和时刻𝑇2来表示</li><li>任务状态：启动、未启动</li><li>作战单元：导弹驱逐舰和轰炸机</li></ul></li><li>在根据想定场景设计出子任务后，HL需要根据任务类型规划出任务启动时间，并进一步确定任务的启动次序。</li></ul></li><li><strong>奖惩函数设计：</strong><ul><li>高层智能体只需要聚焦于 子任务选择是否合适，因此高层智能体的奖励函数HL<del>r</del>设计为当任务合适时给予正奖励回报，反之则为负奖励回报。本文中根据全局任务是否完成判断子任务选择是否正确。</li></ul></li><li><strong>基于AC框架的层次化多智能体算法框架：</strong><ul><li>离策略修正的层次化学习(Hierarchical  reinforcement learning with off-policy correction,  HIRO)[31]算法是一种使用两层策略结构来解决复杂强化学习问题的一种单智能体算法，核心思想是高层策略提出目标，低层策略完成这一目标。</li><li>采用部分可观察马尔可夫决策过程（POMDP）对环境进行建模。</li><li>利用深度确定性策略梯度（Deep Deterministic Policy Gradient, DDPG）算法作为基础，结合多智能体深度强化学习，形成了Hierarchical Multi-Agent Actor-Critic（HMaAC）算法。</li></ul></li><li><strong>HMaAC算法设计：</strong><ul><li>初始化顶层和底层的Critic网络和Actor网络，以及经验回放缓冲池。</li><li>通过采样和最小化损失函数更新Critic网络，通过策略梯度更新Actor网络。</li><li>引入熵约束的概念，最大化策略的熵以学习设置合适的子目标。</li></ul></li><li><strong>仿真环境与仿真结果：</strong><ul><li>使用联合作战仿真推演平台作为实验验证环境，进行了2v2、4v4、6v6等不同规模的作战场景实验。</li><li>实验结果显示，HMaAC算法在多种复杂作战场景下均取得了较好的性能，展现了其在提升军事作战协同决策能力方面的潜力。</li></ul></li><li><strong>网络结构设计和训练参数：</strong><ul><li>设计了上层和下层的神经网络结构，均使用3层全连接层，使用ReLU和Tanh作为激活函数。</li><li>设定了一系列超参数，如最大episode数量、批处理参数、熵正则项系数等。</li></ul></li></ol><p><img src="/2024/11/12/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E5%9F%BA%E4%BA%8E%E6%BC%94%E5%91%98-%E8%AF%84%E8%AE%BA%E5%AE%B6%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B1%82%E6%AC%A1%E5%8C%96%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%8D%8F%E5%90%8C%E5%86%B3%E7%AD%96%E6%96%B9%E6%B3%95/image-20241113205648783.png"></p><ol><li><strong>训练结果分析：</strong><ul><li>对比了HMaAC算法和MADDPG算法在2v2仿真场景中的表现，HMaAC算法在奖励值和收敛速度上优于MADDPG算法。</li></ul></li></ol><p>文章最后指出，尽管HMaAC算法在实验中表现出色，但仍需在实地测试和实战演练中进一步验证其可行性和有效性，同时探讨在更复杂多样化作战环境中的适应性和鲁棒性。</p><p>[1]傅妍芳,雷凯麟,魏佳宁,等.基于演员-评论家框架的层次化多智能体协同决策方法[J].兵工学报,2024,45(10):3385-3396.</p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
      <category>多智能体强化学习任务分配</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
      <tag>科研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.2 因特网概述</title>
    <link href="/2024/11/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2%E5%9B%A0%E7%89%B9%E7%BD%91%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/11/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2%E5%9B%A0%E7%89%B9%E7%BD%91%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-2-因特网概述"><a href="#1-2-因特网概述" class="headerlink" title="1.2 因特网概述"></a>1.2 因特网概述</h1><h2 id="1-网络，互联网和因特网"><a href="#1-网络，互联网和因特网" class="headerlink" title="1. 网络，互联网和因特网"></a>1. 网络，互联网和因特网</h2><ul><li>网络是由若干结点和链接这些结点的链路组成</li><li>多个网络通过路由器互连起来，构成一个覆盖范围更大的网路，称为互联网</li><li>因特网是世界上最大的互联网络，连接在因特网上的计算机称为主机</li></ul><h3 id="1-1-internet和Internet的区别"><a href="#1-1-internet和Internet的区别" class="headerlink" title="1.1 internet和Internet的区别"></a>1.1 internet和Internet的区别</h3><ol><li>internet(互联网或互连网)是一个通用名词，它泛指由多个计算机网络互连而成的网络。在这些网络之间的通信协议可以是任意的。</li><li>Internet(因特网)则是一个专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定计算机网络，它采用TCPP协议族作为通信的规则，其前身是美国的ARPANET。</li></ol><h2 id="2-因特网服务提供者ISP-Internet-Service-Provider"><a href="#2-因特网服务提供者ISP-Internet-Service-Provider" class="headerlink" title="2. 因特网服务提供者ISP(Internet Service Provider)"></a>2. 因特网服务提供者ISP(Internet Service Provider)</h2><ul><li>通过向ISP缴纳费用，拿到IP地址和通信线路，路由器等连网设备的使用权</li><li>同时，每个接入因特网的用户，也可以成为ISP，只需购买调制解调器或路由器这样的设备，让其他用户与之相连</li></ul><p><img src="/2024/11/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2%E5%9B%A0%E7%89%B9%E7%BD%91%E6%A6%82%E8%BF%B0/image-20241115201435974.png" alt="image-20241115201435974"></p><h3 id="2-1-基于ISP的三层结构的因特网"><a href="#2-1-基于ISP的三层结构的因特网" class="headerlink" title="2.1 基于ISP的三层结构的因特网"></a>2.1 基于ISP的三层结构的因特网</h3><ul><li>第一层：国际性区域</li><li>第二层：区域性或国家性覆盖规模</li><li>第三层：本地ISP</li></ul><p><img src="/2024/11/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2%E5%9B%A0%E7%89%B9%E7%BD%91%E6%A6%82%E8%BF%B0/image-20241115201638639.png" alt="image-20241115201638639"></p><h2 id="3-因特网的标准化工作"><a href="#3-因特网的标准化工作" class="headerlink" title="3. 因特网的标准化工作"></a>3. 因特网的标准化工作</h2><ol><li><p>因特网的标准化工作对因特网的发展起到了非常重要的作用。</p></li><li><p>因特网在制定其标准上的一个很大的特点是面向公众。</p><ol><li>因特网所有的<a href="http://www.ietf.org/rfc.html">RFC(Request For Comments)技术文档</a>都可从因特网上免费下载；</li><li>任何人都可以随时用电子邮件发表对某个文档的意见或建议。</li></ol></li><li><p>因特网协会ISOC是一个国际性组织，它负责对因特网进行全面管理，以及在世界范围内促进其发展和使用。</p><ol><li>因特网体系结构委员会IAB,负责管理因特网有关协议的开发：</li><li>因特网工程部ETF，负责研究中短期工程问题，主要针对协议的开发和标准化</li><li>因特网研究部IRTF,从事理论方面的研究和开发一些需要长期考虑的问题。</li></ol></li><li><p>制订因特网的正式标准要经过以下4个阶段：</p><ol><li>因特网草案（在这个阶段还不是RFC文档）</li><li>建议标准（从这个阶段开始就成为RFC文档）<br>因特网体系结构委员会A由</li><li>草案标准</li><li>因特网标准</li></ol><blockquote><p>只有一小部分RFC文档最后才能变成因特网标准</p></blockquote></li></ol><h2 id="4-因特网的组成"><a href="#4-因特网的组成" class="headerlink" title="4. 因特网的组成"></a>4. 因特网的组成</h2><ol><li><p>边缘部分</p><blockquote><p>由所有连接在因特网上 的主机组成。这部分是用户直接使用的，用来进行通信（传送数据，音频或视频)和资源共享。</p></blockquote></li><li><p>核心部分</p><blockquote><p>由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）</p></blockquote><ol><li><strong>路由器</strong>是实现<strong>分组交换</strong>的关键构件，任务是<strong>转发收到的分组</strong></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>os</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github+hexo 搭建个人网站</title>
    <link href="/2024/11/12/hexo/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/"/>
    <url>/2024/11/12/hexo/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h1 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h1><h2 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h2><p>Git版本：Git-2.47.0.2-64-bit</p><p>Node.js版本：node-v22.11.0-x64</p><ol><li>官网下载，一路下一步安装即可。</li></ol><p>安装完成，右键git bash here，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git --version<br>node -v<br>npm -v<br></code></pre></td></tr></table></figure><p>安装成功，可查看版本。</p><ol start="2"><li>安装hexo:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo -g<br></code></pre></td></tr></table></figure><p>hexo 安装成功，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo -v<br></code></pre></td></tr></table></figure><h2 id="git-配置SSH-key"><a href="#git-配置SSH-key" class="headerlink" title="git 配置SSH key"></a>git 配置SSH key</h2><ol><li>生成key</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;xxx@qq.com&quot;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>进入C:\用户\用户名.ssh，进入ssh文件夹，复制id_rsa.pub文件里的所有内容</li><li>打开github主页，点击个人设置，点击左侧SSH and GPG keys，点击New SSh key</li><li>标题随便起，将复制的内容粘贴到Key，点击Add SSH key</li><li>测试是否成功，在git bash中输入：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -T git@github.com<br></code></pre></td></tr></table></figure><p><font style="color:rgb(83, 88, 97);">如果遇到选择，输入yes，看到成功即可。</font></p><ol start="6"><li>配置账号密码</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-comment">#你的github用户名</span><br>git config --global user.email <span class="hljs-string">&quot;xxx@163.com&quot;</span> <span class="hljs-comment">#填写你的github注册邮箱</span><br></code></pre></td></tr></table></figure><ol start="7"><li>安装部署插件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git -save<br></code></pre></td></tr></table></figure><h1 id="搭建个人博客"><a href="#搭建个人博客" class="headerlink" title="搭建个人博客"></a>搭建个人博客</h1><ol><li>新建文件夹，初始化个人博客，右键打开git bash，输入</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init <span class="hljs-comment">#初始化</span><br></code></pre></td></tr></table></figure><ol start="2"><li>生成静态网页并预览</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g <span class="hljs-comment"># 生成静态页面</span><br>hexo s <span class="hljs-comment"># 预览</span><br></code></pre></td></tr></table></figure><ol start="3"><li><p>打开网址即可预览</p></li><li><p>打开github 创建与用户名同名的仓库：username.github.io，并查看主分支是main or master</p></li><li><p>打开博客目录下的_config.ymal，找到对应内容并修改</p></li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">git@github.com:username/username.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br></code></pre></td></tr></table></figure><ol start="6"><li>发布到github</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo d<br></code></pre></td></tr></table></figure><ol start="7"><li>新建博客</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new <span class="hljs-string">&#x27;blog-name&#x27;</span><br>hexo new title -p  <span class="hljs-string">&#x27;subdir/title&#x27;</span><br></code></pre></td></tr></table></figure><p>在source&#x2F;_post目录下可查看新建的md文件。</p><p>注：可在hexo s服务开启的状态下修改问价内容查看预览内容。</p><p>要设置其他主题，可自行查找，博主参考Fluid风格的blog <a href="https://hexo.fluid-dev.com/docs/">Hexo Fluid 用户手册</a>。</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>个人博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rust todo</title>
    <link href="/2024/11/12/Rust/rust/"/>
    <url>/2024/11/12/Rust/rust/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu虚拟机磁盘扩容</title>
    <link href="/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/"/>
    <url>/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu虚拟机磁盘空间不够，如何扩容"><a href="#Ubuntu虚拟机磁盘空间不够，如何扩容" class="headerlink" title="Ubuntu虚拟机磁盘空间不够，如何扩容"></a>Ubuntu虚拟机磁盘空间不够，如何扩容</h1><h2 id="一、软件版本"><a href="#一、软件版本" class="headerlink" title="一、软件版本"></a>一、软件版本</h2><p>1.vmware 15.5.0</p><p>2.ubuntu 20.04</p><h2 id="二、操作步骤"><a href="#二、操作步骤" class="headerlink" title="二、操作步骤"></a>二、操作步骤</h2><p>1.打开虚拟机设置，点击硬盘<br><img src="/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/15fc8dc4f12fa5028a9388249f3af272.png" alt="在这里插入图片描述"></p><p>2.点击扩展<br><img src="/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/03bf87f8780d1f5f0d7b6c7130f738ca.png" alt="在这里插入图片描述"></p><p>3.此处我由50G增加到70G，点击扩展<br><img src="/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/19983adb5563d49266bf294485b59606.png" alt="在这里插入图片描述"></p><p>4.开启虚拟机</p><p>5.点击磁盘<br><img src="/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/c8428adcd11dfe842401ab61e80d16f2.png" alt="在这里插入图片描述"></p><p>6.看到有21G的未分配的磁盘空间</p><p><img src="/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/226cfc5dee27ecee83abb2ac08898792.png" alt="在这里插入图片描述"></p><p>7.点击扩展分区</p><p><img src="/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/e8a7616f83cfd499830719c53a862147.png" alt="在这里插入图片描述"></p><p>8.点击设置</p><p><img src="/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/6b93eb112dfe8bce5b66ddb825349451.png" alt="在这里插入图片描述"></p><p>9.调整大小</p><p>10.把按钮拖动到最大，点击调整大小<br><img src="/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/64180784c7a86f2bccc1103506efefda.png" alt="在这里插入图片描述"></p><p>11.选择文件系统进行同样的操作</p><p>12.在终端使用命令 df查看</p><p><img src="/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/c8b5025526882a778881a1c67620328d.png" alt="在这里插入图片描述"></p><p>扩容成功！！！！！！！！！</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
