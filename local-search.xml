<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>17. 读写分离</title>
    <link href="/2024/12/06/MySQL/17-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    <url>/2024/12/06/MySQL/17-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="读写分离">1. 读写分离</h1><h2 id="介绍">1.1 介绍</h2><p><img src="/2024/12/06/MySQL/17-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/image-20241206170049337.png"></p><p>读写分离，简单地说是把对数据库的读和写操作分开，以对应不同的数据库服务器。主数据库提供写操作，从数据库提供读操作，这样能有效地减轻单台数据库的压力。</p><p>通过MyCat即可轻易实现上述功能，不仅可以支持MySQL,也可以支持Oracle和SQLServer。</p><h2 id="一主一从">1.2 一主一从</h2><p>MySQL的主从复制，是基于二进制日志(binlog)实现的。</p><p><img src="/2024/12/06/MySQL/17-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/image-20241206170246375.png"></p><h2 id="一主一从读写分离">1.3 一主一从读写分离</h2><p><img src="/2024/12/06/MySQL/17-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/image-20241206170431217.png"></p><p>balance配置</p><ul><li>负载均衡策略</li></ul><table><thead><tr><th>参数值</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>不开启读写分离机制，所有读操作都发送到当前可用的writeHost上</td></tr><tr><td>1</td><td>全部的readHost与备用的writeHost都参与select语句的负载均衡（主要针对于双主双从模式）</td></tr><tr><td>2</td><td>所有的读写操作都随机在writeHost, readHost上分发</td></tr><tr><td>3</td><td>所有的读请求随机分发到writeHost对应的readHost上执行，writeHost不负担读压力</td></tr></tbody></table><p>设置为1或者3可实现读写分离</p><h2 id="双主双从">1.4 双主双从</h2><p>一个主机Master:1用于处理所有写请求，它的从机Slave1和另一台主机Master2还有它的从机Slave2负责所有读请求。当Master1主机宕机后，Master2主机负责写请求，Master1、Master2互为备机。架构图如下：</p><p><img src="/2024/12/06/MySQL/17-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/image-20241206171335488.png"></p><ul><li>搭建</li></ul><p>以下是图中内容转换为Markdown格式的内容：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs txt">主库配置 (Master1-192.168.200.211)<br><br>1. 修改配置文件 `/etc/my.cnf`<br><br> mysql服务ID, 保证整个集群环境中唯一, 取值范围: 1 - 2^32-1, 默认为1<br>server-id=1<br> 指定同步的数据库<br>binlog-do-db=db01<br>binlog-do-db=db02<br>binlog-do-db=db03<br> 在作为从数据库的时候，有写入操作也要更新二进制日志文件<br>log-slave-updates<br></code></pre></td></tr></table></figure><h2 id="重启mysql服务器">2. 重启MySQL服务器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">systemctl restart mysqld<br></code></pre></td></tr></table></figure><h2 id="双主双从读写分离">1.5 双主双从读写分离</h2><p><img src="/2024/12/06/MySQL/17-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/image-20241206171956580.png"></p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>16. 分库分表</title>
    <link href="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <url>/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍">3.1 介绍</h1><h2 id="问题分析">3.1.1 问题分析</h2><p><img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/1684131667223-1d3c10ec-fcac-4588-a3d8-c4d1ede94535.png" alt="image.png">随着互联网及移动互联网的发展，应用系统的数据量也是成指数式增长，若采用单数据库进行数据存储，存在以下性能瓶颈：</p><ul><li>IO瓶颈：热点数据太多，数据库缓存不足，产生大量磁盘IO，效率较低。请求数据太多，带宽不够，网络IO瓶颈。</li><li>CPU瓶颈：排序、分组、连接查询、聚合统计等SQL会耗费大量的CPU资源，请求数太多，CPU出现瓶颈。</li></ul><p>为了解决上述问题，我们需要对数据库进行分库分表处理。 <img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/1684131731892-2dee07ba-8232-488d-a2ca-d55b2c06b5ab.png" alt="image.png">分库分表的中心思想都是将数据分散存储，使得单一数据库/表的数据量变小来缓解单一数据库的性能问题，从而达到提升数据库性能的目的。</p><h2 id="拆分策略">3.1.2 拆分策略</h2><p>分库分表的形式，主要是两种：垂直拆分和水平拆分。而拆分的粒度，一般又分为分库和分表，所以组成的拆分策略最终如下： <img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/1684132373667-566a1876-197e-4dd2-9d8a-bd927fe1d029.png" alt="image.png"></p><h2 id="垂直拆分">3.1.3 垂直拆分</h2><p><strong>垂直分库</strong> <img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/1684132416195-8bc94a86-a2c6-4420-a3e2-6e109d3be242.png" alt="image.png">垂直分库：以表为依据，根据业务将不同表拆分到不同库中。 特点：</p><ul><li>每个库的表结构都不一样。</li><li>每个库的数据也不一样。</li><li>所有库的并集是全量数据。</li></ul><p><strong>垂直分表</strong> <img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20241205155054161.png" alt="image-20241205155054161">垂直分表：以字段为依据，根据字段属性将不同字段拆分到不同表中。特点：</p><ul><li>每个表的结构都不一样。</li><li>每个表的数据也不一样，一般通过一列（主键/外键）关联。</li><li>所有表的并集是全量数据。</li></ul><h2 id="水平拆分">3.1.4 水平拆分</h2><p><strong>水平分库</strong> <img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/1684132592195-2e7068d7-37c0-418e-9241-aa2f4703ab69.png" alt="image.png">水平分库：以字段为依据，按照一定策略，将一个库的数据拆分到多个库中。特点：</p><ul><li>每个库的表结构都一样。</li><li>每个库的数据都不一样。</li><li>所有库的并集是全量数据。</li></ul><p><strong>水平分表</strong> <img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/1684132634861-37db8e53-f0cf-4ae9-a927-b6a5964528a9.png" alt="image.png">水平分表：以字段为依据，按照一定策略，将一个表的数据拆分到多个表中。特点：</p><ul><li>每个表的表结构都一样。</li><li>每个表的数据都不一样。</li><li>所有表的并集是全量数据。</li></ul><p>在业务系统中，为了缓解磁盘IO及CPU的性能瓶颈，到底是垂直拆分，还是水平拆分；具体是分库，还是分表，都需要根据具体的业务需求具体分析。</p><h2 id="实现技术">3.1.5 实现技术</h2><ul><li>shardingJDBC：基于AOP原理，在应用程序中对本地执行的SQL进行拦截，解析、改写、路由处理。需要自行编码配置实现，只支持java语言，性能较高。</li><li>MyCat：数据库分库分表中间件，不用调整代码即可实现分库分表，支持多种语言，性能不及前者。</li><li><figure><img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/1684132847430-534e6b0d-2a93-41dd-99d2-fa2f27f724e8.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure></li></ul><h1 id="mycat概述">3.2 Mycat概述</h1><p>Mycat是开源的、活跃的、基于Java语言编写的MySQL数据库中间件。可以像使用mysql一样来使用mycat，对于开发人员来说根本感觉不到mycat的存在。开发人员只需要连接MyCat即可，而具体底层用到几台数据库，每一台数据库服务器里面存储了什么数据，都无需关心。具体的分库分表的策略，只需要在MyCat中配置即可。 <img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/1684132892710-d9cace9d-4d62-4127-a62f-533de44556e9.png" alt="image.png"> 优势：</p><ul><li>性能可靠稳定</li><li>强大的技术团队</li><li>体系完善</li><li>社区活跃</li></ul><h2 id="安装">3.2.1 安装</h2><p>Mycat是采用java语言开发的开源的数据库中间件，支持Windows和Linux运行环境，下面介绍MyCat的Linux中的环境搭建。我们需要在准备好的服务器中安装如下软件。 <img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/1684132973833-dfe2d67a-185d-41b4-b5b5-1077714680cf.png" alt="image.png"> 安装文档 <a href="https://www.yuque.com/attachments/yuque/0/2023/pdf/35653686/1684133124805-2bbdf19c-cb4a-436d-8f1e-e36f3558bc05.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fpdf%2F35653686%2F1684133124805-2bbdf19c-cb4a-436d-8f1e-e36f3558bc05.pdf%22%2C%22name%22%3A%22MyCat%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3.pdf%22%2C%22size%22%3A658633%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22uf569e9fb-0266-4f23-9876-aefec7a3a61%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fpdf%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22JXxrS%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D">MyCat安装文档.pdf</a></p><h2 id="概念介绍">3.2.2 概念介绍</h2><p>在MyCat的整体结构中，分为两个部分：上面的逻辑结构、下面的物理结构。<img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/1684135201347-bc6c2e6d-0000-46a9-9863-1ebd1d19fbaf.png" alt="image.png">在MyCat的逻辑结构主要负责逻辑库、逻辑表、分片规则、分片节点等逻辑结构的处理，而具体的数据存储还是在物理结构，也就是数据库服务器中存储的</p><h1 id="mycat入门">3.3 Mycat入门</h1><h2 id="需求">3.3.1 需求</h2><p>由于 tb_order 表中数据量很大，磁盘IO及容量都到达了瓶颈，现在需要对tb_order表进行数据分片，分为三个数据节点，每一个节点主机位于不同的服务器上,具体的结构，参考下图： <img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/1684135557698-f316e8a3-4e0c-425d-8bff-9649a91ec2cc.png" alt="image.png"></p><h2 id="环境准备">3.3.2 环境准备</h2><p><img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/1684135730946-32eca814-b222-44a1-a9fc-d74c3e0dce9e.png" alt="image.png"> 并且在上述3台数据库中创建数据库 db01</p><h2 id="配置">3.3.3 配置</h2><p><strong>schema.xml</strong>在schema.xml中配置逻辑库、逻辑表、数据节点、节点主机等相关信息。具体的配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mycat</span>:schema <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;schema.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mycat:schema</span> <span class="hljs-attr">xmlns:mycat</span>=<span class="hljs-string">&quot;http://io.mycat/&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">schema</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;DB01&quot;</span> <span class="hljs-attr">checkSQLschema</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">sqlMaxLimit</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;TB_ORDER&quot;</span> <span class="hljs-attr">dataNode</span>=<span class="hljs-string">&quot;dn1,dn2,dn3&quot;</span> <span class="hljs-attr">rule</span>=<span class="hljs-string">&quot;auto-sharding-long&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">schema</span>&gt;</span><br> <br><span class="hljs-tag">&lt;<span class="hljs-name">dataNode</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dn1&quot;</span> <span class="hljs-attr">dataHost</span>=<span class="hljs-string">&quot;dhost1&quot;</span> <span class="hljs-attr">database</span>=<span class="hljs-string">&quot;db01&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dataNode</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dn2&quot;</span> <span class="hljs-attr">dataHost</span>=<span class="hljs-string">&quot;dhost2&quot;</span> <span class="hljs-attr">database</span>=<span class="hljs-string">&quot;db01&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dataNode</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dn3&quot;</span> <span class="hljs-attr">dataHost</span>=<span class="hljs-string">&quot;dhost3&quot;</span> <span class="hljs-attr">database</span>=<span class="hljs-string">&quot;db01&quot;</span> /&gt;</span><br> <br><span class="hljs-tag">&lt;<span class="hljs-name">dataHost</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dhost1&quot;</span> <span class="hljs-attr">maxCon</span>=<span class="hljs-string">&quot;1000&quot;</span> <span class="hljs-attr">minCon</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">balance</span>=<span class="hljs-string">&quot;0&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">writeType</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">dbType</span>=<span class="hljs-string">&quot;mysql&quot;</span> <span class="hljs-attr">dbDriver</span>=<span class="hljs-string">&quot;jdbc&quot;</span> <span class="hljs-attr">switchType</span>=<span class="hljs-string">&quot;1&quot;</span>  <span class="hljs-attr">slaveThreshold</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">heartbeat</span>&gt;</span>select user()<span class="hljs-tag">&lt;/<span class="hljs-name">heartbeat</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">writeHost</span> <span class="hljs-attr">host</span>=<span class="hljs-string">&quot;master&quot;</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;jdbc:mysql://192.168.10.101:3306?useSSL=false<span class="hljs-symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&quot;root&quot;</span> <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;980918&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dataHost</span>&gt;</span><br> <br> <span class="hljs-tag">&lt;<span class="hljs-name">dataHost</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dhost2&quot;</span> <span class="hljs-attr">maxCon</span>=<span class="hljs-string">&quot;1000&quot;</span> <span class="hljs-attr">minCon</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">balance</span>=<span class="hljs-string">&quot;0&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">writeType</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">dbType</span>=<span class="hljs-string">&quot;mysql&quot;</span> <span class="hljs-attr">dbDriver</span>=<span class="hljs-string">&quot;jdbc&quot;</span> <span class="hljs-attr">switchType</span>=<span class="hljs-string">&quot;1&quot;</span>  <span class="hljs-attr">slaveThreshold</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">heartbeat</span>&gt;</span>select user()<span class="hljs-tag">&lt;/<span class="hljs-name">heartbeat</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">writeHost</span> <span class="hljs-attr">host</span>=<span class="hljs-string">&quot;master&quot;</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;jdbc:mysql://192.168.10.107:3316?useSSL=false<span class="hljs-symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&quot;root&quot;</span> <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;980918&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dataHost</span>&gt;</span><br> <br> <span class="hljs-tag">&lt;<span class="hljs-name">dataHost</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dhost3&quot;</span> <span class="hljs-attr">maxCon</span>=<span class="hljs-string">&quot;1000&quot;</span> <span class="hljs-attr">minCon</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">balance</span>=<span class="hljs-string">&quot;0&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">writeType</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">dbType</span>=<span class="hljs-string">&quot;mysql&quot;</span> <span class="hljs-attr">dbDriver</span>=<span class="hljs-string">&quot;jdbc&quot;</span> <span class="hljs-attr">switchType</span>=<span class="hljs-string">&quot;1&quot;</span>  <span class="hljs-attr">slaveThreshold</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">heartbeat</span>&gt;</span>select user()<span class="hljs-tag">&lt;/<span class="hljs-name">heartbeat</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">writeHost</span> <span class="hljs-attr">host</span>=<span class="hljs-string">&quot;master&quot;</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;jdbc:mysql://192.168.10.108:3306?useSSL=false<span class="hljs-symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&quot;root&quot;</span> <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;980918&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dataHost</span>&gt;</span><br> <br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mycat:schema</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>server.xml</strong>需要在server.xml中配置用户名、密码，以及用户的访问权限信息，具体的配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;root&quot;</span> <span class="hljs-attr">defaultAccount</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>980918<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;schemas&quot;</span>&gt;</span>DB01<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 表级 DML 权限设置 --&gt;</span><br><span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">&lt;privileges check=&quot;false&quot;&gt;</span><br><span class="hljs-comment">&lt;schema name=&quot;TESTDB&quot; dml=&quot;0110&quot; &gt;</span><br><span class="hljs-comment">&lt;table name=&quot;tb01&quot; dml=&quot;0000&quot;&gt;&lt;/table&gt;</span><br><span class="hljs-comment">&lt;table name=&quot;tb02&quot; dml=&quot;1111&quot;&gt;&lt;/table&gt;</span><br><span class="hljs-comment">&lt;/schema&gt;</span><br><span class="hljs-comment">&lt;/privileges&gt;</span><br><span class="hljs-comment"> --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">user</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>980918<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;schemas&quot;</span>&gt;</span>DB01<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;readOnly&quot;</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">user</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述的配置表示，定义了两个用户 root 和 user ，这两个用户都可以访问DB01 这个逻辑库，访问密码都是123456，但是root用户访问DB01逻辑库，既可以读，又可以写，但是user用户访问 DB01逻辑库是只读的。</p><h2 id="测试">3.3.4 测试</h2><p>配置完毕后，先启动涉及到的3台分片服务器，然后启动MyCat服务器。切换到Mycat的安装目录，执行如下指令，启动Mycat： 启动：<code>bin/mycat start</code>停止：<code>bin/mycat stop</code> Mycat启动之后，占用端口号 8066。启动完毕之后，可以查看logs目录下的启动日志，查看Mycat是否启动完成。 <img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/1684136813294-5f6c0be2-fee4-4fe0-9e99-0749cf410cbe.png" alt="image.png"> 连接Mycat<code>mysql -h 192.168.200.210 -P 8066 -uroot -p123456</code>我们看到我们是通过MySQL的指令来连接的MyCat，因为MyCat在底层实际上是模拟了MySQL的协议。然后就可以在MyCat中来创建表，并往表结构中插入数据，查看数据在MySQL中的分布情况。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> TB_ORDER (<br> id <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>title <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> ,<br> <span class="hljs-keyword">PRIMARY</span> KEY (id)<br>) ENGINE<span class="hljs-operator">=</span>INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 ;<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> TB_ORDER(id,title) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;goods1&#x27;</span>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> TB_ORDER(id,title) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;goods2&#x27;</span>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> TB_ORDER(id,title) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;goods3&#x27;</span>);<br> <br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> TB_ORDER(id,title) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;goods1&#x27;</span>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> TB_ORDER(id,title) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;goods2&#x27;</span>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> TB_ORDER(id,title) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;goods3&#x27;</span>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> TB_ORDER(id,title) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">5000000</span>,<span class="hljs-string">&#x27;goods5000000&#x27;</span>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> TB_ORDER(id,title) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">10000000</span>,<span class="hljs-string">&#x27;goods10000000&#x27;</span>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> TB_ORDER(id,title) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">10000001</span>,<span class="hljs-string">&#x27;goods10000001&#x27;</span>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> TB_ORDER(id,title) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">15000000</span>,<span class="hljs-string">&#x27;goods15000000&#x27;</span>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> TB_ORDER(id,title) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">15000001</span>,<span class="hljs-string">&#x27;goods15000001&#x27;</span>);<br><br></code></pre></td></tr></table></figure><p>经过测试，我们发现，在往 TB_ORDER 表中插入数据时：</p><ul><li>如果id的值在1-500w之间，数据将会存储在第一个分片数据库中。</li><li>如果id的值在500w-1000w之间，数据将会存储在第二个分片数据库中。</li><li>如果id的值在1000w-1500w之间，数据将会存储在第三个分片数据库中。</li><li>如果id的值超出1500w，在插入数据时，将会报错。</li></ul><p>为什么会出现这种现象，数据到底落在哪一个分片服务器到底是如何决定的呢？这是由逻辑表配置时的一个参数 rule决定的，而这个参数配置的就是分片规则，关于分片规则的配置，在后面的课程中会详细讲解。</p><h1 id="mycat配置">3.4 Mycat配置</h1><h2 id="schema.xml">3.4.1 schema.xml</h2><p>schema.xml 作为MyCat中最重要的配置文件之一 ,涵盖了MyCat的逻辑库、逻辑表、分片规则、分片节点及数据源的配置。主要包含以下三组标签：</p><ul><li>schema标签</li><li>datanode标签</li><li>datahost标签</li></ul><h3 id="schema标签">schema标签</h3><figure><img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/1684137759231-a7bc29c6-dec3-47f1-888c-d7df84da7bc0.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> DB01.TB_ORDER;<br></code></pre></td></tr></table></figure><figure><img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/1684137861277-a26e3734-e211-4161-b1b1-ed873aa38a57.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="datanode标签">datanode标签</h3><figure><img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/1684137982668-2fda6b31-4e8e-42d5-abb3-95142400ddc3.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="datahost标签">datahost标签</h3><figure><img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/1684137994571-1671956d-0c47-49e7-bf2b-ece556988ae0.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><h2 id="rule.xml">3.4.2 rule.xml</h2><p>rule.xml中定义所有拆分表的规则, 在使用过程中可以灵活的使用分片算法,或者对同一个分片算法使用不同的参数,它让分片过程可配置化。主要包含两类标签：tableRule、Function。 <img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/1684138272209-2c0ecefd-1aa3-4fe3-a359-83a3feb86d84.png" alt="image.png"></p><h2 id="server.xml">3.4.3 server.xml</h2><p>server.xml配置文件包含了MyCat的系统配置信息，主要有两个重要的标签：system、user。</p><h3 id="system标签">system标签</h3><p><img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/1684138341423-96dab3e9-6683-4ba7-b020-cb5303a12f24.png" alt="image.png"> <a href="https://www.yuque.com/attachments/yuque/0/2023/xlsx/35653686/1684138375179-cf299206-5ce7-48b3-b3ee-31d397dfec2f.xlsx?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fxlsx%2F35653686%2F1684138375179-cf299206-5ce7-48b3-b3ee-31d397dfec2f.xlsx%22%2C%22name%22%3A%22server%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E5%90%AB%E4%B9%89.xlsx%22%2C%22size%22%3A12830%2C%22ext%22%3A%22xlsx%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22ua156721e-db55-4161-977f-7f8fe83dffb%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fvnd.openxmlformats-officedocument.spreadsheetml.sheet%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22pDpyr%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D">server系统配置信息含义.xlsx</a></p><h3 id="user标签">user标签</h3><p>配置MyCat中的用户、访问密码，以及用户针对于逻辑库、逻辑表的权限信息，具体的权限描述方式及配置说明如下： <img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/1684138427556-1a3b1e9d-15e4-4647-a812-6322e756dc86.png" alt="image.png"> 在测试权限操作时，我们只需要将 privileges标签的注释放开。在 privileges 下的schema标签中配置的dml属性配置的是逻辑库的权限。在privileges的schema下的table标签的dml属性中配置逻辑表的权限。</p><h1 id="mycat分片">3.5 Mycat分片</h1><p>垂直拆分</p><ul><li>场景<ul><li>在业务系统中，涉及以下表结构，但是由于用户与订单每天都会产生大量的数据，单台服务器的数据存储及处理能力是有限的，可以对数据库表进行拆分，原有的数据库表如下。</li></ul></li></ul><p><img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20241206145104929.png"></p><ul><li>配置</li></ul><p><img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20241206145332251.png"></p><p><img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20241206145600422.png"></p><p><img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20241206150752724.png"></p><h2 id="范围分片">3.5.1 范围分片</h2><p>按照特性的范围区间（比如时间区间、ID 区间）来分配数据，比如 将 id 为1~299999 的记录分到第一个库， 300000~599999的分到第二个库。范围分片适合需要经常进行范围查找的场景，不太适合随机读写的场景（数据未被分散，容易出现热点数据的问题）。</p><h2 id="取模分片">3.5.2 取模分片</h2><p>根据指定的字段值与节点数量进行求模运算，根据运算结果，来决定该数据属于哪一个分片。指定节点数</p><h2 id="哈希分片">3.5.3 哈希分片</h2><p>求指定 key（比如 id）的哈希，然后根据哈希值确定数据应被放置在哪个表中。哈希分片比较适合随机读写的场景，不太适合经常需要范围查询的场景。</p><h2 id="一致性哈希分片">3.5.4 一致性哈希分片</h2><p>一致性哈希分片算法利用哈希环的思想，对数据进行哈希映射，并通过顺时针寻找最近的服务节点来进行数据的存储。</p><h2 id="枚举分片">3.5.5 枚举分片</h2><p>通过在配置文件中配置可能的枚举值，指定数据分布到不同数据节点上，本规则适用于按照省份、性别、状态拆分数据等业务。</p><p><img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20241206153405063.png"></p><h2 id="应用指定规则">3.5.6 应用指定规则</h2><p><img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20241206154626699.png"></p><p><img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20241206154557898.png"></p><p><img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20241206154607306.png"></p><h2 id="固定分片hash算法">3.5.7 固定分片hash算法</h2><ul><li>该算法类似于十进制的求模运算，但是为二进制的操作，例如，取id的二进制低10位与1111111111进行位&amp;运算。</li></ul><p><img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20241206154902270.png"></p><p>特点：</p><ul><li>如果是求模，连续的值，分别分配到各个不同的分片；但是此算法会将连续的值可能分配到相同的分片，降低事务处理的难度。</li><li>可以均匀分配，也可以非均匀分配。</li><li>分片字段必须为数字类型。</li></ul><p><img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20241206155709235.png"></p><p><img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20241206155657731.png"></p><p><img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20241206155644282.png"></p><h2 id="字符串hash解析算法">3.5.8 字符串hash解析算法</h2><p>截取字符串中的指定位置的子字符串，进行hash算法，算出分片。</p><p><img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20241206160601441.png"></p><p><img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20241206160905946.png"></p><h2 id="按天分片">3.5.9 按天分片</h2><p><img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20241206161250786.png"></p><p><img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20241206161324940.png"></p><h2 id="自然月">3.5.10 自然月</h2><p>使用场景为按照月份来分片，每个自然月为一个分片。</p><p><img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20241206161945243.png"></p><p><img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20241206162013822.png"></p><h1 id="mycat管理及监控">3.6 Mycat管理及监控</h1><h2 id="mycat原理">3.6.1 Mycat原理</h2><p><img src="/2024/12/06/MySQL/16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20241206163039878.png"></p><h2 id="mycat管理">3.6.2 Mycat管理</h2><p>Mycat默认开通2个端口，可以在server.xml中进行修改。</p><ul><li>8066数据访问端口，即进行DML和DDL操作。</li><li>9066数据库管理端口，即mycat服务管理控制功能，用于管理mycat的整个集群状态</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql <span class="hljs-operator">-</span>h <span class="hljs-number">192.168</span><span class="hljs-number">.200</span><span class="hljs-number">.210</span> <span class="hljs-operator">-</span>P <span class="hljs-number">9066</span> <span class="hljs-operator">-</span>uroot <span class="hljs-operator">-</span>p123456<br></code></pre></td></tr></table></figure><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>show @<span class="citation" data-cites="help">@help</span></td><td>查看Mycat管理工具帮助文档</td></tr><tr><td>show @<span class="citation" data-cites="version">@version</span></td><td>查看Mycat的版本</td></tr><tr><td>reload @<span class="citation" data-cites="config">@config</span></td><td>重新加载Mycat的配置文件</td></tr><tr><td>show @<span class="citation" data-cites="datasource">@datasource</span></td><td>查看Mycat的数据源信息</td></tr><tr><td>show @<span class="citation" data-cites="datanode">@datanode</span></td><td>查看MyCat现有的分片节点信息</td></tr><tr><td>show @<span class="citation" data-cites="threadpool">@threadpool</span></td><td>查看Mycat的线程池信息</td></tr><tr><td>show @<span class="citation" data-cites="sql">@sql</span></td><td>查看执行的SQL</td></tr><tr><td>show @<span class="citation" data-cites="sql.sum">@sql.sum</span></td><td>查看执行的SQL统计</td></tr></tbody></table><h2 id="监控">3.6.3 监控</h2><p>mycat-eye</p><p>zookeeper</p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15. 主从复制</title>
    <link href="/2024/12/06/MySQL/15-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <url>/2024/12/06/MySQL/15-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="概述">2.1 概述</h1><p>主从复制是指将主数据库的 DDL 和 DML操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。MySQL支持一台主库同时向多台从库进行复制，从库同时也可以作为其他从服务器的主库，实现链状复制。<img src="/2024/12/06/MySQL/15-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/1684128112951-0cd4b40b-a815-437d-9bd6-c18096fbd133.png" alt="image.png"> MySQL 复制的优点主要包含以下三个方面：</p><ul><li>主库出现问题，可以快速切换到从库提供服务。</li><li>实现读写分离，降低主库的访问压力。</li><li>可以在从库中执行备份，以避免备份期间影响主库服务。</li></ul><h2 id="原理">2.2 原理</h2><p>MySQL主从复制的核心就是二进制日志，具体的过程如下： <img src="/2024/12/06/MySQL/15-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/1684128165471-d3a65879-da12-489e-bd0f-c8496e40ef7b.png" alt="image.png"> 从上图来看，复制分成三步：</p><ol type="1"><li>Master 主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog中。</li><li>从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 RelayLog</li><li>slave重做中继日志中的事件，将改变反映它自己的数据。</li></ol><h2 id="搭建">2.3 搭建</h2><h3 id="准备">准备</h3><figure><img src="/2024/12/06/MySQL/15-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/1684130779942-736e38ee-e197-4b09-8d67-ff84e1d104ba.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="主库准备">主库准备</h3><ol type="1"><li>修改配置文件 <code>/etc/my.cnf</code></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">#mysql 服务ID，保证整个集群环境中唯一，取值范围：<span class="hljs-number">1</span> – <span class="hljs-number">232</span><span class="hljs-number">-1</span>，默认为<span class="hljs-number">1</span><br><br>server<span class="hljs-operator">-</span>id<span class="hljs-operator">=</span><span class="hljs-number">1</span><br><br>#是否只读,<span class="hljs-number">1</span> 代表只读, <span class="hljs-number">0</span> 代表读写<br><br>read<span class="hljs-operator">-</span><span class="hljs-keyword">only</span><span class="hljs-operator">=</span><span class="hljs-number">0</span><br><br>#忽略的数据, 指不需要同步的数据库<br><br>#binlog<span class="hljs-operator">-</span>ignore<span class="hljs-operator">-</span>db<span class="hljs-operator">=</span>mysql<br>#指定同步的数据库<br><br>#binlog<span class="hljs-operator">-</span>do<span class="hljs-operator">-</span>db<span class="hljs-operator">=</span>db01<br><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>重启MySQL服务器 <code>systemctl restart mysqld</code></li><li>登录mysql，创建远程连接的账号，并授予主从复制权限</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">#创建itcast用户，并设置密码，该用户可在任意主机连接该MySQL服务<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;itcast&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED <span class="hljs-keyword">WITH</span> mysql_native_password <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;Root@123456&#x27;</span> <br>;<br>#为 <span class="hljs-string">&#x27;itcast&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> 用户分配主从复制权限<br><br><span class="hljs-keyword">GRANT</span> REPLICATION SLAVE <span class="hljs-keyword">ON</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;itcast&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>;<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>通过指令，查看二进制日志坐标 <code>show master status ;</code><ol type="1"><li><figure><img src="/2024/12/06/MySQL/15-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/1684130963675-1da0aca0-b2cd-4fd1-8a1f-42fb70c0c2c0.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure></li><li>字段含义说明： file : 从哪个日志文件开始推送日志文件 position：从哪个位置开始推送日志 ， binlog_ignore_db :指定不需要同步的数据库</li></ol></li></ol><h3 id="从库配置">从库配置</h3><ol type="1"><li>修改配置文件 /etc/my.cnf</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">#mysql 服务ID，保证整个集群环境中唯一，取值范围：<span class="hljs-number">1</span> – <span class="hljs-number">2</span><span class="hljs-operator">^</span><span class="hljs-number">32</span><span class="hljs-number">-1</span>，和主库不一样即可<br><br>server<span class="hljs-operator">-</span>id<span class="hljs-operator">=</span><span class="hljs-number">2</span><br><br>#是否只读,<span class="hljs-number">1</span> 代表只读, <span class="hljs-number">0</span> 代表读写<br><br>read<span class="hljs-operator">-</span><span class="hljs-keyword">only</span><span class="hljs-operator">=</span><span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>重启MySQL服务</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">systemctl restart mysqld<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>登录MySQL，设置主库配置</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">CHANGE REPLICATION SOURCE <span class="hljs-keyword">TO</span> SOURCE_HOST<span class="hljs-operator">=</span><span class="hljs-string">&#x27;192.168.200.200&#x27;</span>, SOURCE_USER<span class="hljs-operator">=</span><span class="hljs-string">&#x27;itcast&#x27;</span>, <br>SOURCE_PASSWORD<span class="hljs-operator">=</span><span class="hljs-string">&#x27;Root@123456&#x27;</span>, SOURCE_LOG_FILE<span class="hljs-operator">=</span><span class="hljs-string">&#x27;binlog.000010&#x27;</span>, <br>SOURCE_LOG_POS<span class="hljs-operator">=</span><span class="hljs-number">984</span>;<br></code></pre></td></tr></table></figure><figure><img src="/2024/12/06/MySQL/15-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/1684131033564-1b738c26-1b1e-468c-a02b-d1d3ef1b5ea7.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><ol start="4" type="1"><li>开启同步操作<code>start replica ;</code></li><li>查看主从同步状态<code>show replica status ;</code><ol type="1"><li>这里需要注意，主从库的<code>server-uuid</code>不能一样，具有唯一性<code>vim /var/lib/mysql/auto.cnf</code></li><li><figure><img src="/2024/12/06/MySQL/15-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/1684131070718-6c5f441b-8426-4adc-b923-ca99634fe63e.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure></li></ol></li></ol><h3 id="测试">测试</h3><p>在主库做操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> database db01;<br>use db01;<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tb_user(<br> id <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">primary</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> auto_increment,<br> name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br> sex <span class="hljs-type">varchar</span>(<span class="hljs-number">1</span>)<br>)engine<span class="hljs-operator">=</span>innodb <span class="hljs-keyword">default</span> charset<span class="hljs-operator">=</span>utf8mb4;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_user(id,name,sex) <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>),(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;Trigger&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>),<br>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;Dawn&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在从库查验数据，验证主从是否同步</p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>14. 日志</title>
    <link href="/2024/12/06/MySQL/14-%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/"/>
    <url>/2024/12/06/MySQL/14-%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="错误日志">1.1 错误日志</h1><p>错误日志是 MySQL 中最重要的日志之一，它记录了当 mysqld启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，建议首先查看此日志。该日志是默认开启的，默认存放目录 /var/log/，默认的日志文件名为mysqld.log 。查看日志 置：<code>show variables like '%log_error%';</code> <img src="/2024/12/06/MySQL/14-%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/1684127028346-598bae76-afe0-4b53-ab77-d94744b42295.png" alt="image.png"></p><h1 id="二进制日志">1.2 二进制日志</h1><p>二进制日志（BINLOG）记录了所有的 DDL（数据定义语言）语句和DML（数据操纵语言）语句，但不包括数据查询（SELECT、SHOW）语句。 作用：①. 灾难时的数据恢复； ②.MySQL的主从复制。在MySQL8版本中，默认二进制日志是开启着的，涉及到的参数如下：<code>show variables like '%log_bin%';</code> <img src="/2024/12/06/MySQL/14-%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/1684127103697-5e0d7d7e-33ed-404e-91b7-ab91ea2451df.png" alt="image.png"> 参数说明：</p><ul><li>log_bin_basename：当前数据库服务器的binlog日志的基础名称(前缀)，具体的binlog文件名需要再该basename的基础上加上编号(编号从000001开始)。</li><li>log_bin_index：binlog的索引文件，里面记录了当前服务器关联的binlog文件有哪些。</li></ul><p><img src="/2024/12/06/MySQL/14-%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/1684127210313-747d60c1-b5b2-481e-9a0a-2f1f8b54787c.png" alt="image.png"> <code>show variables like'%binlog_format%';</code><img src="/2024/12/06/MySQL/14-%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/1684127249740-2b9cd808-4fb5-48b0-ac5e-ff13bfbe896e.png" alt="image.png">由于日志是以二进制方式存储的，不能直接读取，需要通过二进制日志查询工具mysqlbinlog来 看，具体语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysqlbinlog [ 参数选项 ] logfilename<br><br>参数选项：<br><br> <span class="hljs-operator">-</span>d 指定数据库名称，只列出指定的数据库相关操作。<br><br> <span class="hljs-operator">-</span>o 忽略掉日志中的前n行命令。<br><br> <span class="hljs-operator">-</span>v 将行事件(数据变更)重构为<span class="hljs-keyword">SQL</span>语句<br><br> <span class="hljs-operator">-</span>vv 将行事件(数据变更)重构为<span class="hljs-keyword">SQL</span>语句，并输出注释信息<br><br></code></pre></td></tr></table></figure><p>对于比较繁忙的业务系统，每天生成的binlog数据巨大，如果长时间不清除，将会占用大量磁盘空间。可以通过以下几种方式清理日志：<img src="/2024/12/06/MySQL/14-%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/1684127556074-51342b98-89da-4576-a7d0-fcee4ce32b9a.png" alt="image.png">也可以在mysql的配置文件中配置二进制日志的过期时间，设置了之后，二进制日志过期会自动删除。（默认30天）<code>show variables like'%binlog_expire_logs_seconds%';</code></p><h1 id="查询日志">1.3 查询日志</h1><p>查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的SQL语句。默认情况下，查询日志是未开启的。<img src="/2024/12/06/MySQL/14-%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/1684127618677-955313b9-780d-494c-8302-1bc0dd402e0b.png" alt="image.png"> 如果需要开启查询日志，可以修改MySQL的配置文件/etc/my.cnf 文件，添加如下内容：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">#该选项用来开启查询日志 ， 可选值 ： <span class="hljs-number">0</span> 或者 <span class="hljs-number">1</span> ； <span class="hljs-number">0</span> 代表关闭， <span class="hljs-number">1</span> 代表开启 <br><br>general_log<span class="hljs-operator">=</span><span class="hljs-number">1</span><br><br>#设置日志的文件名 ， 如果没有指定， 默认的文件名为 host_name.log <br><br>general_log_file<span class="hljs-operator">=</span>mysql_query.log<br><br></code></pre></td></tr></table></figure><p>开启了查询日志之后，在MySQL的数据存放目录，也就是 /var/lib/mysql/目录下就会出现 mysql_query.log文件。之后所有的客户端的增删改查操作都会记录在该日志文件之中，长时间运行后，该日志文件将会非常大。</p><h1 id="慢查询日志">1.4 慢查询日志</h1><p>慢查询日志记录了所有执行时间超过参数 long_query_time设置值并且扫描记录数不小于 min_examined_row_limit的所有的SQL语句的日志，默认未开启。long_query_time 默认为 10 秒，最小为0，精度可以到微秒。如果需要开启慢查询日志，需要在MySQL的配置文件/etc/my.cnf 中配置如下参数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">#慢查询日志<br><br>slow_query_log<span class="hljs-operator">=</span><span class="hljs-number">1</span><br><br>#执行时间参数<br><br>long_query_time<span class="hljs-operator">=</span><span class="hljs-number">2</span><br><br></code></pre></td></tr></table></figure><p>默认情况下，不会记录管理语句，也不会记录不使用索引进行查找的查询。可以使用<code>log_slow_admin_statements</code>和更改此行为<code>log_queries_not_using_indexes</code>，如下所述。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">#记录执行较慢的管理语句<br><br>log_slow_admin_statements <span class="hljs-operator">=</span><span class="hljs-number">1</span><br><br>#记录执行较慢的未使用索引的语句<br><br>log_queries_not_using_indexes <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><p>上述所有的参数配置完成之后，都需要重新启动MySQL服务器才可以生效。</p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9.1 多智能体强化学习</title>
    <link href="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/9-1-%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/9-1-%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念">基本概念</h1><p>多智能体强化学习有四种常见的设定：</p><ul><li>Fullycooperative：各个agent的利益一致，获得的奖励相同，比如同一条生产流水线上的各个机器。</li><li>Fullycompetitive：各个agent相互竞争，一方的收获是另一方的损失。</li><li>Mixed Cooperative &amp;competitive：各个agent之间即存在合作也存在竞争，比如moba游戏中多人一队，队伍之间相互对抗，队伍内部相互合作。</li><li>Self-interested：利己主义，是指每个agent只想最大化自己收益，至于别人收益的高低它不在乎。</li></ul><p>第<span class="math inline">\(i\)</span>个智能体的Discountedreturn<span class="math inline">\(U_t^i\)</span>定义为：</p><p><span class="math inline">\(U_t^i = R_t^i + \gamma R_{t+1}^i +\gamma^2 R_{t+2}^i + \gamma^3 R_{t+3}^i + \ldots + \gamma^nR_n^i\)</span></p><p>每个agent都有自己的policy network<span class="math inline">\(\pi(a^i| s; \theta^i)\)</span>。</p><p>第<span class="math inline">\(i\)</span>个agent的state-valuefunction<span class="math inline">\(V^i(s_t; \theta^1, \ldots,\theta^n)\)</span>定义为：</p><p><span class="math inline">\(V^i(s_t; \theta^1, \ldots, \theta^n) =E[U_t^i | S_t = s_t]\)</span></p><p>单智能体强化学习的目标是使<span class="math inline">\(J(\theta) =E_S(V(S, \theta))\)</span>。</p><p>多智能体强化学习判断收敛的标准是纳什均衡，每个玩家都有自己的<span class="math inline">\(J^i(\theta^1, \theta^2, \ldots, \theta^n) =E_S(V^i(S, \theta^1, \theta^2, \ldots, \theta^n))\)</span>，</p><p>如果对于任意一个玩家来说，如果其他玩家选择的策略不变，那么不能通过改变当前策略来提高<span class="math inline">\(J^i\)</span>值的话，就说明达到了nash均衡。</p><h1 id="三种架构">三种架构</h1><p>三种架构分别为：</p><ul><li>Fullydecentralized：完全去中心化：每个agent使用自己的观测和奖励来学习自己的策略。Agentsdo not communicate。</li><li>Fully centralized：完全中心化：The agents send everything to thecentral controller. The controller makes decisions for all theagents。</li><li>Centralized training with decentralized execution：A centralcontroller is used during training. The controller is disabled aftertraining.</li></ul><ol type="1"><li>Fully decentralized中每个agent单独训练自己的网络，它基于自己的策略网络采取动作，并观测动作发生后自己的状态和奖励，跟前面的单智能体强化学习一样。</li></ol><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/9-1-%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/1733287218172-30524f6c-849e-4f05-86a1-16e712f608d5.png"></p><ol start="2" type="1"><li>Fully centralized由中心决定该做什么，中心有n个策略网络和价值网络，对应n个agents，它接收观测值来更新网络并决定动作。这样做的好处是中心知道所有的状态和价值，可以更好的训练网络和决定动作，坏处是速度会变慢。</li></ol><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/9-1-%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/1733287227571-e2b99d87-ab3b-4150-beaa-482cf496993a.png"></p><p>Centralized training with decentralizedexecution，每个agent独立持有自己的策略函数，中心持有n个价值函数，对应n个agent。训练过程是中心化的，中心知道所有的观测状态、动作、奖励；训练结果是去中心化的，每个agent已经训练好了自己的策略函数，中心的价值函数就没必要存在了。</p><p>如下图所示，每个agent基于自己的策略函数采取动作，然后相关信息传给中心。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/9-1-%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/1733287242079-2cdb22a0-2312-4e80-af06-644be1e40ab5.png"></p><p>如图所示，中心接收到信息后，训练并调用q函数，计算q值返回给各个agent。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/9-1-%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/1733287250212-b1e49ff2-b812-42cf-88ff-7dbb87143aa6.png"></p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/9-1-%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/1733287861024-26be5065-4a1a-4e96-89c2-6dc856b287f5.png"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>RL</category>
      
      <category>DRL-王树森</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8.1 策略学习的高级技巧：置信域策略优化 (TRPO)</title>
    <link href="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/8-1-%E7%AD%96%E7%95%A5%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7-%E7%BD%AE%E4%BF%A1%E5%9F%9F%E7%AD%96%E7%95%A5%E4%BC%98%E5%8C%96-TRPO/"/>
    <url>/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/8-1-%E7%AD%96%E7%95%A5%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7-%E7%BD%AE%E4%BF%A1%E5%9F%9F%E7%AD%96%E7%95%A5%E4%BC%98%E5%8C%96-TRPO/</url>
    
    <content type="html"><![CDATA[<p>策略学习的高级技巧：置信域策略优化 (TRPO)</p><p>PPO算法就是在TRPO的基础上推出的。</p><h1 id="trust-region-policy-optimization-trpo">Trust Region PolicyOptimization (TRPO)</h1><p>置信域策略优化 (trust region policy optimization, TRPO)是一种策略学习方法，跟以前学的策略梯度有很多相似之处。跟策略梯度方法相比，TRPO有两个优势：第一，TRPO表现更稳定，收敛曲线不会剧烈波动，而且对学习率不敏感；第二，TRPO用更少的经验(即 智能体 收集到的状态、动作、奖励)就能达到与策略梯度方法相同的表现。</p><p>学习TRPO 的关键在于理解置信域方法(trust regionmethods)。置信域方法不是TRPO的论文提出的，而是数值最优化领域中一类经典的算法，历史至少可以追溯到1970 年。TRPO论文的贡献在于巧妙地把置信域方法应用到强化学习中，取得非常好的效果。</p><h2 id="置信域方法">置信域方法</h2><p>有这样一个优化问题：<span class="math inline">\(\max_\thetaJ(\theta)\)</span>这里的<span class="math inline">\(J(\theta)\)</span>是目标函数，<span class="math inline">\(\theta\)</span>是优化变量。求解这个优化问题的目的是找到一个变量<span class="math inline">\(\theta\)</span>使得目标函数<span class="math inline">\(J(\theta)\)</span>取得最大值。有各种各样的优化算法用于解决这个问题。几乎所有的数值优化算法都是做这样的迭代：</p><p><span class="math inline">\(\theta_{\text{new}} \leftarrow\text{Update}(Data; \theta_{\text{now}})\)</span></p><p>此处的<span class="math inline">\(\theta_{\text{now}}\)</span>和<span class="math inline">\(\theta_{\text{new}}\)</span>分别是优化变量当前的值和新的值。不同算法的区别在于具体怎么样利用数据更新优化变量。</p><p>置信域方法用到一个概念——置信域。下面介绍置信域。给定变量当前的值<span class="math inline">\(\theta_{\text{now}}\)</span>,用<span class="math inline">\(\mathcal{N}(\theta_{\text{now}})\)</span>表示<span class="math inline">\(\theta_{\text{now}}\)</span>的一个邻域。举个例子：</p><p><span class="math inline">\(\mathcal{N}(\theta_{\text{now}}) = \{\theta \mid \|\theta - \theta_{\text{now}}\|_2 \leq \Delta\}\)</span></p><p>这个例子中，集合<span class="math inline">\(\mathcal{N}(\theta_{\text{now}})\)</span>是以<span class="math inline">\(\theta_{\text{now}}\)</span>为球心、 以<span class="math inline">\(\Delta\)</span>为半径的球；见右图。球中的点都足够接近<span class="math inline">\(\theta_{\text{now}}\)</span>。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/8-1-%E7%AD%96%E7%95%A5%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7-%E7%BD%AE%E4%BF%A1%E5%9F%9F%E7%AD%96%E7%95%A5%E4%BC%98%E5%8C%96-TRPO/1733296514045-1a242c1d-85fc-4b1f-946a-bbd03cafe3f5.png"></p><p>置信域方法需要构造一个函数<span class="math inline">\(L(\theta |\theta_{\text{now}})\)</span>,这个函数要满足这个条件：</p><p><span class="math inline">\(L(\theta | \theta_{\text{now}}) \text{很接近 } J(\theta), \quad \forall \theta \in\mathcal{N}(\theta_{\text{now}})\)</span></p><p>那么集合<span class="math inline">\(\mathcal{N}(\theta_{\text{now}})\)</span>就被称作置信域。顾名思义，在<span class="math inline">\(\theta_{\text{now}}\)</span>的邻域上，我们可以信任<span class="math inline">\(L(\theta | \theta_{\text{now}})\)</span>,可以拿<span class="math inline">\(L(\theta |\theta_{\text{now}})\)</span>来替代目标函数<span class="math inline">\(J(\theta)\)</span>。</p><p>图 9.2 用一个一元函数的例子解释<span class="math inline">\(J(\theta)\)</span>和<span class="math inline">\(L(\theta |\theta_{\text{now}})\)</span>的关系。图中横轴是优化变量<span class="math inline">\(\theta\)</span>,纵轴是函数值。如图9.2(a)所示，函数<span class="math inline">\(L(\theta |\theta_{\text{now}})\)</span>未必在整个定义域上都接近<span class="math inline">\(J(\theta)\)</span>,而只是在<span class="math inline">\(\theta_{\text{now}}\)</span>的领域里接近<span class="math inline">\(J(\theta)\)</span>。<span class="math inline">\(\theta_{\text{now}}\)</span>的邻域就叫做置信域。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/8-1-%E7%AD%96%E7%95%A5%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7-%E7%BD%AE%E4%BF%A1%E5%9F%9F%E7%AD%96%E7%95%A5%E4%BC%98%E5%8C%96-TRPO/1733296582100-f7896c8c-f2f3-406c-933e-4d6c8319fed1.png"></p><p>通常来说，<span class="math inline">\(J\)</span>是个很复杂的函数，我们甚至可能不知道<span class="math inline">\(J\)</span>的解析表达式(比如<span class="math inline">\(J\)</span>是某个函数的期望)。而我们人为构造出的函数<span class="math inline">\(L\)</span>相对较为简单，比如<span class="math inline">\(L\)</span>是<span class="math inline">\(J\)</span>的蒙特卡洛近似，或者是<span class="math inline">\(J\)</span>在<span class="math inline">\(\theta_{\text{now}}\)</span>这个点的二阶泰勒展开。既然可以信任<span class="math inline">\(L\)</span>,那么不妨用<span class="math inline">\(L\)</span>代替复杂的函数<span class="math inline">\(J\)</span>,然后对<span class="math inline">\(L\)</span>做最大化。这样比直接优化<span class="math inline">\(J\)</span>要容易得多。这就是置信域方法的思想。</p><p>具体来说，置信域方法做下面这两个步骤，一直重复下去，当无法让<span class="math inline">\(J\)</span>的值增大的时候终止算法。</p><p>第一步——做近似：给定<span class="math inline">\(\theta_{\text{now}}\)</span>,构造函数<span class="math inline">\(L(\theta |\theta_{\text{now}})\)</span>,使得对于所有的<span class="math inline">\(\theta \in\mathcal{N}(\theta_{\text{now}})\)</span>,函数值<span class="math inline">\(L(\theta | \theta_{\text{now}})\)</span>与<span class="math inline">\(J(\theta)\)</span>足够接近。图9.2(b)解释了做近似这一步。</p><p>第二步一一最大化：在置信域<span class="math inline">\(\mathcal{N}(\theta_{\text{now}})\)</span>中寻找变量<span class="math inline">\(\theta\)</span>的值， 使得函数<span class="math inline">\(L\)</span>的值最大化。把找到的值记作：</p><p><span class="math inline">\(\theta_{\text{new}} =\mathrm{argmax}_{\theta \in \mathcal{N}(\theta_{\text{now}})} L(\theta |\theta_{\text{now}})\)</span></p><p>图 9.2( c) 解释了最大化这一步。</p><p>置信域方法其实是一类算法框架，而非一个具体的算法。有很多种方式实现实现置信域方法。第一步需要做近似，而做近似的方法有多种多样，比如蒙特卡洛、二阶泰勒展开。第二步需要解一个带约束的最大化问题；求解这个问题又需要单独的数值优化算法，比如梯度投影算法、拉格朗日法。除此之外，置信域<span class="math inline">\(\mathcal{N}(\theta_{\text{now}})\)</span>也有多种多样的选择，既可以是球，也可以是两个概率分布的 KL 散度 (KL Divergence)。</p><p>ChatGPT对梯度投影算法的介绍</p><p>梯度投影算法的基本步骤可以通过数学公式进行介绍。考虑带有约束的优化问题：</p><p><span class="math inline">\(min_{x} f(x)\)</span></p><p>其中 (f(x)) 是目标函数，(x) 是优化变量，同时满足一组约束条件：</p><p><span class="math inline">\(g_i(x) \leq 0, \quad i = 1, 2, \ldots,m\)</span></p><p>梯度投影算法的迭代过程如下：</p><ol type="1"><li>初始化： 选择初始解 (<span class="math inline">\(x_0\)</span>)，设置学习率 (<span class="math inline">\(\alpha\)</span>) 和停止准则。</li><li>梯度计算： 计算目标函数在当前解 (<span class="math inline">\(x_k\)</span>) 处的梯度 (<span class="math inline">\(\nabla f(x_k)\)</span>)。</li><li>梯度投影： 将梯度投影到满足约束条件的空间中。假设投影操作为(P(x))，则更新方向为 (<span class="math inline">\(\Delta x_k = P(x_k -\alpha \nabla f(x_k)) - x_k\)</span>)。</li><li>更新变量： 使用投影后的梯度信息来更新变量 (<span class="math inline">\(x_k\)</span>)：</li></ol><p><span class="math inline">\(x_{k+1} = x_k + \alpha \Deltax_k\)</span></p><ol start="5" type="1"><li>收敛判断：判断算法是否达到停止条件，例如目标函数的变化足够小或者达到预定的迭代次数。</li></ol><p>在这里，梯度投影的关键在于投影操作 (P(x))的定义。具体的投影形式取决于约束条件的性质。例如，对于线性约束 (<span class="math inline">\(g_i(x) \leq 0\)</span>)，投影操作可以表示为 (<span class="math inline">\(P(x) =\max(0,g_i(x))\)</span>)。对于更一般的非线性约束，可能需要使用专门的数学工具或算法来进行梯度投影。</p><p>需要注意的是，实际应用中可能需要根据具体问题对算法进行调整和定制。</p><h2 id="策略学习">策略学习</h2><p>首先复习策略学习的基础知识。策略网络记作<span class="math inline">\(\pi(a | s; \theta)\)</span>,它是个概率质量函数。动作价值函数记作<span class="math inline">\(Q_{\pi}(s,a)\)</span>,它是回报的期望。状态价值函数记作：</p><p><span class="math inline">\(V_{\pi}(s) = \mathbb{E}_{A \sim \pi(\cdot| s; \theta)}[Q_{\pi}(s, A)] = \sum_{a \in A} \pi(a | s; \theta) \cdotQ_{\pi}(s, a)\)</span></p><p>注意，<span class="math inline">\(V_{\pi}(s)\)</span>依赖于策略网络<span class="math inline">\(\pi\)</span>, 所以依赖于<span class="math inline">\(\pi\)</span>的参数<span class="math inline">\(\theta\)</span>。策略学习的目标函数是：</p><p><span class="math inline">\(J(\theta) =\mathbb{E}_S[V_{\pi}(S)]\)</span></p><p><span class="math inline">\(J(\theta)\)</span>只依赖于<span class="math inline">\(\theta\)</span>,不依赖于状态<span class="math inline">\(S\)</span>和动作<span class="math inline">\(A\)</span>。前面介绍的策略梯度方法 (包括 REINFORCE和 Actor-Critic) 用蒙特卡洛近似梯度<span class="math inline">\(\nabla_{\theta}J(\theta)\)</span>,得到随机梯度，然后做随机梯度上升更新<span class="math inline">\(\theta\)</span>,使得目标函数<span class="math inline">\(J(\theta)\)</span>增大。</p><p>下面我们要把目标函数<span class="math inline">\(J(\theta)\)</span>变换成一种等价形式。从等式出发，把状态价值写成：</p><p><span class="math inline">\(V_{\pi}(s) = \sum_{a \in A} \pi(a | s;\theta_{\text{now}}) \cdot \frac{\pi(a | s; \theta)}{\pi(a | s;\theta_{\text{now}})} \cdot Q_{\pi}(s, a) = \mathbb{E}_{A \sim \pi(\cdot| s; \theta_{\text{now}})}[\frac{\pi(A | s; \theta)}{\pi(A | s;\theta_{\text{now}})} \cdot Q_{\pi}(s, A)]\)</span></p><p>第一个等式很显然，因为连加中的第一项可以消掉第二项的分母。第二个等式把策略网络<span class="math inline">\(\pi(A | s;\theta_{\text{now}})\)</span>看做动作<span class="math inline">\(A\)</span>的概率质量函数，所以可以把连加写成期望。由公式可得定理 9.1。定理 9.1 是 TRPO 的关键所在，甚至可以说 TRPO就是从这个公式推出的。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/8-1-%E7%AD%96%E7%95%A5%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7-%E7%BD%AE%E4%BF%A1%E5%9F%9F%E7%AD%96%E7%95%A5%E4%BC%98%E5%8C%96-TRPO/1733297357437-8f83c470-83c3-4dda-bfd1-b60217fed8f0.png"></p><p>定理 9.1. 目标函数的等价形式目标函数<span class="math inline">\(J(\theta)\)</span>可以等价写成：</p><p><span class="math inline">\(J(\theta) = \mathbb{E}_S \left[\mathbb{E}_{A \sim \pi(\cdot | S, \theta_{\text{now}})} \left[\frac{\pi(A | S; \theta)}{\pi(A | S; \theta_{\text{now}})} \cdotQ_{\pi}(S, A) \right] \right]\)</span></p><p>上面<span class="math inline">\(Q_{\pi}\)</span>中的<span class="math inline">\(\pi\)</span>指的是<span class="math inline">\(\pi(A | S; \theta)\)</span>。</p><p>公式中的期望是关于状态<span class="math inline">\(S\)</span>和动作<span class="math inline">\(A\)</span>求的。状态<span class="math inline">\(S\)</span>的概率密度函数只有环境知道，而我们并不知道，但是我们可以从环境中获取<span class="math inline">\(S\)</span>的观测值。动作<span class="math inline">\(A\)</span>的概率质量函数是策略网络<span class="math inline">\(\pi(A | S; \theta_{\text{now}})\)</span>;注意，策略网络的参数是旧的值<span class="math inline">\(\theta_{\text{now}}\)</span>.</p><h2 id="trpo-数学推导">TRPO 数学推导</h2><p>前面介绍了数值优化的基础和价值学习的基础，终于可以开始推导 TRPO。TRPO是置信域方法在策略学习中的应用，所以 TRPO也遵循置信域方法的框架，重复做近似和最大化这两个步骤，直到算法收敛。收敛指的是无法增大目标函数<span class="math inline">\(J(\theta)\)</span>, 即无法增大期望回报。</p><p><strong>第一步——做近似</strong>：</p><p>我们从定理 9.1 出发。定理把目标函数<span class="math inline">\(J(\theta)\)</span>写成了期望的形式。我们无法直接算出期望，无法得到<span class="math inline">\(J(\theta)\)</span>的解析表达式；原因在于只有环境知道状态<span class="math inline">\(S\)</span>的概率密度函数，而我们不知道。我们可以对期望做蒙特卡洛近似，从而把函数<span class="math inline">\(J\)</span>近似成函数<span class="math inline">\(L\)</span>。用策略网络<span class="math inline">\(\pi(A | S;\theta_{\text{now}})\)</span>控制智能体跟环境交互，从头到尾玩完一局游戏观测到一条轨迹：</p><p><span class="math inline">\(s_1, a_1, r_1, s_2, a_2, r_2, \cdots,s_n, a_n, r_n.\)</span></p><p>其中的状态<span class="math inline">\(\{s_t\}_{t=1}^n\)</span>都是从环境中观测到的，其中的动作<span class="math inline">\(\{a_t\}_{t=1}^n\)</span>都是根据策略网络<span class="math inline">\(\pi(\cdot | s_t;\theta_{\text{now}})\)</span>抽取的样本。所以，</p><p><span class="math inline">\(\frac{\pi(a_t | s_t; \theta)}{\pi(a_t |s_t; \theta_{\text{now}})} \cdot Q_{\pi}(s_t, a_t)\)</span></p><p>是对定理 9.1 中期望的无偏估计。我们观测到了<span class="math inline">\(n\)</span>组状态和动作，于是应该对公式求平均，把得到均值记作：</p><p><span class="math inline">\(L(\theta | \theta_{\text{now}}) =\frac{1}{n} \sum_{t=1}^{n} \frac{\pi(a_t | s_t; \theta)}{\pi(a_t | s_t;\theta_{\text{now}})} \cdot Q_{\pi}(s_t, a_t)\)</span></p><p>既然连加里每一项都是期望的无偏估计，那么<span class="math inline">\(n\)</span>项的均值<span class="math inline">\(L\)</span>也是无偏估计。所以可以拿<span class="math inline">\(L\)</span>作为目标函数<span class="math inline">\(J\)</span>的蒙特卡洛近似。</p><p>公式中的<span class="math inline">\(L(\theta |\theta_{\text{now}})\)</span>是对目标函数<span class="math inline">\(J(\theta)\)</span>的近似。可惜我们还无法直接对<span class="math inline">\(L\)</span>求最大化，原因是我们不知道动作价值<span class="math inline">\(Q_{\pi}(s_t,a_t)\)</span>。解决方法是做两次近似：</p><p><span class="math inline">\(Q_{\pi}(s_t, a_t) \LongrightarrowQ_{\pi_{\text{old}}}(s_t, a_t) \Longrightarrow u_t.\)</span></p><p>公式中<span class="math inline">\(Q_{\pi}\)</span>中的策略是<span class="math inline">\(\pi(a_t | s_t; \theta)\)</span>, 而<span class="math inline">\(Q_{\pi_{\text{old}}}\)</span>中的策略则是旧策略<span class="math inline">\(\pi(a_t | s_t;\theta_{\text{now}})\)</span>。我们用旧策略<span class="math inline">\(\pi(a_t | s_t;\theta_{\text{now}})\)</span>生成轨迹<span class="math inline">\(\{(s_j,a_j, r_j, s_{j+1})\}_{j=1}^n\)</span>。所以折扣回报</p><p><span class="math inline">\(u_t = r_t + \gamma \cdot r_{t+1} +\gamma^2 \cdot r_{t+2} + \cdots + \gamma^{n-t} \cdot r_n\)</span></p><p>是对<span class="math inline">\(Q_{\pi_{\text{old}}}\)</span>的近似，而未必是对<span class="math inline">\(Q_{\pi}\)</span>的近似。仅当<span class="math inline">\(\theta\)</span>接近<span class="math inline">\(\theta_{\text{now}}\)</span>的时候，<span class="math inline">\(u_t\)</span>才是<span class="math inline">\(Q_{\pi}\)</span>的有效近似。这就是为什么要强调置信域，即<span class="math inline">\(\theta\)</span>在<span class="math inline">\(\theta_{\text{now}}\)</span>的邻域中。</p><p>拿<span class="math inline">\(u_t\)</span>替代<span class="math inline">\(Q_{\pi}(s_t, a_t)\)</span>,那么公式中的<span class="math inline">\(L(\theta | \theta_{\text{now}})\)</span>变成了</p><p><span class="math inline">\(\tilde{L}(\theta | \theta_{\text{now}}) =\frac{1}{n} \sum_{t=1}^{n} \frac{\pi(a_t | s_t; \theta)}{\pi(a_t | s_t;\theta_{\text{now}})} \cdot u_t.\)</span></p><p>总结一下，我们把目标函数<span class="math inline">\(J\)</span>近似成<span class="math inline">\(L\)</span>,然后又把<span class="math inline">\(L\)</span>近似成<span class="math inline">\(\tilde{L}\)</span>。在第二步近似中，我们需要假设<span class="math inline">\(\theta\)</span>接近<span class="math inline">\(\theta_{\text{now}}\)</span>。</p><p><strong>第二步——最大化</strong>：</p><p>TRPO 把公式 中的<span class="math inline">\(\tilde{L}(\theta |\theta_{\text{now}})\)</span>作为对目标函数<span class="math inline">\(J(\theta)\)</span>的近似，然后求解这个带约束的最大化问题：</p><p><span class="math inline">\(\max_{\theta} \tilde{L}(\theta |\theta_{\text{now}}); \quad \text{s.t.} \quad \theta \in\mathcal{N}(\theta_{\text{now}}).\)</span></p><p>公式中的<span class="math inline">\(\mathcal{N}(\theta_{\text{now}})\)</span>是置信域，即<span class="math inline">\(\theta_{\text{now}}\)</span>的一个邻域。该用什么样的置信域呢？</p><ul><li>一种方法是用以<span class="math inline">\(\theta_{\text{now}}\)</span>为球心、以<span class="math inline">\(\Delta\)</span>为半径的球作为置信域。这样的话，公式就变成</li></ul><p><span class="math inline">\(\max_{\theta} \tilde{L}(\theta |\theta_{\text{now}}); \quad \text{s.t.} \quad \|\theta -\theta_{\text{now}}\|_2 \leq \Delta.\)</span></p><ul><li>另一种方法是用 KL 散度衡量两个概率质量函数——<span class="math inline">\(\pi(\cdot | s_i;\theta_{\text{now}})\)</span>和<span class="math inline">\(\pi(\cdot |s_i; \theta)\)</span>—— 的距离。两个概率质量函数区别越大，它们的 KL散度就越大。反之，如果<span class="math inline">\(\theta\)</span>很接近<span class="math inline">\(\theta_{\text{now}}\)</span>,那么两个概率质量函数就越接近。用KL 散度的话，公式就变成</li></ul><p><span class="math inline">\(\max_{\theta} \tilde{L}(\theta |\theta_{\text{now}}); \quad \text{s.t.} \quad \frac{1}{t} \sum_{i=1}^{t}\text{KL}[\pi(\cdot | s_i; \theta_{\text{now}}) \| \pi(\cdot | s_i;\theta)] \leq \Delta.\)</span></p><p>用球作为置信域的好处是置信域是简单的形状，求解最大化问题比较容易，但是用球做置信域的实际效果不如用KL 散度。</p><p>TRPO的第二步—最大化—需要求解带约束的最大化问题。注意，这种问题的求解并不容易；简单的梯度上升算法并不能解带约束的最大化问题。数值优化教材通常有介绍带约束问题的求解，有兴趣的话自己去阅读数值优化教材，这里就不详细解释如何求解问题。读者可以这样看待优化问题：只要你能把一个优化问题的目标函数和约束条件解析地写出来，通常会有数值算法能解决这个问题。</p><h2 id="训练流程">训练流程</h2><p>在本节的最后，我们总结一下用 TRPO 训练策略网络的流程。TRPO需要重复做近似和最大化这两个步骤：</p><ol type="1"><li>做近似——构造函数<span class="math inline">\(\tilde{L}\)</span>近似目标函数<span class="math inline">\(J(\theta)\)</span>:<ul><li>设当前策略网络参数是<span class="math inline">\(\theta_{\text{now}}\)</span>。用策略网络<span class="math inline">\(\pi(a | s;\theta_{\text{now}})\)</span>控制智能体与环境交互，玩完一局游戏，记录下轨迹<span class="math inline">\(s_1, a_1, r_1, s_2, a_2, r_2, \cdots, s_n, a_n,r_n\)</span>.</li><li>对于所有的<span class="math inline">\(t = 1, \cdots, n\)</span>,计算折扣回报<span class="math inline">\(u_t = \sum_{k=t}^n \gamma^{k-t}\cdot r_k\)</span>.</li><li>得出近似函数：<span class="math inline">\(\tilde{L}(\theta |\theta_{\text{now}}) = \frac{1}{n} \sum_{t=1}^{n} \frac{\pi(a_t | s_t;\theta)}{\pi(a_t | s_t; \theta_{\text{now}})} \cdot u_t.\)</span></li></ul></li><li>最大化——用某种数值算法求解带约束的最大化问题：</li></ol><p><span class="math inline">\(\theta_{\text{new}} = \arg\max_{\theta}\tilde{L}(\theta | \theta_{\text{now}}) ; \quad \text{s.t.} \quad\|\theta - \theta_{\text{now}}\|_2 \leq \Delta.\)</span></p><p>此处的约束条件是二范数距离。可以把它替换成 KL 散度，即公式(9.10)。</p><p>TRPO 中有两个需要调的超参数：一个是置信域的半径<span class="math inline">\(\Delta\)</span>,另一个是求解最大化问题的数值算法的学习率。通常来说，<span class="math inline">\(\Delta\)</span>在算法的运行过程中要逐渐缩小。虽然TRPO 需要调参，但是 TRPO对超参数的设置并不敏感。即使超参数设置不够好，TRPO的表现也不会太差。相比之下，策略梯度算法对超参数更敏感。</p><p>TRPO算法真正实现起来并不容易，主要难点在于第二步一一最大化。不建议读者自己去实现TRPO。</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>RL</category>
      
      <category>DRL-王树森</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.2 确定策略梯度 (DPG)</title>
    <link href="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/7-2-%E7%A1%AE%E5%AE%9A%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6-DPG/"/>
    <url>/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/7-2-%E7%A1%AE%E5%AE%9A%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6-DPG/</url>
    
    <content type="html"><![CDATA[<h1 id="确定策略梯度-dpg">确定策略梯度 (DPG)</h1><p>确定策略梯度 (deterministic policy gradient, DPG)是最常用的连续控制方法。DPG 是一种 actor-critic 方法，它有一个策略网络(演员), 一个价值网络 (评委)。策略网络控制智能体做运动，它基于状态<span class="math inline">\(s\)</span>做出动作<span class="math inline">\(a\)</span>。价值网络不控制智能体，只是基于状态<span class="math inline">\(s\)</span>给动作<span class="math inline">\(a\)</span>打分，从而指导策略网络做出改进。图 10.2是两个神经网络的关系。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/7-2-%E7%A1%AE%E5%AE%9A%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6-DPG/1733276393148-f6ec8fbe-9457-4d14-a32c-78836eed2d46.png"></p><h1 id="策略网络和价值网络">策略网络和价值网络</h1><p>本节的策略网络不同于前面章节的策略网络。在之前章节里，策略网络<span class="math inline">\(\pi(a|s;\theta)\)</span>是一个概率质量函数，它输出的是概率值。本节的确定策略网络<span class="math inline">\(\mu(s;\theta)\)</span>的输出是<span class="math inline">\(d\)</span>维的向量<span class="math inline">\(a\)</span>,作为动作。两种策略网络一个是随机的，一个是确定性的：</p><ul><li>之前章节中的策略网络<span class="math inline">\(\pi(a|s;\theta)\)</span>带有随机性：给定状态<span class="math inline">\(s\)</span>, 策略网络输出的是离散动作空间<span class="math inline">\(A\)</span>上的概率分布；</li><li>本节的确定策略网络没有随机性：对于确定的状态<span class="math inline">\(s\)</span>, 策略网络<span class="math inline">\(\mu\)</span>输出的动作<span class="math inline">\(a\)</span>是确定的。动作<span class="math inline">\(a\)</span>直接是<span class="math inline">\(\mu\)</span>的输出，而非随机抽样得到的。</li></ul><p>确定策略网络<span class="math inline">\(\mu\)</span>的结构如图 10.3所示。如果输入的状态<span class="math inline">\(s\)</span>是个矩阵或者张量(例如图片、视频),那么<span class="math inline">\(\mu\)</span>就由若干卷积层、全连接层等组成。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/7-2-%E7%A1%AE%E5%AE%9A%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6-DPG/1733277234294-77dea5b6-056c-420c-b568-9bdfd8e824e5.png"></p><p>确定策略可以看做是随机策略的一个特例。确定策略<span class="math inline">\(\mu(s;\theta)\)</span>的输出是<span class="math inline">\(d\)</span>维向量，它的第<span class="math inline">\(i\)</span>个元素记作<span class="math inline">\(\hat{\mu}_i=[\mu(s;\theta)]_i\)</span>。定义下面这个随机策略：</p><p><span class="math inline">\(\pi(a|s;\theta,\sigma)=\prod_{i=1}^d\frac{1}{\sqrt{6.28}\sigma_i}\cdot\exp\left(-\frac{[a_i-\hat{\mu}_i]^2}{2\sigma_i^2}\right).\quad{(10.1)}\)</span></p><p>这个随机策略是均值为<span class="math inline">\(\mu(s;\theta)\)</span>、协方差矩阵为<span class="math inline">\(\text{diag}(\sigma_1,\cdots,\sigma_d)\)</span>的多元正态分布。本节的确定策略可以看做是上述随机策略在<span class="math inline">\(\sigma=[\sigma_1,\cdots,\sigma_d]\)</span>为全零向量时的特例。</p><p>本节的价值网络<span class="math inline">\(q(s,a;w)\)</span>是对动作价值函数<span class="math inline">\(Q_{\pi}(s,a)\)</span>的近似。价值网络的结构如图10.4 所示。价值网络的输入是状态<span class="math inline">\(s\)</span>和动作<span class="math inline">\(a\)</span>,输出的价值<span class="math inline">\(\hat{q}=q(s,a;w)\)</span>是个实数，可以反映动作的好坏；动作<span class="math inline">\(a\)</span>越好，则价值<span class="math inline">\(\hat{q}\)</span>就越大。所以价值网络可以评价策略网络的表现。在训练的过程中，价值网络帮助训练策略网络；在训练结束之后，价值网络就被丢弃，由策略网络控制智能体。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/7-2-%E7%A1%AE%E5%AE%9A%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6-DPG/1733277392319-e425876e-ca82-4235-8d9e-8ade3dde110b.png"></p><h1 id="算法推导">算法推导</h1><h2 id="用行为策略收集经验">用行为策略收集经验：</h2><p>本节的确定策略网络属于异策略(off-policy) 方法，即行为策略 (behaviorpolicy) 可以不同于目标策略 (target policy)。目标策略即确定策略网络<span class="math inline">\(\mu(s;\theta_{now})\)</span>,其中<span class="math inline">\(\theta_{now}\)</span>是策略网络最新的参数。行为策略可以是任意的，比如</p><p><span class="math inline">\(a=\mu(s;\theta_{old})+\epsilon\)</span>.</p><p>公式的意思是行为策略可以用过时的策略网络参数，而且可以往动作中加入噪声<span class="math inline">\(\epsilon \in\mathbb{R}^d\)</span>。异策略的好处在于可以把收集经验与训练神经网络分割开；把收集到的经验存入经验回放数组(replaybuffer),在做训练的时候重复利用收集到的经验。见图 10.5。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/7-2-%E7%A1%AE%E5%AE%9A%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6-DPG/1733277422761-a61031d2-0c98-4cba-903e-d7dcefa69533.png"></p><p>用行为策略控制智能体与环境交互，把智能体的轨迹(trajectory)整理成<span class="math inline">\((s_t,a_t,r_t,s_{t+1})\)</span>这样的四元组，存入经验回放数组。在训练的时候，随机从数组中抽取一个四元组，记作<span class="math inline">\((s_j,a_j,r_j,s_{j+1})\)</span>。在训练策略网络<span class="math inline">\(\mu(s;\theta)\)</span>的时候，只用到状态<span class="math inline">\(s_j\)</span>。在训练价值网络<span class="math inline">\(q(s,a;w)\)</span>的时候，要用到四元组中全部四个元素：<span class="math inline">\(s_j,a_j,r_j,s_{j+1}\)</span>。</p><h2 id="训练策略网络">训练策略网络：</h2><p>首先通俗解释训练策略网络的原理。如图 10.6 所示，给定状态<span class="math inline">\(s\)</span>,策略网络输出一个动作<span class="math inline">\(a=\mu(s;\theta)\)</span>,然后价值网络会给<span class="math inline">\(a\)</span>打一个分数：<span class="math inline">\(\hat{q}=q(s,a;w)\)</span>。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/7-2-%E7%A1%AE%E5%AE%9A%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6-DPG/1733277473657-212a4de1-9f2c-44a7-9d15-d3b4a3506952.png"></p><p>参数<span class="math inline">\(\theta\)</span>影响<span class="math inline">\(a\)</span>, 从而影响<span class="math inline">\(\hat{q}\)</span>。分数<span class="math inline">\(\hat{q}\)</span>可以反映出<span class="math inline">\(\theta\)</span>的好坏程度。训练策略网络的目标就是改进参数<span class="math inline">\(\theta\)</span>,使<span class="math inline">\(\hat{q}\)</span>变得更大。把策略网络看做演员，价值网络看做评委。训练演员(策略网络)的目的就是让他迎合评委(价值网络) 的喜好，改变自己的表演技巧 (即参数<span class="math inline">\(\theta\)</span>), 使得评委打分<span class="math inline">\(\hat{q}\)</span>的均值更高。</p><p>根据以上解释，我们来推导目标函数。如果当前状态是<span class="math inline">\(s\)</span>, 那么价值网络的打分就是：</p><p><span class="math inline">\(q(s,\mu(s;\theta);w)\)</span>。</p><p>我们希望打分的期望尽量高，所以把目标函数定义为打分的期望：</p><p><span class="math inline">\(J(\theta)=\mathbb{E}_S[q(S,\mu(S;\theta);w)]\)</span>。</p><p>关于状态<span class="math inline">\(S\)</span>求期望消除掉了<span class="math inline">\(S\)</span>的影响；不管面对什么样的状态<span class="math inline">\(S\)</span>,策略网络(演员)都应该做出很好的动作，使得平均分<span class="math inline">\(J(\theta)\)</span>尽量高。策略网络的学习可以建模成这样一个最大化问题：</p><p><span class="math inline">\(\max_{\theta}J(\theta)\)</span>。</p><p>注意，这里我们只训练策略网络，所以最大化问题中的优化变量是策略网络的参数<span class="math inline">\(\theta\)</span>,而价值网络的参数<span class="math inline">\(w\)</span>被固定住。</p><p>可以用梯度上升来增大<span class="math inline">\(J(\theta)\)</span>。每次用随机变量<span class="math inline">\(S\)</span>的一个观测值(记作<span class="math inline">\(s_j\)</span>) 来计算梯度：<span class="math inline">\(g_j \triangleq\nabla_{\theta}q(s_j,\mu(s_j;\theta);w)\)</span>。</p><p>它是<span class="math inline">\(\nabla_{\theta}J(\theta)\)</span>的无偏估计。<span class="math inline">\(g_j\)</span>叫做确定策略梯度 (deterministic policygradient), 缩写DPG。</p><p>可以用链式法则求出梯度<span class="math inline">\(g_j\)</span>。复习一下链式法则。如果有这样的函数关系<span class="math inline">\(\theta \to a \to q\)</span>,那么<span class="math inline">\(q\)</span>关于<span class="math inline">\(\theta\)</span>的导数可以写成</p><p><span class="math inline">\(\frac{\partial q}{\partial \theta} =\frac{\partial a}{\partial \theta} \cdot \frac{\partial q}{\partiala}\)</span>。</p><p>价值网络的输出与<span class="math inline">\(\theta\)</span>的函数关系如图 10.6所示。应用链式法则，我们得到下面的定理。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/7-2-%E7%A1%AE%E5%AE%9A%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6-DPG/1733278437394-8e56538f-e36f-46ab-ad4b-dd94dcb05a51.png"></p><p>定理 10.1. 确定策略梯度</p><p><span class="math inline">\(\nabla_{\theta}q(s_j,\mu(s_j;\theta);w)=\nabla_{\theta}\mu(s_j;\theta)\cdot \nabla_a q(s_j,\hat{a}_j;w), \quad \text{其中} \quad\hat{a}_j=\mu(s_j;\theta).\)</span></p><p>由此我们得到更新<span class="math inline">\(\theta\)</span>的算法。每次从经验回放数组里随机抽取一个状态，记作<span class="math inline">\(s_j\)</span>。计算<span class="math inline">\(\hat{a}_j=\mu(s_j;\theta)\)</span>。用梯度上升更新一次<span class="math inline">\(\theta\)</span>:</p><p><span class="math inline">\(\theta \leftarrow \theta + \beta \cdot\nabla_{\theta}\mu(s_j;\theta) \cdot \nabla_aq(s_j,\hat{a}_j;w).\)</span></p><p>此处的<span class="math inline">\(\beta\)</span>是学习率，需要手动调。这样做梯度上升，可以逐渐让目标函数<span class="math inline">\(J(\theta)\)</span>增大，也就是让评委给演员的平均打分更高。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/7-2-%E7%A1%AE%E5%AE%9A%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6-DPG/1733279212098-876f0c1c-0a9e-4abe-b074-c89d4c1be535.png"></p><p>解决办法：</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/7-2-%E7%A1%AE%E5%AE%9A%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6-DPG/1733279236156-29520efa-80d5-4f6b-9fed-ebee63fc47d5.png"></p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/7-2-%E7%A1%AE%E5%AE%9A%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6-DPG/1733279312061-79ba30b5-1cc4-4573-9e0e-df095537af29.png"></p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/7-2-%E7%A1%AE%E5%AE%9A%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6-DPG/1733279390737-2cd4e7b6-a4ed-4ca9-80f5-d42b9aea27f4.png"></p><h2 id="训练价值网络">训练价值网络：</h2><p>首先通俗解释训练价值网络的原理。训练价值网络的目标是让价值网络<span class="math inline">\(q(s,a;w)\)</span>的预测越来越接近真实价值函数<span class="math inline">\(Q_{\pi}(s,a)\)</span>。如果把价值网络看做评委，那么训练评委的目标就是让他的打分越来越准确。每一轮训练都要用到一个实际观测的奖励<span class="math inline">\(r\)</span>,可以把<span class="math inline">\(r\)</span>看做“真理”,用它来校准评委的打分。</p><p>训练价值网络要用 TD 算法。这里的 TD 算法与之前学过的标准 actor-critic类似，都是让价值网络去拟合 TD目标。每次从经验回放数组中取出一个四元组<span class="math inline">\((s_j,a_j,r_j,s_{j+1})\)</span>,用它更新一次参数<span class="math inline">\(w\)</span>。首先让价值网络做预测：</p><p><span class="math inline">\(\hat{q}_j=q(s_j,a_j;w) \quad \text{和}\quad \hat{q}_{j+1}=q(s_{j+1},\mu(s_{j+1};\theta);w)\)</span></p><p>计算 TD 目标<span class="math inline">\(\hat{y}_j=r_j+\gamma \cdot\hat{g}_{j+1}\)</span>.定义损失函数</p><p><span class="math inline">\(L(w)=\frac{1}{2}\left[q(s_j,a_j;w)-\hat{y}_j\right]^2,\)</span></p><p>计算梯度</p><p><span class="math inline">\(\nabla_{w} L(w) =\underbrace{\left(\hat{q}_{j} - \hat{y}_{j}\right)}_{\text{TD误差}\delta_{j}} \cdot \nabla_{w} q\left(s_{j}, a_{j}; w\right),\)</span></p><p>做一轮梯度下降更新参数<span class="math inline">\(w\)</span>:</p><p><span class="math inline">\(w \leftarrow w - \alpha \cdot \nabla_{w}L(w)\)</span></p><p>这样可以让损失函数<span class="math inline">\(L(w)\)</span>减小，也就是让价值网络的预测<span class="math inline">\(\hat{q}_j=q(s,a;w)\)</span>更接近 TD 目标<span class="math inline">\(\hat{y}_j\)</span>。公式中的<span class="math inline">\(\alpha\)</span>是学习率，需要手动调。</p><p><strong>训练流程</strong>：<br>做训练的时候，可以同时对价值网络和策略网络做训练。每次从经验回放数组中抽取一个四元组，记作<span class="math inline">\((s_j,a_j,r_j,s_{j+1})\)</span>。把神经网络当前参数记作<span class="math inline">\(w_{now}\)</span>和<span class="math inline">\(\theta_{now}\)</span>。执行以下步骤更新策略网络和价值网络：</p><ol type="1"><li>让策略网络做预测：<span class="math inline">\(\hat{a}_j=\mu(s_j;\theta_{now})\)</span>和<span class="math inline">\(\hat{a}_{j+1}=\mu(s_{j+1};\theta_{now})\)</span>.</li><li>让价值网络做预测：<span class="math inline">\(\hat{q}_j=q(s_j,a_j;w_{now})\)</span>和<span class="math inline">\(\hat{q}_{j+1}=q(s_{j+1},\hat{a}_{j+1};w_{now})\)</span>.</li><li>计算 TD 目标和 TD 误差：<span class="math inline">\(\hat{y}_j=r_j+\gamma \cdot\hat{q}_{j+1}\)</span>和<span class="math inline">\(\delta_j=\hat{q}_j-\hat{y}_j\)</span>.</li><li>更新价值网络：<span class="math inline">\(w_{new}=w_{now}-\alpha\cdot \delta_j \cdot \nabla_w q(s_j,a_j;w_{now})\)</span>.</li><li>更新策略网络：<span class="math inline">\(\theta_{new}=\theta_{now}+\beta \cdot\nabla_{\theta}\mu(s_j;\theta_{now}) \cdot \nabla_aq(s_j,\hat{a}j;w_{now})\)</span>.</li></ol><p>在实践中，上述算法的表现并不好；读者应当采用后面介绍的技巧训练策略网络和价值网络。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/7-2-%E7%A1%AE%E5%AE%9A%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6-DPG/1733277619102-cbf150fb-2913-49e7-afa0-e8d5499baa46.png"></p><h1 id="深入分析-dpg">深入分析 DPG</h1><p>上一节介绍的 DPG 是一种“四不像”的方法。DPG乍看起来很像前面介绍的策略学习方法，因为 DPG 的目的是学习一个策略<span class="math inline">\(\mu\)</span>,而价值网络<span class="math inline">\(q\)</span>只起辅助作用。然而 DPG 又很像之前介绍的DQN, 两者都是异策略 (Off-policy), 而且两者存在高估问题。鉴于 DPG的重要性，我们更深入分析 DPG。</p><h2 id="从策略学习的角度看待-dpg">从策略学习的角度看待 DPG</h2><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/7-2-%E7%A1%AE%E5%AE%9A%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6-DPG/1733280642243-5fa19640-5b83-438e-aaee-e64bff97fa84.png"></p><p>答案是动作价值函数<span class="math inline">\(Q_{\pi}(s,a)\)</span>。上一节 DPG的训练流程中，更新价值网络用到 TD 目标：<span class="math inline">\(\hat{y}_j=r_j+\gamma \cdotq(s_{j+1},\mu(s_{j+1};\theta_{now});w_{now})\)</span>。</p><p>很显然，当前的策略<span class="math inline">\(\mu(s;\theta_{now})\)</span>会直接影响价值网络<span class="math inline">\(q\)</span>。策略不同，得到的价值网络<span class="math inline">\(q\)</span>就不同。</p><p>虽然价值网络<span class="math inline">\(q(s,a;w)\)</span>通常是对动作价值函数<span class="math inline">\(Q_{\pi}(s,a)\)</span>的近似，但是我们最终的目标是让<span class="math inline">\(q(s,a;w)\)</span>趋近于最优动作价值函数<span class="math inline">\(Q^{\star}(s,a)\)</span>。回忆一下，如果<span class="math inline">\(\pi\)</span>是最优策略<span class="math inline">\(\pi^{\star}\)</span>, 那么<span class="math inline">\(Q_{\pi}(s,a)\)</span>就等于<span class="math inline">\(Q^{\star}(s,a)\)</span>。训练 DPG 的目的是让<span class="math inline">\(\mu(s;\theta)\)</span>趋近于最优策略<span class="math inline">\(\pi^{\star}\)</span>那么理想情况下，<span class="math inline">\(q(s,a;w)\)</span>最终趋近于<span class="math inline">\(Q^{\star}(s,a)\)</span>。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/7-2-%E7%A1%AE%E5%AE%9A%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6-DPG/1733280692694-384edfe4-ceed-417b-9fbf-a933c5a2e5a4.png"></p><p>答案是目标策略<span class="math inline">\(\mu(s;\theta_{now})\)</span>,因为目标策略对价值网络的影响很大。在理想情况下，行为策略对价值网络没有影响。我们用TD 算法训练价值网络，TD 算法的目的在于鼓励价值网络的预测趋近于 TD目标。理想情况下，</p><p><span class="math inline">\(q(s_j,a_j;w)=r_j+\gamma \cdotQ(s_{j+1},\mu(s_{j+1};\theta_{now});w_{now}), \quad \forall(s_j,a_j,r_j,s_{j+1}).\)</span></p><p>在收集经验的过程中，行为策略决定了如何基于<span class="math inline">\(s_j\)</span>生成<span class="math inline">\(a_j\)</span>,然而这不重要。上面的公式只希望等式左边去拟合等式右边，而不在乎<span class="math inline">\(a_j\)</span>是如何生成的。</p><h2 id="从价值学习的角度看待-dpg">从价值学习的角度看待 DPG</h2><p>假如我们知道最优动作价值函数<span class="math inline">\(Q^{\star}(s,a;w)\)</span>,我们可以这样做决策：给定当前状态<span class="math inline">\(s_t\)</span>,选择最大化 Q 值的动作</p><p><span class="math inline">\(a_t=\arg\max_{a \in A}Q^{\star}(s_t,a)\)</span>.</p><p>DQN 记作<span class="math inline">\(Q(s,a;w)\)</span>,它是<span class="math inline">\(Q^{\star}(s,a;w)\)</span>的函数近似。训练 DQN的目的是让<span class="math inline">\(Q(s,a;w)\)</span>趋近<span class="math inline">\(Q^{\star}(s,a;w)\)</span>,<span class="math inline">\(\forall s \in S, a \in A\)</span>。在训练好 DQN之后，可以这样做决策：</p><p><span class="math inline">\(a_t=\arg\max_{a \in A}Q(s_t,a;w).\)</span></p><p>如果动作空间<span class="math inline">\(A\)</span>是离散集合，那么上述最大化很容易实现。可是如果<span class="math inline">\(A\)</span>是连续集合，则很难对<span class="math inline">\(Q\)</span>求最大化。</p><p>可以把 DPG 看做对最优动作价值函数<span class="math inline">\(Q^{\star}(s,a)\)</span>的另一种近似方式，用于连续控制问题。我们希望学到策略网络<span class="math inline">\(\mu(s;\theta)\)</span>和价值网络<span class="math inline">\(q(s,a;w)\)</span>, 使得</p><p><span class="math inline">\(q(s,\mu(s;\theta);w) \approx \max_{a \inA} Q^{\star}(s,a), \quad \forall s \in S.\)</span></p><p>我们可以把<span class="math inline">\(\mu\)</span>和<span class="math inline">\(q\)</span>看做是<span class="math inline">\(Q^{\star}\)</span>的近似分解，而这种分解的目的在于方便做决策：</p><p><span class="math inline">\(a_t = \mu(s_t;\theta) \approx \arg\max_{a\in A} Q^{\star}(s_t,a).\)</span></p><h1 id="dpg-的高估问题">DPG 的高估问题</h1><p>在之前的笔记 深度强化学习（王树森）笔记08-CSDN博客，我们讨过 DQN的高估问题：如果用 Q 学习算法训练 DQN, 则 DQN会高估真实最优价值函数<span class="math inline">\(Q^{\star}\)</span>。把DQN 记作<span class="math inline">\(Q(s,a;w)\)</span>。如果用 Q学习算法训练 DQN, 那么 TD 目标是</p><p><span class="math inline">\(\hat{y}_j=r_j+\gamma \cdot \max_{a \in A}Q(s_{j+1},a;w).\)</span></p><p>之前得出结论：如果<span class="math inline">\(Q(s,a;w)\)</span>是最优动作价值函数<span class="math inline">\(Q^{\star}(s,a)\)</span>的无偏估计，那么<span class="math inline">\(\hat{y}_j\)</span>是对<span class="math inline">\(Q^{\star}(s_j,a_j)\)</span>的高估。用<span class="math inline">\(\hat{y}_j\)</span>作为目标去更新 DQN, 会导致<span class="math inline">\(Q(s_j,a_j;w)\)</span>高估<span class="math inline">\(Q^{\star}(s_j,a_j)\)</span>。另一个结论是自举会导致高估的传播，造成高估越来越严重。</p><p>DPG 也存在高估问题，用上一节的算法训练出的价值网络<span class="math inline">\(q(s,a;w)\)</span>会高估真实动作价值<span class="math inline">\(Q_{\pi}(s,a)\)</span>。造成 DPG 高估的原因与 DQN类似：第一，TD目标是对真实动作价值的高估；第二，自举导致高估的传播。下面具体分析两个原因；如果读者不感兴趣，只需要记住上述结论即可，可以跳过下面的内容。</p><p><strong>最大化造成高估</strong>：<br>训练策略网络的时候，我们希望策略网络计算出的动作<span class="math inline">\(\hat{a}=a=\mu(s;\theta)\)</span>能得到价值网络尽量高的评价，也就是让<span class="math inline">\(q(s,\hat{a};w)\)</span>尽量大。我们通过求解下面的优化模型来学习策略网络：</p><p><span class="math inline">\(\theta^{\star}=\operatorname{argmax}_{\theta}\mathbb{E}_S[q(S,\hat{A};w)],\quad \text{s.t.} \quad \hat{A}=\mu(S;\theta).\)</span></p><p>这个公式的意思是<span class="math inline">\(\mu(s;\theta^{\star})\)</span>是最优的确定策略网络。上面的公式与下面的公式意义相同(虽然不严格等价)：</p><p><span class="math inline">\(\mu(s;\theta^{\star})=\arg\max_{a \in A}q(s,a;w), \quad \forall s \in S.\)</span></p><p>这个公式的意思也是<span class="math inline">\(\mu(s;\theta^{\star})\)</span>是最优的确定策略网络。训练价值网络<span class="math inline">\(q\)</span>时用的 TD 目标是</p><p><span class="math inline">\(\begin{align*}\widehat{y}_{j} &amp;= r_{j} + \gamma \cdot q\left(s_{j+1},\mu\left(s_{j+1}; \theta\right); w\right) \\&amp;\approx r_{j} + \gamma \cdot \max_{a_{j+1}} q\left(s_{j+1},a_{j+1}; w\right).\end{align*}\)</span></p><p>根据前面的分析，上面公式中的<span class="math inline">\(\max\)</span>会导致<span class="math inline">\(\hat{y}_j\)</span>高估真实动作价值<span class="math inline">\(Q_{\pi}(s_j,a_j)\)</span>。在训练<span class="math inline">\(q\)</span>时，我们把<span class="math inline">\(\hat{y}_j\)</span>作为目标，鼓励价值网络<span class="math inline">\(q(s_j,a_j;w)\)</span>接近<span class="math inline">\(\hat{y}_j\)</span>, 这会导致<span class="math inline">\(q(s_j,a_j;w)\)</span>高估真实动作价值。</p><p><strong>自举造成偏差传播</strong>：<br>前面的笔记中讨论过自举(bootstrapping)造成偏差的传播。</p><p>TD 目标</p><p><span class="math inline">\(\hat{y}_j = r_j + \gamma \cdotq(s_{j+1},\mu(s_{j+1};\theta);w)\)</span></p><p>是用价值网络算出来的，而它又被用于更新价值网络<span class="math inline">\(q\)</span>本身，这属于自举。假如价值网络<span class="math inline">\(q(s_{j+1},a_{j+1};\theta)\)</span>高估了真实动作价值<span class="math inline">\(Q_{\pi}(s_{j+1},a_{j+1})\)</span>,那么 TD目标<span class="math inline">\(\hat{y}_j\)</span>则是对<span class="math inline">\(Q_{\pi}(s_j,a_j)\)</span>的高估，这会导致<span class="math inline">\(q(s_j,a_j;w)\)</span>高估<span class="math inline">\(Q_{\pi}(s_j,a_j)\)</span>。自举让高估从<span class="math inline">\((s_{j+1},a_{j+1})\)</span>传播到<span class="math inline">\((s_j,a_j)\)</span>。</p><h1 id="双延时确定策略梯度-td3">双延时确定策略梯度 (TD3)</h1><p>由于存在高估等问题，DPG 实际运行的效果并不好。本节介绍的 Twin DelayedDeep Deterministic Policy Gradient (TD3)可以大幅提升算法的表现，把策略网络和价值网络训练得更好。注意，本节只是改进训练用的算法，并不改变神经网络的结构。</p><h2 id="高估问题的解决方案">高估问题的解决方案</h2><p><strong>解决方案——目标网络</strong>：<br>为了解决自举和最大化造成的高估，我们需要使用目标网络 (Target Networks)计算 TD 目标<span class="math inline">\(\hat{y}_j\)</span>。训练中需要两个目标网络：</p><p><span class="math inline">\(q(s,a;w^-)\)</span>和<span class="math inline">\(\mu(s;\theta^-)\)</span>.</p><p>它们与价值网络、策略网络的结构完全相同，但是参数不同。TD目标是用目标网络算的：</p><p><span class="math inline">\(\hat{y}_j = r_j + \gamma \cdotq(s_{j+1},\hat{a}_{j+1};w^-), \quad \text{其中} \quad\hat{a}_{j+1}=\mu(s_{j+1};\theta^-).\)</span></p><p>把<span class="math inline">\(\hat{y}_j\)</span>作为目标，更新<span class="math inline">\(w\)</span>,鼓励<span class="math inline">\(q(s_j,a_j;w)\)</span>接近<span class="math inline">\(\hat{y}_j\)</span>。四个神经网络之间的关系如图10.7所示。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/7-2-%E7%A1%AE%E5%AE%9A%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6-DPG/1733280970215-074c9b2c-1dcd-43bc-a735-92cf1c805a34.png"></p><p>这种方法可以在一定程度上缓解高估，但是实验表明高估仍然很严重。</p><p><strong>更好的解决方案——截断双 Q 学习 (clipped doubleQ-learning)</strong>:<br>这种方法使用两个价值网络和一个策略网络：</p><p><span class="math inline">\(q(s,a;w_1)\)</span>,<span class="math inline">\(q(s,a;w_2)\)</span>,<span class="math inline">\(\mu(s;\theta)\)</span>.</p><p>三个神经网络各对应一个目标网络：</p><p><span class="math inline">\(q(s,a;w_1^-)\)</span>,<span class="math inline">\(q(s,a;w_2^-)\)</span>,<span class="math inline">\(\mu(s;\theta^-)\)</span>.</p><p>用目标策略网络计算动作：</p><p><span class="math inline">\(\hat{a}_{j+1}^-=\mu(s_{j+1};\theta^-),\)</span></p><p>然后用两个目标价值网络计算：</p><p><span class="math inline">\(\hat{y}_{j,1} = r_j + \gamma \cdotq(s_{j+1},\hat{a}_{j+1}^-;w_1^-),\)</span></p><p><span class="math inline">\(\hat{y}_{j,2} = r_j + \gamma \cdotq(s_{j+1},\hat{a}_{j+1}^-;w_2^-).\)</span></p><p>取两者较小者为TD 目标：</p><p><span class="math inline">\(\hat{y}_j = \min\{\hat{y}_{j,1},\hat{y}_{j,2}\}.\)</span></p><p><font style="color:rgb(77, 77, 77);">截断双 Q学习中的六个神经网络的关系如图 10.8 所示。</font></p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/7-2-%E7%A1%AE%E5%AE%9A%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6-DPG/1733281046414-16ca9237-4b69-43a3-a03c-a06bfa4062ad.png"></p><h2 id="其他改进方法">其他改进方法</h2><p>可以在截断双 Q学习算法的基础上做两处小的改进、进一步提升算法的表现。两种改进分别是往动作中加噪声、减小更新策略网络和目标网络的频率。</p><p><strong>往动作中加噪声</strong>：<br>上一小节中截断双 Q 学习用目标策略网络计算动作：</p><p><span class="math inline">\(\hat{a}_{j+1}^-=\mu(s_{j+1};\theta^-).\)</span></p><p>把这一步改成：</p><p><span class="math inline">\(\hat{a}_{j+1}^-=\mu(s_{j+1};\theta^-)+\xi.\)</span></p><p>公式中的<span class="math inline">\(\xi\)</span>是个随机向量，表示噪声，它的每一个元素独立随机从截断正态分布<span class="math inline">\(\mathcal{CN}(0,\sigma^2,-c,c)\)</span>中抽取。把截断正态分布记作<span class="math inline">\(\mathcal{CN}(0,\sigma^2,-c,c)\)</span>,意思是均值为零，标准差为<span class="math inline">\(\sigma\)</span>的正态分布，但是变量落在区间<span class="math inline">\([-c,c]\)</span>之外的概率为零。正态分布与截断正态分布的对比如图10.9 所示。使用截断正态分布，而非正态分布，是为了防止噪声<span class="math inline">\(\xi\)</span>过大。使用截断，保证噪声大小不会超过-c 和 c。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/7-2-%E7%A1%AE%E5%AE%9A%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6-DPG/1733281171745-ab054b7e-eddc-4142-9319-678bd6ea4d3c.png"></p><p><strong>减小更新策略网络和目标网络的频率</strong>：</p><p>Actor-critic 用价值网络来指导策略网络的更新。如果价值网络 q本身不可靠，那么用价值网络 q给动作打的分数是不准确的，无助于改进策略网络<span class="math inline">\(\mu\)</span>。在价值网络 q还很差的时候就急于更新<span class="math inline">\(\mu\)</span>,非但不能改进<span class="math inline">\(\mu\)</span>,反而会由于<span class="math inline">\(\mu\)</span>的变化导致 q 的训练不稳定。<br>实验表明，应当让策略网络<span class="math inline">\(\mu\)</span>以及三个目标网络的更新慢于价值网络<span class="math inline">\(q\)</span>。传统的actor-critic的每一轮训练都对策略网络、价值网络、以及目标网络做一次更新。更好的方法是每一轮更新一次价值网络，但是每隔<span class="math inline">\(k\)</span>轮更新一次策略网络和三个目标网络。<span class="math inline">\(k\)</span>是超参数，需要调。</p><h3 id="训练流程">训练流程</h3><p>本节介绍了三种技巧，改进 DPG 的训练。第一，用截断双 Q学习，缓解价值网络的高估。第二，往目标策略网络中加噪声，起到平滑作用。第三，降低策略网络和三个目标网络的更新频率。使用这三种技巧的算法被称作双延时确定策略梯度(twin delayed deep deterministic policy gradient), 缩写是 TD3。</p><p>TD3 与 DPG 都属于异策略 (off-policy),可以用任意的行为策略收集经验，事后做经验回放训练策略网络和价值网络。收集经验的方式与原始的训练算法相同，用<span class="math inline">\(\mu(s_t;\theta)+\epsilon\)</span>与环境交互，把观测到的四元组<span class="math inline">\((s_t,a_t,r_t,s_{t+1})\)</span>存入经验回放数组。</p><p>初始的时候，策略网络和价值网络的参数都是随机的。这样初始化目标网络的参数：</p><p><span class="math inline">\(w_1^- \leftarrow w_1, \quad w_2^-\leftarrow w_2, \quad \theta^- \leftarrow \theta.\)</span></p><p>训练策略网络和价值网络的时候，每次从数组中随机抽取一个四元组，记作<span class="math inline">\((s_j,a_j,r_j,s_{j+1})\)</span>。用下标 now表示神经网络当前的参数，用下标 new表示更新后的参数。然后执行下面的步骤，更新价值网络、策略网络、目标网络。</p><ol type="1"><li>让目标策略网络做预测：</li></ol><p>$<em>{j+1}<sup>-=(s_{j+1};</sup>-</em>{now})+. $</p><p>其中向量<span class="math inline">\(\xi\)</span>的每个元素都独立从截断正态分布<span class="math inline">\(\mathcal{CN}(0,\sigma^2,-c,c)\)</span>中抽取.</p><ol start="2" type="1"><li>让两个目标价值网络做预测：</li></ol><p><span class="math inline">\(\hat{q}_{1,j+1}^-=q(s_{j+1},\hat{a}_{j+1}^-;w_{1,now}^-)\quad \text{和} \quad\hat{q}_{2,j+1}^-=q(s_{j+1},\hat{a}_{j+1}^-;w_{2,now}^-).\)</span></p><ol start="3" type="1"><li>计算 TD 目标：</li></ol><p><span class="math inline">\(\hat{y}_j = r_j + \gamma \cdot\min\{\hat{q}_{1,j+1}^-, \hat{q}_{2,j+1}^-\}.\)</span></p><ol start="4" type="1"><li>让两个价值网络做预测：</li></ol><p><span class="math inline">\(\hat{q}_{1,j}=q(s_j,a_j;w_{1,now}) \quad\text{和} \quad \hat{q}_{2,j}=q(s_j,a_j;w_{2,now}).\)</span></p><ol start="5" type="1"><li>计算 TD 误差：</li></ol><p><span class="math inline">\(\delta_{1,j}=\hat{q}_{1,j}-\hat{y}_j\quad \text{和} \quad \delta_{2,j}=\hat{q}_{2,j}-\hat{y}_j.\)</span></p><ol start="6" type="1"><li>更新价值网络：</li></ol><p><span class="math inline">\(w_{1,new} \leftarrow w_{1,now} - \alpha\cdot \delta_{1,j} \cdot \nabla_w q(s_j,a_j;w_{1,now}),\)</span></p><p><span class="math inline">\(w_{2,new} \leftarrow w_{2,now} - \alpha\cdot \delta_{2,j} \cdot \nabla_w q(s_j,a_j;w_{2,now}).\)</span></p><ol start="7" type="1"><li>每隔<span class="math inline">\(k\)</span>轮更新一次策略网络和三个目标网络：</li></ol><ul><li>让策略网络做预测：</li></ul><p><span class="math inline">\(\hat{a}_j=\mu(s_j;\theta_{now}). \quad\text{然后更新策略网络：}\)</span></p><p><span class="math inline">\(\theta_{new} \leftarrow \theta_{now} +\beta \cdot \nabla_{\theta}\mu(s_j;\theta_{now}) \cdot \nabla_aq(s_j,\hat{a}_j;w_{1,now}).\)</span></p><ul><li>更新目标网络的参数：</li></ul><p><span class="math inline">\(\theta_{new}^- \leftarrow \tau \cdot\theta_{new} + (1-\tau) \cdot \theta_{now}^-,\)</span></p><p><span class="math inline">\(w_{1,new}^- \leftarrow \tau \cdotw_{1,new} + (1-\tau) \cdot w_{1,now}^-,\)</span></p><p><span class="math inline">\(w_{2,new}^- \leftarrow \tau \cdotw_{2,new} + (1-\tau) \cdot w_{2,now}^-.\)</span></p><h1 id="随机高斯策略">随机高斯策略</h1><p>上一节用确定策略网络解决连续控制问题。本节用不同的方法做连续控制，本节的策略网络是随机的，它是随机正态分布(也叫高斯分布)。</p><h2 id="基本思路">基本思路</h2><p>我们先研究最简单的情形：自由度等于 1, 也就是说动作<span class="math inline">\(a\)</span>是实数，动作空间<span class="math inline">\(A \subset\mathbb{R}\)</span>。把动作的均值记作<span class="math inline">\(\mu(s)\)</span>,标准差记作<span class="math inline">\(\sigma(s)\)</span>, 它们都是状态<span class="math inline">\(s\)</span>的函数。用正态分布的概率密度函数作为策略函数：<span class="math inline">\(\pi(a|s)=\frac{1}{\sqrt{6.28}\cdot\sigma(s)}\cdot\exp\left(-\frac{(a-\mu(s))^2}{2\cdot\sigma^2(s)}\right).\quad (10.2)\)</span></p><p>假如我们知道函数<span class="math inline">\(\mu(s)\)</span>和<span class="math inline">\(\sigma(s)\)</span>的解析表达式，可以这样做控制：</p><ol type="1"><li>观测到当前状态<span class="math inline">\(s\)</span>, 预测均值<span class="math inline">\(\widehat{\mu} = \mu(s)\)</span>和标准差<span class="math inline">\(\widehat{\sigma} = \sigma(s).\)</span>。</li><li>从正态分布中做随机抽样<span class="math inline">\(a \simN(\mu^,\sigma^2)\)</span>; 智能体执行动作<span class="math inline">\(a\)</span>。</li></ol><p>然而我们并不知道<span class="math inline">\(\mu(s)\)</span>和<span class="math inline">\(\sigma(s)\)</span>是怎么样的函数。一个很自然的想法是用神经网络来近似这两个函数。把神经网络记作<span class="math inline">\(\mu(s;\theta)\)</span>和<span class="math inline">\(\rho(s;\theta)\)</span>,其中<span class="math inline">\(\theta\)</span>表示神经网络中的可训练参数。但实践中最好不要直接近似标准差<span class="math inline">\(\sigma\)</span>,而是近似方差对数<span class="math inline">\(\ln \sigma^2\)</span>。定义两个神经网络：</p><p><span class="math inline">\(\mu(s;\theta) \quad \text{和} \quad\rho(s;\theta),\)</span></p><p>分别用于预测均值和方差对数。可以按照图10.10来搭建神经网络。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/7-2-%E7%A1%AE%E5%AE%9A%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6-DPG/1733281722169-2371d191-945c-4db2-b338-ccb673693049.png"></p><p>神经网络的输入是状态<span class="math inline">\(s\)</span>,通常是向量、矩阵或者张量。神经网络有两个输出头，分别记作<span class="math inline">\(\mu(s;\theta)\)</span>和<span class="math inline">\(\rho(s;\theta)\)</span>可以这样用神经网络做控制：</p><ol type="1"><li>观测到当前状态<span class="math inline">\(s\)</span>, 计算均值<span class="math inline">\(\widehat{\mu} = \mu(s;\theta)\)</span>,方差对数<span class="math inline">\(\widehat{\rho} =\rho(s;\theta)\)</span>, 以及方差$ ^2 = ()$.</li><li>从正态分布中做随机抽样：<span class="math inline">\(a \sim\mathcal{N}(\widehat{\mu}, \widehat{\sigma}^2)\)</span>;智能体执行动作<span class="math inline">\(a\)</span>.</li></ol><p>用神经网络近似均值和标准差之后，公式 (10.2) 中的策略函数<span class="math inline">\(\pi(a|s)\)</span>变成了下面的策略网络：</p><p><span class="math inline">\(\pi(a|s;\theta)=\frac{1}{\sqrt{6.28\cdot\exp[\rho(s;\theta)]}}\cdot\exp\left(-\frac{(a-\mu(s;\theta))^2}{2\cdot\exp[\rho(s;\theta)]}\right).\)</span></p><p>实际做控制的时候，我们只需要神经网络<span class="math inline">\(\mu(s;\theta)\)</span>和<span class="math inline">\(\rho(s;\theta)\)</span>,用不到真正的策略网络<span class="math inline">\(\pi(a|s;\theta)\)</span>.</p><h2 id="随机高斯策略网络">随机高斯策略网络</h2><p>上一小节假设控制问题的自由度是<span class="math inline">\(d=1\)</span>,也就是说动作<span class="math inline">\(a\)</span>是标量。实际问题中的自由度<span class="math inline">\(d\)</span>往往大于 1, 那么动作<span class="math inline">\(a\)</span>是<span class="math inline">\(d\)</span>维向量。对于这样的问题，我们修改一下神经网络结构，让两个输出<span class="math inline">\(\mu(s;\theta)\)</span>和<span class="math inline">\(\rho(s;\theta)\)</span>都<span class="math inline">\(d\)</span>维向量；见图10.11。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/7-2-%E7%A1%AE%E5%AE%9A%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6-DPG/1733282010401-80abc816-ce3a-42ed-9859-abadc0c73217.png"></p><p>用标量<span class="math inline">\(a_i\)</span>表示动作向量<span class="math inline">\(a\)</span>的第<span class="math inline">\(i\)</span>个元素。用函数<span class="math inline">\(\mu_i(s;\theta)\)</span>和<span class="math inline">\(\rho_i(s;\theta)\)</span>分别表示<span class="math inline">\(\mu(s;\theta)\)</span>和<span class="math inline">\(\rho(s;\theta)\)</span>的第<span class="math inline">\(i\)</span>个元素。我们用下面这个特殊的多元正态分布的概率密度函数作为策略网络：</p><p><span class="math inline">\(\pi(a|s;\theta)=\prod_{i=1}^{d}\frac{1}{\sqrt{6.28\cdot\exp[\rho_i(s;\theta)]}}\cdot\exp\left(-\frac{(a_i-\mu_i(s;\theta))^2}{2\cdot\exp[\rho_i(s;\theta)]}\right).\)</span></p><p>做控制的时候只需要均值网络<span class="math inline">\(\mu(s;\theta)\)</span>和方差对数网络<span class="math inline">\(\rho(s;\theta)\)</span>,不需要策略网络<span class="math inline">\(\pi(a|s;\theta)\)</span>做训练的时候也不需要<span class="math inline">\(\pi(a|s;\theta)\)</span>, 而是要用辅助网络<span class="math inline">\(f(s,a;\theta)\)</span>。总而言之，策略网络<span class="math inline">\(\pi\)</span>只是帮助你理解本节的方法而已，实际算法中不会出现<span class="math inline">\(\pi\)</span>。</p><p>图10.11描述了辅助网络<span class="math inline">\(f(s,a;\theta)\)</span>与<span class="math inline">\(\mu\)</span>、<span class="math inline">\(\rho\)</span>、<span class="math inline">\(a\)</span>的关系。辅助网络具体是这样定义的：</p><p><span class="math inline">\(f(s,a;\theta)=-\frac{1}{2}\sum_{i=1}^{d}\left(\rho_i(s;\theta)+\frac{(a_i-\mu_i(s;\theta))^2}{\exp[\rho_i(s;\theta)]}\right).\)</span></p><p>它的可训练参数<span class="math inline">\(\theta\)</span>都是从<span class="math inline">\(\mu(s;\theta)\)</span>和<span class="math inline">\(\rho(s;\theta)\)</span>中来的。不难发现，辅助网络与策略网络有这样的关系：</p><p><span class="math inline">\(f(s,a;\theta)=\ln\pi(a|s;\theta)+\text{Constant}.\quad (10.3)\)</span></p><h2 id="策略梯度">策略梯度</h2><p>回忆一下之前学过的内容。在<span class="math inline">\(t\)</span>时刻的折扣回报记作随机变量<span class="math inline">\(U_t=R_t+\gamma \cdot R_{t+1}+\gamma^2 \cdotR_{t+2}+\cdots+\gamma^{n-t} \cdot R_n\)</span>.</p><p>动作价值函数<span class="math inline">\(Q_{\pi}(s_t,a_t)\)</span>是对折扣回报<span class="math inline">\(U_t\)</span>的条件期望。前面章节推导过策略梯度的蒙特卡洛近似：</p><p><span class="math inline">\(g=Q_{\pi}(s,a) \cdot\nabla_{\theta}\ln\pi(a|s;\theta).\)</span></p><p>由公式 (10.3) 可得：</p><p><span class="math inline">\(g=Q_{\pi}(s,a) \cdot\nabla_{\theta}f(s,a;\theta). \quad (10.4)\)</span></p><p>有了策略梯度，就可以学习参数<span class="math inline">\(\theta\)</span>。训练的过程大致如下：</p><ol type="1"><li><p>搭建均值网络<span class="math inline">\(\mu(s;\theta)\)</span>、方差对数网络<span class="math inline">\(\rho(s;\theta)\)</span>、辅助网络<span class="math inline">\(f(s,a;\theta)\)</span>。</p></li><li><p>让智能体与环境交互，记录每一步的状态、动作、奖励，并对参数<span class="math inline">\(\theta\)</span>做更新：</p><p>(a). 观测到当前状态<span class="math inline">\(s\)</span>,计算均值、方差对数、方差：<span class="math inline">\(\hat{\mu}=\mu(s;\theta)\)</span>,<span class="math inline">\(\hat{\rho}=\rho(s;\theta)\)</span>,<span class="math inline">\(\hat{\sigma}^2=\exp(\hat{\rho})\)</span>.</p><p>此处的指数函数<span class="math inline">\(\exp(\cdot)\)</span>应用到向量的每一个元素上。</p><p>(b). 设<span class="math inline">\(\hat{\mu}_i\)</span>和<span class="math inline">\(\hat{\sigma}_i\)</span>分别是<span class="math inline">\(d\)</span>维向量<span class="math inline">\(\hat{\mu}\)</span>和<span class="math inline">\(\hat{\sigma}\)</span>的第<span class="math inline">\(i\)</span>个元素。从正态分布中做抽样：<span class="math inline">\(a_i \simN(\hat{\mu}_i,\hat{\sigma}_i^2)\)</span>,<span class="math inline">\(\forall i=1,\cdots,d\)</span>.把得到的动作记作<span class="math inline">\(a=[a_1,\cdots,a_d]\)</span>.</p><p>(c). 近似计算动作价值：<span class="math inline">\(\hat{q} \approxQ_{\pi}(s,a)\)</span>.</p><p>(d). 用反向传播计算出辅助网络关于参数<span class="math inline">\(\theta\)</span>的梯度：<span class="math inline">\(\nabla_{\theta}f(s,a;\theta)\)</span>.</p><p>(e). 用策略梯度上升更新参数：<span class="math inline">\(\theta\leftarrow \theta + \beta \cdot \hat{q} \cdot\nabla_{\theta}f(s,a;\theta)\)</span>. 此处的<span class="math inline">\(\beta\)</span>是学习率。</p></li></ol><h3 id="用-reinforce-学习参数">用 REINFORCE 学习参数</h3><p>REINFORCE 用实际观测的折扣回报<span class="math inline">\(u_t=\sum_{k=t}^n\gamma^{k-t} \cdotr_k\)</span>代替动作价值<span class="math inline">\(Q_{\pi}(s_t,a_t)\)</span>。</p><p>道理是这样的。动作价值是回报的期望：</p><p><span class="math inline">\(Q_{\pi}(s_t,a_t)=\mathbb{E}[U_t|S_t=s_t,A_t=a_t]\)</span>.</p><p>随机变量<span class="math inline">\(U_t\)</span>的一个实际观测值<span class="math inline">\(u_t\)</span>是期望的蒙特卡洛近似。这样一来，公式(10.4) 中的策略梯度就能近似成<span class="math inline">\(g \approx u_t\cdot \nabla_{\theta}f(s,a;\theta)\)</span>.</p><p>在搭建好均值网络<span class="math inline">\(\mu(s;\theta)\)</span>、方差对数网络<span class="math inline">\(\rho(s;\theta)\)</span>、辅助网络<span class="math inline">\(f(s,a;\theta)\)</span>之后，我们用REINFORCE更新参数<span class="math inline">\(\theta\)</span>。设当前参数为<span class="math inline">\(\theta_{now}\)</span>。REINFORCE重复以下步骤，直到收敛：</p><ol type="1"><li>用<span class="math inline">\(\mu(s;\theta_{now})\)</span>和<span class="math inline">\(\rho(s;\theta_{now})\)</span>控制智能体与环境交互，完成一局游戏，得到一条轨迹<span class="math inline">\(s_1,a_1,r_1,s_2,a_2,r_2,\cdots,s_n,a_n,r_n\)</span>.</li><li>计算所有的回报：<span class="math inline">\(u_t=\sum_{k=t}^T\gamma^{k-t} \cdot r_k, \quad\forall t=1,\cdots,n\)</span>.</li><li>对辅助网络做反向传播，得到所有的梯度：<span class="math inline">\(\nabla_{\theta}f(s_t,a_t;\theta_{now}), \quad\forall t=1,\cdots,n\)</span>.</li><li>用策略梯度上升更新参数：<span class="math inline">\(\theta_{new}\leftarrow \theta_{now} + \beta \cdot \sum_{t=1}^{n}\gamma^{t-1} \cdotu_t \cdot \nabla_{\theta}f(s_t,a_t;\theta_{now})\)</span>.</li></ol><p>上述算法标准的 REINFORCE, 效果不如使用基线的REINFORCE。可以用基线改进上面描述的算法。REINFORCE算法属于同策略(on-policy),不能使用经验回放。</p><h3 id="用-actor-critic-学习参数">用 Actor-Critic 学习参数</h3><p>Actor-critic 需要搭建一个价值网络<span class="math inline">\(q(s,a;w)\)</span>, 用于近似动作价值函数<span class="math inline">\(Q_{\pi}(s,a)\)</span>。价值网络的结构如图 10.12所示。此外，还需要一个目标价值网络<span class="math inline">\(q(s,a;w^-)\)</span>,网络结构相同，但是参数不同。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/7-2-%E7%A1%AE%E5%AE%9A%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6-DPG/1733282448343-5c0b3c82-4f80-452a-8908-2503c42f7ecc.png"></p><p>在搭建好均值网络<span class="math inline">\(\mu\)</span>、方差对数网络<span class="math inline">\(\rho\)</span>、辅助网络<span class="math inline">\(f\)</span>、价值网络<span class="math inline">\(q\)</span>之后，我们用 SARSA算法更新价值网络参数<span class="math inline">\(w\)</span>,用近似策略梯度更新控制器参数<span class="math inline">\(\theta\)</span>。设当前参数为<span class="math inline">\(w_{now}\)</span>和<span class="math inline">\(\theta_{now}\)</span>。重复以下步骤更新价值网络参数、控制器参数，直到收敛：</p><ol type="1"><li>实际观测到当前状态<span class="math inline">\(s_t\)</span>,用控制器算出均值<span class="math inline">\(\mu(s_t;\theta_{now})\)</span>和方差对数<span class="math inline">\(\rho(s_t;\theta_{now})\)</span>,然后随机抽样得到动作<span class="math inline">\(a_t\)</span>。智能体执行动作<span class="math inline">\(a_t\)</span>, 观测到奖励<span class="math inline">\(r_t\)</span>与新的状态<span class="math inline">\(s_{t+1}\)</span>。</li><li>计算均值<span class="math inline">\(\mu(s_{t+1};\theta_{now})\)</span>和方差对数<span class="math inline">\(\rho(s_{t+1};\theta_{now})\)</span>,然后随机抽样得到动作<span class="math inline">\(\tilde{a}_{t+1}\)</span>。这个动作只是假想动作，智能体不予执行。</li><li>用价值网络计算出：<span class="math inline">\(\hat{q}_t=q(s_t,a_t;w_{now})\)</span>.</li><li>用目标网络计算出：<span class="math inline">\(\hat{q}_{t+1}=q(s_{t+1},\tilde{a}_{t+1};w_{now}^-)\)</span>.</li><li>计算 TD 目标和 TD 误差：<span class="math inline">\(\hat{y}_t=r_t+\gamma \cdot\hat{q}_{t+1}\)</span>,<span class="math inline">\(\delta_t=\hat{q}_t-\hat{y}_t\)</span>.</li><li>更新价值网络的参数：<span class="math inline">\(w_{new} \leftarroww_{now} - \alpha \cdot \delta_t \cdot \nabla_wq(s_t,a_t;w_{now})\)</span>.</li><li>更新策略网络参数参数：<span class="math inline">\(\theta_{new}\leftarrow \theta_{now} + \beta \cdot \hat{q}_t \cdot\nabla_{\theta}f(s_t,a_t;\theta_{now})\)</span>.</li><li>更新目标网络参数：<span class="math inline">\(w_{new}^- \leftarrow\tau \cdot w_{new} + (1-\tau) \cdot w_{now}^-\)</span>.</li></ol><p>算法中的<span class="math inline">\(\alpha\)</span>、<span class="math inline">\(\beta\)</span>、<span class="math inline">\(\tau\)</span>都是超参数，需要手动调整。上述算法是标准的actor-critic. 效果不如advantage actor-critic(A2C)。可以用A2C改进上述方法。</p><h1 id="总结">总结</h1><p>离散控制问题的动作空间<span class="math inline">\(A\)</span>是个有限的离散集，连续控制问题的动作空间<span class="math inline">\(A\)</span>是个连续集。如果想将 DQN等离散控制方法应用到连续控制问题，可以对连续动作空间做离散化，但这只适用于自由度较小的问题。</p><p>可以用确定策略网络<span class="math inline">\(a=\mu(s;\theta)\)</span>做连续控制。网络的输入是状态<span class="math inline">\(s\)</span>, 输出是动作<span class="math inline">\(a\)</span>,<span class="math inline">\(a\)</span>是向量，大小等于问题的自由度。</p><p>确定策略梯度 (DPG) 借助价值网络<span class="math inline">\(q(s,a;w)\)</span>训练确定策略网络。DPG属于异策略，用行为策略收集经验，做经验回放更新策略网络和价值网络。</p><p>DPG 与 DQN 有很多相似之处，而且它们的训练都存在高估等问题。TD3使用几种技巧改进 DPG: 截断双 Q学习、往动作中加噪声、降低更新策略网络和目标网络的频率。</p><p>可以用随机高斯策略做连续控制。用两个神经网络分别近似高斯分布的均值和方差对数，并用策略梯度更新两个神经网络的参数。</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>RL</category>
      
      <category>DRL-王树森</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.1 连续控制</title>
    <link href="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/7-1-%E8%BF%9E%E7%BB%AD%E6%8E%A7%E5%88%B6/"/>
    <url>/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/7-1-%E8%BF%9E%E7%BB%AD%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="连续控制">连续控制</h1><p>前面的内容全部都是离散控制，即动作空间是一个离散的集合，比如超级玛丽游戏中的动作空间<span class="math inline">\(A=\{左，右，上\}\)</span>是个离散集合。本章的内容是连续控制，即动作空间是个连续集合，比如汽车的转向<span class="math inline">\(A=[-40^{\circ},40^{\circ}]\)</span>就是连续集合。<font style="color:rgb(77, 77, 77);">如果把连续动作空间做离散化，那么离散控制的方法就能直接解决连续控制问题；先讨论连续集合的离散化。然而更好的办法是直接用连续控制方法，而非离散化之后借用离散控制方法。本章介绍两种连续控制方法：确定策略网络和随机策略网络。</font></p><p><font style="color:rgb(77, 77, 77);">ChatGPT对DPG的解释：</font></p><p><font style="color:rgb(77, 77, 77);">确定性策略梯度（DeterministicPolicyGradient，DPG）是强化学习中一种用于训练确定性策略的方法。与传统的随机策略不同，确定性策略直接映射状态到具体的动作，而不是输出一个动作的概率分布。DPG主要应用于连续动作空间的问题，其中动作是实数空间中的连续值。</font></p><p><font style="color:rgb(77, 77, 77);">下面是 DPG的基本思想和主要要素：</font></p><ol type="1"><li><strong><font style="color:rgb(77, 77, 77);">确定性策略</font></strong><font style="color:rgb(77, 77, 77);">：在 DPG中，智能体的策略是确定性的，即给定一个状态，它直接输出一个具体的动作。这样的确定性策略可以表示为(</font><span class="math inline">\(a =\mu(s)\)</span><font style="color:rgb(77, 77, 77);">)，其中(</font><span class="math inline">\(\mu\)</span><font style="color:rgb(77, 77, 77);">)是策略函数，输入为状态 (s)，输出为动作 (a)。</font></li><li><strong><font style="color:rgb(77, 77, 77);">值函数</font></strong><font style="color:rgb(77, 77, 77);">：DPG 使用值函数来评估策略的好坏。通常，包括状态值函数（State ValueFunction）和动作值函数（Action ValueFunction）。其中，状态值函数表示在给定状态下的期望累积回报，动作值函数表示在给定状态和动作的情况下的期望累积回报。</font></li><li><strong><font style="color:rgb(77, 77, 77);">策略梯度</font></strong><font style="color:rgb(77, 77, 77);">：DPG使用策略梯度方法来更新策略参数。策略梯度是关于策略参数的梯度，它告诉我们如何调整策略以最大化期望累积回报。在DPG 中，通过对值函数对动作的梯度来计算策略梯度。</font></li><li><strong><font style="color:rgb(77, 77, 77);">Actor-Critic结构</font></strong><font style="color:rgb(77, 77, 77);">： DPG 通常采用Actor-Critic 结构，其中包括一个 Actor 网络负责输出动作，一个 Critic网络负责估计值函数。这两个网络共同工作，Actor 的参数通过 Critic的估计值函数的梯度进行更新。</font></li></ol><p><font style="color:rgb(77, 77, 77);">总体来说，DPG的训练过程涉及通过策略梯度来调整 Actor 网络的参数，以最大化 Critic网络估计的值函数。这样，DPG可以在连续动作空间中有效地训练确定性策略。</font></p><h1 id="离散控制与连续控制的区别">离散控制与连续控制的区别</h1><p>考虑这样一个问题：我们需要控制一只机械手臂，完成某些任务，获取奖励。机械手臂有两个关节，分别可以在<span class="math inline">\([0^{\circ},360^{\circ}]\)</span>与<span class="math inline">\([0^{\circ},180^{\circ}]\)</span>的范围内转动。这个问题的自由度是<span class="math inline">\(d=2\)</span>,动作是二维向量，动作空间是连续集合<span class="math inline">\(A=[0,360]\times [0,180]\)</span>。</p><p>此前我们学过的强化学习方法全部都是针对离散动作空间，不能直接解决上述连续控制问题。想把此前学过的离散控制方法应用到连续控制上，必须要对连续动作空间做离散化(网格化)。比如把连续集合<span class="math inline">\(A=[0,360] \times[0,180]\)</span>变成离散集合<span class="math inline">\(\{0,20,40,\cdots,360\} \times\{0,20,40,\cdots,180\}\)</span>; 见图 10.1。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/7-1-%E8%BF%9E%E7%BB%AD%E6%8E%A7%E5%88%B6/1733276346262-c89dc0ca-689a-4338-a1fc-4773b2fb139f.png"></p><p>对动作空间做离散化之后，就可以应用之前学过的方法训练 DQN或者策略网络，用于控制机械手臂。可是用离散化解决连续控制问题有个缺点。把自由度记作<span class="math inline">\(d\)</span>。自由度<span class="math inline">\(d\)</span>越大，网格上的点就越多，而且数量随着<span class="math inline">\(d\)</span>指数增长，会造成维度灾难。动作空间的大小即网格上点的数量。如果动作空间太大，DQN和策略网络的训练都变得很困难，强化学习的结果会不好。上述离散化方法只适用于自由度<span class="math inline">\(d\)</span>很小的情况；如果<span class="math inline">\(d\)</span>不是很小，就应该使用连续控制方法。后面两节介绍两种连续控制的方法。</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>RL</category>
      
      <category>DRL-王树森</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.3 Advantage Actor-Critic (A2C)</title>
    <link href="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/6-3-Advantage-Actor-Critic-A2C/"/>
    <url>/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/6-3-Advantage-Actor-Critic-A2C/</url>
    
    <content type="html"><![CDATA[<h1 id="advantage-actor-critic-a2c">Advantage Actor-Critic (A2C)</h1><p>之前我们推导出了带基线的策略梯度，并且对策略梯度做了蒙特卡洛近似，得到策略梯度的一个无偏估计：</p><p><span class="math inline">\(g(s, a; \theta) = \left[ Q_\pi(s, a) -V_\pi(s) \right] \cdot \nabla_\theta \ln \pi(a | s; \theta). \quad(8.2)\)</span></p><p>公式中的<span class="math inline">\(Q_\pi -V_\pi\)</span>被称作优势函数 (advantagefunction)。因此，基于上面公式得到的actor-critic 方法被称为 advantageactor-critic, 缩写 A2C。</p><p>A2C 属于 actor-critic 方法。有一个策略网络<span class="math inline">\(\pi(a|s;\theta)\)</span>,相当于演员，用于控制智能体运动。还有一个价值网络<span class="math inline">\(v(s;w)\)</span>,相当于评委，他的评分可以帮助策略网络(演员)改进技术。两个神经网络的结构与上一节中的完全相同，但是本节和上一节用不同的方法训练两个神经网络。</p><h2 id="算法推导">算法推导</h2><p><strong>训练价值网络</strong>：训练价值网络<span class="math inline">\(v(s;w)\)</span>的算法是从贝尔曼公式来的：</p><p><span class="math inline">\(V_\pi(s_t) = \mathbb{E}_{A_t \sim\pi(\cdot|s_t;\theta)}\left[ \mathbb{E}_{S_{t+1} \simp(\cdot|s_t,A_t)}\left[R_t + \gamma \cdot V_\pi(S_{t+1})\right]\right].\)</span></p><p>我们对贝尔曼方程左右两边做近似：</p><ul><li>方程左边的<span class="math inline">\(V_\pi(s_t)\)</span>可以近似成<span class="math inline">\(v(s_t;w)\)</span>。<span class="math inline">\(v(s_t;w)\)</span>是价值网络在<span class="math inline">\(t\)</span>时刻对<span class="math inline">\(V_\pi(s_t)\)</span>做出的估计。</li><li>方程右边的期望是关于当前时刻动作<span class="math inline">\(A_t\)</span>与下一时刻状态<span class="math inline">\(S_{t+1}\)</span>求的。给定当前状态<span class="math inline">\(s_t\)</span>,智能体执行动作<span class="math inline">\(a_t\)</span>,环境会给出奖励<span class="math inline">\(r_t\)</span>和新的状态<span class="math inline">\(s_{t+1}\)</span>。用观测到的<span class="math inline">\(r_t\)</span>、<span class="math inline">\(s_{t+1}\)</span>对期望做蒙特卡洛近似，得到：</li></ul><p><span class="math inline">\(r_t + \gamma \cdotV_\pi(s_{t+1}).\)</span></p><ul><li>进一步把公式中的<span class="math inline">\(V_\pi(s_{t+1})\)</span>近似成<span class="math inline">\(v(s_{t+1};w)\)</span>, 得到</li></ul><p><span class="math inline">\(\hat{y}_t \triangleq r_t + \gamma \cdotv(s_{t+1};w).\)</span></p><p>把它称作 TD 目标。它是价值网络在<span class="math inline">\(t+1\)</span>时刻对<span class="math inline">\(V_\pi(s_t)\)</span>做出的估计。<span class="math inline">\(v(s_t;w)\)</span>和<span class="math inline">\(\hat{y}_t\)</span>都是对动作价值<span class="math inline">\(V_\pi(s_t)\)</span>的估计。由于<span class="math inline">\(\hat{y}_t\)</span>部分基于真实观测到的奖励<span class="math inline">\(r_t\)</span>,我们认为<span class="math inline">\(\hat{y}_t\)</span>比<span class="math inline">\(v(s_t;w)\)</span>更可靠。所以把<span class="math inline">\(\hat{y}_t\)</span>固定住，更新<span class="math inline">\(w\)</span>, 使得<span class="math inline">\(v(s_t;w)\)</span>更接近<span class="math inline">\(\hat{y}_t\)</span>。</p><p>具体这样更新价值网络参数<span class="math inline">\(w\)</span>。定义损失函数</p><p><span class="math inline">\(L(w) \triangleq \frac{1}{2} [v(s_t;w) -\hat{y}_t]^2.\)</span></p><p>设<span class="math inline">\(\hat{v}_t \triangleqv(s_t;w)\)</span>。损失函数的梯度是：</p><p><span class="math inline">\(\nabla_w L(w) = (\hat{v}_t - \hat{y}_t)\cdot \nabla_w v(s_t;w).\)</span></p><p>定义 TD 误差为</p><p><span class="math inline">\(\delta_t \triangleq \hat{v}_t -\hat{y}_t.\)</span></p><p>做一轮梯度下降更新<span class="math inline">\(w\)</span>：</p><p><span class="math inline">\(w \leftarrow w - \alpha \cdot \delta_t\cdot \nabla_w v(s_t;w).\)</span></p><p>这样可以让价值网络的预测<span class="math inline">\(v(s_t;w)\)</span>更接近<span class="math inline">\(\hat{y}_t\)</span>。</p><p><strong>训练策略网络</strong>：A2C 从公式出发，对<span class="math inline">\(\boldsymbol{g}(s,a;\theta)\)</span>做近似，记作<span class="math inline">\(\tilde{\boldsymbol{g}}\)</span>, 然后用<span class="math inline">\(\tilde{\boldsymbol{g}}\)</span>更新策略网络参数<span class="math inline">\(\theta\)</span>。下面我们做数学推导。回忆一下贝尔曼公式：</p><p><span class="math inline">\(Q_\pi(s_t,a_t) = \mathbb{E}_{S_{t+1} \simp(\cdot|s_t,a_t)}\left[R_t + \gamma \cdotV_\pi(S_{t+1})\right].\)</span></p><p>把近似策略梯度<span class="math inline">\(\boldsymbol{g}(s_t,u_t;\theta)\)</span>中的<span class="math inline">\(Q_\pi(s_t,a_t)\)</span>替换成上面的期望，得到：</p><p><span class="math inline">\(\begin{align*}g(s_t, a_t; \theta) &amp;= \left[Q_{\pi}(s_t, a_t) - V_{\pi}(s_t)\right]\cdot \nabla_{\theta} \ln \pi(a_t \mid s_t; \theta) \\&amp;= \left[E_{S_{t+1}}\left[R_t + \gamma \cdot V_{\pi}(S_{t+1})\right]- V_{\pi}(s_t)\right] \cdot \nabla_{\theta} \ln \pi(a_t \mid s_t;\theta).\end{align*}\)</span></p><p>当智能体执行动作<span class="math inline">\(a_t\)</span>之后，环境给出新的状态<span class="math inline">\(s_{t+1}\)</span>和奖励<span class="math inline">\(r_t\)</span>; 利用<span class="math inline">\(s_{t+1}\)</span>和<span class="math inline">\(r_t\)</span>对上面的期望做蒙特卡洛近似，得到：</p><p><span class="math inline">\(\boldsymbol{g}(s_t,a_t;\theta) \approx[r_t + \gamma \cdot V_\pi(s_{t+1}) - V_\pi(s_t)] \cdot \nabla_\theta \ln\pi(a_t | s_t; \theta).\)</span></p><p>进一步把状态价值函数<span class="math inline">\(V_\pi(s)\)</span>替换成价值网络<span class="math inline">\(v(s;w)\)</span>, 得到：</p><p><span class="math inline">\(\tilde{\boldsymbol{g}}(s_t,a_t;\theta)\triangleq [r_t + \gamma \cdot v(s_{t+1};w) - v(s_t;w)] \cdot\nabla_\theta \ln \pi(a_t | s_t; \theta).\)</span></p><p>前面定义了 TD 目标和 TD 误差：</p><p><span class="math inline">\(\hat{y}_t \triangleq r_t + \gamma \cdotv(s_{t+1};w)\)</span>和<span class="math inline">\(\delta_t \triangleq\hat{v}_t - \hat{y}_t.\)</span></p><p>因此，可以把<span class="math inline">\(\tilde{\boldsymbol{g}}(s_t,a_t;\theta)\)</span>写成：</p><p><span class="math inline">\(\tilde{\boldsymbol{g}}(s_t,a_t;\theta)\triangleq -\delta_t \cdot \nabla_\theta \ln \pi(a_t | s_t;\theta).\)</span></p><p><span class="math inline">\(\tilde{\boldsymbol{g}}\)</span>是<span class="math inline">\(\boldsymbol{g}\)</span>的近似，所以也是策略梯度<span class="math inline">\(\nabla_\theta J(\theta)\)</span>的近似。用<span class="math inline">\(\tilde{\boldsymbol{g}}\)</span>更新策略网络参数<span class="math inline">\(\theta\)</span>：</p><p><span class="math inline">\(\theta \leftarrow \theta + \beta \cdot\tilde{\boldsymbol{g}}(s_t,a_t;\theta).\)</span></p><p>这样可以让目标函数<span class="math inline">\(J(\theta)\)</span>变大。</p><p><strong>策略网络与价值网络的关系</strong> : A2C 中策略网络 (演员)和价值网络 (评委) 的关系如图 8.4 所示。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/6-3-Advantage-Actor-Critic-A2C/1733230865685-1d606c3d-93ab-4bee-a308-631ac01f41f1.png"></p><p>智能体由策略网络 π控制，与环境交互，并收集状态、动作、奖励。策略网络(演员) 基于状态<span class="math inline">\(s_t\)</span>做出动作<span class="math inline">\(a_t\)</span>。价值网络 (评委) 基于<span class="math inline">\(s_t\)</span>、<span class="math inline">\(s_{t+1}\)</span>、<span class="math inline">\(r_t\)</span>算出 TD 误差<span class="math inline">\(\delta_t\)</span>。策略网络(演员) 依靠<span class="math inline">\(\delta_t\)</span>来判断自己动作的好坏，从而改进自己的演技(即参数<span class="math inline">\(\theta\)</span>)。</p><p>读者可能会有疑问: 价值网络<span class="math inline">\(v\)</span>只知道两个状态<span class="math inline">\(s_t\)</span>、<span class="math inline">\(s_{t+1}\)</span>,而并不知道动作<span class="math inline">\(a_t\)</span>,那么价值网络为什么能评价<span class="math inline">\(a_t\)</span>的好坏呢？价值网络<span class="math inline">\(v\)</span>告诉策略网络<span class="math inline">\(\pi\)</span>的唯一信息是<span class="math inline">\(\delta_t\)</span>。回顾一下<span class="math inline">\(\delta_t\)</span>的定义：</p><p><span class="math inline">\(-\delta_t = \underbrace{r_t + \gamma\cdot v(s_{t+1}; \boldsymbol{w})}_{\text{TD目标} \hat{y}_t} -\underbrace{v(s_t; \boldsymbol{w})}_{\text{基线}}.\)</span></p><p>基线<span class="math inline">\(v(s_t;w)\)</span>是价值网络在<span class="math inline">\(t\)</span>时刻对<span class="math inline">\(\mathbb{E}[U_t]\)</span>的估计；此时智能体尚未执行动作<span class="math inline">\(a_t\)</span>。而 TD 目标<span class="math inline">\(\hat{y}_t\)</span>是价值网络在<span class="math inline">\(t+1\)</span>时刻对<span class="math inline">\(\mathbb{E}[U_t]\)</span>的估计；此时智能体已经执行动作<span class="math inline">\(a_t\)</span>。</p><ul><li>如果<span class="math inline">\(\hat{y}_t &gt;v(s_t;w)\)</span>,说明动作<span class="math inline">\(a_t\)</span>很好，使得奖励<span class="math inline">\(r_t\)</span>超出预期，或者新的状态<span class="math inline">\(s_{t+1}\)</span>比预期好；这种情况下应该更新<span class="math inline">\(\theta\)</span>,使得<span class="math inline">\(\pi(a_t | s_t;\theta)\)</span>变大。</li><li>如果<span class="math inline">\(\hat{y}_t &lt;v(s_t;w)\)</span>,说明动作<span class="math inline">\(a_t\)</span>不好，导致奖励<span class="math inline">\(r_t\)</span>不及预期，或者新的状态<span class="math inline">\(s_{t+1}\)</span>比预期差；这种情况下应该更新<span class="math inline">\(\theta\)</span>,使得<span class="math inline">\(\pi(a_t | s_t;\theta)\)</span>减小。</li></ul><p>综上所述，<span class="math inline">\(\delta_t\)</span>中虽然不包含动作<span class="math inline">\(a_t\)</span>,但是<span class="math inline">\(\delta_t\)</span>可以间接反映出动作<span class="math inline">\(a_t\)</span>的好坏，可以帮助策略网络(演员)改进演技。</p><p>训练流程下面概括 A2C 训练流程。设当前策略网络参数是<span class="math inline">\(\theta_{\text{now}}\)</span>,价值网络参数是<span class="math inline">\(w_{\text{now}}\)</span>。执行下面的步骤，将参数更新成<span class="math inline">\(\theta_{\text{new}}\)</span>和<span class="math inline">\(w_{\text{new}}\)</span>:</p><ol type="1"><li>观测到当前状态<span class="math inline">\(s_t\)</span>,根据策略网络做决策<span class="math inline">\(a_t \sim\pi(\cdot|s_t;\theta_{\text{now}})\)</span>,并让智能体执行动作<span class="math inline">\(a_t\)</span>。</li><li>从环境中观测到奖励<span class="math inline">\(r_t\)</span>和新的状态<span class="math inline">\(s_{t+1}\)</span>。</li><li>让价值网络打分：<span class="math inline">\(\hat{v}_t = v(s_t;w_{\text{now}})\)</span>和<span class="math inline">\(\hat{v}_{t+1} =v(s_{t+1}; w_{\text{now}})\)</span>。</li><li>计算 TD 目标和 TD 误差：<span class="math inline">\(\hat{y}_t = r_t+ \gamma \cdot \hat{v}_{t+1}\)</span>和<span class="math inline">\(\delta_t = \hat{v}_t - \hat{y}_t\)</span>。</li><li>更新价值网络：</li></ol><p><span class="math inline">\(w_{\text{new}} \leftarrow w_{\text{now}}- \alpha \cdot \delta_t \cdot \nabla_w v(s_t;w_{\text{now}}).\)</span></p><ol start="6" type="1"><li>更新策略网络：</li></ol><p><span class="math inline">\(\theta_{\text{new}} \leftarrow\theta_{\text{now}} - \beta \cdot \delta_t \cdot \nabla_\theta \ln\pi(a_t | s_t; \theta_{\text{now}}).\)</span></p><p>注此处训练策略网络和价值网络的方法属于同策略(on-policy),要求行为策略(behavionpolicy)与目标策略 (target policy) 相同，都是最新的策略网络<span class="math inline">\(\pi(a|s;\theta_{\text{now}})\)</span>。不能使用经验回放，因为经验回放数组中的数据是用旧的策略网络<span class="math inline">\(\pi(a|s;\theta_{\text{old}})\)</span>获取的，不能在当前重复利用。</p><h2 id="用目标网络改进训练">用目标网络改进训练</h2><p>上述训练价值网络的算法存在自举——即用价值网络自己的估值<span class="math inline">\(\hat{v}_{t+1}\)</span>去更新价值网络自己。为了缓解自举造成的偏差，可以使用目标网络(targetnetwork) 计算 TD 目标。把目标网络记作<span class="math inline">\(v(s;w^-)\)</span>,它的结构与价值网络的结构相同，但是参数不同。使用目标网络计算 TD目标，那么 A2C 的训练就变成了：</p><ol type="1"><li>观测到当前状态<span class="math inline">\(s_t\)</span>,根据策略网络做决策<span class="math inline">\(a_t \sim\pi(\cdot|s_t;\theta_{\text{now}})\)</span>, 并让智能体执行动作<span class="math inline">\(a_t\)</span>。</li><li>从环境中观测到奖励<span class="math inline">\(r_t\)</span>和新的状态<span class="math inline">\(s_{t+1}\)</span>。</li><li>让价值网络给<span class="math inline">\(s_t\)</span>打分：<span class="math inline">\(\hat{v}_t = v(s_t; w_{\text{now}})\)</span>。</li><li>让目标网络给<span class="math inline">\(s_{t+1}\)</span>打分：<span class="math inline">\(\hat{v}_{t+1}^- = v(s_{t+1};w_{\text{now}}^-)\)</span>。</li><li>计算 TD 目标和 TD 误差：<span class="math inline">\(\hat{y}_t^- =r_t + \gamma \cdot \hat{v}_{t+1}^-\)</span>和<span class="math inline">\(\delta_t = \hat{v}_t - \hat{y}_t^-\)</span>。</li><li>更新价值网络：</li></ol><p><span class="math inline">\(w_{\text{new}} \leftarrow w_{\text{now}}- \alpha \cdot \delta_t \cdot \nabla_w v(s_t;w_{\text{now}}).\)</span></p><ol start="7" type="1"><li>更新策略网络：</li></ol><p><span class="math inline">\(\theta_{\text{new}} \leftarrow\theta_{\text{now}} - \beta \cdot \delta_t \cdot \nabla\theta \ln\pi(a_t | s_t; \theta{\text{now}}).\)</span></p><ol start="8" type="1"><li>设<span class="math inline">\(\tau \in(0,1)\)</span>是需要手动调的超参数。做加权平均更新目标网络的参数：</li></ol><p><span class="math inline">\(\bar{w}_{\text{new}} \leftarrow \tau\cdot w_{\text{new}} + (1-\tau) \cdot w_{\text{now}}^-.\)</span></p><h2 id="总结">总结</h2><ul><li>在策略梯度中加入基线 (baseline)可以降低方差，显著提升实验效果。实践中常用<span class="math inline">\(b= V_\pi(s)\)</span>作为基线。</li><li>可以用基线来改进 REINFORCE 算法。价值网络<span class="math inline">\(v(s;w)\)</span>近似状态价值函数<span class="math inline">\(V_\pi(s)\)</span>,把<span class="math inline">\(v(s;w)\)</span>作为基线。用策略梯度上升来更新策略网络<span class="math inline">\(\pi(a|s;\theta)\)</span>。用蒙特卡洛(而非自举)来更新价值网络<span class="math inline">\(v(s;w)\)</span>。</li><li>可以用基线来改进 actor-critic, 得到的方法叫做 advantageactor-critic(A2C),它也有一个策略网络<span class="math inline">\(\pi(a|s;\theta)\)</span>和一个价值网络<span class="math inline">\(v(s;\theta)\)</span>。用策略梯度上升来更新策略网络，用TD 算法来更新价值网络。</li><li>多步TD target</li></ul><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/6-3-Advantage-Actor-Critic-A2C/1733231407692-5bab22b8-e88e-445e-8ac1-eadd83991c27.png"></p><ul><li>a2c vs REINFORCE</li></ul><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/6-3-Advantage-Actor-Critic-A2C/1733231596323-61ca3f3b-8397-4cfa-a3ae-c90aa5dd97cf.png"></p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/6-3-Advantage-Actor-Critic-A2C/1733231619423-392d201b-c689-484b-883e-11e9872db7d2.png"></p><p>reinforce是a2c的特例 ， a2c是reinforce的特例</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>RL</category>
      
      <category>DRL-王树森</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.2 带基线的 REINFORCE 算法</title>
    <link href="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/6-2-%E5%B8%A6%E5%9F%BA%E7%BA%BF%E7%9A%84-REINFORCE-%E7%AE%97%E6%B3%95/"/>
    <url>/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/6-2-%E5%B8%A6%E5%9F%BA%E7%BA%BF%E7%9A%84-REINFORCE-%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="带基线的-reinforce-算法">带基线的 REINFORCE 算法</h1><p>上一节推导出了带基线的策略梯度，并且对策略梯度做了蒙特卡洛近似。本节中，我们使用状态价值<span class="math inline">\(V_\pi(s)\)</span>作基线，得到策略梯度的一个无偏估计：</p><p><span class="math inline">\(\boldsymbol{g}(s,a;\theta) =\left[Q_\pi(s,a) - V_\pi(s)\right] \cdot \nabla_\theta \ln\pi(a|s;\theta).\)</span></p><p>我们在 深度强化学习（王树森）笔记03: 主要介绍policy network， policygradient，REINFORCE 中学过 REINFORCE, 它使用实际观测的回报<span class="math inline">\(u\)</span>来代替动作价值<span class="math inline">\(Q_\pi(S,A)\)</span>。 此处我们同样用<span class="math inline">\(u\)</span>代替<span class="math inline">\(Q_\pi(S,A)\)</span>。此外，我们还用一个神经网络<span class="math inline">\(v(s;w)\)</span>近似状态价值函数<span class="math inline">\(V_\pi(S)\)</span>。这样一来，<span class="math inline">\(\boldsymbol{g}(s,a;\theta)\)</span>就被近似成了：</p><p><span class="math inline">\(\tilde{\boldsymbol{g}}(s,a;\theta) =\left[u - v(s;w)\right] \cdot \nabla_\theta \ln\pi(a|s;\theta).\)</span></p><p>可以用<span class="math inline">\(\tilde{\boldsymbol{g}}(s,a;\theta)\)</span>作为策略梯度<span class="math inline">\(\nabla_\thetaJ(\theta)\)</span>的近似，更新策略网络参数：</p><p><span class="math inline">\(\theta \leftarrow \theta + \beta \cdot\tilde{\boldsymbol{g}}(s,a;\theta).\)</span></p><h2 id="策略网络和价值网络">策略网络和价值网络</h2><p>带基线的 REINFORCE 需要两个神经网络：策略网络<span class="math inline">\(\pi(a|s;\theta)\)</span>和价值网络<span class="math inline">\(v(s;w)\)</span>;</p><p>神经网络结构如图 8.2 和 8.3所示。策略网络与之前章节一样：输入是状态<span class="math inline">\(s\)</span>,输出是一个向量，每个元素表示一个动作的概率。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/6-2-%E5%B8%A6%E5%9F%BA%E7%BA%BF%E7%9A%84-REINFORCE-%E7%AE%97%E6%B3%95/1733226096824-e09bdd2a-efba-4f46-aead-de4313d08003.png"></p><p>此处的价值网络<span class="math inline">\(v(s;w)\)</span>与之前使用的价值网络<span class="math inline">\(q(s,a;w)\)</span>区别较大。此处的<span class="math inline">\(v(s;w)\)</span>是对状态价值<span class="math inline">\(V_\pi\)</span>的近似，而非对动作价值<span class="math inline">\(Q_\pi\)</span>的近似。<span class="math inline">\(v(s;w)\)</span>的输入是状态<span class="math inline">\(s\)</span>,输出是一个实数，作为基线。策略网络和价值网络的输入都是状态<span class="math inline">\(s\)</span>,因此可以让两个神经网络共享卷积网络的参数，这是编程实现中常用的技巧。</p><p>虽然带基线的 REINFORCE有一个策略网络和一个价值网络，但是这种方法不是actor-critic。价值网络没有起到“评委”的作用，只是作为基线而已，目的在于降低方差，加速收敛。真正帮助策略网络(演员)改进参数<span class="math inline">\(\theta\)</span>的不是价值网络，而是实际观测到的回报<span class="math inline">\(u\)</span>。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/6-2-%E5%B8%A6%E5%9F%BA%E7%BA%BF%E7%9A%84-REINFORCE-%E7%AE%97%E6%B3%95/1733229158735-749356a6-c3bf-40d5-ba6c-e6e085c70cca.png"></p><h2 id="算法的推导">算法的推导</h2><p><strong>训练策略网络</strong> 的方法是近似的策略梯度上升。从<span class="math inline">\(t\)</span>时刻开始，智能体完成一局游戏，观测到全部奖励<span class="math inline">\(r_t,r_{t+1}, \cdots, r_n\)</span>然后计算回报<span class="math inline">\(u_t= \sum_{k=t}^n \gamma^{k-t} \cdot r_k\)</span>。让价值网络做出预测<span class="math inline">\(\hat{v}_t =v(s_t;w)\)</span>，作为基线。这样就得到了带基线的策略梯度：</p><p><span class="math inline">\(\tilde{\boldsymbol{g}}(s_t,a_t;\theta) =(u_t - \hat{v}_t) \cdot \nabla_\theta \ln \pi(a_t | s_t;\theta).\)</span></p><p>它是策略梯度<span class="math inline">\(\nabla_\thetaJ(\theta)\)</span>的近似。最后做梯度上升更新<span class="math inline">\(\theta\)</span>：</p><p><span class="math inline">\(\theta \leftarrow \theta + \beta \cdot\tilde{\boldsymbol{g}}(s_t,a_t;\theta).\)</span></p><p>这样可以让目标函数<span class="math inline">\(J(\theta)\)</span>逐渐增大。</p><p><strong>训练价值网络</strong> 的方法是回归(regression)。回忆一下，状态价值是回报的期望：</p><p><span class="math inline">\(V_\pi(s_t) = \mathbb{E}[U_t | S_t =s_t],\)</span></p><p>期望消掉了动作<span class="math inline">\(A_t, A_{t+1}, \cdots,A_n\)</span>和状态<span class="math inline">\(S_{t+1}, \cdots,S_n\)</span>。训练价值网络的目的是让<span class="math inline">\(v(s_t;w)\)</span>拟合<span class="math inline">\(V_\pi(s_t)\)</span></p><p>,即拟合<span class="math inline">\(u_t\)</span>的期望。定义损失函数：</p><p><span class="math inline">\(L(w) = \frac{1}{2n} \sum_{t=1}^{n}[v(s_t;w) - u_t]^2.\)</span></p><p>设<span class="math inline">\(\hat{v}_t =v(s_t;w)\)</span>。损失函数的梯度是：</p><p><span class="math inline">\(\nabla_w L(w) = \frac{1}{n}\sum_{t=1}^{n} (\hat{v}_t - u_t) \cdot \nabla_w v(s_t;w).\)</span></p><p>做一次梯度下降更新<span class="math inline">\(w\)</span>：</p><p><span class="math inline">\(w \leftarrow w - \alpha \cdot \nabla_wL(w).\)</span></p><h2 id="训练流程">训练流程</h2><p>当前策略网络的参数是<span class="math inline">\(\theta_{\text{now}}\)</span>,价值网络的参数是<span class="math inline">\(w_{\text{now}}\)</span>。执行下面的步骤，对参数做一轮更新。</p><ol type="1"><li>用策略网络<span class="math inline">\(\theta_{\text{now}}\)</span>控制智能体从头开始玩一局游戏，得到一条轨迹(trajectory)：</li></ol><p><span class="math inline">\(s_1, a_1, r_1, s_2, a_2, r_2, \cdots,s_n, a_n, r_n.\)</span></p><ol start="2" type="1"><li>计算所有的回报：</li></ol><p><span class="math inline">\(u_t = \sum_{k=t}^n \gamma^{k-t} \cdotr_k, \quad \forall t = 1, \cdots, n.\)</span></p><ol start="3" type="1"><li>让价值网络做预测：</li></ol><p><span class="math inline">\(\hat{v}_t = v(s_t; w_{\text{now}}), \quad\forall t = 1, \cdots, n.\)</span></p><ol start="4" type="1"><li>计算误差</li></ol><p><span class="math inline">\(\delta_t = \hat{v}_t - u_t, \quad \forallt = 1, \cdots, n.\)</span></p><ol start="5" type="1"><li>用<span class="math inline">\(\{s_t\}_{t=1}^n\)</span>作为价值网络输入，做反向传播计算：</li></ol><p><span class="math inline">\(\nabla_w v(s_t; w_{\text{now}}), \quad\forall t = 1, \cdots, n.\)</span></p><ol start="6" type="1"><li>更新价值网络参数：</li></ol><p><span class="math inline">\(w_{\text{new}} \leftarrow w_{\text{now}}- \alpha \cdot \sum_{t=1}^{n} \delta_t \cdot \nabla_w v(s_t;w_{\text{now}}).\)</span></p><ol start="7" type="1"><li>用<span class="math inline">\(\{(s_t,a_t)\}_{t=1}^n\)</span>作为数据，做反向传播计算：</li></ol><p><span class="math inline">\(\nabla_\theta \ln \pi(a_t | s_t;\theta_{\text{now}}), \quad \forall t = 1, \cdots, n.\)</span></p><ol start="8" type="1"><li>做随机梯度上升更新策略网络参数：</li></ol><p><span class="math inline">\(\theta_{\text{new}} \leftarrow\theta_{\text{now}} - \beta \cdot \sum_{t=1}^{n} \gamma^{t-1} \cdot\delta_t \cdot \nabla_\theta \ln \pi(a_t | s_t;\theta_{\text{now}}).\)</span></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>RL</category>
      
      <category>DRL-王树森</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.1 带基线的策略梯度方法</title>
    <link href="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/6-1-%E5%B8%A6%E5%9F%BA%E7%BA%BF%E7%9A%84%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6%E6%96%B9%E6%B3%95/"/>
    <url>/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/6-1-%E5%B8%A6%E5%9F%BA%E7%BA%BF%E7%9A%84%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="带基线的策略梯度方法">带基线的策略梯度方法</h1><p>上一章推导出策略梯度，并介绍了两种策略梯度方法——REINFORCE 和actor-critic。</p><p>虽然上一章的方法在理论上是正确的，但是在实践中效果并不理想。本章介绍的带基线的策略梯度(policy gradient with baseline)可以大幅提升策略梯度方法的表现。使用基线(baseline) 之后，REINFORCE 变成REINFORCE with baseline, actor-critic 变成 advantage actor-critic(A2C)。</p><h2 id="策略梯度中的基线">策略梯度中的基线</h2><p>首先回顾上一章的内容。策略学习通过最大化目标函数<span class="math inline">\(J(\theta) =\mathbb{E}_S[V_\pi(S)]\)</span>训练出策略网络<span class="math inline">\(\pi(a|s;\theta)\)</span>。可以用策略梯度<span class="math inline">\(\nabla_\theta J(\theta)\)</span>来更新参数<span class="math inline">\(\theta\)</span></p><p><span class="math inline">\(\theta_{\text{new}} \leftarrow\theta_{\text{now}} + \beta \cdot \nabla_\thetaJ(\theta_{\text{now}}).\)</span></p><p>策略梯度定理证明：</p><p><span class="math inline">\(\nabla_\theta J(\theta) =\mathbb{E}_S\left[\mathbb{E}_{A\sim\pi(\cdot|S,\theta)}\left[Q_\pi(S,A)\cdot \nabla_\theta \ln \pi(A|S;\theta)\right]\right].\)</span></p><p>上一章中，我们对策略梯度<span class="math inline">\(\nabla_\thetaJ(\theta)\)</span>做近似，推导出 REINFORCE 和 actor-critic;两种方法区别在于具体如何做近似。</p><h2 id="基线-baseline">基线 (Baseline)</h2><p>基于策略梯度公式 (8.1) 得出的 REINFORCE 和 actor-critic方法效果通常不好。只需对策略梯度公式 (8.1)做一个微小的改动，就能大幅提升表现：把<span class="math inline">\(b\)</span>作为动作价值函数<span class="math inline">\(Q_\pi(S,A)\)</span>的基线 (baseline), 用<span class="math inline">\(Q_\pi(S,A) - b\)</span></p><p>替换掉<span class="math inline">\(Q_\pi\)</span>。设<span class="math inline">\(b\)</span>是任意的函数，只要不依赖于动作<span class="math inline">\(A\)</span>就可以，例如<span class="math inline">\(b\)</span>可以是状态价值函数<span class="math inline">\(V_\pi(S)\)</span>。</p><p>定理 8.1. 带基线的策略梯度定理</p><p>设<span class="math inline">\(b\)</span>是任意的函数，但是<span class="math inline">\(b\)</span>不能依赖于<span class="math inline">\(A\)</span>。把<span class="math inline">\(b\)</span>作为动作价值函数<span class="math inline">\(Q_\pi(S,A)\)</span>的基线，对策略梯度没有影响：</p><p><span class="math inline">\(\nabla_\theta J(\theta) =\mathbb{E}_S\left[\mathbb{E}_{A\sim\pi(\cdot|S;\theta)}\left[(Q_\pi(S,A)- b) \cdot \nabla_\theta \ln \pi(A|S;\theta)\right]\right].\)</span></p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/6-1-%E5%B8%A6%E5%9F%BA%E7%BA%BF%E7%9A%84%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6%E6%96%B9%E6%B3%95/c3d57c264988c4213064eeef36151b5a.png"></p><p>定理 8.1 说明<span class="math inline">\(b\)</span>的取值不影响策略梯度的正确性。不论是让<span class="math inline">\(b = 0\)</span>还是让<span class="math inline">\(b= V_\pi(S)\)</span>, 对期望的结果毫无影响，期望的结果都会等于<span class="math inline">\(\nabla_\theta J(\theta)\)</span>。其原因在于</p><p><span class="math inline">\(\mathbb{E}_S\left[\mathbb{E}_{A\sim\pi(\cdot|S;\theta)}\left[b\cdot \nabla_\theta \ln \pi(A|S;\theta)\right]\right] = 0.\)</span></p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/6-1-%E5%B8%A6%E5%9F%BA%E7%BA%BF%E7%9A%84%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6%E6%96%B9%E6%B3%95/1733224482543-ea224a19-4b62-467b-92f0-5a68098b84a3.png"></p><p>定理中的策略梯度表示成了期望的形式，我们对期望做蒙特卡洛近似。从环境中观测到一个状态<span class="math inline">\(s\)</span>,然后根据策略网络抽样得到<span class="math inline">\(a \sim\pi(\cdot|s;\theta)\)</span>。那么策略梯度<span class="math inline">\(\nabla_\thetaJ(\theta)\)</span>可以近似为下面的随机梯度：</p><p><span class="math inline">\(\boldsymbol{g}_b(s,a;\theta) =\left[Q_\pi(s,a) - b\right] \cdot \nabla_\theta \ln\pi(a|s;\theta).\)</span></p><p>不论<span class="math inline">\(b\)</span>的取值是 0 还是<span class="math inline">\(V_\pi(s)\)</span>, 得到的随机梯度<span class="math inline">\(\boldsymbol{g}_b(s,a;\theta)\)</span>都是<span class="math inline">\(\nabla_\theta J(\theta)\)</span>的无偏估计：</p><p><span class="math inline">\(\text{Bias} =\mathbb{E}_{S,A}\left[\boldsymbol{g}_b(S,A;\theta)\right] -\nabla_\theta J(\theta) = 0.\)</span></p><p>虽然<span class="math inline">\(b\)</span>的取值对<span class="math inline">\(\mathbb{E}_{S,A}\left[\boldsymbol{g}_b(S,A;\theta)\right]\)</span>毫无影响，但是<span class="math inline">\(b\)</span>对随机梯度<span class="math inline">\(\boldsymbol{g}_b(s,a;\theta)\)</span>是有影响的。用不同的<span class="math inline">\(b\)</span></p><p>, 得到的方差</p><p><span class="math inline">\(\text{Var} =\mathbb{E}_{S,A}\left\|\boldsymbol{g}_b(S,A;\theta) - \nabla_\thetaJ(\theta)\right\|^2\)</span></p><p>会有所不同。如果<span class="math inline">\(b\)</span>很接近<span class="math inline">\(Q_\pi(s,a)\)</span>关于<span class="math inline">\(a\)</span>的均值，那么方差会比较小。因此，<span class="math inline">\(b = V_\pi(S)\)</span>是很好的基线。</p><h2 id="基线的直观解释">基线的直观解释</h2><p>策略梯度公式期望中的<span class="math inline">\(Q_\pi(S,A) \cdot\nabla_\theta \ln \pi(A|S;\theta)\)</span>的意义是什么呢？以图8.1中的左图为例。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/6-1-%E5%B8%A6%E5%9F%BA%E7%BA%BF%E7%9A%84%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6%E6%96%B9%E6%B3%95/1733224326893-df037946-f4bf-4673-834a-ac957d5ac53d.png"></p><p>给定状态<span class="math inline">\(s_t\)</span>, 动作空间是<span class="math inline">\(A=\{左，右，上\}\)</span>,动作价值函数给每个动作打分：</p><p><span class="math inline">\(Q_\pi(s_t,左)=80, Q_\pi(s_t,右)=-20,Q_\pi(s_t,上)=180\)</span></p><p>这些分值会乘到梯度<span class="math inline">\(\nabla_\theta \ln\pi(A|S;\theta)\)</span>上。在做完梯度上升之后，新的策略会倾向于分值高的动作。</p><ul><li>动作价值<span class="math inline">\(Q_\pi(s_t,上)=180\)</span>很大，说明基于状态<span class="math inline">\(s_t\)</span>选择动作“上”是很好的决策。让梯度<span class="math inline">\(\nabla_\theta \ln\pi(上|s_t;\theta)\)</span>乘以大的系数<span class="math inline">\(Q_\pi(s_t,上)=180\)</span>,那么做梯度上升更新<span class="math inline">\(\theta\)</span>之后，会让<span class="math inline">\(\pi(上|s_t;\theta)\)</span>变大，在状态<span class="math inline">\(s_t\)</span>的情况下更倾向于动作“上”。</li><li>相反，<span class="math inline">\(Q_\pi(s_t,右)=-20\)</span>说明基于状态<span class="math inline">\(s_t\)</span>选择动作“右”是糟糕的决策。让梯度<span class="math inline">\(\nabla_\theta \ln\pi(右|s_t;\theta)\)</span>乘以负的系数<span class="math inline">\(Q_\pi(s_t,右)=-20\)</span>,那么做梯度上升更新<span class="math inline">\(\theta\)</span>之后， 会让<span class="math inline">\(\pi(右|s_t;\theta)\)</span>变小，在状态<span class="math inline">\(s_t\)</span>的情况下选择动作“右”的概率更小。</li></ul><p>根据上述分析，我们在乎的是动作价值<span class="math inline">\(Q_\pi(s_t,左)\)</span>、<span class="math inline">\(Q_\pi(s_t,右)\)</span>、<span class="math inline">\(Q_\pi(s_t,上)\)</span>三者的相对大小，而非绝对大小。如果给三者都减去<span class="math inline">\(b=60\)</span>,那么三者的相对大小是不变的；动作“上”仍然是最好的，动作“右”仍然是最差的。因此<span class="math inline">\([Q_\pi(s_t,a_t) - b] \cdot \nabla_\theta \ln\pi(A|S;\theta)\)</span>依然能指导<span class="math inline">\(\theta\)</span>做调整，使得<span class="math inline">\(\pi(上|s_t;\theta)\)</span>变大，而<span class="math inline">\(\pi(右|s_t;\theta)\)</span>变小。</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>RL</category>
      
      <category>DRL-王树森</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.3 Dueling Network</title>
    <link href="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/5-3-Dueling-Network/"/>
    <url>/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/5-3-Dueling-Network/</url>
    
    <content type="html"><![CDATA[<h1 id="对决网络-dueling-network">对决网络 (Dueling Network)</h1><p>本节介绍对决网络 (dueling network), 它是对 DQN的神经网络结构的改进。它的基本想法是将最优动作价值<span class="math inline">\(Q^*\)</span>分解成最优状态价值<span class="math inline">\(V^*\)</span>加最优优势<span class="math inline">\(D^*\)</span>。对决网络的训练与 DQN完全相同，可以用 Q 学习算法或者双 Q 学习算法 。</p><h2 id="最优优势函数">最优优势函数</h2><p>在介绍对决网络 (duelingnetwork)之前，先复习一些基础知识。动作价值函数<span class="math inline">\(Q_\pi(s, a)\)</span>是回报的期望：</p><p><span class="math inline">\(Q_\pi(s, a) = \mathbb{E}[U_t | S_t = s,A_t = a]\)</span>.</p><p>最优动作价值<span class="math inline">\(Q^*\)</span>的定义是：</p><p><span class="math inline">\(Q^*(s, a) = \max_\pi Q_\pi(s, a), \foralls \in S, a \in A\)</span>.</p><p>状态价值函数<span class="math inline">\(V_\pi(s)\)</span>是<span class="math inline">\(Q_\pi(s, a)\)</span>关于<span class="math inline">\(a\)</span>的期望：</p><p><span class="math inline">\(V_\pi(s) = \mathbb{E}_{A \sim\pi}[Q_\pi(s, A)]\)</span>.</p><p>最优状态价值<span class="math inline">\(V^*\)</span>的定义是：</p><p><span class="math inline">\(V^*(s) = \max_\pi V_\pi(s), \forall s \inS\)</span>.</p><p>最优优势函数 (optimal advantage function) 的定义是：</p><p><span class="math inline">\(D^*(s, a) \triangleq Q^*(s, a) -V^*(s)\)</span>.</p><p>通过数学推导，可以证明下面的定理：</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/5-3-Dueling-Network/1733215260567-a6f5c97f-8176-40e9-b342-7e0e9696aaf9.png"></p><p><span class="math inline">\(Q^*(s, a) = V^*(s) + D^*(s, a) - \max_aD^*(s, a) \quad \forall s \in S, a \in A\)</span>.</p><h2 id="对决网络">对决网络</h2><p>与 DQN 一样，对决网络 (dueling network) 也是对最优动作价值函数<span class="math inline">\(Q^*\)</span>的近似。对决网络与 DQN的区别在于神经网络结构不同。直观上，对决网络可以了解到哪些状态有价值或者没价值，而无需了解每个动作对每个状态的影响。实践中，对决网络具有更好的效果。由于对决网络与DQN 都是对<span class="math inline">\(Q^*\)</span>的近似，可以用完全相同的算法训练两种神经网络。</p><p>对决网络由两个神经网络组成。一个神经网络记作<span class="math inline">\(D(s, a; w^D)\)</span>, 它是对最优优势函数<span class="math inline">\(D^*(s, a)\)</span>的近似。另一个神经网络记作<span class="math inline">\(V(s; w^V)\)</span>,它是对最优状态价值函数<span class="math inline">\(V^*(s)\)</span>的近似。把定理 6.1 中的<span class="math inline">\(D^*\)</span>和<span class="math inline">\(V^*\)</span>替换成相应的神经网络，那么最优动作价值函数<span class="math inline">\(Q^*\)</span>就被近似成下面的神经网络：</p><p><span class="math inline">\(Q(s, a; w) \triangleq V(s; w^V) + D(s, a;w^D) - \max_{a \in \mathcal{A}} D(s, a; w^D).\)</span>.</p><p>公式左边的<span class="math inline">\(Q(s, a;w)\)</span>就是对决网络，它是对最优动作价值函数<span class="math inline">\(Q^*\)</span>的近似。它的参数记作<span class="math inline">\(w \triangleq (w^V; w^D)\)</span>。</p><p>对决网络的结构如图 6.6 所示。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/5-3-Dueling-Network/1733215564829-2b8fcd67-d02d-42ee-b881-92026b097436.png"></p><p>可以让两个神经网络<span class="math inline">\(D(s, a;w^D)\)</span>与<span class="math inline">\(V(s;w^V)\)</span>共享部分卷积层；这些卷积层把输入的状态<span class="math inline">\(s\)</span>映射成特征向量，特征向量是“优势头”与“状态价值头”的输入。优势头输出一个向量，向量的维度是动作空间的大小<span class="math inline">\(\|A\|\)</span>,向量每个元素对应一个动作。举个例子，动作空间是<span class="math inline">\(\{左，右，上\}\)</span>。优势头的输出是三个值：</p><p><span class="math inline">\(D(s, 左; w^D) = -90, D(s, 右; w^D) =-420, D(s, 上; w^D) = 30\)</span>.</p><p>状态价值头输出的是一个实数，比如</p><p><span class="math inline">\(V(s; w^V) = 300\)</span>.</p><p>首先计算</p><p><span class="math inline">\(\max_a D(s, a; w^D) = \max\{-90, -420,30\} = 30\)</span>.</p><p>然后用公式 (6.1) 计算出：</p><p><span class="math inline">\(Q(s, 左; w) = 180, Q(s, 右; w) = -150,Q(s, 上; w) = 300\)</span>.</p><p>这样就得到了对决网络的最终输出。</p><h2 id="解决不唯一性">解决不唯一性</h2><p>读者可能会有下面的疑问。对决网络是由定理 6.1推导出的，而定理中最右的一项恒等于零：</p><p><span class="math inline">\(\max_a D^*(s, a) = 0, \forall s \inS\)</span>.</p><p>也就是说，可以把最优动作价值写成两种等价形式：</p><p><span class="math inline">\(\begin{array}{lll}Q_{\star}(s, a) &amp;=&amp; V_{\star}(s) + D_{\star}(s, a) &amp;\text{(第一种形式)} \\&amp;=&amp; V_{\star}(s) + D_{\star}(s, a) - \max_{a \in \mathcal{A}}D_{\star}(s, a). &amp; \text{(第二种形式)}\end{array}\)</span></p><p>之前我们根据第二种形式实现对决网络。我们可否根据第一种形式，把对决网络按照下面的方式实现呢：</p><p><span class="math inline">\(Q(s, a; w) = V(s; w^V) + D(s, a;w^D)\)</span>?</p><p>答案是不可以这样实现对决网络，因为这样会导致不唯一性。假如这样实现对决网络，那么<span class="math inline">\(V\)</span>和<span class="math inline">\(D\)</span>可以随意上下波动，比如一个增大 100,另一个减小 100：</p><p><span class="math inline">\(V(s; w^{\tilde{V}}) \triangleq V(s; w^V)+ 100, D(s, a; w^{\tilde{D}}) \triangleq D(s, a; w^D) -100\)</span>.</p><p>这样的上下波动不影响最终的输出：</p><p><span class="math inline">\(V(s; w^V) + D(s, a; w^D) = V(s;w^{\tilde{V}}) + D(s, a; w^{\tilde{D}})\)</span>.</p><p>这就意味着<span class="math inline">\(V\)</span>和<span class="math inline">\(D\)</span>的参数可以很随意地变化，却不会影响输出的Q。我们不希望这种情况出现，因为这会导致训练的过程中参数不稳定。</p><p>因此很有必要在对决网络中加入<span class="math inline">\(\max_a D(s,a; w^D)\)</span>这一项。它使得<span class="math inline">\(V\)</span>和<span class="math inline">\(D\)</span>不能随意上下波动。假如让<span class="math inline">\(V\)</span>变大 100,让<span class="math inline">\(D\)</span>变小 100, 则对决网络的输出会增大100,而非不变：</p><p><span class="math inline">\(V\left(s; \tilde{w}^{V}\right) +D\left(s, a; \tilde{w}^{D}\right) - \max_{a} D\left(s, a;\tilde{w}^{D}\right)\)</span>.</p><p><span class="math inline">\(= V\left(s; w^{V}\right) + D\left(s, a;w^{D}\right) - \max_{a} D\left(s, a; w^{D}\right) + 100.\)</span></p><p>以上讨论说明了为什么<span class="math inline">\(\max_a D(s, a;w^D)\)</span>这一项不能省略。</p><h2 id="对决网络的实际实现">对决网络的实际实现</h2><p>按照定理 6.1, 对决网络应该定义成：</p><p><span class="math inline">\(Q(s, a; w) \triangleq V(s; w^V) + D(s, a;w^D) - \max_a D(s, a; w^D)\)</span>.</p><p>最右边的 max 项的目的是解决不唯一性。实际实现的时候，用 mean 代替 max会有更好的效果。所以实际 上会这样定义对决网络：</p><p><span class="math inline">\(Q(s, a; w) \triangleq V(s; w^V) + D(s, a;w^D) - \text{mean}_{a \in \mathcal{A}} D(s, a; w^D).\)</span>.</p><p>对决网络与 DQN 都是对最优动作价值函数<span class="math inline">\(Q^*\)</span>的近似，所以对决网络的训练和决策与 DQN完全一样。比如可以这样训练对决网络：</p><ul><li>用<span class="math inline">\(\epsilon\)</span>-greedy算法控制智能体，收集经验，把<span class="math inline">\((s_j, a_j, r_j,s_{j+1})\)</span>这样的四元组存入经验回放数组。</li><li>从数组里随机抽取四元组，用双 Q 学习算法更新对决网络参数<span class="math inline">\(w = (w^D, w^V)\)</span>。</li></ul><p>完成训练之后，基于当前状态<span class="math inline">\(s_t\)</span>,让对决网络给所有动作打分，然后选择分数最高的动作：</p><p><span class="math inline">\(a_t = \underset{a \inA}{\operatorname{argmax}} Q(s_t, a; w)\)</span>.</p><p>简而言之，怎么样训练 DQN,就怎么样训练对决网络；怎么样用 DQN做控制，就怎么样用对决网络做控制。如果一个技巧能改进 DQN的训练，这个技巧也能改进对决网络。同样的道理，因为 Q 学习算法导致 DQN出现高估，所以 Q 学习算法也会导致对决网络出现高估。</p><h1 id="噪声网络">噪声网络</h1><p>本节介绍噪声网络(noisy net),这是一种非常简单的方法，可以显著提高 DQN的表现。噪声网络的应用不局限于 DQN,它可以用于几乎所有的深度强化学习方法。</p><h2 id="噪声网络的原理">噪声网络的原理</h2><p>把神经网络中的参数<span class="math inline">\(w\)</span>替换成<span class="math inline">\(\mu + \sigma \circ \xi\)</span>。此处的<span class="math inline">\(\mu\)</span>、<span class="math inline">\(\sigma\)</span>、<span class="math inline">\(\xi\)</span>的形状与<span class="math inline">\(w\)</span>完全相同。</p><p><span class="math inline">\(\mu\)</span>、<span class="math inline">\(\sigma\)</span>分别表示均值和标准差，它们是神经网络的参数，需要从经验中学习。<span class="math inline">\(\xi\)</span>是随机噪声，它的每个元素独立从标准正态分布<span class="math inline">\(\mathcal{N}(0,1)\)</span>中随机抽取。符号“<span class="math inline">\(\circ\)</span>”表示逐项乘积。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/5-3-Dueling-Network/1733216326369-7ef961a9-6932-415c-83e2-9a584cc9a6f2.png"></p><p>如果<span class="math inline">\(w\)</span>是向量，那么有</p><p><span class="math inline">\(w_i = \mu_i + \sigma_i \cdot\xi_i\)</span>.</p><p>如果<span class="math inline">\(w\)</span>是矩阵，那么有</p><p><span class="math inline">\(w_{ij} = \mu_{ij} + \sigma_{ij} \cdot\xi_{ij}\)</span>.</p><p>噪声网络的意思是参数<span class="math inline">\(w\)</span>的每个元素<span class="math inline">\(w_i\)</span>从均值为<span class="math inline">\(\mu_i\)</span>、标准差为<span class="math inline">\(\sigma_i\)</span>的正态分布中抽取。</p><p>举个例子，某一个全连接层记作：</p><p><span class="math inline">\(z = \text{ReLU}(Wx + b)\)</span>.</p><p>公式中的向量<span class="math inline">\(x\)</span>是输入，矩阵<span class="math inline">\(W\)</span>和向量<span class="math inline">\(b\)</span>是参数，ReLU 是激活函数，<span class="math inline">\(z\)</span>是这一层的输出。噪声网络把这个全连接层替换成：</p><p><span class="math inline">\(z = \text{ReLU}((W^\mu + W^\sigma \circW^\xi)x + (b^\mu + b^\sigma \circ b^\xi))\)</span>.</p><p>公式中的<span class="math inline">\(W^\mu\)</span>、<span class="math inline">\(W^\sigma\)</span>、<span class="math inline">\(b^\mu\)</span>、<span class="math inline">\(b^\sigma\)</span>是参数，需要从经验中学习。矩阵<span class="math inline">\(W^\xi\)</span>和向量<span class="math inline">\(b^\xi\)</span>的每个元素都是独立从<span class="math inline">\(\mathcal{N}(0,1)\)</span>中随机抽取的，表示噪声。</p><p>训练噪声网络的方法与训练标准的神经网络完全相同，都是做反向传播计算梯度，然后用梯度更新神经参数。把损失函数记作<span class="math inline">\(L\)</span>。已知梯度<span class="math inline">\(\frac{\partial L}{\partialz}\)</span>,可以用链式法则算出损失关于参数的梯度：</p><p><span class="math inline">\(\frac{\partial L}{\partial W^\mu} =\frac{\partial z}{\partial W^\mu} \cdot \frac{\partial L}{\partial z},\frac{\partial L}{\partial b^\mu} = \frac{\partial z}{\partial b^\mu}\cdot \frac{\partial L}{\partial z}, \frac{\partial L}{\partialW^\sigma} = \frac{\partial z}{\partial W^\sigma} \cdot \frac{\partialL}{\partial z}, \frac{\partial L}{\partial b^\sigma} = \frac{\partialz}{\partial b^\sigma} \cdot \frac{\partial L}{\partial z}\)</span>.</p><p>然后可以做梯度下降更新参数<span class="math inline">\(W^\mu\)</span>、<span class="math inline">\(W^\sigma\)</span>、<span class="math inline">\(b^\mu\)</span>、<span class="math inline">\(b^\sigma\)</span>。</p><h2 id="噪声-dqn">噪声 DQN</h2><p>噪声网络可以用于 DQN。标准的 DQN 记作<span class="math inline">\(Q(s,a; w)\)</span>, 其中的<span class="math inline">\(w\)</span>表示参数。把<span class="math inline">\(w\)</span>替换成<span class="math inline">\(\mu +\sigma \circ \xi\)</span>, 得到噪声 DQN, 记作：</p><p><span class="math inline">\(\tilde{Q}(s, a, \xi; \mu, \sigma)\triangleq Q(s, a; \mu + \sigma \circ \xi)\)</span>.</p><p>其中的<span class="math inline">\(\mu\)</span>和<span class="math inline">\(\sigma\)</span>是参数，一开始随机初始化，然后从经验中学习；而<span class="math inline">\(\xi\)</span>则是随机生成，每个元素都从<span class="math inline">\(\mathcal{N}(0, 1)\)</span>中抽取。噪声 DQN的参数数量比标准 DQN 多一倍。</p><h2 id="收集经验">收集经验：</h2><p>DQN 属于异策略 (off-policy)。我们用任意的行为策略 (behavior policy)控制智能体，收集经验，事后做经验回放更新参数。在之前章节中，我们用<span class="math inline">\(\epsilon\)</span>-greedy 作为行为策略：</p><p><span class="math inline">\(a_t = \begin{cases} \underset{a \inA}{\operatorname{argmax}} Q(s_t, a; w), &amp; \text{以概率 }(1-\epsilon); \\ \text{均匀抽取 } A \text{ 中的一个动作}, &amp;\text{以概率 } \epsilon. \end{cases}\)</span></p><p><span class="math inline">\(\epsilon\)</span>-greedy策略带有一定的随机性，可以让智能体尝试更多动作，探索更多状态。</p><p>噪声 DQN 本身就带有随机性，可以鼓励探索，起到与<span class="math inline">\(\epsilon\)</span>-greedy策略相同的作用。我们直接用</p><p><span class="math inline">\(a_t = \underset{a \inA}{\operatorname{argmax}} \tilde{Q}(s, a, \xi; \mu, \sigma)\)</span></p><p>作为行为策略，效果比<span class="math inline">\(\epsilon\)</span>-greedy更好。每做一个决策，要重新随机生成一个<span class="math inline">\(\xi\)</span>。</p><h2 id="q-学习算法">Q 学习算法:</h2><p>训练的时候，每一轮从经验回放数组中随机抽样出一个四元组，记作<span class="math inline">\((s_j, a_j, r_j,s_{j+1})\)</span>。从标准正态分布中做抽样，得到<span class="math inline">\(\xi&#39;\)</span>的每一个元素。计算 TD 目标：</p><p><span class="math inline">\(\widehat{y}_j = r_j + \gamma \cdot \max_a\tilde{Q}(s_{j+1}, a, \xi&#39;; \mu, \sigma)\)</span>.</p><p>把损失函数记作：</p><p><span class="math inline">\(L(\mu, \sigma) = \frac{1}{2}[\tilde{Q}(s_j, a_j, \xi; \mu, \sigma) - \widehat{y}_j]^2\)</span>,</p><p>其中的<span class="math inline">\(\xi\)</span>也是随机生成的噪声，但是它与<span class="math inline">\(\xi&#39;\)</span>不同。然后做梯度下降更新参数：</p><p><span class="math inline">\(\mu \leftarrow \mu - \alpha_\mu \cdot\nabla_\mu L(\mu, \sigma), \sigma \leftarrow \sigma - \alpha_\sigma\cdot \nabla_\sigma L(\mu, \sigma)\)</span>.</p><p>公式中的<span class="math inline">\(\alpha_\mu\)</span>和<span class="math inline">\(\alpha_\sigma\)</span>是学习率。这样做梯度下降更新参数，可以让损失函数减小，让噪声DQN 的预测更接近 TD 目标。</p><h3 id="做决策">做决策 :</h3><p>做完训练之后，可以用噪声 DQN做决策。做决策的时候不再需要噪声，因此可以把参数<span class="math inline">\(\sigma\)</span>设置成全零，只保留参数<span class="math inline">\(\mu\)</span>。这样一来，噪声 DQN 就变成标准的DQN:</p><p><span class="math inline">\(\tilde{Q}(s, a, \xi&#39;; \mu, 0) = Q(s,a; \mu)\)</span>.</p><p>在训练的时候往 DQN的参数中加入噪声，不仅有利于探索，还能增强鲁棒性。鲁棒性的意思是即使参数被扰动，DQN也能对动作价值<span class="math inline">\(Q^*\)</span>做出可靠的估计。为什么噪声可以让 DQN有更强的鲁棒性呢？</p><p>假设在训练的过程中不加入噪声。把学出的参数记作<span class="math inline">\(\mu\)</span>。当参数严格等于<span class="math inline">\(\mu\)</span>的时候 DQN可以对最优动作价值做出较为准确的估计。但是对<span class="math inline">\(\mu\)</span>做较小的扰动，就可能会让 DQN的输出偏离很远。所谓“失之毫厘，谬以千里”。</p><p>噪声 DQN 训练的过程中，参数带有噪声：</p><p><span class="math inline">\(w = \mu + \sigma \circ \xi\)</span>.</p><p>训练迫使 DQN 在参数带噪声的情况下最小化 TD 误差，也就是迫使 DQN容忍对参数的扰动。训练出的 DQN 具有鲁棒性：参数不严格等于<span class="math inline">\(\mu\)</span>也没关系，只要参数在<span class="math inline">\(\mu\)</span>的邻域内，DQN做出的预测都应该比较合理。用噪声 DQN, 不会出现“失之毫厘，谬以千里”。</p><h3 id="训练流程">训练流程</h3><p>实际编程实现 DQN 的时候，应该将本章的四种技巧——优先经验回放、双Q学习、对决网络、噪声DQN——全部用到。应该用对决网络的神经网络结构，而不是简单的 DQN结构。往对决网络中的参数<span class="math inline">\(w\)</span>中加入噪声，得到噪声 DQN, 记作<span class="math inline">\(\tilde{Q}(s, a, \xi; \mu,\sigma)\)</span>。训练要用双 Q学习、优先经验回放，而不是原始的 Q学习。双 Q学习需要目标网络<span class="math inline">\(\tilde{Q}(s, a,\xi; \mu^-, \sigma^-)\)</span>计算 TD 目标。它跟噪声 DQN的结构相同，但是参数不同。</p><p>初始化的时候，随机初始化<span class="math inline">\(\mu\)</span>、<span class="math inline">\(\sigma\)</span>,并且把它们赋值给目标网络参数：</p><p><span class="math inline">\(\mu^- \leftarrow \mu. \sigma^- \leftarrow\sigma\)</span>.</p><p>然后重复下面的步骤更新参数。把当前的参数记作<span class="math inline">\(\mu_{\text{now}}\)</span>、<span class="math inline">\(\sigma_{\text{now}}\)</span>、<span class="math inline">\(\mu_{\text{now}}^-\)</span>、<span class="math inline">\(\sigma_{\text{now}}^-\)</span>.</p><ol type="1"><li>用优先经验回放，从数组中抽取一个四元组，记作<span class="math inline">\((s_j, a_j, r_j, s_{j+1})\)</span>。</li><li>用标准正态分布生成<span class="math inline">\(\xi\)</span>。对噪声DQN 做正向传播，得到：</li></ol><p><span class="math inline">\(\widehat{q}_j = \tilde{Q}(s_j, a_j, \xi;\mu_{\text{now}}, \sigma_{\text{now}})\)</span>.</p><ol start="3" type="1"><li>用噪声 DQN 选出最优动作：</li></ol><p><span class="math inline">\(\tilde{a}_{j+1} = \underset{a \inA}{\operatorname{argmax}} \tilde{Q}(s_{j+1}, a, \xi; \mu_{\text{now}},\sigma_{\text{now}})\)</span>.</p><ol start="4" type="1"><li>用标准正态分布生成<span class="math inline">\(\xi&#39;\)</span>。用目标网络计算价值：</li></ol><p><span class="math inline">\(\widehat{q}_{j+1}^- = \tilde{Q}(s_{j+1},\tilde{a}_{j+1}, \xi&#39;; \mu_{\text{now}}^-,\sigma_{\text{now}}^-)\)</span>.</p><ol start="5" type="1"><li>计算 TD 目标和 TD 误差：</li></ol><p><span class="math inline">\(\widehat{y}_j^- = r_j + \gamma \cdot\widehat{q}_{j+1}^-\)</span>和<span class="math inline">\(\delta_j =\widehat{q}_j - \widehat{y}_j^-\)</span>.</p><ol start="6" type="1"><li>设<span class="math inline">\(\alpha_\mu\)</span>和<span class="math inline">\(\alpha_\sigma\)</span>为学习率。做梯度下降更新噪声DQN 的参数：</li></ol><p><span class="math inline">\(\begin{align*}\mu_{\text{new}} &amp;\leftarrow \mu_{\text{now}} - \alpha_\mu \cdot\delta_j \cdot \nabla_\mu \widetilde{Q}(s_j, a_j, \xi; \mu_{\text{now}},\sigma_{\text{now}}), \\\sigma_{\text{new}} &amp;\leftarrow \sigma_{\text{now}} - \alpha_\sigma\cdot \delta_j \cdot \nabla_\sigma \widetilde{Q}(s_j, a_j, \xi;\mu_{\text{now}}, \sigma_{\text{now}}).\end{align*}\)</span>.</p><ol start="7" type="1"><li>设<span class="math inline">\(\tau \in (0,1)\)</span>是需要手动调整的超参数。做加权平均更新目标网络的参数：</li></ol><p><span class="math inline">\(\begin{align*}\mu_{\text{new}}^{-} &amp;\leftarrow \tau \cdot \mu_{\text{new}} + (1 -\tau) \cdot \mu_{\text{now}}^{-}, \\\sigma_{\text{new}}^{-} &amp;\leftarrow \tau \cdot \sigma_{\text{new}} +(1 - \tau) \cdot \sigma_{\text{now}}^{-}.\end{align*}\)</span>.</p><h1 id="总结">总结</h1><ul><li>经验回放可以用于异策略算法。经验回放有两个好处：打破相邻两条经验的相关性、重复利用收集的经验。</li><li>优先经验回放是对经验回放的一种改进。在做经验回放的时候，从经验回放数组中做加权随机抽样，TD误差的绝对值大的经验被赋予较大的抽样概率、较小的学习率。</li><li>Q 学习算法会造成 DQN高估真实的价值。高估的原因有两个：第一，最大化造成TD目标高估真实价值；第二，自举导致高估传播。高估并不是由 DQN本身的缺陷造成的，而是由于 Q学习算法不够好。双 Q学习是对 Q学习算法的改进，可以有效缓解高估。</li><li>对决网络与 DQN 一样，都是对最优动作价值函数<span class="math inline">\(Q^*\)</span>的近似；两者的唯一区别在于神经网络结构。对决网络由两部分组成：<span class="math inline">\(D(s, a; w^D)\)</span>是对最优优势函数的近似，<span class="math inline">\(V(s;w^V)\)</span>是对最优状态价值函数的近似。对决网络的训练与 DQN完全相同。</li><li>噪声网络是一种特殊的神经网络结构，神经网络中的参数带有随机噪声。噪声网络可以用于DQN等多种深度强化学习模型。噪声网络中的噪声可以鼓励探索，让智能体尝试不同的动作，这有利于学到更好的策略。</li></ul>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>RL</category>
      
      <category>DRL-王树森</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.2 高估问题</title>
    <link href="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/5-2-%E9%AB%98%E4%BC%B0%E9%97%AE%E9%A2%98/"/>
    <url>/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/5-2-%E9%AB%98%E4%BC%B0%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="高估问题及解决方法">高估问题及解决方法</h1><p>Q 学习算法有一个缺陷：用 Q 学习训练出的 DQN会高估真实的价值，而且高估通常是非均匀的。这个缺陷导致 DQN的表现很差。高估问题并不是 DQN 模型的缺陷，而是 Q 学习算法的缺陷。</p><p>Q学习产生高估的原因有两个：第一，自举导致偏差的传播；第二，最大化导致 TD目标高估真实价值。为了缓解高估，需要从导致高估的两个原因下手，改进Q学习算法。双 Q学习算法是一种有效的改进，可以大幅缓解高估及其危害。</p><h2 id="自举导致偏差的传播">自举导致偏差的传播</h2><p>在强化学习中，自举意思是“用一个估算去更新同类的估算”,类似于“自己把自己给举起来”。我们在前面的笔记中讨论过SARSA 算法中的自举。下面回顾训练 DQN 用的Q学习算法，研究其中存在的自举。算法每次从经验回放数组中抽取一个四元组<span class="math inline">\((s_j, a_j, r_j,s_{j+1})\)</span>。然后执行以下步骤，对 DQN 的参数做一轮更新：</p><p>1.计算TD目标：</p><p><span class="math inline">\(y_j^{\hat{}} = r_j + \gamma \cdot \max_aQ(s_{j+1}, a; w_{\text{now}})\)</span></p><p>2.定义损失函数</p><p><span class="math inline">\(L(w) = \frac{1}{2} [Q(s_j, a_j; w) -y_j^{\hat{}}]^2\)</span></p><p>3.把<span class="math inline">\(y_j^{\hat{}}\)</span>看做常数，做一次梯度下降更新参数：</p><p><span class="math inline">\(w_{\text{new}} \leftarrow w_{\text{now}}- \alpha \cdot \nabla_w L(w_{\text{now}})\)</span></p><p>第一步中的 TD 目标<span class="math inline">\(y_j^{\hat{}}\)</span>部分基于 DQN自己做出的估计。第二步让 DQN 去拟合<span class="math inline">\(y_j^{\hat{}}\)</span>。这就意味着我们用了 DQN自己做出的估计去更新 DQN 自己，这属于自举。</p><p>自举对 DQN 的训练有什么影响呢？</p><p><span class="math inline">\(Q(s, a; w)\)</span>是对价值<span class="math inline">\(Q^*(s, a)\)</span>的近似，最理想的情况下，<span class="math inline">\(Q(s, a; w) = Q^*(s, a)\)</span>，<span class="math inline">\(\forall s, a\)</span>。假如碰巧<span class="math inline">\(Q(s_{j+1}, a_{j+1};w)\)</span>低估(或高估)真实价值<span class="math inline">\(Q^*(s_{j+1},a_{j+1})\)</span>, 则会发生下面的情况：</p><p><span class="math inline">\(\begin{align*}Q(s_{j+1}, a_{j+1}; w) &amp; \quad \text{低估(或高估)} \quadQ^*(s_{j+1}, a_{j+1}) \\\implies \widehat{y}_j &amp; \quad \text{低估(或高估)} \quad Q^*(s_j,a_j) \\\implies Q(s_j, a_j; w) &amp; \quad \text{低估(或高估)} \quad Q^*(s_j,a_j).\end{align*}\)</span></p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/5-2-%E9%AB%98%E4%BC%B0%E9%97%AE%E9%A2%98/1733209029314-ef1f00eb-3e4a-4a1e-9444-d06b2426864b.png"></p><p>如果<span class="math inline">\(Q(s_{j+1},a_{j+1};\boldsymbol{w})\)</span>是对真实价值<span class="math inline">\(Q_\star(s_{j+1},a_{j+1})\)</span>的低估 (或高估),就会导致<span class="math inline">\(Q(s_j,a_j;\boldsymbol{w})\)</span>低估 (或高估)价值<span class="math inline">\(Q_\star(s_j,a_j)\)</span>,也就是说低估(或高估) 从<span class="math inline">\((s_{j+1},a_{j+1})\)</span>传播到<span class="math inline">\((s_j,a_j)\)</span>, 让更多的价值被低估(或高估)。</p><h2 id="最大化导致高估">最大化导致高估</h2><p>首先用数学解释为什么最大化会导致高估。设<span class="math inline">\(x_1, \cdots, x_d\)</span>为任意<span class="math inline">\(d\)</span>个实数。往<span class="math inline">\(x_1, \cdots,x_d\)</span>中加入任意均值为零的随机噪声，得到<span class="math inline">\(Z_1, \cdots,Z_d\)</span>,它们是随机变量，随机性来源于随机噪声。很容易证明均值为零的随机噪声不会影响均值：</p><p><span class="math inline">\(\mathbb{E}[mean(Z_1, \cdots, Z_d)] =mean(x_1, \cdots, x_d)\)</span>.</p><p>用稍微复杂一点的证明，可以得到：</p><p><span class="math inline">\(\mathbb{E}[max(Z_1, \cdots, Z_d)] \geqmax(x_1, \cdots, x_d)\)</span>.</p><p><span class="math inline">\(E[max(Z1,⋯,Zd)]≥max(x1,⋯,xd).\)</span></p><p>公式中的期望是关于噪声求的。这个不等式意味着先加入均值为零的噪声，然后求最大值，会产生高估。</p><p>假设对于所有的动作<span class="math inline">\(a \inA\)</span>和状态<span class="math inline">\(s \in S\)</span>, DQN的输出是真实价值<span class="math inline">\(Q^*(s,a)\)</span>加上均值为零的随机噪声<span class="math inline">\(\epsilon\)</span>:</p><p><span class="math inline">\(Q(s, a; w) = Q^*(s, a) +\epsilon\)</span>.</p><p>显然<span class="math inline">\(Q(s, a; w)\)</span>是对真实价值<span class="math inline">\(Q^*(s,a)\)</span>的无偏估计。然而有这个不等式：</p><p><span class="math inline">\(\mathbb{E}_{\epsilon} \left[ \max_{a \in\mathcal{A}} Q(s, a; w) \right] \geq \max_{a \in \mathcal{A}}Q^{\star}(s, a).\)</span></p><p>公式说明哪怕 DQN 是对真实价值的无偏估计，但是如果求最大化，DQN就会高估真实价值。复习一下，TD 目标是这样算出来的：</p><p><span class="math inline">\(\widehat{y}_{j} = r_{j} + \gamma \cdot\underbrace{\max_{a \in \mathcal{A}} Q\left(s_{j+1}, a;w\right)}_{\text{高估} \max_{a \in \mathcal{A}} Q^{\star}\left(s_{j+1},a\right)}.\)</span></p><p>这说明 TD 目标<span class="math inline">\(y_j^{\hat{}}\)</span>通常是对真实价值<span class="math inline">\(Q^*(s_j, a_j)\)</span>的高估。TD 算法鼓励<span class="math inline">\(Q(s_j, a_j; w)\)</span>接近 TD 目标<span class="math inline">\(y_j^{\hat{}}\)</span>, 这会导致<span class="math inline">\(Q(s_j, a_j; w)\)</span>高估真实价值<span class="math inline">\(Q^*(s_j, a_j)\)</span>。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/5-2-%E9%AB%98%E4%BC%B0%E9%97%AE%E9%A2%98/1733209830691-ec5c92c3-4caa-4c33-b0c6-0e84065befa9.png"></p><p>即使 DQN 是真实价值<span class="math inline">\(Q^*\)</span>的无偏估计，只要 DQN 不恒等于<span class="math inline">\(Q^*\)</span>, TD 目标就会高估真实价值。TD目标是高估，而 Q学习算法鼓励 DQN 预测接近 TD 目标，因此 DQN会出现高估。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/5-2-%E9%AB%98%E4%BC%B0%E9%97%AE%E9%A2%98/1733209869899-5b0d912c-5060-4590-8822-43f665b62853.png"></p><h2 id="高估的危害">高估的危害</h2><p>我们为什么要避免高估？高估真的有害吗？如果高估是均匀的，则高估没有危害；如果高估非均匀，就会有危害。举个例子，动作空间是<span class="math inline">\(A = \{左，右，上\}\)</span>。给定当前状态<span class="math inline">\(s\)</span>, 每个动作有一个真实价值：</p><p><span class="math inline">\(Q^*(s, 左) = 200, Q^*(s, 右) = 100,Q^*(s, 上) = 230\)</span>.</p><p>智能体应当选择动作“上”,因为“上”的价值最高。假如高估是均匀的，所有的价值都被高估了100：</p><p><span class="math inline">\(Q(s, 左; w) = 300, Q(s, 右; w) = 200,Q(s, 上; w) = 330\)</span>.</p><p>那么动作“上”仍然有最大的价值，智能体会选择“上”。这个例子说明高估本身不是问题，只要所有动作价值被同等高估。</p><p>但实践中，所有的动作价值会被同等高估吗？每当取出一个四元组<span class="math inline">\((s, a, r, s&#39;)\)</span>用来更新一次 DQN,就很有可能加重 DQN 对<span class="math inline">\(Q^*(s,a)\)</span>的高估。对于同一个状态<span class="math inline">\(s\)</span>,三种组合<span class="math inline">\((s, 左)\)</span>、<span class="math inline">\((s, 右)\)</span>、<span class="math inline">\((s,上)\)</span>出现在经验回放数组中的频率是不同的，所以三种动作被高估的程度是不同的。假如动作价值被高估的程度不同，比如</p><p><span class="math inline">\(Q(s, 左; w) = 280, Q(s, 右; w) = 300,Q(s, 上; w) = 260\)</span>,</p><p>那么智能体做出的决策就是向右走，因为“右”的价值貌似最高。但实际上“右”是最差的动作，它的实际价值低于其余两个动作。</p><p>综上所述，用 Q学习算法训练 DQN 总会导致 DQN高估真实价值。对于多数的<span class="math inline">\(s \inS\)</span>和<span class="math inline">\(a \in A\)</span>,有这样的不等式：</p><p><span class="math inline">\(Q(s, a; w) &gt; Q^*(s, a)\)</span>.</p><p>高估本身不是问题，真正的麻烦在于 DQN 的高估往往是非均匀的。如果 DQN有非均匀的高估，那么用 DQN做出的决策是不可靠的。我们已经分析过导致高估的原因：</p><ul><li>TD 算法属于“自举”,即用 DQN 的估计值去更新 DQN自己。自举会导致偏差的传播。如果<span class="math inline">\(Q(s_{j+1},a_{j+1}; w)\)</span>是对<span class="math inline">\(Q^*(s_{j+1},a_{j+1})\)</span>的高估，那么高估会传播到<span class="math inline">\((s_j, a_j)\)</span>让<span class="math inline">\(Q(s_j, a_j; w)\)</span>高估<span class="math inline">\(Q^*(s_j, a_j)\)</span>。自举导致 DQN的高估从一个二元组<span class="math inline">\((s,a)\)</span>传播到更多的二元组。</li><li>TD 目标<span class="math inline">\(y_j^{\hat{}}\)</span>中包含一项最大化，这会导致 TD目标高估真实价值<span class="math inline">\(Q_*\)</span>。Q 学习算法鼓励DQN 的预测接近 TD 目标，因此 DQN 会高估<span class="math inline">\(Q_*\)</span>。</li></ul><p>找到了产生高估的原因，就可以想办法解决问题。想要避免 DQN的高估，要么切断自举，要么避免最大化造成高估。注意，高估并不是 DQN自身的属性，高估纯粹是算法造成的。想要避免高估，就要用更好的算法替代原始的Q 学习算法。</p><h2 id="使用目标网络">使用目标网络</h2><p>上文已经讨论过，切断“自举”可以避免偏差的传播，从而缓解 DQN的高估。回顾一下，Q 学习算法这样计算 TD 目标：</p><p><span class="math inline">\(\widehat{y}_j = r_j + \gamma \cdot\max_{a \in \mathcal{A}} Q(s_{j+1}, a; w) \,.\)</span></p><p>然后做梯度下降更新<span class="math inline">\(w\)</span>,使得<span class="math inline">\(Q(s_j, a_j; w)\)</span>更接近<span class="math inline">\(y_j^{\hat{}}\)</span>。想要切断自举，可以用另一个神经网络计算TD 目标，而不是用 DQN 自己计算 TD 目标。另一个神经网络被称作<strong>目标网络 (target network)</strong> 。把目标网络记作：</p><p><span class="math inline">\(Q(s, a; w^-)\)</span>.</p><p>它的神经网络结构与 DQN 完全相同，但是参数<span class="math inline">\(w^-\)</span>不同于<span class="math inline">\(w\)</span>。</p><p>使用目标网络的话，Q学习算法用下面的方式实现。每次随机从经验回放数组中取一个四元组，记作<span class="math inline">\((s_j, a_j, r_j, s_{j+1})\)</span>。设 DQN和目标网络当前的参数分别为<span class="math inline">\(w_{\text{now}}\)</span>和<span class="math inline">\(\bar{w}_{\text{now}}\)</span>,执行下面的步骤对参数做一次更新：</p><p>1.对 DQN 做正向传播，得到：</p><p><span class="math inline">\(q_j^{\hat{}} = Q(s_j, a_j;w_{\text{now}})\)</span></p><p>2.对目标网络做正向传播，得到</p><p><span class="math inline">\(q_{j+1}^{-} = \max_a Q(s_{j+1}, a;w_{\text{now}}^-)\)</span></p><p>3.计算 TD 目标和 TD 误差：</p><p><span class="math inline">\(y_j^- = r_j + \gamma \cdotq_{j+1}^{-}\)</span>和<span class="math inline">\(\delta_j =q_j^{\hat{}} - y_j^-\)</span></p><p>4.对 DQN 做反向传播，得到梯度</p><p><span class="math inline">\(\nabla_w Q(s_j, a_j;w_{\text{now}})\)</span></p><p>5.做梯度下降更新 DQN 的参数：</p><p><span class="math inline">\(w_{\text{new}} \leftarrow w_{\text{now}}- \alpha \cdot \delta_j \cdot \nabla_w Q(s_j, a_j;w_{\text{now}})\)</span></p><p>6.设<span class="math inline">\(\tau \in (0,1)\)</span>是需要手动调的超参数。做加权平均更新目标网络的参数：</p><p><span class="math inline">\(\bar{w}_{\text{new}} \leftarrow \tau\cdot w_{\text{new}} + (1 - \tau) \cdot\bar{w}_{\text{now}}\)</span></p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/5-2-%E9%AB%98%E4%BC%B0%E9%97%AE%E9%A2%98/1733210558085-bccc9371-1de2-4bf3-a61a-d99f62c93653.png"></p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/5-2-%E9%AB%98%E4%BC%B0%E9%97%AE%E9%A2%98/1733210648273-45d7e502-b270-4f5b-a7a2-925700f52d0d.png"></p><p>如图 6.4 (左) 所示，原始的 Q学习算法用 DQN 计算<span class="math inline">\(y_j^{\hat{}}\)</span>,然后拿<span class="math inline">\(y_j^{\hat{}}\)</span>更新 DQN 自己，造成自举。如图 6.4(右)所示，可以改用目标网络计算<span class="math inline">\(y_j^{\hat{}}\)</span>,这样就避免了用 DQN的估计更新 DQN自己，降低自举造成的危害。然而这种方法不能完全避免自举，原因是目标网络的参数仍然与DQN 相关。</p><h2 id="双-q-学习算法">双 Q 学习算法</h2><p>造成 DQN 高估的原因不是 DQN 模型本身的缺陷，而是 Q学习算法有不足之处：第一，自举造成偏差的传播；第二，最大化造成 TD目标的高估。在 Q学习算法中使用目标网络，可以缓解自举造成的偏差，但是无助于缓解最大化造成的高估。本小节介绍双Q 学习 (double Q learning)算法，它在目标网络的基础上做改进，缓解最大化造成的高估。</p><p>注 本小节介绍的双 Q 学习算法在文献中被称作 double DQN, 缩写DDQN。本书不采用 DDQN这名字，因为这个名字比较误导。双 Q 学习 (即所谓的DDQN) 只是一种 TD 算法而已，它可以把 DQN 训练得更好。双 Q学习并没有用区别于 DQN 的模型。本节中的模型只有一个，就是DQN。我们讨论的只是训练 DQN 的三种 TD 算法：原始的 Q 学习、 用目标网络的Q 学习、双 Q 学习。</p><p>为了解释原始的 Q 学习、用目标网络的 Q 学习、以及双 Q学习三者的区别，我们再回顾一下Q 学习算法中的 TD 目标：</p><p><span class="math inline">\(\widehat{y}_j = r_j + \gamma \cdot\max_{a \in \mathcal{A}} Q(s_{j+1}, a; w) \,.\)</span></p><p>不妨把最大化拆成两步：</p><p>1.选择——即基于状态<span class="math inline">\(s_{j+1}\)</span>,选出一个动作使得 DQN的输出最大化：</p><p><span class="math inline">\(a^{\star} = \underset{a \inA}{\operatorname{argmax}} Q(s_{j+1}, a; w)\)</span></p><p>2.求值——即计算<span class="math inline">\((s_{j+1},a^{\star})\)</span>的价值，从而算出 TD 目标：</p><p><span class="math inline">\(y_j^{\hat{}} = r_j + Q(s_{j+1},a^{\star}; w)\)</span></p><p>以上是原始的 Q 学习算法，选择和求值都用 DQN。上一小节改进了 Q学习，选择和求值都用目标网络：</p><p>选择：</p><p><span class="math inline">\(a^- = \underset{a \inA}{\operatorname{argmax}} Q(s_{j+1}, a; w^-)\)</span>,</p><p>求值：</p><p><span class="math inline">\(\widetilde{y}_j = r_j + Q(s_{j+1}, a^-;w^-)\)</span>.</p><p>本小节介绍双 Q 学习，第一步的选择用 DQN, 第二步的求值用目标网络：</p><p>选择：</p><p><span class="math inline">\(a^{\star} = \underset{a \inA}{\operatorname{argmax}} Q(s_{j+1}, a; w)\)</span>,</p><p>求值：</p><p><span class="math inline">\(\widetilde{y}_j = r_j + Q(s_{j+1},a^{\star}; w^-)\)</span>.</p><p>为什么双 Q 学习可以缓解最大化造成的高估呢？不难证明出这个不等式：</p><p><span class="math inline">\(\underbrace{Q\left(s_{j+1}, a^{*};w^{-}\right)}_{\text{双 Q学习}} \leq \underbrace{\max_{a \in\mathcal{A}} Q\left(s_{j+1}, a; w^{-}\right)}_{\text{用目标网络的Q学习}}.\)</span>.</p><p>因此，</p><p><span class="math inline">\(\underbrace{\widetilde{y}_{t}}_{\text{双Q学习}}\leq\underbrace{\widehat{y}_{t}}_{\text{用目标网络的Q学习}}.\)</span></p><p>这个公式说明双 Q 学习得到的 TD 目标更小。也就是说，与用目标网络的 Q学习相比，双 Q学习缓解了高估。</p><p>双 Q学习算法的流程如下。每次随机从经验回放数组中取出一个四元组，记作<span class="math inline">\((s_j, a_j, r_j, s_{j+1})\)</span>。设 DQN和目标网络当前的参数分别为<span class="math inline">\(w_{\text{now}}\)</span>和<span class="math inline">\(w_{\text{now}}^-\)</span>,执行下面的步骤对参数做一次更新：</p><p>1.对 DQN 做正向传播，得到：</p><p><span class="math inline">\(q_j^{\hat{}} = Q(s_j, a_j;w_{\text{now}})\)</span></p><p>2.选择：</p><p><span class="math inline">\(a^{\star} = \underset{a \inA}{\operatorname{argmax}} Q(s_{j+1}, a; w_{\text{now}})\)</span></p><p>3.求值：</p><p><span class="math inline">\(q_{j+1} = Q(s_{j+1}, a^{\star};\bar{w}_{\text{now}})\)</span></p><p>4.计算 TD 目标和 TD 误差：</p><p><span class="math inline">\(\widetilde{y}_j = r_j + \gamma \cdotq_{j+1}\)</span>和<span class="math inline">\(\delta_j = q_j^{\hat{}} -\widetilde{y}_j\)</span></p><p>5.对 DQN 做反向传播，得到梯度</p><p><span class="math inline">\(\nabla_w Q(s_j, a_j;w_{\text{now}})\)</span></p><p>6.做梯度下降更新 DQN 的参数：</p><p><span class="math inline">\(w_{\text{new}} \leftarrow w_{\text{now}}- \alpha \cdot \delta_j \cdot \nabla_w Q(s_j, a_j;w_{\text{now}})\)</span></p><p>7.设<span class="math inline">\(\tau \in (0,1)\)</span>是需要手动调整的超参数。做加权平均更新目标网络的参数：</p><p><span class="math inline">\(\bar{w}_{\text{new}} \leftarrow \tau\cdot w_{\text{new}} + (1 - \tau) \cdot\bar{w}_{\text{now}}\)</span></p><h2 id="总结">总结</h2><p>本节研究了 DQN 的高估问题以及解决方案。DQN 的高估不是 DQN模型造成的，不是 DQN 的本质属性。高估只是因为原始 Q 学习算法不好。Q学习算法产生高估的原因有两个：第一，自举导致偏差从一个<span class="math inline">\((s,a)\)</span>二元组传播到更多的二元组；第二，最大化造成 TD目标高估真实价值。</p><p>想要解决高估问题，就要从自举、最大化这两方面下手。本节介绍了两种缓解高估的算法：使用目标网络、双Q学习。Q 学习算法与目标网络的结合可以缓解自举造成的偏差。双Q学习基于目标网络的想法，进一步将 TD 目标的计算分解成选择和求值两步，缓解了最大化造成的高估。图 6.5 总结了本节研究的三种算法。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/5-2-%E9%AB%98%E4%BC%B0%E9%97%AE%E9%A2%98/1733212786643-e1052770-7aba-41fb-9fbc-8c193827c04e.png"></p><p>注 如果使用原始 Q学习算法，自举和最大化都会造成严重高估。在实践中，应当尽量使用双Q学习，它是三种算法中最好的。</p><p>注 如果使用 SARSA 算法 (比如在 actor-critic 中),自举的问题依然存在，但是不存在最大化造成高估这一问题。对于 SARSA,只需要解决自举问题，所以应当将目标网络应用到 SARSA 。</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>RL</category>
      
      <category>DRL-王树森</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.1 经验回放</title>
    <link href="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/5-1-%E7%BB%8F%E9%AA%8C%E5%9B%9E%E6%94%BE/"/>
    <url>/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/5-1-%E7%BB%8F%E9%AA%8C%E5%9B%9E%E6%94%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="价值学习高级技巧">价值学习高级技巧</h1><p>前面介绍了 DQN, 并且用 Q学习算法训练 DQN。如果用最原始的 Q学习算法，那么训练出的 DQN 效果会很不理想。想要提升 DQN的表现，需要用本章的高级技巧。文献中已经有充分实验结果表明这些高级技巧对DQN非常有效，而且这些技巧不冲突，可以一起使用。有些技巧并不局限于DQN，而是可以应用于多种价值学习和策略学习方法。</p><p>介绍经验回放 (experience replay) 和优先经验回放(prioritizedexperience replay)。讨论 DQN 的高估问题以及解决方案——目标网络(targetnetwork) 和双 Q 学习算法(double Q-learning)。</p><p>介绍两种方法改进 DQN 的神经网络结构 (不是对 Q学习算法的改进)：对决网络 (dueling network),它把动作价值 (action value)分解成状态价值(state value) 与优势 (advantage)；噪声网络 (noisy net),它往神经网络的参数中加入随机噪声,鼓励探索。</p><h1 id="经验回放">经验回放</h1><p>经验回放(experiencereplay)是强化学习中一个重要的技巧，可以大幅提升强化学习的表现。经验回放的意思是把智能体与环境交互的记录(即经验)储存到一个数组里，事后反复利用这些经验训练智能体。这个数组被称为经验回放数组(replay buffer)。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/5-1-%E7%BB%8F%E9%AA%8C%E5%9B%9E%E6%94%BE/1733201744660-70545f81-e6a4-44ee-a10a-d8bb5762d746.png"></p><p>具体来说，把智能体的轨迹划分成<span class="math inline">\(s_t, a_t,r_t, s_{t+1}\)</span>这样的四元组，存入一个数组。需要人为指定数组的大小(记作<span class="math inline">\(b\)</span>)。数组中只保留最近<span class="math inline">\(b\)</span>条数据；当数组存满之后，删除掉最旧的数据。数组的大小<span class="math inline">\(b\)</span>是个需要调的超参数，会影响训练的结果。通常设置<span class="math inline">\(b\)</span>为<span class="math inline">\(10^5\sim10^6\)</span>。</p><p>在实践中，要等回放数组中有足够多的四元组时，才开始做经验回放更新DQN。根据论文的实验分析，如果将 DQN 用于 Atari 游戏，最好是在收集到 20万条四元组时才开始做经验回放更新 DQN; 如果是用更好的 Rainbow DQN, 收集到8 万条四元组时就可以开始更新DQN。在回放数组中的四元组数量不够的时候，DQN 只与环境交互，而不去更新DQN 参数，否则实验效果不好。</p><h1 id="经验回放的优点">经验回放的优点</h1><p>经验回放的一个好处在于打破序列的相关性。训练 DQN的时候，每次我们用一个四元组对 DQN的参数做一次更新。我们希望相邻两次使用的四元组是独立的。然而当智能体收集经验的时候，相邻两个四元组<span class="math inline">\((s_t, a_t, r_t, s_{t+1})\)</span>和<span class="math inline">\((s_{t+1}, a_{t+1}, r_{t+1},s_{t+2})\)</span>有很强的相关性。依次使用这些强关联的四元组训练 DQN,效果往往会很差。经验回放每次从数组里随机抽取一个四元组，用来对 DQN参数做一次更新。这样随机抽到的四元组都是独立的，消除了相关性。</p><p>经验回放的另一个好处是重复利用收集到的经验、而不是用一次就丢弃，这样可以用更少的样本数量达到同样的表现。重复利用经验、不重复利用经验的收敛曲线通常如图6.2 所示。图的横轴是样本数量，纵轴是平均回报。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/5-1-%E7%BB%8F%E9%AA%8C%E5%9B%9E%E6%94%BE/1733201838369-eb1a4f6e-ab3a-45b9-83d7-03c73331017c.png"></p><p>注 在阅读文献的时候请注意“样本数量"(sample complexity)与“更新次数"两者的区别。样本数量是指智能体从环境中获取的奖励<span class="math inline">\(r\)</span>的数量。而一次更新的意思是从经验回放数组里取出一个或多个四元组，用它对参数<span class="math inline">\(w\)</span>做一次更新。通常来说，样本数量更重要，因为在实际应用中收集经验比较困难。比如，在机器人的应用中，需要在现实世界做一次实验才能收集到一条经验，花费的时间和金钱远大于做一次计算。相对而言，做更新的次数不是那么重要，更新次数只会影响训练时的计算量而已。</p><h1 id="经验回放的局限性">经验回放的局限性</h1><p>需要注意，并非所有的强化学习方法都允许重复使用过去的经验。经验回放数组里的数据全都是用行为策略(behavior policy)控制智能体收集到的。在收集经验同时，我们也在不断地改进策略。策略的变化导致收集经验时用的行为策略是过时的策略，不同于当前我们想要更新的策略——即目标策略(targetpolicy)。也就是说，经验回放数组中的经验通常是过时的行为策略收集的，而我们真正想要学的目标策略不同于过时的行为策略。</p><p>有些强化学习方法允许行为策略不同于目标策略。这样的强化学习方法叫做异策略(off-policy)。比如Q 学习、确定策略梯度 (DPG)都属于异策略。由于它们允许行为策略不同于目标策略，过时的行为策略收集到的经验可以被重复利用。经验回放适用于异策略。</p><p>有些强化学习方法要求行为策略与目标策略必须相同。这样的强化学习方法叫做同策略(on-policy)。比如 SARSA、REINFORCE、A2C都属于同策略。它们要求经验必须是当前的目标策略收集到的，而不能使用过时的经验。经验回放不适用于同策略。</p><h1 id="优先经验回放">优先经验回放</h1><p>优先经验回放 (prioritized experience replay)是一种特殊的经验回放方法，它比普通的经验回放效果更好：既能让收敛更快，也能让收敛时的平均回报更高。经验回放数组里有<span class="math inline">\(b\)</span>个四元组，普通经验回放每次均匀抽样得到一个样本——即四元组<span class="math inline">\((s_j, a_j, r_j, s_{j+1})\)</span>。用它来更新 DQN的参数。优先经验回放给每个四元组一个权重，然后根据权重做非均匀随机抽样。如果DQN 对<span class="math inline">\((s_j,a_j)\)</span>的价值判断不准确，即<span class="math inline">\(Q(s_j, a_j;w)\)</span>离<span class="math inline">\(Q^*(s_j,a_j)\)</span>较远，则四元组<span class="math inline">\((s_j, a_j, r_j,s_{j+1})\)</span>应当有较高的权重。</p><p>为什么样本的重要性会有所不同呢？设想你用强化学习训练一辆无人车。经验回放数组中的样本绝大多数都是车辆正常行驶的情形，只有极少数样本是意外情况，比如旁边车辆强行变道、行人横穿马路、警察封路要求绕行。数组中的样本的重要性显然是不同的。绝大多数的样本都是车辆正常行驶，而且正常行驶的情形很容易处理，出错的可能性非常小。意外情况的样本非常少，但是又极其重要，处理不好就会车毁人亡。所以意外情况的样本应当有更高的权重，受到更多关注。这两种样本不应该同等对待。</p><p>如何自动判断哪些样本更重要呢？举个例子，自动驾驶中的意外情况数量少、而且难以处理，导致DQN 的预测<span class="math inline">\(Q(s_j, a_j;w)\)</span>严重偏离真实价值<span class="math inline">\(Q^*(s_j,a_j)\)</span>。因此，要是<span class="math inline">\(|Q(s_j, a_j; w) -Q^*(s_j, a_j)|\)</span>较大，则应该给样本<span class="math inline">\((s_j, a_j, r_j,s_{j+1})\)</span>较高的权重。然而实际上我们不知道<span class="math inline">\(Q^*\)</span>，因此无从得知<span class="math inline">\(|Q(s_j, a_j; w) - Q^*(s_j,a_j)|\)</span>。不妨把它替换成 TD 误差。回忆一下，TD 误差的定义是：</p><p><span class="math inline">\(\delta_j = \Delta Q(s_j, a_j;w_{\text{now}}) - [r_t + \gamma \cdot \max_a Q(s_{j+1}, a;w_{\text{now}})]\)</span></p><p>如果 TD 误差的绝对值<span class="math inline">\(|\delta_j|\)</span>大，说明 DQN 对<span class="math inline">\((s_j,a_j)\)</span>的真实价值的评估不准确，那么应该给<span class="math inline">\((s_j, a_j, r_j,s_{j+1})\)</span>设置较高的权重。</p><p>优先经验回放对数组里的样本做非均匀抽样。四元组<span class="math inline">\((s_j, a_j, r_j, s_{j+1})\)</span>的权重是 TD误差的绝对值<span class="math inline">\(|\delta_j|\)</span>。有两种方法设置抽样概率。一种抽样概率是：</p><p><span class="math inline">\(p_j \propto |\delta_j| +\epsilon\)</span>.</p><p>此处的<span class="math inline">\(\epsilon\)</span>是个很小的数，防止抽样概率接近零，用于保证所有样本都以非零的概率被抽到。另一种抽样方式先对<span class="math inline">\(|\delta_j|\)</span>做降序排列，然后计算</p><p><span class="math inline">\(p_j \propto\frac{1}{\text{rank}(j)}\)</span>.</p><p>此处的<span class="math inline">\(\text{rank}(j)\)</span>是<span class="math inline">\(|\delta_j|\)</span>的序号。大的<span class="math inline">\(|\delta_j|\)</span>的序号小，小的<span class="math inline">\(|\delta_j|\)</span>的序号大。两种方式的原理是一样的，<span class="math inline">\(|\delta_j|\)</span>大的样本被抽样到的概率大。</p><p>优先经验回放做非均匀抽样，四元组<span class="math inline">\((s_j,a_j, r_j, s_{j+1})\)</span>被抽到的概率是<span class="math inline">\(p_j\)</span>。抽样是非均匀的，不同的样本有不同的抽样概率，这样会导致DQN 的预测有偏差。应该相应调整学习率，抵消掉不同抽样概率造成的偏差。TD算法用“随机梯度下降”来更新参数：</p><p><span class="math inline">\(w_{\text{new}} \leftarrow w_{\text{now}}- \alpha \cdot g\)</span>,</p><p>此处的<span class="math inline">\(\alpha\)</span>是学习率，<span class="math inline">\(g\)</span>是损失函数关于<span class="math inline">\(w\)</span>的梯度。如果用均匀抽样，那么所有样本有相同的学习率<span class="math inline">\(\alpha\)</span>。如果做非均匀抽样的话，应该根据抽样概率来调整学习率<span class="math inline">\(\alpha\)</span>。如果一条样本被抽样的概率大，那么它的学习率就应该比较小。可以这样设置学习率：</p><p><span class="math inline">\(\alpha_j = \frac{\alpha}{(b \cdotp_j)^\beta}\)</span>,</p><p>此处的<span class="math inline">\(b\)</span>是经验回放数组中样本的总数，<span class="math inline">\(\beta \in (0,1)\)</span>是个需要调的超参数（论文里建议一开始让<span class="math inline">\(\beta\)</span>比较小，最终增长到 1）。</p><p>注 均匀抽样是一种特例，即所有抽样概率都相等：</p><p><span class="math inline">\(p_1 = \cdots = p_b =\frac{1}{b}\)</span>.</p><p>在这种情况下，有<span class="math inline">\((b \cdot p_j)^\beta =1\)</span>, 因此学习率都相同：</p><p><span class="math inline">\(\alpha_1 = \cdots = \alpha_b =\alpha_o\)</span>.</p><p>注 读者可能会问下面的问题。如果样本<span class="math inline">\((s_j,a_j, r_j, s_{j+1})\)</span>很重要，它被抽到的概率<span class="math inline">\(p_j\)</span>很大，可是它的学习率却很小。当<span class="math inline">\(\beta = 1\)</span>时，如果抽样概率<span class="math inline">\(p_j\)</span>变大 10 倍，则学习率<span class="math inline">\(\alpha_j\)</span>减小 10倍。抽样概率、学习率两者岂不是抵消了吗，那么优先经验回放有什么意义呢？大抽样概率、小学习率两者其实并没有抵消，因为下面两种方式并不等价：</p><ul><li>设置学习率为<span class="math inline">\(\alpha\)</span>,使用样本<span class="math inline">\((s_j, a_j, r_j,s_{j+1})\)</span>计算一次梯度，更新一次参数<span class="math inline">\(w\)</span>;</li><li>设置学习率为<span class="math inline">\(\frac{\alpha}{10}\)</span>,使用样本<span class="math inline">\((s_j, a_j, r_j,s_{j+1})\)</span>计算十次梯度，更新十次参数<span class="math inline">\(w\)</span>。</li></ul><p>乍看起来两种方式区别不大，但其实第二种方式是对样本更有效的利用。第二种方式的缺点在于计算量大了十倍，所以第二种方式只被用于重要的样本。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/5-1-%E7%BB%8F%E9%AA%8C%E5%9B%9E%E6%94%BE/1733202010568-2c83e20c-97ce-4227-aeea-8a893769e0cd.png"></p><p>优先经验回放数组如图 6.3 所示。设<span class="math inline">\(b\)</span>为数组大小，需要手动调整。如果样本(即四元组) 的数量超过了<span class="math inline">\(b\)</span>,那么要删除最旧的样本。数组里记录了四元组、TD误差、抽样概率、以及学习率。注意，数组里存的 TD 误差<span class="math inline">\(\delta_j\)</span>是用很多步之前过时的 DQN参数计算出来的：</p><p><span class="math inline">\(\delta_j = Q(s_j, a_j; w_{\text{old}}) -[r_t + \gamma \cdot \max_a Q(s_{j+1}, a; w_{\text{old}})]\)</span>.</p><p>做经验回放的时候，每次取出一个四元组，用它计算出新的 TD 误差：</p><p><span class="math inline">\(\delta_j&#39; = Q(s_j, a_j;w_{\text{now}}) - [r_t + \gamma \cdot \max_a Q(s_{j+1}, a;w_{\text{now}})]\)</span>,</p><p>然后用它更新 DQN 的参数。用这个新的<span class="math inline">\(\delta_j&#39;\)</span>取代数组中旧的<span class="math inline">\(\delta_j\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>RL</category>
      
      <category>DRL-王树森</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.3 多步 TD目标</title>
    <link href="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/4-3-%E5%A4%9A%E6%AD%A5-TD%E7%9B%AE%E6%A0%87/"/>
    <url>/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/4-3-%E5%A4%9A%E6%AD%A5-TD%E7%9B%AE%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<h1 id="多步-td-目标">多步 TD 目标</h1><p>首先回顾一下 SARSA 算法。给定五元组<span class="math inline">\((s_t,a_t, r_t, s_{t+1}, a_{t+1})\)</span>, SARSA 计算 TD 目标：</p><p><span class="math inline">\(\hat{y}_t = r_t + \gamma \cdot q(s_{t+1},a_{t+1}; \boldsymbol{w}).\)</span></p><p>公式中只用到一个奖励<span class="math inline">\(r_t\)</span>,这样得到的<span class="math inline">\(\hat{y}_t\)</span>叫做单步 TD 目标。多步 TD目标用<span class="math inline">\(m\)</span>个奖励可以视作单步 TD目标的推广。下面我们推导多步 TD 目标。</p><h2 id="数学推导">数学推导：</h2><p>设一局游戏的长度为<span class="math inline">\(n\)</span>。根据定义，<span class="math inline">\(t\)</span>时刻的回报<span class="math inline">\(U_t\)</span>是<span class="math inline">\(t\)</span>时刻之后的所有奖励的加权和：</p><p><span class="math inline">\(U_t = R_t + \gamma R_{t+1} + \gamma^2R_{t+2} + \cdots + \gamma^{n-t} R_n.\)</span></p><p>同理，<span class="math inline">\(t+m\)</span>时刻的回报可以写成：</p><p><span class="math inline">\(U_{t+m} = R_{t+m} + \gamma R_{t+m+1} +\gamma^2 R_{t+m+2} + \cdots + \gamma^{n-t-m} R_n.\)</span></p><p>下面我们推导两个回报的关系。把<span class="math inline">\(U_t\)</span>写成：</p><p><span class="math inline">\(\begin{align*}U_{t} &amp;= \left(R_{t} + \gamma R_{t+1} + \cdots + \gamma^{m-1}R_{t+m-1}\right) + \left(\gamma^{m} R_{t+m} + \cdots + \gamma^{n-t}R_{n}\right) \\&amp;= \left(\sum_{i=0}^{m-1} \gamma^{i} R_{t+i}\right) + \gamma^{m}\underbrace{\left(R_{t+m} + \gamma R_{t+m+1} + \cdots + \gamma^{n-t-m}R_{n}\right)}_{\text{等于} U_{t+m}}.\end{align*}\)</span></p><p>因此，回报可以写成这种形式：</p><p><span class="math inline">\(U_t = ( \sum_{i=0}^{m-1} \gamma^i R_{t+i}) + \gamma^m U_{t+m}.\)</span></p><p>动作价值函数<span class="math inline">\(Q_\pi(s_t,a_t)\)</span>是回报<span class="math inline">\(U_t\)</span>的期望，而<span class="math inline">\(Q_\pi(s_{t+m}, a_{t+m})\)</span>是回报<span class="math inline">\(U_{t+m}\)</span>的期望。利用公式，再按照贝尔曼方程的证明，不难得出下面的定理：</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/4-3-%E5%A4%9A%E6%AD%A5-TD%E7%9B%AE%E6%A0%87/1733200971858-f2d763c8-9406-4c2c-986a-4a5acff344b4.png"></p><p>设<span class="math inline">\(R_k\)</span>是<span class="math inline">\(S_k, A_k\)</span>的函数，<span class="math inline">\(\forall k = 1, \cdots, n\)</span>。那么</p><p><span class="math inline">\(\underbrace{Q_\pi(s_t, a_t)}_{U_t\text{的期望}} = \mathbb{E} \left[ \left( \sum_{i=0}^{m-1} \gamma^iR_{t+i} \right) + \gamma^m \cdot \underbrace{Q_\pi(S_{t+m},A_{t+m})}_{U_{t+m} \text{的期望}} \bigg \| S_t = s_t, A_t = a_t\right].\)</span></p><p>公式中的期望是关于随机变量<span class="math inline">\(S_{t+1},A_{t+1}, \cdots, S_{t+m}, A_{t+m}\)</span>求的。</p><p>注 回报<span class="math inline">\(U_t\)</span>的随机性来自于<span class="math inline">\(t\)</span>到<span class="math inline">\(n\)</span>时刻的状态和动作：</p><p><span class="math inline">\(S_t, A_t, S_{t+1}, A_{t+1}, \cdots,S_{t+m}, A_{t+m}, S_{t+m+1}, A_{t+m+1}, \cdots, S_n, A_n.\)</span></p><p>定理中把<span class="math inline">\(S_t = s_t\)</span>和<span class="math inline">\(A_t = a_t\)</span>看做是观测值，用期望消掉<span class="math inline">\(S_{t+1}, A_{t+1}, \cdots, S_{t+m},A_{t+m}\)</span>, 而<span class="math inline">\(Q_\pi(S_{t+m},A_{t+m})\)</span>则消掉了剩余的随机变量<span class="math inline">\(S_{t+m+1}, A_{t+m+1}, \cdots, S_n,A_n\)</span>。</p><h2 id="多步-td目标">多步 TD目标：</h2><p>我们对定理中的期望做蒙特卡洛近似，然后再用价值网络<span class="math inline">\(q(s, a;\boldsymbol{w})\)</span>近似动作价值函数<span class="math inline">\(Q_\pi(s, a)\)</span>。具体做法如下：</p><ul><li>在<span class="math inline">\(t\)</span>时刻，价值网络做出预测<span class="math inline">\(\hat{q}_t = q(s_t, a_t; \boldsymbol{w})\)</span>,它是对<span class="math inline">\(Q_\pi(s_t, a_t)\)</span>的估计。</li><li>已知当前状态<span class="math inline">\(s_t\)</span>, 用策略<span class="math inline">\(\pi\)</span>控制智能体与环境交互<span class="math inline">\(m\)</span>次，得到轨迹<span class="math inline">\(r_t, s_{t+1}, a_{t+1}, r_{t+1}, \cdots, s_{t+m-1},a_{t+m-1}, r_{t+m-1}, s_{t+m}, a_{t+m}\)</span>.</li><li>在<span class="math inline">\(t+m\)</span>时刻，用观测到的轨迹对定理中的期望做蒙特卡洛近似，把近似的结果记作：</li></ul><p><span class="math inline">\(\left(\sum_{i=0}^{m-1} \gamma^ir_{t+i}\right) + \gamma^m \cdot Q_\pi(s_{t+m}, a_{t+m}).\)</span></p><ul><li>进一步用<span class="math inline">\(q(s_{t+m}, a_{t+m};\boldsymbol{w})\)</span>近似<span class="math inline">\(Q_\pi(s_{t+m},a_{t+m})\)</span>, 得到：</li></ul><p><span class="math inline">\(\hat{y}_t \triangleq\left(\sum_{i=0}^{m-1} \gamma^i r_{t+i}\right) + \gamma^m \cdotq(s_{t+m}, a_{t+m}; \boldsymbol{w}).\)</span></p><p>把<span class="math inline">\(\hat{y}_t\)</span>称作<span class="math inline">\(m\)</span>步TD 目标。</p><p><span class="math inline">\(\hat{q}_t = q(s_t, a_t;\boldsymbol{w})\)</span>和<span class="math inline">\(\hat{y}_t\)</span>分别是价值网络在<span class="math inline">\(t\)</span>时刻和<span class="math inline">\(t+m\)</span>时刻做出的预测，两者都是对<span class="math inline">\(Q_\pi(s_t, a_t)\)</span>的估计值。<span class="math inline">\(\hat{q}_t\)</span>是纯粹的预测，而<span class="math inline">\(\hat{y}_t\)</span>则基于<span class="math inline">\(m\)</span>组实际观测，因此<span class="math inline">\(\hat{y}_t\)</span>比<span class="math inline">\(\hat{q}_t\)</span>更可靠。我们鼓励<span class="math inline">\(\hat{q}_t\)</span>接近<span class="math inline">\(\hat{y}_t\)</span>。设损失函数为：</p><p><span class="math inline">\(L(\boldsymbol{w}) \triangleq \frac{1}{2}\Big[q(s_t, a_t; \boldsymbol{w}) - \hat{y}_t\Big]^2.\)</span></p><p>做一步梯度下降更新价值网络参数<span class="math inline">\(\boldsymbol{w}\)</span>:</p><p><span class="math inline">\(\boldsymbol{w} \leftarrow \boldsymbol{w}- \alpha \cdot (\hat{q}_t - \hat{y}_t) \cdot \nabla_{\boldsymbol{w}}q(s_t, a_t; \boldsymbol{w}).\)</span></p><p><strong>训练流程</strong>：</p><p>设当前价值网络的参数为<span class="math inline">\(\boldsymbol{w}_{\text{now}}\)</span>,当前策略为<span class="math inline">\(\pi_{\text{now}}\)</span>。执行以下步骤更新价值网络和策略。</p><ol type="1"><li>用策略网络<span class="math inline">\(\pi_{\text{now}}\)</span>控制智能体与环境交互，完成一个回合，得到轨迹<span class="math inline">\(s_1, a_1, r_1, s_2, a_2, r_2, \cdots, s_n, a_n,r_n\)</span>.</li><li>对于所有的<span class="math inline">\(t = 1, \cdots, n-m\)</span>,计算<span class="math inline">\(\hat{q}_t = q(s_t, a_t;\boldsymbol{w}_{\text{now}})\)</span>.<br>3.对于所有的<span class="math inline">\(t = 1, \cdots,n-m\)</span>,计算多步 TD 目标和 TD 误差：</li></ol><p><span class="math inline">\(\hat{y}_t = \sum_{i=0}^{m-1} \gamma^ir_{t+i} + \gamma^m \hat{q}_{t+m}, \quad \delta_t = \hat{q}_t -\hat{y}_t.\)</span></p><ol start="4" type="1"><li>对于所有的<span class="math inline">\(t = 1, \cdots, n-m\)</span>,对价值网络<span class="math inline">\(q\)</span>做反向传播，计算<span class="math inline">\(q\)</span>关于<span class="math inline">\(\boldsymbol{w}\)</span>的梯度：<span class="math inline">\(\nabla_{\boldsymbol{w}} q(s_t, a_t;\boldsymbol{w}_{\text{now}})\)</span>.</li><li>更新价值网络参数：</li></ol><p><span class="math inline">\(\boldsymbol{w}_{\text{new}} \leftarrow\boldsymbol{w}_{\text{now}} - \alpha \cdot \sum_{t=1}^{n-m} \delta_t\cdot \nabla_{\boldsymbol{w}} q(s_t, a_t;\boldsymbol{w}_{\text{now}}).\)</span></p><ol start="6" type="1"><li>用某种算法更新策略函数<span class="math inline">\(\pi\)</span>。该算法与 SARSA 算法无关。</li></ol><h2 id="蒙特卡洛与自举">蒙特卡洛与自举</h2><p>上一节介绍了多步 TD 目标。单步 TD 目标、回报是多步 TD目标的两种特例。如下图所示，如果设<span class="math inline">\(m=1\)</span>,那么多步 TD 目标变成单步 TD目标。如果设<span class="math inline">\(m=n-t+1\)</span>,那么多步 TD目标变成实际观测的回报<span class="math inline">\(u_t\)</span>。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/4-3-%E5%A4%9A%E6%AD%A5-TD%E7%9B%AE%E6%A0%87/1733201036864-2bc98eb5-101c-4e51-b254-dfd667733d36.png"></p><h3 id="蒙特卡洛">蒙特卡洛</h3><p>训练价值网络<span class="math inline">\(q(s, a;\boldsymbol{w})\)</span>的时候，我们可以将一局游戏进行到底，观测到所有的奖励<span class="math inline">\(r_1, \cdots, r_n\)</span>,然后计算回报<span class="math inline">\(u_t = \sum_{i=0}^{n-t} \gamma^ir_{t+i}\)</span>。拿<span class="math inline">\(u_t\)</span>作为目标，鼓励价值网络<span class="math inline">\(q(s_t, a_t; \boldsymbol{w})\)</span>接近<span class="math inline">\(u_t\)</span>。定义损失函数：</p><p><span class="math inline">\(L(\boldsymbol{w}) = \frac{1}{2}\left[q(s_t, a_t; \boldsymbol{w}) - u_t\right]^2.\)</span></p><p>然后做一次梯度下降更新<span class="math inline">\(\boldsymbol{w}\)</span>:</p><p><span class="math inline">\(\boldsymbol{w} \leftarrow \boldsymbol{w}- \alpha \cdot \nabla_{\boldsymbol{w}} L(\boldsymbol{w}),\)</span></p><p>这样可以让价值网络的预测<span class="math inline">\(q(s_t, a_t;\boldsymbol{w})\)</span>更接近<span class="math inline">\(u_t\)</span>。这种训练价值网络的方法不是 TD。</p><p>在强化学习中，训练价值网络的时候以<span class="math inline">\(u_t\)</span>作为目标，这种方式被称作“蒙特卡洛”。原因是这样的，动作价值函数可以写作<span class="math inline">\(Q_{\pi}(s_{t}, a_{t}) = \mathbb{E}[U_{t} \midS_{t} = s_{t}, A_{t} = a_{t}].\)</span>, 而我们用实际观测<span class="math inline">\(u_t\)</span>去近似期望，这就是典型的蒙特卡洛近似。</p><p>蒙特卡洛的好处是无偏性：<span class="math inline">\(u_t\)</span>是<span class="math inline">\(Q_\pi(s_t, a_t)\)</span>的无偏估计。由于<span class="math inline">\(u_t\)</span>的无偏性，拿<span class="math inline">\(u_t\)</span>作为目标训练价值网络，得到的价值网络也是无偏的。</p><p>蒙特卡洛的坏处是方差大。随机变量<span class="math inline">\(U_t\)</span>依赖于<span class="math inline">\(S_{t+1}, A_{t+1}, \cdots, S_n,A_n\)</span>这些随机变量，其中不确定性很大。观测值<span class="math inline">\(u_t\)</span>虽然是<span class="math inline">\(U_t\)</span>的无偏估计，但可能实际上离<span class="math inline">\(\mathbb{E}\{U_t\}\)</span>很远。</p><p>因此，拿<span class="math inline">\(u_t\)</span>作为目标训练价值网络，收敛会很慢。</p><h3 id="自举">自举</h3><p>在介绍价值学习的自举之前，先解释一下什么叫自举。大家可能经常在强化学习和统计学的文章里见到bootstrapping 这个词。它的字面意思是“拔自己的鞋带，把自己举起来”。所以bootstrapping 翻译成“自举”,即自己把自己举起来。自举听起来很荒谬。即使你“力拔山兮气盖世”,你也没办法拔自己的鞋带，把自己举起来。虽然自举乍看起来不现实，但是在统计和机器学习 是可以做到自举的；自举在统计和机器学习里面非常常用。</p><p>在强化学习中，“自举”的意思是“用一个估算去更新同类的估算”,类似于“自己把自己给举起来”。SARSA使用的单步 TD 目标定义为：</p><p>SARSA 鼓励<span class="math inline">\(q(s_t, a_t;\boldsymbol{w})\)</span>接近<span class="math inline">\(\hat{y}_t\)</span>, 所以定义损失函数：</p><p><span class="math inline">\(L(w) = \frac{1}{2} \left[q(s_t, a_t;\boldsymbol{w}) - \hat{y}_t\right]^2.\)</span></p><p>TD 目标<span class="math inline">\(\hat{y}_t\)</span>的一部分是价值网络做出的估计<span class="math inline">\(\gamma \cdot q(s_{t+1}, a_{t+1};\boldsymbol{w})\)</span>, 然后 SARSA 让<span class="math inline">\(q(s_t, a_t; \boldsymbol{w})\)</span>去拟合<span class="math inline">\(\hat{y}_t\)</span>。这就是用价值网络自己做出的估计去更新价值网络自己，这属于“自举”。(严格地说，TD目标<span class="math inline">\(\hat{y}_t\)</span>中既有自举的成分，也有蒙特卡洛的成分。TD目标中的<span class="math inline">\(\gamma \cdot q(s_{t+1}, a_{t+1};\boldsymbol{w})\)</span>是自举，因为它拿价值网络自己的估计作为目标。TD目标中的<span class="math inline">\(r_t\)</span>是实际观测，它是对<span class="math inline">\(\mathbb{E}[R_t]\)</span>的蒙特卡洛。)</p><p>自举的好处是方差小。单步 TD 目标的随机性只来自于<span class="math inline">\(S_{t+1}, A_{t+1}\)</span>, 而回报<span class="math inline">\(U_t\)</span>的随机性来自于<span class="math inline">\(S_{t+1}, A_{t+1}, \cdots, S_n,A_n\)</span>。很显然，单步 TD目标的随机性较小，因此方差较小。用自举训练价值网络，收敛比较快。</p><p>自举的坏处是有偏差。价值网络<span class="math inline">\(q(s, a;\boldsymbol{w})\)</span>是对动作价值<span class="math inline">\(Q_\pi(s,a)\)</span>的近似。最理想的情况下，<span class="math inline">\(q(s, a;\boldsymbol{w}) = Q_\pi(s, a), \forall s, a\)</span>。假如碰巧<span class="math inline">\(q(s_{j+1}, a_{j+1};\boldsymbol{w})\)</span>低估(或高估)真实价值<span class="math inline">\(Q_\pi(s_{j+1},a_{j+1})\)</span>,则会发生下面的情况：</p><p><span class="math inline">\(\begin{align*}&amp;\Longrightarrow\quad q(s_{j+1}, a_{j+1}; w) \quad\text{低估(或高估)} \quad Q_{\pi}(s_{j+1}, a_{j+1}) \\&amp;\Longrightarrow\quad \widehat{y_{j}} \quad \text{低估(或高估)}\quad Q_{\pi}(s_{j}, a_{j}) \\&amp;\Longrightarrow\quad q(s_{j}, a_{j}; w) \quad \text{低估(或高估)}\quad Q_{\pi}(s_{j}, a_{j}).\end{align*}\)</span></p><p>也就是说，自举会让偏差从<span class="math inline">\((s_{t+1},a_{t+1})\)</span>传播到<span class="math inline">\((s_t,a_t)\)</span>。后面详细讨论自举造成的偏差以及解决方案。</p><h3 id="蒙特卡洛和自举的对比">蒙特卡洛和自举的对比</h3><p>在价值学习中，用实际观测的回报<span class="math inline">\(u_t\)</span>作为目标的方法被称为蒙特卡洛，即图 5.5中的蓝色的箱型图。</p><p><span class="math inline">\(u_t\)</span>是<span class="math inline">\(Q_\pi(s_t, a_t)\)</span>的无偏估计，即<span class="math inline">\(\mathbb{E}\{U_t\} = Q_\pi(s_t,a_t)\)</span>。但是它的方差很大，也就是说实际观测到的<span class="math inline">\(u_t\)</span>可能离<span class="math inline">\(Q_\pi(s_t, a_t)\)</span>很远。</p><p>用单步 TD 目标<span class="math inline">\(\hat{y}_t\)</span>作为目标的方法被称为自举，即图5.5中的红色的箱型图。自举的好处在于方差小，<span class="math inline">\(\hat{y}_t\)</span>不会偏离期望太远。但是<span class="math inline">\(\hat{y}_t\)</span>往往是有偏的，它的期望往往不等于<span class="math inline">\(Q_\pi(s_t,a_t)\)</span>。用自举训练出的价值网络往往有系统性的偏差(低估或者高估)。实践中，自举通常比蒙特卡洛收敛更快，这就是为什么训练 DQN和价值网络通常用 TD 算法。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/4-3-%E5%A4%9A%E6%AD%A5-TD%E7%9B%AE%E6%A0%87/1733201216510-1e04b391-1f6b-4ffc-84aa-c413475ed842.png"></p><p>如图 5.4 所示，多步 TD 目标<span class="math inline">\(\hat{y}_t =\left(\sum_{i=0}^{m-1} \gamma^i r_{t+i}\right) + \gamma^m \cdotq(s_{t+m}, a_{t+m}; \boldsymbol{w})\)</span>介于蒙特卡洛和自举之间。多步TD 目标有很大的蒙特卡洛成分，其中的<span class="math inline">\(\sum_{i=0}^{m-1} \gamma^ir_{t+i}\)</span>基于<span class="math inline">\(m\)</span>个实际观测到的奖励。多步 TD目标也有自举的成分，其中的<span class="math inline">\(\gamma^m \cdotq(s_{t+m}, a_{t+m};\boldsymbol{w})\)</span>是用价值网络自己算出来的。如果把<span class="math inline">\(m\)</span>设置得比较好，可以在方差和偏差之间找到好的平衡，使得多步TD 目标优于单步 TD 目标，也优于回报<span class="math inline">\(u_t\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>RL</category>
      
      <category>DRL-王树森</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.2 Q-learning算法</title>
    <link href="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/4-2-Q-learning%E7%AE%97%E6%B3%95/"/>
    <url>/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/4-2-Q-learning%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="q-学习与-sarsa-的对比">Q 学习与 SARSA 的对比：</h1><p>Q学习不依赖于<span class="math inline">\(\pi\)</span>,因此Q学习属于异策略 (off-policy), 可以用经验回放。而 SARSA 依赖于<span class="math inline">\(\pi\)</span>, 因此 SARSA 属于同策略(on-policy),不能用经验回放。两种算法的对比如图 5.2 所示。</p><p>Q学习的目标是学到表格<span class="math inline">\(\tilde{Q}\)</span>,作为最优动作价值函数<span class="math inline">\(Q^*\)</span>的近似。因为<span class="math inline">\(Q^*\)</span>与<span class="math inline">\(\pi\)</span>无关，所以在理想情况下，不论收集经验用的行为策略<span class="math inline">\(\pi\)</span>是什么，都不影响Q学习得到的最优动作价值函数。因此，Q学习属于异策略(off-policy),允许行为策略区别于目标策略。Q学习允许使用经验回放，可以重复利用过时的经验。</p><p>SARSA 算法的目标是学到表格<span class="math inline">\(q\)</span>,作为动作价值函数<span class="math inline">\(Q_\pi\)</span>的近似。<span class="math inline">\(Q_\pi\)</span>与一个策略<span class="math inline">\(\pi\)</span>相对应，用不同的策略<span class="math inline">\(\pi\)</span>, 对应<span class="math inline">\(Q_\pi\)</span>就会不同。策略<span class="math inline">\(\pi\)</span>越好，<span class="math inline">\(Q_\pi\)</span>的值越大。经验回放数组里的经验<span class="math inline">\((s_j, a_j, r_j,s_{j+1})\)</span>是过时的行为策略<span class="math inline">\(\pi_{\text{old}}\)</span>收集到的，与当前策略<span class="math inline">\(\pi_{\text{now}}\)</span>应的价值<span class="math inline">\(Q_{\pi_{\text{now}}}\)</span>对应不上。想要学习<span class="math inline">\(Q_\pi\)</span>的话，必须要用与当前策略<span class="math inline">\(\pi_{\text{now}}\)</span>收集到的经验，而不能用过时的<span class="math inline">\(\pi_{\text{old}}\)</span>收集到的经验。这就是为什么SARSA 不能用经验回放的原因。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/4-2-Q-learning%E7%AE%97%E6%B3%95/1733196209962-673cefaf-0128-4011-9ec9-dea4bdd088d8.png"></p><h1 id="q学习算法">Q学习算法</h1><p>Q学习算法上一节用 TD 算法训练DQN（介绍DQN的笔记在这里：深度强化学习（王树森）笔记02）,更准确地说，我们用的 TD 算法叫做 Q 学习算法 (Q- learning)。TD算法是一大类算法，常见的有 Q 学习和 SARSA。Q学习的目的是学到最优动作价值函数<span class="math inline">\(Q^*\)</span>，而 SARSA的目的是学习动作价值函数<span class="math inline">\(Q_\pi\)</span>。下一章会介绍 SARSA 算法。</p><p>Q 学习是在 1989 年提出的，而 DQN 则是 2013 年才提出。从 DQN 的名字(深度 Q 网络)就能看出 DQN 与 Q 学习的联系。最初的 Q学习都是以表格形式出现的。虽然表格形式的 Q学习在实践中不常用，但还是建议读者有所了解。</p><h2 id="用表格表示q">用表格表示<span class="math inline">\(Q^*\)</span>:</h2><p>假设状态空间<span class="math inline">\(S\)</span>和动作空间<span class="math inline">\(\mathcal{A}\)</span>都是有限集，即集合中元素数量有限。比如，<span class="math inline">\(S\)</span>中一共有3种状态，<span class="math inline">\(\mathcal{A}\)</span>中一共有4种动作。那么最优动作价值函数<span class="math inline">\(Q^*(s,a)\)</span>可以表示为一个3×4的表格，比如右边的表格。基于当前状态<span class="math inline">\(s_t\)</span>,做决策时使用的公式<span class="math inline">\(a_t = \mathop{\mathrm{argmax}}_{a \in \mathcal{A}}Q^*(s_t,a)\)</span>的意思是找到<span class="math inline">\(s_t\)</span>对应的行(3行中的某一行),找到该行最大的价值，返回该元素对应的动作。举个例子，当前状态<span class="math inline">\(s_t\)</span>是第2种状态，那么我们查看第2行，发现该行最大的价值是210,对应第4种动作。那么应当执行的动作<span class="math inline">\(a_t\)</span>就是第4种动作。</p><p>该如何通过智能体的轨迹来学习这样一个表格呢？答案是用一个表格<span class="math inline">\(\tilde{Q}\)</span>来近似<span class="math inline">\(Q^*\)</span>。</p><p>首先初始化<span class="math inline">\(\tilde{Q}\)</span>,可以让它是全零的表格。然后用表格形式的Q学习算法更新<span class="math inline">\(\tilde{Q}\)</span>,每次更新表格的一个元素。最终<span class="math inline">\(\tilde{Q}\)</span>会收敛到<span class="math inline">\(Q^*\)</span>。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/4-2-Q-learning%E7%AE%97%E6%B3%95/1733199888226-65ba1f32-75a4-4ffa-8288-9fa892eebbe9.png"></p><h2 id="算法推导">算法推导：</h2><p>首先复习一下最优贝尔曼方程：</p><p><span class="math inline">\(Q^*(s_t, a_t) = \mathbb{E}_{S_{t+1} \simp(\cdot|s_t, a_t)} \Big[ R_t + \gamma \cdot \max_{A \in \mathcal{A}}Q^*(S_{t+1}, A) \Big| S_t = s_t, A_t = a_t \Big].\)</span></p><p>我们对方程左右两边做近似：</p><ul><li>方程左边的<span class="math inline">\(Q^*(s_t,a_t)\)</span>可以近似成<span class="math inline">\(\tilde{Q}(s_t,a_t)\)</span>。</li><li>方程右边的期望是关于下一时刻状态<span class="math inline">\(S_{t+1}\)</span>求的。给定当前状态<span class="math inline">\(s_t\)</span>, 智能体执行动作<span class="math inline">\(a_t\)</span>,环境会给出奖励<span class="math inline">\(r_t\)</span>和新的状态<span class="math inline">\(s_{t+1}\)</span>。用观测到的<span class="math inline">\(r_t\)</span>和<span class="math inline">\(s_{t+1}\)</span>对期望做蒙特卡洛近似，得到：<span class="math inline">\(r_t + \gamma \cdot \max_{a \in \mathcal{A}}Q^*(s_{t+1}, a)\)</span>.</li><li>进一步把公式中的<span class="math inline">\(Q^*\)</span>近似成<span class="math inline">\(\tilde{Q}\)</span>, 得到</li></ul><p><span class="math inline">\(\widehat{y}_{t} \triangleq r_{t} + \gamma\cdot \max_{a \in \mathcal{A}} \widetilde{Q}(s_{t+1}, a).\)</span></p><p>把它称作 TD 目标。它是表格在 t+1时刻对<span class="math inline">\(Q^*(s_t, a_t)\)</span>做出的估计。</p><p><span class="math inline">\(\tilde{Q}(s_t, a_t)\)</span>和<span class="math inline">\(\hat{y}_t\)</span>都是对最优动作价值<span class="math inline">\(Q^*(s_t, a_t)\)</span>的估计。由于<span class="math inline">\(\hat{y}_t\)</span>部分基于真实观测到的奖励<span class="math inline">\(r_t\)</span>,我们认为<span class="math inline">\(\hat{y}_t\)</span>是更可靠的估计，所以鼓励<span class="math inline">\(\tilde{Q}(s_t, a_t)\)</span>更接近<span class="math inline">\(\hat{y}_t\)</span>。更新表格<span class="math inline">\(\tilde{Q}\)</span>中<span class="math inline">\((s_t, a_t)\)</span>位置上的元素：</p><p><span class="math inline">\(\tilde{Q}(s_t, a_t) \leftarrow (1-\alpha)\cdot \tilde{Q}(s_t, a_t) + \alpha \cdot \hat{y}_t.\)</span></p><p>这样可以使得<span class="math inline">\(\tilde{Q}(s_t,a_t)\)</span>更接近<span class="math inline">\(\hat{y}_t\)</span>。Q学习的目的是让<span class="math inline">\(\tilde{Q}\)</span>逐渐趋近于<span class="math inline">\(Q^*\)</span>。</p><h2 id="收集训练数据">收集训练数据：</h2><p>Q学习更新<span class="math inline">\(\tilde{Q}\)</span>的公式不依赖于具体的策略。我们可以用任意策略控制智能体，与环境交互，把得到的轨迹划分成<span class="math inline">\((s_t, a_t, r_t,s_{t+1})\)</span>这样的四元组，存入经验回放数组。这个控制智能体的策略叫做行为策略(behaviorpolicy), 比较常用的行为策略是<span class="math inline">\(\epsilon\)</span>-greedy:</p><p><span class="math inline">\(a_t = \left\{ \begin{array}{ll}\mathrm{argmax}_a \tilde{Q}(s_t, a), &amp; \text{以概率 } (1-\epsilon);\\ \text{均匀抽取 } A \text{ 中的一个动作}, &amp; \text{以概率 }\epsilon. \end{array} \right.\)</span></p><p>事后用经验回放更新表格<span class="math inline">\(\tilde{Q}\)</span>,可以重复利用收集到的四元组。</p><p><strong>经验回放更新表格</strong><span class="math inline">\(\tilde{Q}\)</span>:</p><p>随机从经验回放数组中抽取一个四元组，记作<span class="math inline">\((s_j, a_j, r_j,s_{j+1})\)</span>。设当前表格为<span class="math inline">\(\tilde{Q}_{\text{now}}\)</span>。更新表格中<span class="math inline">\((s_j,a_j)\)</span>位置上的元素，把更新之后的表格记作<span class="math inline">\(\tilde{Q}_{\text{new}}\)</span>。</p><ol type="1"><li>把表格<span class="math inline">\(\tilde{Q}_{\text{now}}\)</span>中第<span class="math inline">\((s_j, a_j)\)</span>位置上的元素记作：<span class="math inline">\(\hat{q}_j = \tilde{Q}_{\text{now}}(s_j,a_j)\)</span>.</li><li>查看表格<span class="math inline">\(\tilde{Q}_{\text{now}}\)</span>的第<span class="math inline">\(s_{j+1}\)</span>行，把该行的最大值记作：<span class="math inline">\(\hat{q}_{j+1} = \max_a\tilde{Q}_{\text{now}}(s_{j+1}, a)\)</span>.</li><li>计算 TD 目标和 TD 误差：<span class="math inline">\(\hat{y}_j = r_j+ \gamma \cdot \hat{q}_{j+1}, \quad \delta_j = \hat{q}_j -\hat{y}_j\)</span>.</li><li>更新表格中<span class="math inline">\((s_j,a_j)\)</span>位置上的元素：<span class="math inline">\(\tilde{Q}_{\text{new}}(s_j, a_j) \leftarrow\tilde{Q}_{\text{now}}(s_j, a_j) - \alpha \cdot \delta_j\)</span>.</li></ol><p>收集经验与更新表格<span class="math inline">\(\tilde{Q}\)</span>可以同时进行。每当智能体执行一次动作，我们可以用经验回放对<span class="math inline">\(\tilde{Q}\)</span>做几次更新。也可以每当完成一局游戏，对<span class="math inline">\(\tilde{Q}\)</span>做几次更新。</p><h2 id="同策略-on-policy-与异策略-off-policy">同策略 (On-policy)与异策略 (Off-policy)</h2><p>在强化学习中经常会遇到两个专业术语：同策略(on-policy) 和异策略(off-policy)。</p><p>为了解释同策略和异策略，我们要从行为策略 (behavior policy) 和目标策略(target policy) 讲起。</p><p>在强化学习中，我们让智能体与环境交互，记录下观测到的状态、动作、奖励，用这些经验来学习一个策略函数。在这一过程中，控制智能体与环境交互的策略被称作行为策略。行为策略的作用是收集经验(experience),即观测的状态、动作、奖励。</p><p>强化学习的目的是得到一个策略函数，用这个策略函数来控制智能体。这个策略函数就叫做目标策略。在本章中，目标策略是一个确定性的策略，即用DQN 控制智能体：</p><p><span class="math inline">\(a_t :=\underset{a}{\operatorname*{argmax}}\: Q(s_t, a;\boldsymbol{w}).\)</span></p><p>本章的 Q 学习算法用任意的行为策略收集<span class="math inline">\((s_t, a_t, r_t,s_{t+1})\)</span>这样的四元组，然后拿它们训练目标策略，即 DQN。</p><p>行为策略和目标策略可以相同，也可以不同。同策略是指用相同的行为策略和目标策略，后面章节会介绍同策略。异策略是指用不同的行为策略和目标策略，本章的DQN 属于异策略。同策略和异策略如图 4.6、4.7 所示。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/4-2-Q-learning%E7%AE%97%E6%B3%95/1733200093902-6f272eca-a75d-4476-b836-45a6e8b417ee.png"></p><p>由于DQN是异策略，行为策略可以不同于目标策略，可以用任意的行为策略收集经验，<font style="color:rgb(77, 77, 77);">比如最常用的行为策略是</font><span class="math inline">\(\epsilon-greedy\)</span><font style="color:rgb(77, 77, 77);">:</font></p><p><span class="math inline">\(a_{t} = \left\{  \begin{array}{ll}    \operatorname{argmax}_{a} Q(s_{t}, a; w), &amp;\text{以概率}(1-\epsilon); \\    \text{均匀抽取}\mathcal{A}\text{中的一个动作}, &amp;\text{以概率}\epsilon.  \end{array}\right.\)</span></p><p>让行为策略带有随机性的好处在于能探索更多没见过的状态。在实验中，初始的时候让<span class="math inline">\(\epsilon\)</span>比较大 (比如<span class="math inline">\(\epsilon=0.5)\)</span>; 在训练的过程中，让<span class="math inline">\(\epsilon\)</span>逐渐衰减，在几十万步之后衰减到较小的值(<span class="math inline">\(\epsilon=0.01\)</span>), 此后固定住<span class="math inline">\(\epsilon=0.01\)</span>。</p><p>异策略的好处是可以用行为策略收集经验，把<span class="math inline">\((s_t, a_t, r_t,s_{t+1})\)</span>这样的四元组记录到一个数组里，在事后反复利用这些经验去更新目标策略。这个数组被称作经验回放数组(replaybuffer), 这种训练方式被称作经验回放 (experiencereplay)。注意，经验回放只适用于异策略，不适用于同策略，其原因是收集经验时用的行为策略不同于想要训练出的目标策略。</p><h1 id="总结">总结</h1><p>DQN 是对最优动作价值函数<span class="math inline">\(Q^*\)</span>的近似。DQN 的输入是当前状态<span class="math inline">\(s_t\)</span>, 输出是每个动作的 Q 值。DQN要求动作空间<span class="math inline">\(\mathcal{A}\)</span>是离散集合，集合中的元素数量有限。如果动作空间<span class="math inline">\(\mathcal{A}\)</span>的大小是 k,那么 DQN 的输出就是k 维向量。DQN 可以用于做决策，智能体执行 Q 值最大的动作。</p><p>TD 算法的目的在于让预测更接近实际观测。以驾车问题为例，如果使用 TD算法，无需完成整个旅途就能做梯度下降更新模型。请读者理解并记忆 TD目标、TD 误差的定义，它们将出现在所有价值学习的章节中。</p><p>Q 学习算法是 TD 算法的一种，可以用于训练 DQN。Q学习算法由最优贝尔曼方程推导出。Q学习算法属于异策略，允许使用经验回放。由任意行为策略收集经验，存入经验回放数组。事后做经验回放，用 TD 算法更新 DQN 参数。</p><p>如果状态空间<span class="math inline">\(S\)</span>、动作空间<span class="math inline">\(\mathcal{A}\)</span>都是较小的有限离散集合，那么可以用表格形式的Q学习算法学习<span class="math inline">\(Q^*\)</span>。如今表格形式的 Q学习已经不常用。</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>RL</category>
      
      <category>DRL-王树森</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.1 Sarsa算法</title>
    <link href="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/4-1-Sarsa%E7%AE%97%E6%B3%95/"/>
    <url>/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/4-1-Sarsa%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>TD 算法是一大类算法的总称。Q 学习是一种 TD 算法，Q学习的目的是学习最优动作价值函数<span class="math inline">\(Q^*\)</span>。这里介绍 SARSA, 它也是一种 TD算法，SARSA 的目的是学习动作价值函数<span class="math inline">\(Q_\pi(s,a)\)</span>。</p><h1 id="表格形式的-sarsa">表格形式的 SARSA</h1><p>假设状态空间<span class="math inline">\(S\)</span>和动作空间<span class="math inline">\(\mathcal{A}\)</span>都是有限集，即集合中元素数量有限。比如，<span class="math inline">\(S\)</span>中一共有 3 种状态，<span class="math inline">\(\mathcal{A}\)</span>中一共有 4种动作。那么动作价值函数<span class="math inline">\(Q_\pi(s,a)\)</span>可以表示为一个 3×4的表格，比如右边的表格。该表格与一个策略函数<span class="math inline">\(\pi(a|s)\)</span>相关联；如果<span class="math inline">\(\pi\)</span>发生变化， 表格<span class="math inline">\(Q_\pi\)</span>也会发生变化。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/4-1-Sarsa%E7%AE%97%E6%B3%95/1733195913964-02d289b3-9568-4e46-87d9-35b541bab6bc.png"></p><p>我们用表格<span class="math inline">\(q\)</span>近似<span class="math inline">\(Q_\pi\)</span>。该如何通过智能体与环境的交互来学习表格<span class="math inline">\(q\)</span>呢？首先初始化<span class="math inline">\(q\)</span>,可以让它是全零的表格。然后用表格形式的SARSA 算法更新<span class="math inline">\(q\)</span>,每次更新表格的一个元素。最终<span class="math inline">\(q\)</span>收敛到<span class="math inline">\(Q_\pi\)</span>。</p><h2 id="推导">推导 :</h2><p>SARSA 算法由下面的贝尔曼方程推导出：</p><p><span class="math inline">\(Q_\pi(s_t, a_t) = \mathbb{E}_{S_{t+1},A_{t+1}} \big[R_t + \gamma \cdot Q_\pi(S_{t+1}, A_{t+1}) \big| S_t =s_t, A_t = a_t\big]\)</span></p><p>我们对贝尔曼方程左右两边做近似：</p><ul><li>方程左边的<span class="math inline">\(Q_\pi(s_t,a_t)\)</span>可以近似成<span class="math inline">\(q(s_t,a_t)\)</span>。</li><li>方程右边的期望是关于下一时刻状态<span class="math inline">\(S_{t+1}\)</span>和动作<span class="math inline">\(A_{t+1}\)</span>求的。给定当前状态<span class="math inline">\(s_t\)</span>, 智能体执行动作<span class="math inline">\(a_t\)</span>,环境会给出奖励<span class="math inline">\(r_t\)</span>和新的状态<span class="math inline">\(s_{t+1}\)</span>。然后基于<span class="math inline">\(s_{t+1}\)</span>做随机抽样，得到新的动作<span class="math inline">\(\tilde{a}_{t+1} \sim\pi(\cdot|s_{t+1})\)</span>。用观测到的<span class="math inline">\(r_t\)</span>、<span class="math inline">\(s_{t+1}\)</span>和计算出的<span class="math inline">\(\tilde{a}_{t+1}\)</span>对期望做蒙特卡洛近似，得到：</li></ul><p><span class="math inline">\(r_t + \gamma \cdot Q_\pi(s_{t+1},\tilde{a}_{t+1})\)</span>.</p><ul><li>进一步把公式中的<span class="math inline">\(Q_\pi\)</span>近似成<span class="math inline">\(q\)</span>, 得到</li></ul><p><span class="math inline">\(\hat{y}_t \triangleq r_t + \gamma \cdotq(s_{t+1}, \tilde{a}_{t+1})\)</span>.</p><p>把它称作 TD 目标。它是表格在<span class="math inline">\(t+1\)</span>时刻对<span class="math inline">\(Q_\pi(s_t, a_t)\)</span>做出的估计。</p><p><span class="math inline">\(q(s_t, a_t)\)</span>和<span class="math inline">\(\hat{y}_t\)</span>都是对动作价值<span class="math inline">\(Q_\pi(s_t, a_t)\)</span>的估计。</p><p>由于<span class="math inline">\(\hat{y}_t\)</span>部分基于真实观测到的奖励<span class="math inline">\(r_t\)</span>, 我们认为<span class="math inline">\(\hat{y}_t\)</span>是更可靠的估计，所以鼓励<span class="math inline">\(q(s_t, a_t)\)</span>趋近<span class="math inline">\(\hat{y}_t\)</span>。更新表格<span class="math inline">\((s_t, a_t)\)</span>位置上的元素：</p><p><span class="math inline">\(q(s_t, a_t) \leftarrow (1-\alpha) \cdotq(s_t, a_t) + \alpha \cdot \hat{y}_t.\)</span></p><p>这样可以使得<span class="math inline">\(q(s_t,a_t)\)</span>更接近<span class="math inline">\(\hat{y}_t\)</span>。</p><p>SARSA 是 State-Action-Reward-State-Action 的缩写，原因是 SARSA算法用到了这个五元组<span class="math inline">\((s_t, a_t, r_t, s_{t+1},\tilde{a}_{t+1})\)</span>。SARSA 算法学到的<span class="math inline">\(q\)</span>依赖于策略<span class="math inline">\(\pi\)</span>, 这是因为五元组中的<span class="math inline">\(\tilde{a}_{t+1}\)</span>是根据<span class="math inline">\(\pi(\cdot|s_{t+1})\)</span>抽样得到的。</p><h2 id="训练流程">训练流程：</h2><p>设当前表格为<span class="math inline">\(q_{\text{now}}\)</span>,当前策略为<span class="math inline">\(\pi_{\text{now}}\)</span>。每一轮更新表格中的一个元素，把更新之后的表格记作<span class="math inline">\(q_{\text{new}}\)</span>。</p><ol type="1"><li>观测到当前状态<span class="math inline">\(s_t\)</span>,根据当前策略做抽样<span class="math inline">\(a_t \sim\pi_{\text{now}}(\cdot|s_t)\)</span>。</li><li>把表格<span class="math inline">\(q_{\text{now}}\)</span>中第<span class="math inline">\((s_t, a_t)\)</span>位置上的元素记作：<span class="math inline">\(\hat{q}_t = q_{\text{now}}(s_t,a_t)\)</span>.</li><li>智能体执行动作<span class="math inline">\(a_t\)</span>之后，观测到奖励<span class="math inline">\(r_t\)</span>和新的状态<span class="math inline">\(s_{t+1}\)</span>。</li><li>根据当前策略做抽样<span class="math inline">\(\tilde{a}_{t+1} \sim\pi_{\text{now}}(\cdot|s_{t+1})\)</span>。注意，<span class="math inline">\(\tilde{a}_{t+1}\)</span>只是假想的动作，智能体不予执行。</li><li>把表格<span class="math inline">\(q_{\text{now}}\)</span>中第<span class="math inline">\((s_{t+1},\tilde{a}_{t+1})\)</span>位置上的元素记作：<span class="math inline">\(\hat{q}_{t+1} = q_{\text{now}}(s_{t+1},\tilde{a}_{t+1})\)</span>.</li><li>计算 TD 目标和 TD 误差：<span class="math inline">\(\hat{y}_t = r_t+ \gamma \cdot \hat{q}_{t+1}, \quad \delta_t = \hat{q}_t -\hat{y}_t\)</span>.</li><li>更新表格中<span class="math inline">\((s_t,a_t)\)</span>位置上的元素：<span class="math inline">\(q_{\text{new}}(s_t, a_t) \leftarrowq_{\text{now}}(s_t, a_t) - \alpha \cdot \delta_t\)</span>.</li><li>用某种算法更新策略函数。该算法与 SARSA 算法无关。</li></ol><h1 id="神经网络形式的-sarsa">神经网络形式的 SARSA</h1><h2 id="价值网络">价值网络：</h2><p>如果状态空间<span class="math inline">\(S\)</span>是无限集，那么我们无法用一张表格表示<span class="math inline">\(Q_\pi\)</span>,否则表格的行数是无穷。一种可行的方案是用一个神经网络<span class="math inline">\(q(s, a; \boldsymbol{w})\)</span>来近似<span class="math inline">\(Q_\pi(s, a)\)</span>; 理想情况下，<span class="math inline">\(q(s, a; \boldsymbol{w}) = Q_\pi(s, a), \forall s\in \mathcal{S}, a \in \mathcal{A}\)</span>.</p><p>神经网络<span class="math inline">\(q(s, a;\boldsymbol{w})\)</span>被称为价值网络 (value network), 其中的<span class="math inline">\(\boldsymbol{w}\)</span>表示神经网络中可训练的参数。神经网络的结构是人预先设定的（比如有多少层，每一层的宽度是多少）,而参数<span class="math inline">\(\boldsymbol{w}\)</span>需要通过智能体与环境的交互来学习。首先随机初始化<span class="math inline">\(\boldsymbol{w}\)</span>,然后用 SARSA 算法更新<span class="math inline">\(\boldsymbol{w}\)</span>。</p><p>神经网络的结构见图 5.3。价值网络的输入是状态<span class="math inline">\(s\)</span>。如果<span class="math inline">\(s\)</span>是矩阵或张量 (tensor),那么可以用卷积网络处理<span class="math inline">\(s\)</span>(如图5.3)。如果<span class="math inline">\(s\)</span>是向量，那么可以用全连接层处理<span class="math inline">\(s\)</span>。价值网络的输出是每个动作的价值。动作空间<span class="math inline">\(\mathcal{A}\)</span>中有多少种动作，则价值网络的输出就是多少维的向量，向量每个元素对应一个动作。举个例子，动作空间是<span class="math inline">\(\{左，右，上\}\)</span>, 价值网络的输出是</p><p><span class="math inline">\(q(s, 左; \boldsymbol{w}) = 219, q(s, 右;\boldsymbol{w}) = -73, q(s, 上; \boldsymbol{w}) = 580\)</span>.</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/4-1-Sarsa%E7%AE%97%E6%B3%95/1733196263670-b083519b-5bee-4071-87c1-b90c0cccc87a.png"></p><h2 id="算法推导">算法推导：</h2><p>给定当前状态<span class="math inline">\(s_t\)</span>,智能体执行动作<span class="math inline">\(a_t\)</span>,环境会给出奖励<span class="math inline">\(r_t\)</span>和新的状态<span class="math inline">\(s_{t+1}\)</span>。然后基于<span class="math inline">\(s_{t+1}\)</span>做随机抽样，得到新的动作<span class="math inline">\(\tilde{a}_{t+1} \sim\pi(\cdot|s_{t+1})\)</span>。定义 TD 目标：</p><p><span class="math inline">\(\hat{y}_t \triangleq r_t + \gamma \cdotq(s_{t+1}, \tilde{a}_{t+1}; \boldsymbol{w}).\)</span></p><p>我们鼓励<span class="math inline">\(q(s_t, a_t;\boldsymbol{w})\)</span>接近 TD 目标<span class="math inline">\(\hat{y}_t\)</span>, 所以定义损失函数：</p><p><span class="math inline">\(L(\boldsymbol{w}) \triangleq \frac{1}{2}\Big[q(s_t, a_t; \boldsymbol{w}) - \hat{y}_t\Big]^2.\)</span></p><p>损失函数的变量是<span class="math inline">\(\boldsymbol{w}\)</span>,而<span class="math inline">\(\hat{y}_t\)</span>被视为常数。(尽管<span class="math inline">\(\hat{y}_t\)</span>也依赖于参数<span class="math inline">\(\boldsymbol{w}\)</span>, 但这一点被忽略掉.)设<span class="math inline">\(\hat{q}_t = q(s_t, a_t;\boldsymbol{w})\)</span>。损失函数关于<span class="math inline">\(\boldsymbol{w}\)</span>的梯度是：</p><p><span class="math inline">\(\nabla_{\boldsymbol{w}} L(\boldsymbol{w})= (\hat{q}_t - \hat{y}_t) \cdot \nabla_{\boldsymbol{w}} q(s_t, a_t;\boldsymbol{w}).\)</span></p><p>做一次梯度下降更新<span class="math inline">\(\boldsymbol{w}\)</span>:</p><p><span class="math inline">\(\boldsymbol{w} \leftarrow \boldsymbol{w}- \alpha \cdot \delta_t \cdot \nabla_{\boldsymbol{w}} q(s_t, a_t;\boldsymbol{w}).\)</span></p><p>这样可以使得<span class="math inline">\(q(s_t, a_t;\boldsymbol{w})\)</span>更接近<span class="math inline">\(\hat{y}_t\)</span>。此处的<span class="math inline">\(\alpha\)</span>是学习率，需要手动调整。</p><p><strong>训练流程</strong>：</p><p>设当前价值网络的参数为<span class="math inline">\(\boldsymbol{w}_{\text{now}}\)</span>,当前策略为<span class="math inline">\(\pi_{\text{now}}\)</span>。每一轮训练用五元组<span class="math inline">\((s_t, a_t, r_t, s_{t+1},\tilde{a}_{t+1})\)</span>对价值网络参数做一次更新。</p><ol type="1"><li>观测到当前状态<span class="math inline">\(s_t\)</span>,根据当前策略做抽样：<span class="math inline">\(a_t \sim\pi_{\text{now}}(\cdot|s_t)\)</span>。</li><li>用价值网络计算<span class="math inline">\((s_t,a_t)\)</span>的价值：<span class="math inline">\(\hat{q}_t = q(s_t, a_t;\boldsymbol{w}_{\text{now}})\)</span>.</li><li>智能体执行动作<span class="math inline">\(a_t\)</span>之后，观测到奖励<span class="math inline">\(r_t\)</span>和新的状态<span class="math inline">\(s_{t+1}\)</span>。</li><li>根据当前策略做抽样<span class="math inline">\(\tilde{a}_{t+1} \sim\pi_{\text{now}}(\cdot|s_{t+1})\)</span>。注意，<span class="math inline">\(\tilde{a}_{t+1}\)</span>只是假想的动作，智能体不予执行。</li><li>用价值网络计算<span class="math inline">\((s_{t+1},\tilde{a}_{t+1})\)</span>的价值：<span class="math inline">\(\hat{q}_{t+1} = q(s_{t+1}, \tilde{a}_{t+1};\boldsymbol{w}_{\text{now}})\)</span>.</li><li>计算 TD 目标和 TD 误差：<span class="math inline">\(\hat{y}_t = r_t+ \gamma \cdot \hat{q}_{t+1}, \quad \delta_t = \hat{q}_t -\hat{y}_t\)</span>.</li><li>对价值网络<span class="math inline">\(q\)</span>做反向传播，计算<span class="math inline">\(q\)</span>关于<span class="math inline">\(\boldsymbol{w}\)</span>的梯度：<span class="math inline">\(\nabla_{\boldsymbol{w}} q(s_t, a_t;\boldsymbol{w}_{\text{now}})\)</span>.</li><li>更新价值网络参数：<span class="math inline">\(\boldsymbol{w}_{\text{new}} \leftarrow\boldsymbol{w}_{\text{now}} - \alpha \cdot \delta_t \cdot\nabla_{\boldsymbol{w}} q(s_t, a_t;\boldsymbol{w}_{\text{now}})\)</span>.</li><li>用某种算法更新策略函数。该算法与 SARSA 算法无关。</li></ol>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>RL</category>
      
      <category>DRL-王树森</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.1 随机排列</title>
    <link href="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/3-1-Random-Permutation/"/>
    <url>/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/3-1-Random-Permutation/</url>
    
    <content type="html"><![CDATA[<h1 id="random-permutation随机排列">Random Permutation（随机排列）</h1><p>What is uniform random permutation?</p><h2 id="fisher-yates-洗牌算法">Fisher-Yates 洗牌算法</h2><p>排列数等于n!</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/3-1-Random-Permutation/5ee370a88aadf06f3d80c94cb32e0342.png"></p><p>“uniform randompermutation”（均匀随机排列）是指生成一个排列，其中每个可能的排列都以相等的概率出现。具体来说，对于含有n个元素的集合，它的所有n!个排列中的每一个都有相同的概率被选中。</p><p>实现均匀随机排列的一种简单方法是 Fisher-Yates洗牌算法。该算法基于迭代，从最后一个元素开始，每次随机选择当前位置及之前的一个位置，并将它们的元素交换。通过不断重复这个过程，最终得到一个均匀随机排列。</p><p>这种排列方法在各种应用中都很有用，例如在随机化算法、模拟实验和密码学中。在实际应用中，均匀随机排列通常要求具有良好的随机性质，以确保生成的排列满足统计学上的随机性要求。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/3-1-Random-Permutation/cde60544fcaa6ad0ee23f46ab4cece6f.png"></p><h2 id="fisher-yates-shuffle">Fisher-Yates Shuffle</h2><p>Fisher-YatesShuffle，又称为洗牌算法，是一种用于随机排列数组元素的有效且简单的算法。其目标是生成一个均匀随机的排列，即每个元素在排列中出现的概率相等。下面是Fisher-YatesShuffle的详细步骤：</p><ol type="1"><li><strong>初始化：</strong>算法开始时，数组中的元素按照其原始顺序排列。</li><li><strong>迭代：</strong>从数组的最后一个元素开始，依次向前迭代到第一个元素。</li><li><strong>随机选择：</strong>对于当前迭代的位置（假设为i），生成一个[0, i]范围内的随机整数 j。</li><li><strong>交换元素：</strong>将当前位置（i）的元素与随机选择位置（j）的元素进行交换。</li><li><strong>递减迭代：</strong>继续迭代，减小当前位置，直到第一个元素。</li></ol><p>通过这个过程，每个元素都有机会被选择到任何一个位置，而且每个位置被选择的概率是相等的。因此，经过足够的迭代次数后，数组中的元素将被洗牌成一个均匀随机的排列。</p><p>Fisher-YatesShuffle是一种简单而强大的洗牌算法，广泛应用于计算机科学领域，尤其在实现随机算法、模拟实验和游戏开发等方面。</p><p>以下是使用Python实现Fisher-Yates Shuffle的简单代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fisher_yates_shuffle</span>(<span class="hljs-params">arr</span>):<br>    <span class="hljs-comment"># 从最后一个元素开始迭代</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(arr) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-comment"># 生成随机索引，范围是 [0, i]</span><br>        j = random.randint(<span class="hljs-number">0</span>, i)<br><br>        <span class="hljs-comment"># 交换当前位置的元素与随机选择位置的元素</span><br>        arr[i], arr[j] = arr[j], arr[i]<br><br><span class="hljs-comment"># 示例用法</span><br>my_array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>fisher_yates_shuffle(my_array)<br><span class="hljs-built_in">print</span>(my_array)<br></code></pre></td></tr></table></figure><p>这段代码使用了Python的 <code>random</code> 模块中的<code>randint</code> 函数来生成随机整数。通过调用<code>fisher_yates_shuffle</code> 函数，可以对任意数组进行Fisher-YatesShuffle。在示例用法中，数组 <code>[1, 2, 3, 4, 5]</code>被洗牌，打印结果可能是类似 <code>[3, 5, 1, 4, 2]</code> 的随机排列。</p><p><code>range(len(arr) - 1, 0, -1)</code> 是一个用于生成迭代索引的Python 内置函数 <code>range</code>的调用。具体来说，这个函数的参数是起始值、结束值和步长。</p><ul><li><code>len(arr) - 1</code>:这是起始值，表示从数组的最后一个元素开始。</li><li><code>0</code>: 这是结束值（不包含在范围内），表示索引递减至0。</li><li><code>-1</code>: 这是步长，表示递减的步长为 1。</li></ul><p>因此， <code>range(len(arr) - 1, 0, -1)</code>生成了一个逆序的索引序列，从数组的最后一个元素开始递减到第一个元素。这个逆序的索引序列用于在Fisher-Yates Shuffle算法中迭代数组的位置。在每次迭代中，会随机选择一个之前的位置，并与当前位置的元素交换，从而完成洗牌的过程。</p><p>Fisher-Yates Shuffle 的时间复杂度是 O(n)，其中 n是数组的长度。这是因为算法需要对数组中的每个元素进行一次迭代，并在每次迭代中进行一次交换。</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>RL</category>
      
      <category>DRL-王树森</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.1 蒙特卡洛估计</title>
    <link href="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/2-1-%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E4%BC%B0%E8%AE%A1/"/>
    <url>/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/2-1-%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E4%BC%B0%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="chatgpt对蒙特卡洛方法的介绍">ChatGPT对蒙特卡洛方法的介绍</h1><p>蒙特卡洛方法是一类基于随机抽样和统计学原理的数值计算方法，其核心思想是通过随机抽样来近似解决问题。这种方法在强化学习、优化问题、概率估计等领域都有广泛的应用。以下是关于蒙特卡洛方法的一些基本概念：</p><ol type="1"><li>基本思想<ul><li><strong>随机抽样：</strong>蒙特卡洛方法利用随机抽样的方式来近似计算某个问题的数值解。通过大量的随机样本，可以得到对问题的概率分布、期望值等进行估计的结果。</li></ul></li><li>应用领域<ul><li><strong>强化学习：</strong>在强化学习中，蒙特卡洛方法用于估计状态值、动作值，以及计算策略的期望回报。通过采样多条轨迹，可以近似地计算期望值。</li><li><strong>数值积分：</strong>蒙特卡洛方法可以用于估计复杂函数的积分值。通过在函数定义域内随机采样，计算函数值的平均值，可以得到积分的近似值。</li><li><strong>概率估计：</strong>蒙特卡洛方法在概率估计中也有应用，例如通过采样估计随机变量的期望、方差等统计量。</li></ul></li><li>算法步骤<ol type="1"><li><strong>随机抽样：</strong>根据问题的特性，通过随机抽样生成一系列样本点。</li><li><strong>计算统计量：</strong>对每个样本点进行计算，得到需要估计的统计量，例如期望值、方差等。</li><li><strong>平均估计：</strong>对所有样本点计算的统计量进行平均，得到最终的近似解。</li></ol></li><li>优缺点<ul><li><strong>优点：</strong>蒙特卡洛方法是一种通用的数值计算方法，对于复杂问题具有很强的适应性。它不依赖于问题的具体形式，而是通过随机抽样来逼近解。</li><li><strong>缺点：</strong>收敛速度相对较慢，特别是在维度较高的问题中，需要大量的样本才能获得准确的估计。同时，对于一些问题，可能存在抽样偏差。</li></ul></li></ol><p>总体而言，蒙特卡洛方法是一种强大的数值计算工具，尤其在面对复杂、高维度的问题时显示出其优越性。</p><p>蒙特卡洛(Monte Carlo) 是一大类随机算法(randomized algorithms)的总称，它们通过随机样本来估算真实值。本节用几个例子讲解蒙特卡洛算法。</p><h1 id="例一近似pi值">例一：近似<span class="math inline">\(\pi\)</span>值</h1><p>我们都知道圆周率<span class="math inline">\(\pi\)</span>约等于3.1415927。现在假装我们不知道<span class="math inline">\(\pi\)</span>,而是要想办法近似估算<span class="math inline">\(\pi\)</span>值。假设我们有一个 (伪)随机数生成器，我们能不能用随机样本来近似<span class="math inline">\(\pi\)</span>呢？这一小节讨论使用蒙特卡洛如何近似<span class="math inline">\(\pi\)</span>值。</p><p>假设我们有一个 (伪) 随机数生成器，可以均匀生成 -1 到 +1之间的数。每次生成两个随机数，一个作为<span class="math inline">\(x\)</span>,另一个作为<span class="math inline">\(y\)</span>。于是每次生成了一个平面坐标系中的点<span class="math inline">\((x,y)\)</span>, 见图 2.3(左)。因为<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>都是在 ([-1,1])区间上均匀分布，所以这个正方形内的点被抽到的概率是相同的。我们重复抽样<span class="math inline">\(n\)</span>次，得到了<span class="math inline">\(n\)</span>个正方形内的点。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/2-1-%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E4%BC%B0%E8%AE%A1/b5c4792d8e806dea2de245eb613c8f50.png"></p><p>如图2.3(右)所示，蓝色正方形里面包含一个绿色的圆，圆心是(0,0),半径等于1。刚才随机生成的<span class="math inline">\(n\)</span>个点有些落在圆外面，有些落在圆里面。</p><p>请问一个点落在圆里面的概率有多大呢？由于抽样是均匀的，因此这个概率显然是圆的面积与正方形面积的比值。正方形的面积是边长的平方，即<span class="math inline">\(a_1=2^2=4\)</span>。圆的面积是<span class="math inline">\(\pi \times1^2=\pi\)</span>。那么一个点落在圆里面的概率就是<span class="math inline">\(p=\frac{a_2}{a_1}=\frac{\pi}{4}\)</span>。</p><p>设我们随机抽样了<span class="math inline">\(n\)</span>个点，设圆内的点的数量为随机变量<span class="math inline">\(M\)</span>。显然，<span class="math inline">\(M\)</span>的期望等于<span class="math inline">\(\mathbb{E}[M]=pn=\frac{\pi n}{4}\)</span>。</p><p>注意，这只是期望，并不是实际发生的结果。如果你抽<span class="math inline">\(n=5\)</span>个点，那么期望有<span class="math inline">\(\mathbb{E}[M]=\frac{5\pi}{4}\)</span>个点落在圆内。但实际观测值<span class="math inline">\(m\)</span>可能等于 0、1、2、3、4、5中的任何一个。</p><p>给定一个点的坐标<span class="math inline">\((x,y)\)</span>,如何判断该点是否在圆内呢？已知圆心在原点，半径等于1,我们用一下圆的方程。如果<span class="math inline">\((x,y)\)</span>满足：<span class="math inline">\(x^2+y^2\leq1\)</span>,则说明<span class="math inline">\((x,y)\)</span>落在圆里面；反之，点就在圆外面。</p><p>我们均匀随机抽样得到<span class="math inline">\(n\)</span>个点，通过圆的方程对每个点做判别，发现有<span class="math inline">\(m\)</span>个点落在圆里面。如果<span class="math inline">\(n\)</span>非常大，那么随机变量<span class="math inline">\(M\)</span>的真实观测值<span class="math inline">\(m\)</span>就会非常接近期望<span class="math inline">\(\mathbb{E}[M]=\frac{\pi n}{4}\)</span>:</p><p><span class="math inline">\(m \approx \frac{\pi n}{4}.\)</span></p><p>由此得到：</p><p><span class="math inline">\(\pi \approx \frac{4m}{n}.\)</span></p><p>我们可以依据这个公式做编程实现。下面是伪代码：</p><ol type="1"><li>初始化<span class="math inline">\(m=0\)</span>。用户指定样本数量<span class="math inline">\(n\)</span>的大小。<span class="math inline">\(n\)</span>越大，精度越高，但是计算量越大。</li><li>把下面的步骤重复<span class="math inline">\(n\)</span>次：(a).从区间 ([-1,1]) 上做两次均匀随机抽样得到实数<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>。(b). 如果<span class="math inline">\(x^2+y^2\leq1\)</span>, 那么<span class="math inline">\(m \leftarrow m+1\)</span>。</li><li>返回<span class="math inline">\(\frac{4m}{n}\)</span>作为对<span class="math inline">\(\pi\)</span>的估计。</li></ol><p>大数定律保证了蒙特卡洛的正确性：当<span class="math inline">\(n\)</span>趋于无穷，<span class="math inline">\(\frac{4m}{n}\)</span>趋于<span class="math inline">\(\pi\)</span>。其实还能进一步用概率不等式分析误差的上界。比如使用Bernstein 不等式，可以证明出下面结论：</p><p><span class="math inline">\(\left\|\frac{4m}{n}-\pi\right\|=O\left(\frac{1}{\sqrt{n}}\right).\)</span></p><p>这个不等式说明<span class="math inline">\(\frac{4m}{n}\)</span>(即对<span class="math inline">\(\pi\)</span>的估计) 会收敛到<span class="math inline">\(\pi\)</span>, 收敛率是<span class="math inline">\(\frac{1}{\sqrt{n}}\)</span>。然而这个收敛率并不快：样本数量<span class="math inline">\(n\)</span>增加一万倍，精度才能提高一百倍。</p><h1 id="例二估算阴影部分面积">例二：估算阴影部分面积</h1><p>图2.4中有正方形、圆、扇形，几个形状相交。请估算阴影部分面积。这个问题常见于初中数学竞赛。假如你不会微积分，也不会几何技巧，你是否有办法近似估算阴影部分面积呢？用蒙特卡洛可以很容易解决这个问题。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/2-1-%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E4%BC%B0%E8%AE%A1/1733135856255-36277529-c6c9-4205-ad78-21f6c177226b.png"></p><p>图 2.5 中绿色圆的圆心是 (1,1), 半径等于 1;蓝色扇形的圆心是(0,0)、半径等于2。目的点<span class="math inline">\((x,y)\)</span>在绿色的圆中，而不在蓝色的扇形中。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/2-1-%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E4%BC%B0%E8%AE%A1/4743c4dfdc896695524ef4a49289d47b.png"></p><p>利用圆的方程可以判定点<span class="math inline">\((x,y)\)</span>是否在绿色圆里面。如果<span class="math inline">\((x,y)\)</span>满足方程<span class="math inline">\((x-1)^2+(y-1)^2\leq1\)</span>,</p><p>则说明<span class="math inline">\((x,y)\)</span>在绿色圆里面。</p><p>利用扇形的方程可以判定点<span class="math inline">\((x,y)\)</span>是否在蓝色扇形外面。如果点<span class="math inline">\((x,y)\)</span>满足方程</p><p><span class="math inline">\(x^2+y^2&gt;4\)</span>,</p><p>则说明<span class="math inline">\((x,y)\)</span>在蓝色扇形外面。</p><p>如果一个点同时满足方程 (2.1)和(2.2),那么这个点一定在阴影区域内。从<span class="math inline">\([0,2]\times [0,2]\)</span>这个正方形中做随机抽样，得到<span class="math inline">\(n\)</span>个点。然后用两个方程筛选落在阴影部分的点。</p><p>我们在正方形<span class="math inline">\([0,2] \times[0,2]\)</span>中随机均匀抽样，得到的点有一定概率会落在阴影部分。我们来计算这个概率。正方形的边长等于2，所以面积<span class="math inline">\(a_1=4\)</span>。设阴影部分面积为<span class="math inline">\(a_2\)</span>。那么点落在阴影部分概率是</p><p><span class="math inline">\(p=\frac{a_2}{a_1}=\frac{a_2}{4}\)</span>。</p><p>我们从正方形中随机抽<span class="math inline">\(n\)</span>个点，设有<span class="math inline">\(M\)</span>个点落在阴影部分内(<span class="math inline">\(M\)</span>是个随机变量)。每个点落在阴影部分的概率是<span class="math inline">\(p\)</span>,所以<span class="math inline">\(M\)</span>的期望等于<span class="math inline">\(\mathbb{E}[M]=np=\frac{na_2}{4}\)</span>。</p><p>用方程 (2.1)和 (2.2) 对<span class="math inline">\(n\)</span>个点做筛选，发现实际上有<span class="math inline">\(m\)</span>个点落在阴影部分内 (<span class="math inline">\(m\)</span>是随机变量<span class="math inline">\(M\)</span>的观测值)。如果<span class="math inline">\(n\)</span>很大，那么<span class="math inline">\(m\)</span>会比较接近期望<span class="math inline">\(\mathbb{E}[M]=\frac{na_2}{4}\)</span>, 即<span class="math inline">\(m \approx \frac{na_2}{4}\)</span>。</p><p>也即<span class="math inline">\(a_2 \approx\frac{4m}{n}\)</span>。</p><p>这个公式就是对阴影部分面积的估计。我们依据这个公式做编程实现。下面是伪代码：</p><ol type="1"><li>初始化<span class="math inline">\(m=0\)</span>。用户指定样本数量<span class="math inline">\(n\)</span>的大小。<span class="math inline">\(n\)</span>越大，精度越高，但是计算量越大。</li><li>把下面的步骤重复<span class="math inline">\(n\)</span>次：(a).从区间<span class="math inline">\([0,2]\)</span>上均匀随机抽样得到<span class="math inline">\(x\)</span>; 再做一次均匀随机抽样，得到<span class="math inline">\(y\)</span>。(b). 如果<span class="math inline">\((x-1)^2+(y-1)^2\leq1\)</span>和<span class="math inline">\(x^2+y^2&gt;4\)</span>两个不等式都成立，那么让<span class="math inline">\(m \leftarrow m+1\)</span>。</li><li>返回<span class="math inline">\(\frac{4m}{n}\)</span>作为对阴影部分面积的估计。</li></ol><h1 id="例三近似定积分">例三：近似定积分</h1><p>近似求积分是蒙特卡洛最重要的应用之一，在科学和工程中有广泛的应用。举个例子，给定一个函数：</p><p><span class="math inline">\(f(x)=\frac{1}{1+(\sin x)\cdot(\lnx)^2},\)</span></p><p>要求计算<span class="math inline">\(f\)</span>在区间 0.8 到 3上的定积分：</p><p><span class="math inline">\(I=\int_{0.8}^{3}f(x)dx.\)</span></p><p>有很多科学和工程问题需要计算定积分，而函数<span class="math inline">\(f(x)\)</span>可能很复杂，求定积分会很困难，甚至有可能不存在解析解。如果求解析解很困难，或者解析解不存在，则可以用蒙特卡洛近似计算数值解。</p><p><strong>一元函数的定积分</strong>是相对比较简单的问题。一元函数的意思是变量<span class="math inline">\(x\)</span>是个标量。给定一元函数<span class="math inline">\(f(x)\)</span>, 求函数在<span class="math inline">\(a\)</span>到<span class="math inline">\(b\)</span>区间上的定积分：</p><p><span class="math inline">\(I=\int_{a}^{b}f(x)dx.\)</span></p><p>蒙特卡洛方法通过下面的步骤近似定积分：</p><ol type="1"><li>在区间<span class="math inline">\([a,b]\)</span>上做随机抽样，得到<span class="math inline">\(n\)</span>个样本，记作：<span class="math inline">\(x_1,\cdots,x_n\)</span>。样本数量<span class="math inline">\(n\)</span>由用户自己定，<span class="math inline">\(n\)</span>越大，计算量越大，近似越准确。</li><li>对函数值<span class="math inline">\(f(x_1),\cdots,f(x_n)\)</span>求平均，再乘以区间长度<span class="math inline">\(b-a\)</span>:</li></ol><p><span class="math inline">\(q_n=(b-a)\cdot\frac{1}{n}\sum_{i=1}^{n}f(x_i).\)</span></p><ol start="3" type="1"><li>返回<span class="math inline">\(q_n\)</span>作为定积分<span class="math inline">\(I\)</span>的估计值。</li></ol><p><strong>多元函数的定积分</strong> 要复杂一些。设<span class="math inline">\(f:\mathbb{R}^d\mapsto\mathbb{R}\)</span>是一个多元函数，变量<span class="math inline">\(x\)</span>是<span class="math inline">\(d\)</span>维向量。要求计算<span class="math inline">\(f\)</span>在集合<span class="math inline">\(\Omega\)</span>上的定积分：</p><p><span class="math inline">\(I=\int_{\Omega}f(\boldsymbol{x})d\boldsymbol{x}.\)</span></p><p>蒙特卡洛方法通过下面的步骤近似定积分：</p><ol type="1"><li>在集合<span class="math inline">\(\Omega\)</span>上做均匀随机抽样，得到<span class="math inline">\(n\)</span>个样本，记作向量<span class="math inline">\(x_1,\cdots,x_n\)</span>。样本数量<span class="math inline">\(n\)</span>由用户自己定，<span class="math inline">\(n\)</span>越大，计算量越大，近似越准确。</li><li>计算集合<span class="math inline">\(\Omega\)</span>的体积：<span class="math inline">\(v=\int_{\Omega}d\boldsymbol{x}.\)</span></li><li>对函数值<span class="math inline">\(f(x_1),\cdots,f(x_n)\)</span>求平均，再乘以<span class="math inline">\(\Omega\)</span>的体积<span class="math inline">\(v\)</span>:</li></ol><p><span class="math inline">\(q_n=v\cdot\frac{1}{n}\sum_{i=1}^{n}f(x_i).\)</span>(2.3)</p><ol start="4" type="1"><li>返回<span class="math inline">\(q_n\)</span>作为定积分<span class="math inline">\(I\)</span>的估计值。</li></ol><p>注意，算法第二步需要求<span class="math inline">\(\Omega\)</span>的体积。如果<span class="math inline">\(\Omega\)</span>是长方体、球体等规则形状，那么可以解析地算出体积<span class="math inline">\(v\)</span>。可是如果<span class="math inline">\(\Omega\)</span>是不规则形状，那么就需要定积分求<span class="math inline">\(\Omega\)</span>的体积<span class="math inline">\(v\)</span>,这是比较困难的。可以用类似于上一小节“求阴影部分面积”的方法近似计算体积<span class="math inline">\(v\)</span>。</p><p>举例讲解多元函数的蒙特卡洛积分：这个例子中被积分的函数是二元函数：</p><p><span class="math inline">\(f(x,y)=\left\{\begin{array}{ll}1,&amp;\text{if}x^2+y^2\leq1;\\0,&amp;\text{otherwise}.\end{array}\right.\)</span>(2.4)</p><p>直观地说，如果点<span class="math inline">\((x,y)\)</span>落在右图的绿色圆内，那么函数值就是1; 否则函数值就是 0。定义集合<span class="math inline">\(\Omega=[-1,1]\times[-1,1]\)</span>,即右图中蓝色的正方形，它的面积是<span class="math inline">\(v=4\)</span>。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/2-1-%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E4%BC%B0%E8%AE%A1/1733136459845-bbf7be59-ef0e-451a-aed7-b19052789cd7.png"></p><p>定积分<span class="math inline">\(I=\int_{\Omega}f(x,y)dxdy\)</span></p><p>等于多少呢？很显然，定积分等于圆的面积，即<span class="math inline">\(\pi \cdot 1^2=\pi\)</span>。因此，定积分<span class="math inline">\(I=\pi\)</span>。用蒙特卡洛求出<span class="math inline">\(I\)</span>,就得到了<span class="math inline">\(\pi\)</span>。从集合<span class="math inline">\(\Omega=[-1,1]\times[-1,1]\)</span>上均匀随机抽样<span class="math inline">\(n\)</span>个点，记作<span class="math inline">\((x_1,y_1),\cdots,(x_n,y_n)\)</span>。应用公式(2.3),可得</p><p><span class="math inline">\(q_n=v\cdot\frac{1}{n}\sum_{i=1}^{n}f(x_i,y_i)=\frac{4}{n}\sum_{i=1}^{n}f(x_i,y_i).\)</span>(2.5)</p><p>把<span class="math inline">\(q_n\)</span>作为对定积分<span class="math inline">\(I=\pi\)</span>的近似。这与前面近似<span class="math inline">\(\pi\)</span>的算法完全相同，区别在于此处的算法是从另一个角度推导出的。</p><h1 id="例四近似期望">例四：近似期望</h1><p>蒙特卡洛还可以用来近似期望，这在整本书中会反复应用。设<span class="math inline">\(X\)</span>是<span class="math inline">\(d\)</span>维随机变量，它的取值范围是集合<span class="math inline">\(\Omega \subset \mathbb{R}^d\)</span>。函数<span class="math inline">\(p(x)\)</span>是<span class="math inline">\(X\)</span>的概率密度函数。设<span class="math inline">\(f:\Omega \mapsto\mathbb{R}\)</span>是任意的多元函数，它关于变量<span class="math inline">\(X\)</span>的期望是：</p><p><span class="math inline">\(\mathbb{E}_{X\simp(\cdot)}\Big[f(X)\Big]=\int_{\Omega}p(x)\cdot f(x)d x.\)</span></p><p>由于期望是定积分，所以可以按照上一小节的方法，用蒙特卡洛求定积分。上一小节在集合<span class="math inline">\(\Omega\)</span>上做均匀抽样，用得到的样本近似上面公式中的定积分。</p><p>下面介绍一种更好的算法。既然我们知道概率密度函数<span class="math inline">\(p(x)\)</span>, 我们最好是按照<span class="math inline">\(p(x)\)</span>做非均匀抽样，而不是均匀抽样。按照<span class="math inline">\(p(x)\)</span>做非均匀抽样，可以比均匀抽样有更快的收敛。具体步骤如下：</p><ol type="1"><li>按照概率密度函数<span class="math inline">\(p(x)\)</span>,在集合<span class="math inline">\(\Omega\)</span>上做非均匀随机抽样，得到<span class="math inline">\(n\)</span>个样本，记作向量<span class="math inline">\(x_1,\cdots,x_n \simp(\cdot)\)</span>。样本数量<span class="math inline">\(n\)</span>由用户自己定，<span class="math inline">\(n\)</span>越大，计算量越大；近似越准确。</li><li>对函数值<span class="math inline">\(f(x_1),\cdots,f(x_n)\)</span>求平均：</li></ol><p><span class="math inline">\(q_n=\frac{1}{n}\sum_{i=1}^{n}f(x_i).\)</span></p><ol start="3" type="1"><li>返回<span class="math inline">\(q_n\)</span>作为期望<span class="math inline">\(\mathbb{E}_{X\simp(\cdot)}\Big[f(X)\Big]\)</span>的估计值。</li></ol><p>注 如果按照上述方式做编程实现，需要储存函数值<span class="math inline">\(f(x_1),\cdots,f(x_n)\)</span>。但用如下的方式做编程实现，可以减小内存开销。初始化<span class="math inline">\(q_0=0\)</span>。从<span class="math inline">\(t=1\)</span>到<span class="math inline">\(n\)</span>,依次计算</p><p><span class="math inline">\(q_t=(1-\frac{1}{t})\cdotq_{t-1}+\frac{1}{t}\cdot f(x_t).\)</span>(2.6)</p><p>不难证明，这样得到的<span class="math inline">\(q_n\)</span>等于<span class="math inline">\(\frac{1}{n}\sum_{i=1}^{n}f(x_i)\)</span>。这样无需存储所有的<span class="math inline">\(f(x_1),\cdots,f(x_n)\)</span>。可以进一步把公式(2.6)中的<span class="math inline">\(\frac{1}{t}\)</span>替换成<span class="math inline">\(\alpha_t\)</span>,得到公式：</p><p><span class="math inline">\(q_t=(1-\alpha_t)\cdotq_{t-1}+\alpha_t\cdot f(x_t).\)</span></p><p>这个公式叫做 Robbins-Monro 算法，其中<span class="math inline">\(\alpha_n\)</span>称为学习步长或学习率。只要<span class="math inline">\(\alpha_t\)</span>满足下面的性质，就能保证算法的正确性：</p><p><span class="math inline">\(\lim_{n\to\infty}\sum_{t=1}^{n}\alpha_t=\infty\)</span>和<span class="math inline">\(\lim_{n\to\infty}\sum_{t=1}^{n}\alpha_t^2&lt;\infty.\)</span></p><p>显然，<span class="math inline">\(\alpha_t=\frac{1}{t}\)</span>满足上述性质。Robbins-Monro算法可以应用在 Q 学习算法中。</p><h1 id="例五随机梯度">例五：随机梯度</h1><p>我们可以用蒙特卡洛近似期望来理解随机梯度算法。</p><p>设随机变量<span class="math inline">\(X\)</span>为一个数据样本，令<span class="math inline">\(w\)</span>为神经网络的参数。设<span class="math inline">\(p(x)\)</span>为随机变量<span class="math inline">\(X\)</span>的概率密度函数。定义损失函数<span class="math inline">\(L(X;w)\)</span>。它的值越小，意味着模型做出的预测越准确；反之，它的值越大，则意味着模型做出的预测越差。因此，我们希望调整神经网络的参数<span class="math inline">\(w\)</span>,使得损失函数的期望尽量小。神经网络的训练可以定义为这样的优化问题：</p><p><span class="math inline">\(\min_{\boldsymbol{w}}\mathbb{E}_{X\simp(\cdot)}\Big[L(X;\boldsymbol{w})\Big].\)</span></p><p>目标函数<span class="math inline">\(\mathbb{E}_X[L(X;\boldsymbol{w})]\)</span>关于<span class="math inline">\(\boldsymbol{w}\)</span>的梯度是：</p><p><span class="math inline">\(\boldsymbol{g} \triangleq\nabla_{\boldsymbol{w}}\mathbb{E}_{X\simp(\cdot)}\Big[L(X;\boldsymbol{w})\Big]=\mathbb{E}_{X\simp(\cdot)}\Big[\nabla_{\boldsymbol{w}}L(X;\boldsymbol{w})\Big].\)</span>(2.7)</p><p>可以做梯度下降更新<span class="math inline">\(\boldsymbol{w}\)</span>, 以减小目标函数<span class="math inline">\(\mathbb{E}_X[L(X;\boldsymbol{w})]\)</span>:</p><p><span class="math inline">\(\boldsymbol{w} \leftarrow \boldsymbol{w}- \alpha \cdot \boldsymbol{g}.\)</span></p><p>此处的<span class="math inline">\(\alpha\)</span>被称作学习率(learning rate)。直接计算梯度<span class="math inline">\(\boldsymbol{g}\)</span>通常会比较慢。为了加速计算，可以对期望</p><p><span class="math inline">\(\boldsymbol{g}=\mathbb{E}_{X\simp(\cdot)}\Big[\nabla_{\boldsymbol{w}}L(X;\boldsymbol{w})\Big]\)</span></p><p>做蒙特卡洛近似，把得到的近似梯度<span class="math inline">\(\tilde{\boldsymbol{g}}\)</span>称作随机梯度(stochastic gradient), 用<span class="math inline">\(\tilde{\boldsymbol{g}}\)</span>代替<span class="math inline">\(\boldsymbol{g}\)</span>来更新<span class="math inline">\(\boldsymbol{w}\)</span>。</p><ol type="1"><li>根据概率密度函数<span class="math inline">\(p(x)\)</span>做随机抽样，得到<span class="math inline">\(B\)</span>个样本，记作<span class="math inline">\(\tilde{x}_1,\ldots,\tilde{x}_B\)</span>。</li><li>计算梯度<span class="math inline">\(\nabla_{\boldsymbol{w}}L(\tilde{x}_j;\boldsymbol{w}),\forall j=1,\ldots,B\)</span>。对它们求平均：</li></ol><p><span class="math inline">\(\tilde{\boldsymbol{g}}:=\frac{1}{B}\sum_{j=1}^{B}\nabla_{\boldsymbol{w}}L(\tilde{x}_j;\boldsymbol{w}).\)</span></p><p>我们称<span class="math inline">\(\tilde{\boldsymbol{g}}\)</span>为<strong>随机梯度</strong>。因为<span class="math inline">\(\mathbb{E}[\tilde{\boldsymbol{g}}]=\boldsymbol{g}\)</span>,它是<span class="math inline">\(\boldsymbol{g}\)</span>的一个无偏估计。</p><ol start="3" type="1"><li>做随机梯度下降更新<span class="math inline">\(\boldsymbol{w}\)</span>:</li></ol><p><span class="math inline">\(\boldsymbol{w} \leftarrow \boldsymbol{w}- \alpha \cdot \tilde{\boldsymbol{g}}.\)</span></p><p>样本数量<span class="math inline">\(B\)</span>称作批量大小 (batchsize), 通常是一个比较小的正整数，比如 1、8、16、32。所以我们称之为<strong>最小批 (mini-batch) SGD</strong>。</p><p>在实际应用中，样本真实的概率密度函数<span class="math inline">\(p(x)\)</span>一般是未知的。在训练神经网络的时候，我们通常会收集一个训练数据集<span class="math inline">\(\mathcal{X}=\{x_1,\cdots,x_n\}\)</span>,并求解这样一个经验风险最小化 (empirical risk minimization) 问题：</p><p><span class="math inline">\(\min_{\boldsymbol{w}}\frac{1}{n}\sum_{i=1}^{n}L(\boldsymbol{x}_i;\boldsymbol{w}).\)</span>(2.8)</p><p>这相当于我们用下面这个概率质量函数代替真实的<span class="math inline">\(p(x)\)</span>:</p><p><span class="math inline">\(p(x) =\begin{cases}\frac{1}{n}, &amp; \text{如果 } x \in \mathcal{X}; \\0, &amp; \text{如果 } x \notin \mathcal{X}.\end{cases}\)</span></p><p>公式的意思是随机变量<span class="math inline">\(X\)</span>的取值是<span class="math inline">\(n\)</span>个数据点中的一个，概率都是<span class="math inline">\(\frac{1}{n}\)</span>。那么最小批 SGD的每一轮都从集合<span class="math inline">\(\{x_1,\cdots,x_n\}\)</span>中均匀随机抽取<span class="math inline">\(B\)</span>个样本，计算随机梯度，更新模型参数<span class="math inline">\(\boldsymbol{w}\)</span>。</p><h1 id="总结">总结</h1><p>本文详细讲解了蒙特卡洛的应用。其中最重要的知识点是蒙特卡洛近似期望：设<span class="math inline">\(X\)</span>是随机变量，<span class="math inline">\(x\)</span>是观测值，蒙特卡洛用<span class="math inline">\(f(x)\)</span>近似期望<span class="math inline">\(\mathbb{E}[f(X)]\)</span>。强化学习中的 Q学习、SARSA、策略梯度等算法都需要这样用蒙特卡洛近似期望。</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>RL</category>
      
      <category>DRL-王树森</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.5 ALPHAGO</title>
    <link href="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/"/>
    <url>/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/</url>
    
    <content type="html"><![CDATA[<p>围棋游戏介绍</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733122092352-f6e13ed7-09d6-4188-837a-6e2f22fbc16a.png"></p><h1 id="high-level-ideas">High level Ideas</h1><p>训练包含3步：</p><ol type="1"><li>用behavior cloning初始化策略网络</li><li>用策略梯度训练策略网络</li><li>策略网络训练完之后，用它来训练价值网络。</li></ol><h2 id="behavior-cloning">Behavior Cloning</h2><h3 id="chatgpt介绍什么是behavior-cloning">ChatGPT介绍什么是Behaviorcloning：</h3><p>Behaviorcloning（行为克隆）是一种强化学习中的学习方法，其中一个模型（通常是神经网络）被训练来模仿从专家或经验数据中收集的行为，而不是通过试错和奖励信号的方式学习。</p><p>具体来说，Behavior Cloning 的步骤通常包括：</p><ol type="1"><li><strong>数据收集：</strong>从一个经验丰富的策略（通常是人类专家）中收集行为数据。这些数据包括状态和相应的行为。</li><li><strong>模型训练：</strong>使用这些收集到的专家数据来训练一个模型，通常是一个神经网络。模型的目标是学习输入状态与相应的动作之间的映射，以最大程度地模仿专家的行为。</li><li><strong>评估和部署：</strong>对训练好的模型进行评估，看它在模仿专家行为方面的表现。如果表现良好，可以将该模型部署到实际环境中，让它执行相似的任务。</li></ol><h3 id="behavior-cloning-1">Behavior Cloning</h3><p>Behavior Cloning的优势在于它可以通过直接模仿专家的行为，快速学习复杂的任务，而不需要通过强化学习中的奖励信号进行调整。然而，它的局限性在于如果专家的行为在某些情况下是不完美的，模型也会模仿这些不完美的行为。此外，对于某些复杂的任务，仅仅通过行为克隆可能无法获得鲁棒且高效的策略。</p><h2 id="蒙特卡洛树搜索">蒙特卡洛树搜索</h2><p>执行（真正和人下棋）的时候：用策略网络和价值网络进行蒙特卡洛树搜索（MCTS）</p><h3 id="cahtgpt介绍什么是mcts">CahtGPT介绍什么是MCTS：</h3><p>蒙特卡洛树搜索（Monte Carlo TreeSearch，MCTS）是一种用于决策树搜索的概率模型，主要用于解决不确定性和部分可观察性问题。它最初是为解决棋类游戏的人工智能问题而提出的，但后来被扩展应用到各种领域。</p><p>MCTS的核心思想是通过模拟随机采样的方式来估计每个决策节点的值，从而构建一个搜索树，帮助在决策时找到最优的路径。整个搜索过程包括以下四个阶段：</p><ol type="1"><li><strong>选择（Selection）：</strong>从树的根节点开始，根据一定的策略选择一个节点，直到达到一个未被完全扩展的节点。</li><li><strong>扩展（Expansion）：</strong>对于选择的节点，根据可行的动作扩展一层节点，选择一个未被访问的子节点。</li><li><strong>模拟（Simulation）：</strong>从扩展的节点开始，使用随机策略或启发式方法模拟若干步，直到达到某个终止状态，得到一个模拟的结果。</li><li><strong>反向传播（Backpropagation）：</strong>将模拟结果反向传播到选择的路径上的所有节点，更新它们的统计信息（例如，访问次数和累积奖励），以帮助更好地估计节点的价值。</li></ol><p>这四个阶段不断迭代执行，直到分配给搜索的计算时间达到预定的限制。最终，根据节点的统计信息选择一个最有希望的决策。</p><p>MCTS 的一个典型应用是在棋类游戏中，如AlphaGo就使用了变种的 MCTS算法。然而，MCTS 也可以应用于其他领域，如规划问题和决策问题。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733122496590-7c53504c-8501-4f5f-8d4e-4b96a3e4c1cc.png"></p><h2 id="alphago-zero的状态"><font style="color:rgb(77, 77, 77);">AlphaGozero的状态</font></h2><p><font style="color:rgb(77, 77, 77);">19 x 19 x 17 stack</font></p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733122536989-fcca24af-d85a-4c8b-9fbc-232d9354e197.png"></p><p>AlphaGo 2016 版本使用 19 × 19 × 48 的张量 (tensor)表示一个状态。AlphaGo Zero 使用 19 × 19 × 17的张量表示一个状态。本书只解释后者；见图 18.1。下面解释 19 × 19 × 17的状态张量的意义。</p><ul><li>张量每个切片(slice)是 19×19 的矩阵，对应 19 × 19 的棋盘。一个 19×19的矩阵可以表示棋盘上所有黑子的位置。如果一个位置上有黑子，矩阵对应的元素就是1,否则就是 0。同样的道理，用一个 19×19 的矩阵来表示当前棋盘上所有白子的位置。</li><li>张量中一共有 17 个这样的矩阵；17 是这样得来的。记录最近8步棋盘上黑子的位置，需要 8 个矩阵。同理，还需要 8个矩阵记录白子的位置。还另外需要一个矩阵表示该哪一方下棋；如果该下黑子，那么该矩阵元素全部等于1；如果该下白子，那么该矩阵的元素全都等于0。</li></ul><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733122761265-81b27c27-7dfa-42d4-9a8e-0223a7980ef9.png"></p><p>策略网络<span class="math inline">\(\pi(a|s;\boldsymbol{\theta})\)</span>的结构如图18.2 所示。策略网络的输入是 19 × 19 × 17 的状态 s 。 策略网络的输出是361 维的向量 f , 它的每个元素对应一个动作(即在棋盘上一个位置放棋子)。向量 f 所有元素都是正数，而且相加等于1。</p><p>AlphaGo 还有一个价值网络<span class="math inline">\(v(s;w)\)</span>,它是对状态价值函数<span class="math inline">\(V_\pi(s)\)</span>的近似。价值网络的结构如图 18.3所示。价值网络的输入是 19× 19× 17 的状态 s。价值网络的输出是一个实数，它的大小评价当前状态 s 的好坏</p><p>策略网络和价值的输入相同，都是状态 s。它们都用多个卷积层把 s映射到特征向量。因此可以让策略网络和价值网络共用卷积层。训练策略网络和价值网络的方法在之后解释。</p><h2 id="initialize-policy-network-by-behavior-cloning">Initialize PolicyNetwork by Behavior Cloning</h2><p>从人的记录中学习</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733123168117-7f8f4d70-03de-4cc1-ae16-118e7f3ade5c.png"></p><p>用到的是behaviorcloning，这不是强化学习，这是模仿学习。模仿学习没有reward。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733123416559-2c244024-c94b-4ba4-a7b9-7c78b22248e1.png"></p><p>用棋盘上的动作来看behaviorcloning：就是多分类（361个分类，具体指的是下在棋盘的哪个位置），把人类玩家的动作看作是groundtruth（真实的标签）</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733123482029-b1a7610a-35dd-46ef-86a8-67d308e48e31.png"></p><p>但是behavior cloning存在缺陷，它的效果不如强化学习。</p><p>下面是ChatGPT给出的答案：</p><p>是的，行为克隆（BehaviorCloning）虽然在某些情境下表现得很好，但也存在一些缺陷和限制：</p><ol type="1"><li><strong>数据分布偏差：</strong>行为克隆是基于专家示范数据的学习方法，如果专家示范的数据不能充分覆盖所有可能的情况，模型在未见过的情况下可能表现不佳。模型只能复制示范的行为，而不一定能够泛化到未知情况。</li><li><strong>错误传递：</strong>如果专家示范中存在错误的决策或不良策略，行为克隆模型也会学到这些错误。模型无法纠正示范数据中的错误，而是简单地复制了这些错误的决策。</li><li><strong>缺乏探索：</strong>行为克隆不具备主动探索新的策略的能力。它仅仅复制了专家的行为，而无法在未知环境中进行探索和发现更好的策略。</li><li><strong>分布变化敏感：</strong>如果环境的分布发生变化，行为克隆模型可能会失效。它对训练时的数据分布敏感，而无法适应新的分布。</li><li><strong>缺乏理解：</strong>行为克隆模型通常是一个黑盒，无法理解其内部决策过程。这在需要解释和理解模型行为的场景中可能是一个问题。</li><li><strong>需要大量专家示范数据：</strong>在某些情况下，行为克隆需要大量的专家示范数据才能学到鲁棒的模型。这可能对于一些复杂任务来说是一个挑战，因为获取专家示范数据可能很昂贵或困难。</li></ol><p>为了解决这些问题，研究者们提出了许多改进方法，如结合强化学习和自我对弈来引入探索、使用逆强化学习来更好地理解任务目标等。在实际应用中，选择合适的学习方法取决于具体问题的特性和需求。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733123697170-9a9cef05-cb15-44c7-9c23-b3cf751c85c8.png"></p><h2 id="train-policy-network-using-policy-gradient">Train Policy NetworkUsing Policy Gradient</h2><p>具体怎么用强化学习来训练策略网络呢？AlphaGo让两个策略网络进行博弈，一个叫做Player，另一个叫做Opponent。</p><p>Player是agent，它是由策略网络来控制的，用的是策略网络最新的模型参数（每下完一局围棋把胜负作为奖励，靠奖励来更新player的参数）</p><p>Opponent相当于environment，它负责陪玩（player下一步棋，opponent跟着下一步），它也是用策略网络来控制的，但是opponent的参数无需学习，随机从旧的策略网络的参数中随机选择一个即可。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733123885302-ccb59f3b-6e07-4248-9d6e-399be3d00311.png"></p><p>让“玩家”和“对手”博弈，将一局游戏进行到底，假设走了<span class="math inline">\(n\)</span>步。游戏没结束的时候，奖励全都是零：<span class="math inline">\(r_1 = r_2 = \cdots = r_{n-1} = 0\)</span>.</p><p>游戏结束的时候，如果“玩家”赢了，奖励是<span class="math inline">\(r_n= +1\)</span>，那么所有的回报都是 +1:<span class="math inline">\(u_1 =u_2 = \cdots = u_n = +1\)</span>.</p><p>如果“玩家”输了，奖励是<span class="math inline">\(r_n =-1\)</span>，那么所有的回报都是 -1:<span class="math inline">\(u_1 = u_2= \cdots = u_n = -1\)</span>.</p><p>所有<span class="math inline">\(n\)</span>步都用同样的回报，这相当于不区分哪一步棋走得好，哪一步走得烂；只要赢了，每一步都被视为“好棋”, 假如输了，每一步都被看成“臭棋”。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733123986612-7353bfeb-3860-4610-bdda-18f32a61642a.png"></p><p>回顾策略梯度：策略梯度是状态价值函数<span class="math inline">\(V\)</span>关于<span class="math inline">\(\theta\)</span>的导数</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733124014380-6ac87f63-62a5-48ba-976f-932a6fa6dd78.png"></p><p>两个策略网络玩游戏到终局，得到每个时刻的回报return，然后用近似策略梯度更新策略网络。</p><p>这里只更新策略网络player的参数，无需更新策略网络opponent的参数。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733124096680-565c66db-63e4-4c4b-8214-11c3f455daa5.png"></p><p>策略网络的方法还不够好，需要用到后面的蒙特卡洛树搜索。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733124241034-4ffb9182-f48e-42f0-881e-9f89924b618d.png"></p><p>为了介绍蒙特卡洛树搜索，先介绍价值网络。</p><h2 id="train-the-value-network">Train the Value Network</h2><p>这里的价值网络是对状态价值函数<span class="math inline">\(V\)</span>的近似，不是<span class="math inline">\(Q\)</span>的近似</p><p>用神经网络近似状态价值函数，用来评估当前形势的好坏，胜算有多大。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733124303703-d7f87ab8-d272-4955-86c1-670dc247fbe3.png"></p><p>AlphaGo Zero中让策略网络<span class="math inline">\(\pi\)</span>和价值网络<span class="math inline">\(v\)</span>共享前面的卷积层。</p><p>策略网络的输出是361个概率值，每个值代表一个动作。策略网络的输出说明下一步该如何走动。</p><p>价值网络的输出是1个标量，是对当前状态<span class="math inline">\(s\)</span>的打分，反映出当前状态的胜算有多大。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733124405946-902e1d04-7e5b-4c4c-9a78-bd60e380c157.png"></p><p>策略网络和价值网络是分别训练的，不是同时训练的。首先训练策略网络<span class="math inline">\(\pi\)</span>，然后训练价值网络<span class="math inline">\(v\)</span>。后者需要前者的帮助。这不算actor-critic方法，因为ac方法是同时训练策略网络和价值网络。</p><p>价值网络是这样训练的：让两个策略网络博弈，每下完一局，更新一次价值网络。价值网络的学习是一个回归问题，让预测值<span class="math inline">\(v\)</span>和观测值<span class="math inline">\(u_t\)</span>尽可能接近，用随机梯度下降更新价值网络的参数。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733124957443-ffae2865-d79a-4170-b666-de7a85fa22f5.png"></p><h2 id="monte-carlo-tree-searchmcst">Monte Carlo Tree Search(MCST)</h2><p>之前训练策略网络和价值网络的目的是帮助蒙特卡洛树搜索</p><p>回忆一下高手下围棋，需要向前看好多步，看看各种可能的结果，然后做决策。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733125115904-1045855a-1ab3-4663-98d7-e3b5e5497fa0.png"></p><p>搜索未来可能发生的状态，从中选出一个胜算最大的。</p><p>蒙特卡洛树搜索的主要思想：选择一个动作<span class="math inline">\(a\)</span>（按照动作的好坏程度选择，基于策略函数排除不好的动作），然后让策略网络自我博弈一直到游戏结束，看是否胜利，然后根据胜负和价值函数两个因素来给动作<span class="math inline">\(a\)</span>打分。重复上述过程很多次，所以每个动作都有很多分数，选择一个分数最高的动作。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733125143034-b79a4a24-22bb-4e6b-b172-4f3211106648.png"></p><p>蒙特卡洛树搜索有如下4步：selection，expansion，evaluation，backup</p><p>AlphaGo每下一个棋子，都要把这四步重复很多次。</p><ol type="1"><li>selection：player执行动作a，这是假想动作，不会实际执行。</li><li>expansion：opponent也执行一个动作，此时状态更新。这里也是假想动作。使用策略网络作为假想对手，不是真正的实际的对手。</li><li>evaluation：给上述选择的动作a打分，分数有两部分构成：一是价值网络的打分v，另一个是游戏的结果（策略网络自我博弈到游戏结束）获得奖励r。两者的平均值作为分数。</li><li>backup：反向传播，用上述打分来更新动作的分数。</li></ol><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733127734885-ee76b526-bdcd-4f77-84e3-08603fbe2bc0.png"></p><h3 id="第一步选择selection">第一步——选择(Selection)</h3><p>观测棋盘上当前的格局，找出所有空位，然后判断其中哪些位置符合围棋规则；每个符合规则的位置对应一个可行的动作。每一步至少有几十、甚至上百个可行的动作；假如挨个搜索和评估所有可行动作，计算量会大到无法承受。虽然有几十、上百个可行动作，好在只有少数几个动作有较高的胜算。第一步——选择——的目的就是找出胜算较高的动作，只搜索这些好的动作，忽略掉其他的动作。</p><p>如何判断动作<span class="math inline">\(a\)</span>的好坏呢？有两个指标：第一，动作<span class="math inline">\(a\)</span>的胜率；第二，策略网络给动作<span class="math inline">\(a\)</span>的评分（概率值）。用下面这个分值评价<span class="math inline">\(a\)</span>的好坏：</p><p><span class="math inline">\(\mathrm{score}(a) \triangleq Q(a) +\frac{\eta}{1+N(a)} \cdot \pi(a|s;\boldsymbol{\theta}).\quad{(18.1)}\)</span></p><p>此处的<span class="math inline">\(\eta\)</span>是个需要调的超参数。公式中的<span class="math inline">\(N(a)\)</span>、<span class="math inline">\(Q(a)\)</span>的定义如下：</p><p>+<span class="math inline">\(N(a)\)</span>是动作<span class="math inline">\(a\)</span>已经被访问过的次数。初始的时候，对于所有的<span class="math inline">\(a\)</span>,令<span class="math inline">\(N(a)\gets 0\)</span>。动作<span class="math inline">\(a\)</span>每被选中一次，我们就把<span class="math inline">\(N(a)\)</span>加一：<span class="math inline">\(N(a) \gets N(a) + 1\)</span>。 +<span class="math inline">\(Q(a)\)</span>是之前<span class="math inline">\(N(a)\)</span>次模拟算出来的动作价值，主要由胜率和价值函数决定。<span class="math inline">\(Q(a)\)</span>的初始值是 0; 动作<span class="math inline">\(a\)</span>每被选中一次，就会更新一次<span class="math inline">\(Q(a)\)</span>；后面会详解。</p><p>可以这样理解公式 (18.1):</p><ul><li>如果动作<span class="math inline">\(a\)</span>还没被选中过，那么<span class="math inline">\(Q(a)\)</span>和<span class="math inline">\(N(a)\)</span>都等于零，因此可得<span class="math inline">\(\operatorname{score}(a) \propto\pi(a|s;\boldsymbol{\theta}),\)</span>也就是说完全由策略网络评价动作<span class="math inline">\(a\)</span>的好坏。</li><li>如果动作<span class="math inline">\(a\)</span>已经被选中过很多次，那么<span class="math inline">\(N(a)\)</span>就很大，导致策略网络在<span class="math inline">\(\operatorname{score}(a)\)</span>中的权重降低。当<span class="math inline">\(N(a)\)</span>很大的时候，有<span class="math inline">\(\operatorname{score}(a) \approxQ(a),\)</span>此时主要基于<span class="math inline">\(Q(a)\)</span>判断<span class="math inline">\(a\)</span>的好坏，而策略网络已经无关紧要。</li><li>系数<span class="math inline">\(\frac{1}{1+N(a)}\)</span>的另一个作用是鼓励探索，也就是让被选中次数少的动作有更多的机会被选中。假如两个动作有相近的<span class="math inline">\(Q\)</span>分数和<span class="math inline">\(\pi\)</span>分数，那么被选中次数少的动作的<span class="math inline">\(\operatorname{score}\)</span>会更高。</li></ul><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733130349731-608a91d1-3179-4c1f-9149-11481b1ade28.png"></p><p>MCTS 根据公式 (18.1) 算出所有动作的分数<span class="math inline">\(\operatorname{score}(a), \forall a\)</span>。MCTS选择分数最高的动作。图18.4 的例子中有3个可行动作，分数分别为0.4、0.3、0.5。第三个动作分数最高，会被选中，这一轮模拟会执行这个动作。(只是在模拟中执行而已，不是AlphaGo 真的走一步棋)。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733130359339-30e1e4eb-d9d1-4161-a6b6-881b35dc5599.png"></p><h3 id="第二步扩展-expansion">第二步——扩展 (Expansion)</h3><p>把第一步选中的动作记作<span class="math inline">\(a_t\)</span>，它只是个假想的动作，只在“模拟器”中执行，而不是AlphaGo 真正执行的动作。</p><p>AlphaGo 需要考虑这样一个问题：假如它执行动作<span class="math inline">\(a_t\)</span>，那么对手会执行什么动作呢？对手肯定不会把自己的想法告诉AlphaGo, 那么 AlphaGo 只能自己猜测对手的动作。AlphaGo 可以“推已及人”:如果 AlphaGo 认为几个动作很好，对手也会这么认为。所以 AlphaGo用策略网络模拟对手， 根据策略网络随机抽样一个动作：<span class="math inline">\(a_t&#39; \sim \pi(\cdot|s_t&#39;;\boldsymbol{\theta})\)</span>.</p><p>此处的状态<span class="math inline">\(s&#39;\)</span>是站在对手的角度观测到的棋盘上的格局，动作<span class="math inline">\(a_t&#39;\)</span>是 (假想) 对手选择的动作。</p><p>图 18.5 的例子中对手有四种可行动作，AlphaGo用策略网络算出每个动作的概率值，然后根据概率值随机抽样一个对手的动作，记作<span class="math inline">\(a_t&#39;\)</span>。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733130369357-69dd4530-4e0d-43fc-a40b-740f8410052b.png"></p><p>假设根据概率值 0.1,0.3,0.2, 0.4 做随机抽样，选中第二种动作；见图18.6。从 AlphaGo 的角度来看，对手的动作就是AlphaGo 新的状态。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733130390456-2c790d49-1bd5-4a41-8b57-f476bba3e6e6.png"></p><p>AlphaGo需要在模拟中跟对手将一局游戏进行下去，所以需要一个模拟器(即环境)。在模拟器中，AlphaGo每执行一个动作<span class="math inline">\(a_k\)</span>，模拟器就会返回一个新的状态<span class="math inline">\(s_{k+1}\)</span>。想要搭建一个好的模拟器，关键在于使用正确的状态转移函数<span class="math inline">\(p(s_{k+1}|s_k,a_k);\)</span>。如果状态转移函数与事实偏离太远，那么用模拟器做MCTS 是毫无意义的。</p><p>AlphaGo 模拟器利用了围棋游戏的对称性：AlphaGo的策略，在对手看来是状态转移函数；对手的策略，在 AlphaGo看来是状态转移函数。最理想的情况下，模拟器的状态转移函数是对手的真实策略；然而AlphaGo 并不知道对手的真实策略。AlphaGo 退而求其次，用 AlphaGo自己训练出的策略网络<span class="math inline">\(\pi\)</span>代替对手的策略，作为模拟器的状态转移函数。</p><p>想要用 MCTS做决策，必须要有模拟器，而搭建模拟器的关键在于构造正确的状态转移函数<span class="math inline">\(p(s_{k+1}|s_k,a_k)\)</span>。从搭建模拟器的角度来看，围棋是非常简单的问题：由于围棋的对称性，可以用策略网络作为状态转移函数。但是对于大多数的实际问题，构造状态转移函数是非常困难的。比如机器人、无人车等应用，状态转移的构造需要物理模型，要考虑到力、运动、以及外部世界的干扰。如果物理模型不够准确，导致状态转移函数偏离事实太远，那么MCTS 的模拟结果就不可靠。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733130412531-447db396-ad87-43a1-ba86-a194aad31cf4.png"></p><h3 id="第三步一一求值-evaluation">第三步一一求值 (Evaluation)</h3><p>从状态<span class="math inline">\(s_{t+1}\)</span>开始，双方都用策略网络<span class="math inline">\(\pi\)</span>做决策，在模拟器中交替落子，直到分出胜负；见图18.7。AlphaGo 基于状态<span class="math inline">\(s_k\)</span>，根据策略网络抽样得到动作</p><p><span class="math inline">\(a_k \sim\pi(\cdot|s_k;\boldsymbol{\theta})\)</span>.</p><p>对手基于状态<span class="math inline">\(s_k&#39;\)</span>（从对手角度观测到的棋盘上的格局）,根据策略网络抽样得到动作</p><p><span class="math inline">\(a_k&#39; \sim\pi(\cdot|s_k&#39;;\boldsymbol{\theta})\)</span>.</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733130463388-82373845-cbad-46b5-a09f-8781db9b585f.png"></p><p>当这局游戏结束时，可以观测到奖励。如果 AlphaGo 胜利，则<span class="math inline">\(r=+1\)</span>，否则<span class="math inline">\(r=-1\)</span>。</p><p>回顾一下，棋盘上真实的状态是<span class="math inline">\(s_t\)</span>，AlphaGo 在模拟器中执行动作<span class="math inline">\(a_t\)</span>，然后模拟器中的对手执行动作<span class="math inline">\(a_t&#39;\)</span>，带来新的状态<span class="math inline">\(s_{t+1}\)</span>。状态<span class="math inline">\(s_{t+1}\)</span>越好，则这局游戏胜算越大。</p><ul><li>如果 AlphaGo 赢得这局模拟<span class="math inline">\((r=+1)\)</span>，则说明<span class="math inline">\(s_{t+1}\)</span>可能很好；如果输了<span class="math inline">\((r=-1)\)</span>，以反映出<span class="math inline">\(s_{t+1}\)</span>的好坏。</li><li>此外，还可以用价值网络<span class="math inline">\(v\)</span>评价状态<span class="math inline">\(s_{t+1}\)</span>的好坏。价值<span class="math inline">\(v(s_{t+1};w)\)</span>越大，则说明状态<span class="math inline">\(s_{t+1}\)</span>越好。</li></ul><p>奖励<span class="math inline">\(r\)</span>是模拟获得的胜负，是对<span class="math inline">\(s_{t+1}\)</span>很可靠的评价，但是随机性太大。价值网络的评估<span class="math inline">\(v(s_{t+1};w)\)</span>没有<span class="math inline">\(r\)</span>可靠，但是价值网络更稳定、随机性小。AlphaGo 的解决方案是把奖励<span class="math inline">\(r\)</span>与价值网络的输出<span class="math inline">\(v(s_{t+1};w)\)</span>取平均，记作：<span class="math inline">\(V(s_{t+1}) \triangleq \frac{r +v(s_{t+1};w)}{2},\)</span></p><p>把它记录下来，作为对状态<span class="math inline">\(s_{t+1}\)</span>的评价。</p><p>实际实现的时候，AlphaGo还训练了一个更小的神经网络，它做决策更快。MCTS在第一步和第二步用大的策略网络，第三步用小的策略网络。读者可能好奇，为什么在且仅在第三步用小的策略网络呢？第三步两个策略网络交替落子，通常要走一两百步，导致第三步成为MCTS 的瓶颈。用小的策略网络代替大的策略网络，可以大幅加速 MCTS。</p><p>自己和对方交替做决策下棋的过程称为fast rollout。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733130533506-b6a9ef30-2409-4fa1-8598-ece3b9226d29.png"></p><p>除了用奖励<span class="math inline">\(r\)</span>来评价状态<span class="math inline">\(s_{t+1}\)</span>,AlphaGo还用价值网络<span class="math inline">\(v\)</span>来评价状态<span class="math inline">\(s_{t+1}\)</span></p><p>两者取平均，作为<span class="math inline">\(s_{t+1}\)</span>的分数。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733130551144-a13751f1-6aa7-4001-8800-b4f118dbd3a3.png"></p><h3 id="第四步一一回溯-backup">第四步一一回溯 (Backup)</h3><p>第三步一一求值——算出了第<span class="math inline">\(t+1\)</span>步某一个状态的价值，记作<span class="math inline">\(V(s_{t+1})\)</span>；每一次模拟都会得出这样一个价值，并且记录下来。模拟会重复很多次，于是第<span class="math inline">\(t+1\)</span>步每一种状态下面可以有多条记录；如图18.8 所示。第<span class="math inline">\(t\)</span>步的动作<span class="math inline">\(a_t\)</span>下面有多个可能的状态(子节点),每个状态下面有若干条记录。把<span class="math inline">\(a_t\)</span>下面所有的记录取平均，记作价值<span class="math inline">\(Q(a_t)\)</span>,它可以反映出动作<span class="math inline">\(a_t\)</span>的好坏。</p><p>在图 18.8 中，<span class="math inline">\(a_t\)</span>下面一共有 12条记录，<span class="math inline">\(Q(a_t)\)</span>是 12条记录的均值。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733130576870-15863743-16e0-4a1d-bd75-16e76f98a188.png"></p><p>给定棋盘上的真实状态<span class="math inline">\(s_t\)</span>,有多个动作<span class="math inline">\(a\)</span>可供选择。对于所有的<span class="math inline">\(a\)</span>,价值<span class="math inline">\(Q(a)\)</span>的初始值是零。动作<span class="math inline">\(a\)</span>每被选中一次 (成为<span class="math inline">\(a_t\)</span>),它下面就会多一条记录，我们就对<span class="math inline">\(Q(a)\)</span>做一次更新。</p><p>回顾第一步——选择 (Selection): 基于棋盘上真实的状态<span class="math inline">\(s_t\)</span>, MCTS需要从可行的动作中选出一个，作为<span class="math inline">\(a_t\)</span>。MCTS 计算每一个动作<span class="math inline">\(a\)</span>的分数：<span class="math inline">\(\mathrm{score}(a) \triangleq Q(a) +\frac{\eta}{1+N(a)} \cdot \pi(a|s;\boldsymbol{\theta}), \quad \foralla,\)</span></p><p>然后选择分数最高的<span class="math inline">\(a\)</span>。MCTS算出的<span class="math inline">\(Q(a)\)</span>的用途就是这里。</p><p>第四步：</p><p>MCTS会重复上述模拟很多次，所以每个状态下都有很多条记录，每个动作<span class="math inline">\(a_t\)</span>下面有很多子节点，所以<span class="math inline">\(a_t\)</span>对应很多记录，将<span class="math inline">\(a_t\)</span>下面的所有记录做平均作为<span class="math inline">\(a_t\)</span>新的价值<span class="math inline">\(Q(a_t)\)</span>。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733130656963-4b282a74-cd83-43ec-b817-709acf00ef23.png"></p><h3 id="decision-making-after-mcts">Decision Making after MCTS</h3><p>MCTS 的决策</p><p>上面讲解了单次模拟的四个步骤，注意，这只是单次模拟而已。MCTS想要真正做出一个决策 (即往真正的棋盘上落一个棋子),需要做成千上万次模拟。在做了无数次模拟之后，MCTS 做出真正的决策：</p><p><span class="math inline">\(a_t = \operatorname{argmax}_aN(a).\)</span></p><p>此时 AlphaGo 才会真正往棋盘上放一个棋子。</p><p>为什么要依据<span class="math inline">\(N(a)\)</span>来做决策呢？在每一次模拟中，MCTS找出所有可行的动作<span class="math inline">\(\{a\}\)</span>计算它们的分数<span class="math inline">\(\operatorname{score}(a)\)</span>,然后选择其中分数最高的动作，然后在模拟器里执行。如果某个动作<span class="math inline">\(a\)</span>在模拟中胜率很大，那么它的价值<span class="math inline">\(Q(a)\)</span>就会很大，它的分数<span class="math inline">\(\operatorname{score}(a)\)</span>会很高：于是它被选中的几率就大。也就是说如果某个动作<span class="math inline">\(a\)</span>很好，它被选中的次数<span class="math inline">\(N(a)\)</span>就会大。</p><p>观测到棋盘上当前状态<span class="math inline">\(s_t\)</span>, MCTS做成千上万次模拟，记录每个动作<span class="math inline">\(a\)</span>被选中的次数<span class="math inline">\(N(a)\)</span>,最终做出决策<span class="math inline">\(a_t = \operatorname{argmax}_aN(a)\)</span>。到了下一时刻，状态变成了<span class="math inline">\(s_{t+1}\)</span>, MCTS 把所有动作<span class="math inline">\(a\)</span>的<span class="math inline">\(Q(a)\)</span>、<span class="math inline">\(N(a)\)</span>全都初始化为零，然后从头开始做模拟，而不能利用上一次的结果。</p><p>AlphaGo 下棋非常“暴力”每走一步棋之前，它先在“脑海里”模拟几千、几万局、它可以预知它每一种动作带来的后果，对手最有可能做出的反应都在AlphaGo 的算计之内。由于计算量差距悬殊，人类面对 AlphaGo时不太可能有胜算。这样的比赛对人来说是不公平的；假如李世石下每一颗棋子之前，先跟柯洁模拟一千局，或许李世石的胜算会大于AlphaGo。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733130752228-209ee0e7-e39e-4c23-8e89-4f6b930908bc.png"></p><h3 id="mcts-summary">MCTS: Summary</h3><p>MCTS 4步：</p><p>第一，selection，根据动作的分数，选出分数最高的动作。</p><p>第二，expansion，用策略网络来模拟对手的动作，产生新的状态。</p><p>第三，evaluation，通过自我博弈和价值网络这两个途径算出两个分数，记录它们的平均值。</p><p>第四，backup，用第三步算出来的分数来更新这个动作的分数。</p><p>AlphaGo每走一步，都要进行成千上万次模拟。每次模拟都要重复以上四步。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733130891555-b108e708-121b-4a9b-9545-0d0bec4965c6.png"></p><h2 id="summary">Summary</h2><p>AlphaGo的训练分三步：</p><p>第一步：用behaviorcloning初步训练一个策略网络，这一步训练用的是16万局游戏的棋谱，让策略网络来模仿人类玩家的动作。这一步之后策略网络可以打败业余玩家。</p><p>第二步：用策略梯度进一步训练策略网络，AlphaGo让策略网络做自我博弈，用游戏胜负这个信息来更新策略网络，经过这个步骤，策略网络的能力变得更强。</p><p>第三步：训练一个价值网络，用来评估状态的好坏。这一步让策略网络做自我博弈，用胜负结果作为target，让价值网络来拟合这个target。训练价值网络，实际上就是做回归（regression）。</p><p>虽然可以用策略网络来下棋，但是更好的办法是用蒙特卡洛树搜索。AlphaGo每走一步都要做成千上万次搜索，计算每一个动作的胜算有多大，给每个动作打分，最终AlphaGo会执行分数最高的动作。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733130904644-77e53fec-ebb2-4333-8449-d48bff8af9f3.png"></p><h1 id="alphago-zero">AlphaGo Zero</h1><p>AlphaGo Zero完胜AlphaGo，它俩的区别有两个：</p><ul><li>AlphaGo Zero没有做behavior cloning。</li><li>AlphaGoZero在训练策略网络的时候就用了蒙特卡洛树搜索，让策略网络来模仿搜索做出来的动作。</li></ul><p>AlphaGo是模仿人类玩家，AlphaGo Zero是模仿蒙特卡洛树搜索。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733130919135-bc604fa0-963f-42ee-87ff-1277b8be9563.png"></p><p>在围棋游戏中，人类经验(behavior cloning)是有害的（或者说 性能有限）。</p><p>但是behaviorcloning还是有用的尤其是物理世界的实体，比如手术机器人、无人驾驶汽车。先学习人类经验再做强化学习。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733131079632-0ae0523e-7802-4b2e-89cc-fa5f9ab6bf2f.png"></p><p>AlphaGo Zero是如何训练策略网络的：使用MCTS。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-5-ALPHAGO/1733131200190-b8a7c3e2-516a-40b2-bd06-0ae32cd42fa2.png"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>RL</category>
      
      <category>DRL-王树森</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.4 Actor-Critic Method</title>
    <link href="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-4-Actor-Critic-Method/"/>
    <url>/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-4-Actor-Critic-Method/</url>
    
    <content type="html"><![CDATA[<p>Actor-Critic方法把价值学习和策略学习结合起来。</p><h1 id="value-network-and-policy-network">Value Network and PolicyNetwork</h1><p>离散状态下状态价值函数可以写成：</p><p><span class="math inline">\(V_{\pi}(s) = \sum_{a} \pi(a|s) \cdotQ_{\pi}(s,a).\)</span></p><p>但是其中策略函数<span class="math inline">\(\pi(a|s)\)</span>和动作价值函数<span class="math inline">\(Q_{\pi}(s,a)\)</span>都不知道，可以分别用两个神经网络进行近似，这两个神经网络分别称为策略网络和价值网络，在表述形式上里面分别添加了一个<span class="math inline">\(\theta\)</span>和<span class="math inline">\(w\)</span>参数，表示的是神经网络的参数。</p><p>策略网络控制agent运动，是actor，相当于是运动员；价值网络不控制agent运动，它负责给agent打分，是critic，相当于裁判。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-4-Actor-Critic-Method/357ab1b7876184230ebc401afea086e2.png"></p><p>分别看一下这两个神经网络</p><h2 id="策略网络actor">策略网络actor</h2><p>策略网络actor，它只有一个输入state，输出是所有action的概率分布。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-4-Actor-Critic-Method/ab4ce18b88d15879c28c88521cc23026.png"></p><h2 id="价值网络critic">价值网络critic</h2><p>价值网络critic，有两个输入，分别是state和action；输出是一个标量，表示的是对actor的打分。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-4-Actor-Critic-Method/dcab05ee32d8fd26d0829cd28943f4b3.png"></p><p>同时学习一个策略和一个值函数就是actor-critic方法。</p><h2 id="train-the-neural-networks">Train the Neural Networks</h2><p>训练<span class="math inline">\(\pi\)</span>网络是提高actor的平均分，即让状态价值函数V函数的值更大；让价值网络q来当裁判，给actor的表现打分，更新它的参数<span class="math inline">\(w\)</span>是为了让它打分越来越精准。通过两个网络，让运动员的得分越来越高，裁判的打分越来越精准。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-4-Actor-Critic-Method/79373a6cc0977b9519bccdc95d004948.png"></p><ul><li>通过以下五个步骤来对<span class="math inline">\(\theta\)</span>和<span class="math inline">\(w\)</span>参数进行更新</li></ul><ol type="1"><li>Observe the state<span class="math inline">\(s_t\)</span>.</li><li>Randomly sample action<span class="math inline">\(\alpha_t\)</span>according to<span class="math inline">\(\pi(\cdot|s_t; \theta_t)\)</span>.</li><li>Perform<span class="math inline">\(a_t\)</span>and observe newstate<span class="math inline">\(s_{t+1}\)</span>and reward<span class="math inline">\(r_t\)</span>.</li><li>Update<span class="math inline">\(w\)</span>(in value network) usingtemporal difference (TD).</li><li>Update<span class="math inline">\(\theta\)</span>(in policy network)using policy gradient.</li></ol><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-4-Actor-Critic-Method/c4f09abd96d25ef0d054f54ddea0a703.png"></p><h2 id="update-value-network-q-using-td">Update value network q usingTD</h2><p>使用时间差分TD算法更新价值网络q，让裁判打分更准</p><p>损失函数是预测q和target<span class="math inline">\(y_t\)</span>之间差的平方</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-4-Actor-Critic-Method/f752868b84e9554039c20d217c52b74b.png"></p><ul><li>使用策略梯度算法更新策略网络<span class="math inline">\(\pi\)</span>，让运动员得分更高</li><li>下图中的V是状态价值函数，相当于运动员所有动作的平均分</li><li>策略梯度是状态价值函数V关于<span class="math inline">\(\theta\)</span>的导数</li><li>定义g是<span class="math inline">\(\log \pi\)</span>对<span class="math inline">\(\theta\)</span>的导数乘以q，这里q是裁判的打分</li><li>策略梯度等于对函数g求期望，消掉动作A。</li><li>g函数是策略梯度的无偏估计，用g函数代替策略梯度</li><li>然后使用随机梯度上升算法来更新<span class="math inline">\(\theta\)</span>的值。</li></ul><h2 id="chatgpt补充梯度的概念">ChatGPT：补充梯度的概念</h2><p>在数学和计算机科学中，梯度是一个向量，表示一个多元函数在某一点上的变化率和变化的方向。对于一个具有多个输入变量的函数，梯度给出了该函数对每个输入变量的偏导数。</p><p>考虑一个函数<span class="math inline">\(f(x_1, x_2, \ldots,x_n)\)</span>，其梯度记为<span class="math inline">\(\boldsymbol{\nabla}f\)</span>或者<span class="math inline">\(\frac{\partial f}{\partial\mathbf{x}}\)</span>，其中<span class="math inline">\(\boldsymbol{\nabla}\)</span>是 nabla符号，表示梯度运算，<span class="math inline">\(\mathbf{x} = [x_1, x_2,\ldots,x_n]\)</span>是输入变量的向量。梯度是一个向量，其每个分量是函数对相应输入变量的偏导数。</p><p><span class="math inline">\(\boldsymbol{\nabla} f = \left[\frac{\partial f}{\partial x_1}, \frac{\partial f}{\partial x_2},\ldots, \frac{\partial f}{\partial x_n} \right]\)</span></p><p>梯度的方向是函数在某一点上变化最快的方向，而梯度的模（长度）表示变化率。如果梯度的模较大，意味着函数在该点的变化较为剧烈。</p><p>在优化问题中，梯度的使用很常见。梯度下降算法就是一种基于梯度的优化方法，通过迭代更新参数，使得目标函数逐渐趋向最小值。梯度上升算法则是类似的优化方法，用于最大化目标函数。</p><p>总的来说，梯度是一个重要的数学概念，特别在优化、机器学习和深度学习等领域有广泛的应用。</p><h2 id="整个actor-critic-method的框图">整个Actor-CriticMethod的框图</h2><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-4-Actor-Critic-Method/1733107575622-b3e5250d-0863-48bd-9405-c11d59319d72.png"></p><p>整个算法的流程共有9步，这里是前5步，主要复习以下TD 目标。</p><p><span class="math inline">\(r_t + \gamma \cdot q_{t+1}\)</span>是TDtarget，时间差分算法里面的（TD目标表示了在当前时刻 t的奖励<span class="math inline">\(r_t\)</span>加上未来奖励的折扣。这个目标被用于更新值函数，通过比较当前值函数的估计和这个目标，可以调整值函数的参数以逐渐提高估计的准确性。）</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-4-Actor-Critic-Method/1733107776026-ebb01c65-b6be-4681-bf0f-3844970b84f2.png"></p><p>Actor-Critic算法流程：更新价值网络（critic）是梯度下降，更新策略网络（actor）是梯度上升。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-4-Actor-Critic-Method/1733107789868-990f159a-edee-4b7d-a9db-12cdecc2a019.png"></p><p>上面第9步中用<span class="math inline">\(q_t\)</span>更新，也可以用<span class="math inline">\(\delta_t\)</span>来更新。两种方法都是对的。</p><h2 id="summary">Summary</h2><h3 id="总结一下actor-critic方法中actor和-critic的作用">总结一下Actor-Critic方法中Actor和Critic的作用</h3><p>在训练中，agent是被策略网络控制的，价值网络打分提供反馈；训练后，agent还是被策略网络控制，但此时价值网络（critic）就没用了。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-4-Actor-Critic-Method/1733107801627-a4fccf87-3bf3-4921-a97e-cb88fa7f4113.png"></p><h3 id="怎样训练两个网络">怎样训练两个网络：</h3><p>策略网络是策略梯度来训练。用<strong>梯度上升</strong>，让状态价值函数V的值增加，这就意味着运动员的平均分提高。</p><p>价值网络是用TD算法来训练。TD算法要用到价值网络的预测<span class="math inline">\(q_t\)</span>（价值网络对期望回报的估计）以及TDtarget（也是对期望回报的估计，由于它用到真实的奖励<span class="math inline">\(r_t\)</span>,所以它的估计比<span class="math inline">\(q_t\)</span>更靠谱，<span class="math inline">\(y_t\)</span>作为TDtarget，相当于监督学习中的标签），对损失函数关于价值网络函数的参数<span class="math inline">\(w\)</span>求导得到梯度，然后用<strong>梯度下降</strong>，让估计<span class="math inline">\(q_t\)</span>更接近TD target 也就是<span class="math inline">\(y_t\)</span>。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-4-Actor-Critic-Method/1733113503811-82b20e6d-854f-48ca-9f66-2a13d1ce6803.png"></p><h3 id="为什么用损失函数对w求导chatgpt的回答">为什么用损失函数对<span class="math inline">\(w\)</span>求导？ChatGPT的回答：</h3><p>在机器学习中，使用损失函数对模型参数（例如权重<span class="math inline">\(w\)</span>）求导的目的是通过梯度下降或其他优化算法来更新模型参数，以最小化或最大化损失函数。这是因为损失函数衡量了模型在训练数据上的性能，我们的目标是使模型在训练数据上表现得越好越好。</p><p>考虑一个典型的机器学习问题，其中我们有输入特征 (X) 和对应的目标变量(Y)，我们的模型通过一些参数 (w) 进行参数化，表示为<span class="math inline">\(Y = f(X; w)\)</span>。我们的目标是找到最优的参数(w)，使得模型预测的 (Y) 与真实的目标 (Y) 之间的差距最小。</p><p>这个差距通常通过损失函数（也叫目标函数）来定义，表示为<span class="math inline">\(L(Y, f(X;w))\)</span>。梯度下降的思想是沿着损失函数下降最快的方向更新参数，直至找到使损失最小化的参数。</p><p>为了更新参数，我们需要计算损失函数关于参数 (w)的梯度（导数）。梯度是一个向量，其中每个分量表示损失函数关于相应参数的偏导数。通过梯度下降，我们按照梯度的反方向更新参数，使得损失函数逐渐减小。</p><p>具体来说，对于参数 (w)，我们使用链式法则计算损失函数关于 (w)的梯度，并使用这个梯度来更新(w)。这个过程反复进行，直到达到停止条件（例如达到最大迭代次数或梯度变化很小）。</p><p>总之，使用损失函数对参数 (w)求导的目的是优化模型，使其在训练数据上的性能达到最优。</p><h1 id="书">书</h1><p>策略梯度方法用策略梯度<span class="math inline">\(\boldsymbol{\nabla}_{\boldsymbol{\theta}}J(\boldsymbol{\theta})\)</span>更新策略网络参数<span class="math inline">\(\boldsymbol{\theta}\)</span>,从而增大目标函数。前面推导出策略梯度<span class="math inline">\(\boldsymbol{\nabla}_{\boldsymbol{\theta}}J(\boldsymbol{\theta})\)</span>的无偏估计，即下面的随机梯度：</p><p><span class="math inline">\(\boldsymbol{g}(s,a;\boldsymbol{\theta})\triangleq Q_{\pi}(s,a) \cdot\boldsymbol{\nabla}_{\boldsymbol{\theta}}\ln\pi(a\|s;\boldsymbol{\theta}).\)</span></p><p>但是其中的动作价值函数<span class="math inline">\(Q_{\pi}\)</span>是未知的，导致无法直接计算<span class="math inline">\(\boldsymbol{g}(s,a;\boldsymbol{\theta})\)</span>。上一节的REINFORCE 用实际观测的回报近似<span class="math inline">\(Q_{\pi}\)</span>, 本节的 actor-critic方法用神经网络近似<span class="math inline">\(Q_{\pi}\)</span>。</p><h2 id="价值网络">价值网络</h2><p>Actor-critic 方法用一个神经网络近似动作价值函数<span class="math inline">\(Q_{\pi}(s,a)\)</span>, 这个神经网络叫做“价值网络",记为<span class="math inline">\(q(s,a;\boldsymbol{w})\)</span>,其中的<span class="math inline">\(\boldsymbol{w}\)</span>表示神经网络中可训练的参数。价值网络的输入是状态<span class="math inline">\(s\)</span>, 输出是每个动作的价值。动作空间<span class="math inline">\(A\)</span>中有多少种动作，那么价值网络的输出就是多少维的向量，向量每个元素对应一个动作。举个例子，动作空间是<span class="math inline">\(A=\{左，右，上\}\)</span>,</p><p><span class="math inline">\(q(s, 左; w) = 219, \quad q(s, 右; w) =-73, \quad q(s, 上; w) = 580.\)</span></p><p>神经网络的结构见图 7.2。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-4-Actor-Critic-Method/1733113794334-099e1ce6-f491-4d03-a070-25a281d5c2d0.png"></p><p>虽然价值网络<span class="math inline">\(q(s,a;\boldsymbol{w})\)</span>与之前学的 DQN有相同的结构，但是两者的意义不同，训练算法也不同。</p><ul><li>价值网络是对动作价值函数<span class="math inline">\(Q_{\pi}(s,a)\)</span>的近似。而 DQN则是对最优动作价值函数<span class="math inline">\(Q^*(s,a)\)</span>的近似。</li><li>对价值网络的训练使用的是 SARSA算法，它属于同策略，不能用经验回放。对 DQN的训练使用的是 Q学习算法，它属于异策略，可以用经验回放。</li></ul><h2 id="算法推导">算法推导</h2><p>Actor-critic 翻译成“演员一评委”方法。策略网络<span class="math inline">\(\pi(a|s;\boldsymbol{\theta})\)</span>相当于演员，它基于状态<span class="math inline">\(s\)</span>做出动作<span class="math inline">\(a\)</span>。价值网络<span class="math inline">\(q(s,a;\boldsymbol{w})\)</span>相当于评委，它给演员的表现打分，评价在状态<span class="math inline">\(s\)</span>的情况下做出动作<span class="math inline">\(a\)</span>的好坏程度。策略网络(演员)和价值网络(评委)的关系如图7.3所示。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-4-Actor-Critic-Method/1733113845596-bb4a6e86-c013-48f7-ba33-a6eb95462f00.png"></p><p>读者可能会对图 7.3 感到不解：为什么不直接把奖励<span class="math inline">\(R\)</span>反馈给策略网络 (演员),而要用价值网络(评委) 这样一个中介呢？原因是这样的：策略学习的目标函数<span class="math inline">\(J(\boldsymbol{\theta})\)</span>是回报<span class="math inline">\(U\)</span>的期望，而不是奖励<span class="math inline">\(R\)</span>的期望；注意回报<span class="math inline">\(U\)</span>和奖励<span class="math inline">\(R\)</span>的区别。虽然能观测到当前的奖励<span class="math inline">\(R\)</span>,但是它对策略网络是毫无意义的；训练策略网络(演员)需要的是回报<span class="math inline">\(U\)</span>,而不是奖励<span class="math inline">\(R\)</span>。价值网络 (评委) 能够估算出回报<span class="math inline">\(U\)</span>的期望，因此能帮助训练策略网络(演员)。</p><h3 id="训练策略网络-演员">训练策略网络 (演员)</h3><p>策略网络 (演员)想要改进自己的演技，但是演员自己不知道什么样的表演才算更好，所以需要价值网络(评委)的帮助。在演员做出动作<span class="math inline">\(a\)</span>之后，评委会打一个分数<span class="math inline">\(\hat{q} \triangleqq(s,a;\boldsymbol{w})\)</span>,并把分数反馈给演员，帮助演员做出改进。演员利用当前状态<span class="math inline">\(s\)</span>, 自己的动作<span class="math inline">\(a\)</span>, 以及评委的打分<span class="math inline">\(\hat{q}\)</span>,计算近似策略梯度，然后更新自己的参数<span class="math inline">\(\boldsymbol{\theta}\)</span>(相当于改变自己的技术)。通过这种方式，演员的表现越来越受评委的好评，于是演员的获得的评分<span class="math inline">\(\hat{q}\)</span>越来越高。</p><p>训练策略网络的基本想法是用策略梯度<span class="math inline">\(\boldsymbol{\nabla}_{\boldsymbol{\theta}}J(\boldsymbol{\theta})\)</span>的近似来更新参数<span class="math inline">\(\boldsymbol{\theta}\)</span>。之前我们推导过策略梯度的无偏估计：</p><p><span class="math inline">\(g(s,a;\theta) \triangleq Q_{\pi}(s,a)\cdot \nabla_{\theta} \ln \pi(a \mid s; \theta).\)</span></p><p>价值网络<span class="math inline">\(q(s,a;\boldsymbol{w})\)</span>是对动作价值函数<span class="math inline">\(Q_{\pi}(s,a)\)</span>的近似，所以把上面公式中的<span class="math inline">\(Q_{\pi}\)</span>替换成价值网络，得到近似策略梯度：</p><p><span class="math inline">\(\widehat{g}\left(s,a;\theta\right) \quad\triangleq \quad \underbrace{q(s,a;w)}_{\text{评委的打分}} \cdot\nabla_{\theta} \ln \pi(a \mid s; \theta).\)</span></p><p>最后做梯度上升更新策略网络的参数：</p><p><span class="math inline">\(\boldsymbol{\theta} \leftarrow\boldsymbol{\theta} + \beta \cdot\hat{\boldsymbol{g}}(s,a;\boldsymbol{\theta}).\)</span></p><p>注:用上述方式更新参数之后，会让评委打出的分数越来越高，原因是这样的。状态价值函数<span class="math inline">\(V_{\pi}(s)\)</span>可以近似成为：</p><p><span class="math inline">\(v(s; \theta) = \mathbb{E}_{A \sim\pi(\cdot | s; \theta)} \left[ q(s, A; w) \right].\)</span></p><p>因此可以将<span class="math inline">\(v(s;\boldsymbol{\theta})\)</span>看做评委打分的均值。不难证明，公式(7.11) 中定义的近似策略梯度<span class="math inline">\(\hat{\boldsymbol{g}}(s,a;\boldsymbol{\theta})\)</span>的期望等于<span class="math inline">\(v(s;\boldsymbol{\theta})\)</span>关于<span class="math inline">\(\boldsymbol{\theta}\)</span>的梯度：</p><p><span class="math inline">\(\nabla_{\theta v}(s; \theta) =\mathbb{E}_{A \sim \pi(\cdot \mid s; \theta)} \left[ \widehat{g}(s, A;\theta) \right].\)</span></p><p>因此，用公式 7.12 中的梯度上升更新<span class="math inline">\(\boldsymbol{\theta}\)</span>,会让<span class="math inline">\(v(s;\boldsymbol{\theta})\)</span>变大，也就是让评委打分的均值更高。</p><h3 id="训练价值网络评委">训练价值网络(评委)</h3><p>通过以上分析，我们不难发现上述训练策略网络(演员)的方法不是真正让演员表现更好，只是让演员更迎合评委的喜好而已。因此，评委的水平也很重要，只有当评委的打分<span class="math inline">\(\hat{q}\)</span>真正反映出动作价值<span class="math inline">\(Q_{\pi}\)</span>,演员的水平才能真正提高。初始的时候，价值网络的参数<span class="math inline">\(\boldsymbol{w}\)</span>是随机的，也就是说评委的打分是瞎猜。可以用SARSA 算法更新<span class="math inline">\(\boldsymbol{w}\)</span>,提高评委的水平。每次从环境中观测到一个奖励<span class="math inline">\(r\)</span>,把<span class="math inline">\(r\)</span>看做是真相，用<span class="math inline">\(r\)</span>来校准评委的打分<span class="math inline">\(q(s,a;\boldsymbol{w})\)</span>。</p><p>第5.1 节已经推导过 SARSA 算法，现在我们再回顾一下。在<span class="math inline">\(t\)</span>时刻，价值网络输出<span class="math inline">\(\hat{q}_t =q(s_t,a_t;\boldsymbol{w})\)</span>,</p><p>它是对动作价值函数<span class="math inline">\(Q_{\pi}(s_t,a_t)\)</span>的估计。在<span class="math inline">\(t+1\)</span>时刻，实际观测到<span class="math inline">\(r_t,s_{t+1},a_{t+1}\)</span>, 于是可以计算 TD目标</p><p><span class="math inline">\(\hat{y}_t = r_t + \gamma \cdotq(s_{t+1},a_{t+1};\boldsymbol{w})\)</span>,</p><p>它也是对动作价值函数<span class="math inline">\(Q_{\pi}(s_t,a_t)\)</span>的估计。由于<span class="math inline">\(\hat{y}_t\)</span>部分基于实际观测到的奖励<span class="math inline">\(r_t\)</span>,我们认为<span class="math inline">\(\hat{y}_t\)</span>比<span class="math inline">\(q(s_t,a_t;\boldsymbol{w})\)</span>更接近事实真相。所以把<span class="math inline">\(\hat{y}_t\)</span>固定住，鼓励<span class="math inline">\(q(s_t,a_t;\boldsymbol{w})\)</span>去接近<span class="math inline">\(\hat{y}_t\)</span>。</p><p>SARSA 算法具体这样更新价值网络参数<span class="math inline">\(\boldsymbol{w}\)</span>。定义损失函数：</p><p><span class="math inline">\(L(\boldsymbol{w}) \triangleq \frac{1}{2}[q(s_t,a_t;\boldsymbol{w}) - \hat{y}_t]^2.\)</span></p><p>设<span class="math inline">\(\hat{q}_t \triangleqq(s_t,a_t;\boldsymbol{w})\)</span>。损失函数的梯度是：</p><p><span class="math inline">\(\boldsymbol{\nabla}_{\boldsymbol{w}}L(\boldsymbol{w})= (\hat{q}_t - \hat{y}_t) \cdot\boldsymbol{\nabla}_{\boldsymbol{w}}q(s_t,a_t;\boldsymbol{w}).\)</span></p><p>做一轮梯度下降更新<span class="math inline">\(\boldsymbol{w}\)</span>:</p><p><span class="math inline">\(\boldsymbol{w} \leftarrow \boldsymbol{w}- \alpha \cdot\boldsymbol{\nabla}_{\boldsymbol{w}}L(\boldsymbol{w}).\)</span></p><p>这样更新<span class="math inline">\(\boldsymbol{w}\)</span>可以让<span class="math inline">\(q(s_t,a_t;\boldsymbol{w})\)</span>更接近<span class="math inline">\(\hat{y}_t\)</span>。可以这样理解 SARSA:用观测到的奖励<span class="math inline">\(r\)</span>来“校准”评委的打分<span class="math inline">\(q(s_t,a_t;\boldsymbol{w})\)</span>。</p><h2 id="训练流程">训练流程</h2><p>下面概括 actor-critic 训练流程。设当前策略网络参数是<span class="math inline">\(\boldsymbol{\theta}_{\text{now}}\)</span>,价值网络参数是<span class="math inline">\(\boldsymbol{w}_{\text{now}}\)</span>。</p><p>执行下面的步骤，将参数更新成<span class="math inline">\(\boldsymbol{\theta}_{\text{new}}\)</span>和<span class="math inline">\(\boldsymbol{w}_{\text{new}}\)</span>:</p><ol type="1"><li>观测到当前状态<span class="math inline">\(s_t\)</span>,根据策略网络做决策<span class="math inline">\(a_t \sim \pi(\cdot|s_t;\boldsymbol{\theta}_{\text{now}})\)</span>, 并让智能体执行动作<span class="math inline">\(a_t\)</span>。</li><li>从环境中观测到奖励<span class="math inline">\(r_t\)</span>和新的状态<span class="math inline">\(s_{t+1}\)</span>。</li><li>根据策略网络做决策<span class="math inline">\(\tilde{a}_{t+1} \sim\pi(\cdot|s_{t+1};\boldsymbol{\theta}_{\text{now}})\)</span>,但不让智能体执行动作<span class="math inline">\(\tilde{a}_{t+1}\)</span>。</li><li>让价值网络给<span class="math inline">\((s_t,a_t)\)</span>打分：<span class="math inline">\(\hat{q}_t = q(s_t, a_t;\boldsymbol{w}_{\text{now}})\)</span>和<span class="math inline">\(\hat{q}_{t+1} = q(s_{t+1}, \tilde{a}_{t+1};\boldsymbol{w}_{\text{now}})\)</span>.</li><li>计算 TD 目标和 TD 误差：<span class="math inline">\(\hat{y}_t = r_t+ \gamma \cdot \hat{q}_{t+1}\)</span>和<span class="math inline">\(\delta_t = \hat{q}_t - \hat{y}_t\)</span>.</li><li>更新价值网络：<span class="math inline">\(\boldsymbol{w}_{\text{new}} \leftarrow\boldsymbol{w}_{\text{now}} - \alpha \cdot \delta_t \cdot\boldsymbol{\nabla}_{\boldsymbol{w}}q(s_t, a_t;\boldsymbol{w}_{\text{now}})\)</span>.</li><li>更新策略网络：<span class="math inline">\(\boldsymbol{\theta}_{\text{new}} \leftarrow\boldsymbol{\theta}_{\text{now}} + \beta \cdot \hat{q}_t \cdot\boldsymbol{\nabla}_{\boldsymbol{\theta}}\ln\pi(a_t \| s_t;\boldsymbol{\theta}_{\text{now}})\)</span>.</li></ol><h2 id="用目标网络改进训练">用目标网络改进训练</h2><p>第 6.2 节讨论了 Q 学习中的自举及其危害，以及用目标网络 (targetnetwork) 缓解自举造成的偏差。SARSA算法中也存在自举一一即用价值网络自己的估值<span class="math inline">\(\hat{q}_{t+1}\)</span>去更新价值网络自己；我们同样可以用目标网络计算TD 目标，从而缓解偏差。把目标网络记作<span class="math inline">\(q(s,a;\boldsymbol{w}^-)\)</span>,它的结构与价值网络相同，但是参数不同。使用目标网络计算TD 目标，那么 actor-critic 的训练就变成了：</p><ol type="1"><li>观测到当前状态<span class="math inline">\(s_t\)</span>,根据策略网络做决策<span class="math inline">\(a_t \sim \pi(\cdot|s_t;\boldsymbol{\theta}_{\text{now}})\)</span>, 并让智能体执行动作<span class="math inline">\(a_t\)</span>.</li><li>从环境中观测到奖励<span class="math inline">\(r_t\)</span>和新的状态<span class="math inline">\(s_{t+1}\)</span>.</li><li>根据策略网络做决策<span class="math inline">\(\tilde{a}_{t+1} \sim\pi(\cdot|s_{t+1};\boldsymbol{\theta}_{\text{now}})\)</span>,但是不让智能体执行动作<span class="math inline">\(\tilde{a}_{t+1}\)</span>.</li><li>让价值网络给<span class="math inline">\((s_t,a_t)\)</span>打分：<span class="math inline">\(\hat{q}_t = q(s_t, a_t;\boldsymbol{w}_{\text{now}})\)</span>.</li><li>让目标网络给<span class="math inline">\((s_{t+1},\tilde{a}_{t+1})\)</span>打分：<span class="math inline">\(\hat{q}_{t+1}^- = q(s_{t+1}, \tilde{a}_{t+1};\boldsymbol{w}_{\text{now}}^-)\)</span>.</li><li>计算 TD 目标和 TD 误差：<span class="math inline">\(\hat{y}_t^- =r_t + \gamma \cdot \hat{q}_{t+1}^-\)</span>和<span class="math inline">\(\delta_t = \hat{q}_t - \hat{y}_t^-\)</span>.</li><li>更新价值网络：<span class="math inline">\(\boldsymbol{w}_{\text{new}} \leftarrow\boldsymbol{w}_{\text{now}} - \alpha \cdot \delta_t \cdot\boldsymbol{\nabla}_{\boldsymbol{w}}q(s_t, a_t;\boldsymbol{w}_{\text{now}})\)</span>.</li><li>更新策略网络：<span class="math inline">\(\boldsymbol{\theta}_{\text{new}} \leftarrow\boldsymbol{\theta}_{\text{now}} + \beta \cdot \hat{q}_t \cdot\boldsymbol{\nabla}_{\boldsymbol{\theta}}\ln\pi(a_t \| s_t;\boldsymbol{\theta}_{\text{now}})\)</span>.</li><li>设<span class="math inline">\(\tau \in(0,1)\)</span>是需要手动调整的超参数。做加权平均更新目标网络的参数：<span class="math inline">\(\boldsymbol{w}_{\text{new}}^- \leftarrow \tau\cdot \boldsymbol{w}_{\text{new}} + (1-\tau) \cdot\boldsymbol{w}_{\text{now}}^-\)</span>.</li></ol><h2 id="本章总结">本章总结</h2><ul><li>可以用神经网络<span class="math inline">\(\pi(a|s;\boldsymbol{\theta})\)</span>近似策略函数。策略学习的目标函数是<span class="math inline">\(J(\boldsymbol{\theta}) =\mathbb{E}_S[V_{\pi}(S)]\)</span>, 它的值越大，意味着策略越好。</li><li>策略梯度指的是<span class="math inline">\(J(\boldsymbol{\theta})\)</span>关于策略参数<span class="math inline">\(\boldsymbol{\theta}\)</span>的梯度。策略梯度定理将策略梯度表示成<span class="math inline">\(\boldsymbol{g}(s,a;\boldsymbol{\theta}) \triangleqQ_{\pi}(s,a) \cdot\boldsymbol{\nabla}_{\boldsymbol{\theta}}\ln\pi(a|s;\boldsymbol{\theta})\)</span><font style="color:rgb(6, 6, 7);">的期望。</font></li><li><font style="color:rgb(6, 6, 7);">REINFORCE算法用实际观测的回报<span class="math inline">\(u\)</span>近似</font><span class="math inline">\(Q_{\pi}(s,a)\)</span><font style="color:rgb(6, 6, 7);">,从而把 </font><span class="math inline">\(\boldsymbol{g}(s,a;\boldsymbol{\theta})\)</span><font style="color:rgb(6, 6, 7);">近似成 </font><span class="math inline">\(\tilde{\boldsymbol{g}}(s,a;\boldsymbol{\theta})\triangleq u \cdot\boldsymbol{\nabla}_{\boldsymbol{\theta}}\ln\pi(a|s;\boldsymbol{\theta})\)</span><font style="color:rgb(6, 6, 7);">.REINFORCE 算法做梯度上升更新策略网络：</font><span class="math inline">\(\boldsymbol{\theta} \leftarrow \boldsymbol{\theta}+ \beta \cdot\tilde{\boldsymbol{g}}(s,a;\boldsymbol{\theta})\)</span><font style="color:rgb(6, 6, 7);"></font></li><li><font style="color:rgb(6, 6, 7);">Actor-critic 用价值网络</font><span class="math inline">\(q(s,a;\boldsymbol{w})\)</span><font style="color:rgb(6, 6, 7);">近似 </font><span class="math inline">\(Q_{\pi}(s,a)\)</span><font style="color:rgb(6, 6, 7);">,从而把 </font><span class="math inline">\(\boldsymbol{g}(s,a;\boldsymbol{\theta})\)</span><font style="color:rgb(6, 6, 7);">近似成 </font><span class="math inline">\(\hat{\boldsymbol{g}}(s,a;\boldsymbol{\theta})\triangleq q(s,a;\boldsymbol{w}) \cdot\boldsymbol{\nabla}_{\boldsymbol{\theta}}\ln\pi(a|s;\boldsymbol{\theta})\)</span><font style="color:rgb(6, 6, 7);">.Actor-critic 用 SARSA 算法更新价值网络<span class="math inline">\(q\)</span>, 用梯度上升更新策略网络 </font><span class="math inline">\(\boldsymbol{\theta} \leftarrow \boldsymbol{\theta}+ \beta \cdot\hat{\boldsymbol{g}}(s,a;\boldsymbol{\theta})\)</span><font style="color:rgb(6, 6, 7);">.</font></li></ul>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>RL</category>
      
      <category>DRL-王树森</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.3 策略学习</title>
    <link href="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-3-Policy-based-RL/"/>
    <url>/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-3-Policy-based-RL/</url>
    
    <content type="html"><![CDATA[<h1 id="复习策略函数">复习策略函数</h1><ol type="1"><li>复习策略函数的定义：策略函数是一个概率密度函数，把state作为输入，输出一个所有action的概率分布。</li></ol><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-3-Policy-based-RL/855248240284f24c6bf9d4d98568525f.png"></p><h1 id="策略网络policy-network">策略网络policy network</h1><h2 id="用神经网络来近似策略函数pi">用神经网络来近似策略函数<span class="math inline">\(\pi\)</span>。</h2><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-3-Policy-based-RL/e6043f0a92b78f642b1f3c60e40776ce.png"></p><h2 id="状态价值函数回顾">状态价值函数回顾</h2><ol type="1"><li>状态价值函数是对动作价值函数求期望（关于action积分（或累加和），将action消掉）。</li></ol><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-3-Policy-based-RL/7f8625fad5c4472dd75f15e4ece9385e.png"></p><ol start="2" type="1"><li>近似状态价值函数：用策略网络近似策略函数，然后将其带入价值函数中，如下图所示。主要的区别是里面多了一个<span class="math inline">\(\theta\)</span>变量，这是神经网络的参数。</li></ol><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-3-Policy-based-RL/a533bac25686fc4f6915343c0b21c260.png"></p><ol start="3" type="1"><li>改进模型参数<span class="math inline">\(\theta\)</span>使得V函数变大，目标函数<span class="math inline">\(J(\theta)\)</span>是对V函数求期望，J函数是对策略网络的评价，策略网络越好，J就越大。</li><li>policy based learning的目标就是改进模型参数<span class="math inline">\(\theta\)</span>使得<span class="math inline">\(J(\theta)\)</span>越大越好。</li></ol><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-3-Policy-based-RL/71e911a656746f4bfa3e95112340d2a9.png"></p><h2 id="策略梯度policy-gradient">策略梯度policy gradient</h2><ol type="1"><li>推导策略梯度</li></ol><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-3-Policy-based-RL/9174dae4c25d1077dd025de4073196a4.png"></p><ol start="2" type="1"><li>下面用了log函数求导的性质，从第一个蓝色方框推到到第二个蓝色方框。</li></ol><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-3-Policy-based-RL/1733103261321-337059ac-f3fe-4062-b682-4464cca8b062.png"></p><ul><li>第二个等式关于<span class="math inline">\(\pi\)</span>求和，就是对随机变量A求期望。</li></ul><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-3-Policy-based-RL/1733103274107-d46805f1-0aaf-4b6e-afc3-7848f74a55ea.png"></p><ul><li>经过推导，得到策略梯度下面两种形式</li></ul><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-3-Policy-based-RL/1733103299239-d6b3ce88-ee11-49b7-ad5a-cb2e5221ddde.png"></p><ol start="3" type="1"><li>对于离散动作求策略梯度：用form1</li></ol><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-3-Policy-based-RL/1733103315078-3c411bb2-eb87-4b42-bed6-e2be71af9aa5.png"></p><ol start="4" type="1"><li>对于连续动作求策略梯度：用form2，这里用到了蒙特卡洛近似</li></ol><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-3-Policy-based-RL/1733103389442-3d60ad49-bfd1-4b69-820c-af093cd6f925.png"></p><h2 id="update-policy-network-using-policy-gradient">Update policynetwork using policy gradient</h2><ul><li>策略梯度算法：每一轮迭代都做如下的6步</li></ul><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-3-Policy-based-RL/1733103633521-793fd47d-92aa-4e67-92c8-b7e4fc9ee64f.png"></p><ul><li>对于第三步<span class="math inline">\(q_t \approx Q_{\pi}(s_t,a_t)\)</span>中的动作价值函数<span class="math inline">\(Q_{\pi}\)</span>不知道是什么，有两个办法近似计算<span class="math inline">\(q_t\)</span><ul><li>第一个算法：REINFORCE算法<ul><li>如下图所示：但是它需要玩完一轮游戏，观测到所有的奖励，然后才能更新策略网络。</li></ul><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-3-Policy-based-RL/1733103962960-effbf4fc-f109-43b7-b543-71f70c52fa40.png"></li></ul></li><li>第二个方法：用神经网络代替<span class="math inline">\(Q_{\pi}\)</span></li></ul><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-3-Policy-based-RL/1733104000958-79e5150a-14a9-4e6d-8581-b5f7f526f9cb.png"></p><ul><li>总结一下：如果策略函数已知，那么agent的动作就可以采样这个策略函数，进而被控制。但是策略函数不知道，所以用策略网络来近似这个策略函数。</li><li>具体是用策略梯度算法来学习策略网络。</li></ul><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-3-Policy-based-RL/1733105009444-077d9874-dad1-401a-b86c-73b4dffd5cd2.png"></p><h1 id="书">书</h1><ul><li>策略学习(policy-based reinforcement learning) 以及策略梯度 (policygradient)。策略学习的意思是通过求解一个优化问题，学出最优策略函数或它的近似函数(比如策略网络)。</li></ul><h2 id="策略网络">策略网络</h2><p>本章假设动作空间是离散的，比如<span class="math inline">\(A=\{左，右，上\}\)</span>。策略函数<span class="math inline">\(\pi\)</span>是个条件概率质量函数：</p><p><span class="math inline">\(\pi(a|s) \triangleqP(A=a|S=s).\)</span></p><p>策略函数<span class="math inline">\(\pi\)</span>的输入是状态<span class="math inline">\(s\)</span>和动作<span class="math inline">\(a\)</span>, 输出是一个 0 到 1 之间的概率值。举个例子，把超级玛丽游戏当前屏幕上的画面作为<span class="math inline">\(s\)</span>, 策略函数会输出每个动作的概率值：</p><p><span class="math inline">\(\pi(左|s) = 0.5, \quad \pi(右|s) = 0.2,\quad \pi(上|s) = 0.3.\)</span></p><p>如果我们有这样一个策略函数，我们就可以拿它控制智能体。每当观测到一个状态<span class="math inline">\(s\)</span>,就用策略函数计算出每个动作的概率值，然后做随机抽样，得到一个动作<span class="math inline">\(a\)</span>,让智能体执行<span class="math inline">\(a\)</span>。</p><p>怎么样才能得到这样一个策略函数呢？当前最有效的方法是用神经网络<span class="math inline">\(\pi(a|s;\theta)\)</span>近似策略函数<span class="math inline">\(\pi(a|s)\)</span>。神经网络<span class="math inline">\(\pi(a|s;\theta)\)</span>被称为策略网络。</p><p><span class="math inline">\(\theta\)</span>表示神经网络的参数；一开始随机初始化<span class="math inline">\(\theta\)</span>,随后利用收集的状态、动作、奖励去更新<span class="math inline">\(\theta\)</span>。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-3-Policy-based-RL/1733104100274-e498b077-9362-460d-8886-f1baf20d27c6.png"></p><p>策略网络的结构如图 7.1 所示。策略网络的输入是状态<span class="math inline">\(s\)</span>。在 Atari游戏、围棋等应用中，状态是张量 (比如图片),那么应该如图 7.1所示用卷积网络处理输入。在机器人控制等应用中，状态<span class="math inline">\(s\)</span>是向量，它的元素是多个传感器的数值，那么应该把卷积网络换成全连接网络。策略网络输出层的激活函数是softmax, 因此输出的向量 (记作<span class="math inline">\(f\)</span>)所有元素都是正数，而且相加等于1。动作空间<span class="math inline">\(A\)</span>的大小是多少，向量<span class="math inline">\(f\)</span>的维度就是多少。在超级玛丽的例子中，<span class="math inline">\(A=\{左，右，上\}\)</span>,那么<span class="math inline">\(f\)</span>就是 3 维的向量，比如<span class="math inline">\(f = [0.2, 0.1, 0.7]\)</span>。</p><p><span class="math inline">\(f\)</span>描述了动作空间<span class="math inline">\(A\)</span>上的离散概率分布，<span class="math inline">\(f\)</span>每个元素对应一个动作：</p><p><span class="math inline">\(f_1 = \pi(左|s) = 0.2, \quad f_2 =\pi(右|s) = 0.1, \quad f_3 = \pi(上|s) = 0.7.\)</span></p><h2 id="策略学习的目标函数">策略学习的目标函数</h2><p>为了推导策略学习的目标函数，我们需要先复习回报和价值函数。回报<span class="math inline">\(U_t\)</span>是从<span class="math inline">\(t\)</span>时刻开始的所有奖励之和。<span class="math inline">\(U_t\)</span>依赖于<span class="math inline">\(t\)</span>时刻开始的所有状态和动作：</p><p><span class="math inline">\(S_t, A_t, S_{t+1}, A_{t+1}, S_{t+2},A_{t+2}, \cdots\)</span></p><p>在<span class="math inline">\(t\)</span>时刻，<span class="math inline">\(U_t\)</span>是随机变量，它的不确定性来自于未来未知的状态和动作。动作价值函数的定义是：</p><p><span class="math inline">\(Q_{\pi}(s_t, a_t) = \mathbb{E}[U_t | S_t= s_t, A_t = a_t].\)</span></p><p>条件期望把<span class="math inline">\(t\)</span>时刻状态<span class="math inline">\(s_t\)</span>和动作<span class="math inline">\(a_t\)</span>看做已知观测值，把<span class="math inline">\(t+1\)</span>时刻后的状态和动作看做未知变量，并消除这些变量。状态价值函数的定义是：</p><p><span class="math inline">\(V_{\pi}(s_t) = \mathbb{E}_{A_t \sim\pi(\cdot | s_t; \theta)}[Q_{\pi}(s_t, A_t)].\)</span></p><p>状态价值既依赖于当前状态<span class="math inline">\(s_t\)</span>,也依赖于策略网络<span class="math inline">\(\pi\)</span>的参数<span class="math inline">\(\theta\)</span>。</p><ul><li>当前状态<span class="math inline">\(s_t\)</span>越好，则<span class="math inline">\(V_{\pi}(s_t)\)</span>越大，即回报<span class="math inline">\(U_t\)</span>的期望越大。例如，在超级玛丽游戏中，如果玛丽奥已经接近终点(也就是说当前状态<span class="math inline">\(s_t\)</span>很好),那么回报的期望就会很大。</li><li>策略<span class="math inline">\(\pi\)</span>越好 (即参数<span class="math inline">\(\theta\)</span>越好),那么<span class="math inline">\(V_{\pi}(s_t)\)</span>也会越大。例如，从同一起点出发打游戏，高手(好的策略) 的期望回报远高于初学者 (差的策略)。</li></ul><p>如果一个策略很好，那么状态价值<span class="math inline">\(V_{\pi}(S)\)</span>的均值应当很大。因此我们定义目标函数：</p><p><span class="math inline">\(J(\theta) =\mathbb{E}_S[V_{\pi}(S)].\)</span></p><p>这个目标函数排除掉了状态<span class="math inline">\(S\)</span>的因素，只依赖于策略网络<span class="math inline">\(\pi\)</span>的参数<span class="math inline">\(\theta\)</span>; 策略越好，则<span class="math inline">\(J(\theta)\)</span>越大。所以策略学习可以描述为这样一个优化问题：</p><p><span class="math inline">\(\max_{\theta} J(\theta).\)</span></p><p>我们希望通过对策略网络参数<span class="math inline">\(\theta\)</span>的更新，使得目标函数<span class="math inline">\(J(\theta)\)</span>越来越大，也就意味着策略网络越来越强。想要求解最大化问题，显然可以用梯度上升更新<span class="math inline">\(\theta\)</span>,使得<span class="math inline">\(J(\theta)\)</span>增大。设当前策略网络的参数为<span class="math inline">\(\theta_{\text{now}}\)</span>,做梯度上升更新参数，得到新的参数<span class="math inline">\(\theta_{\text{new}}\)</span>:</p><p><span class="math inline">\(\theta_{\text{new}} \leftarrow\theta_{\text{now}} + \beta \cdot \nabla_{\theta}J(\theta_{\text{now}}).\)</span></p><p>此处的<span class="math inline">\(\beta\)</span>是学习率，需要手动调整。上面的公式就是训练策略网络的基本思路，其中的梯度</p><p><span class="math inline">\(\nabla_{\theta}J\left(\theta_{\text{now}}\right) \triangleq \frac{\partialJ(\theta)}{\partial \theta} \bigg|_{\theta =\theta_{\text{now}}}\)</span></p><p>被称作策略梯度。策略梯度可以写成下面定理中的期望形式。之后的算法推导都要基于这个定理，并对其中的期望做近似。</p><p><span class="math inline">\(\frac{\partial J(\theta)}{\partial\theta} = \mathbb{E}_S \left[ \mathbb{E}_{A \sim \pi(\cdot|\theta)}\left[ \frac{\partial \ln \pi(A|S;\theta)}{\partial \theta} \cdotQ_{\pi}(S,A) \right] \right].\)</span></p><p>注上面的策略梯度定理是不严谨的表述，尽管大多数论文和书籍使用这种表述。严格地讲，这个定理只有在“状态<span class="math inline">\(S\)</span>服从马尔科夫链的稳态分布<span class="math inline">\(d(\cdot)\)</span>”这个假设下才成立。定理中的等号其实是不对的，期望前面应该有一项系数<span class="math inline">\(\frac{1-\gamma^n}{1-\gamma}\)</span>,其中<span class="math inline">\(\gamma\)</span>是折扣率，<span class="math inline">\(n\)</span>是一局游戏的长度。严格地讲，策略梯度定理应该是：</p><p><span class="math inline">\(\frac{\partial J(\theta)}{\partial\theta} = \frac{1-\gamma^n}{1-\gamma} \cdot \mathbb{E}_S \sim d(\cdot)\left[ \mathbb{E}_{A \sim \pi(\cdot|S;\theta)} \left[ \frac{\partial \ln\pi(A|S;\theta)}{\partial \theta} \cdot Q_{\pi}(S,A) \right]\right].\)</span></p><p><span class="math inline">\(1-\gamma^n\)</span>会被学习率<span class="math inline">\(\beta\)</span>吸收。</p><h2 id="策略梯度定理的证明">策略梯度定理的证明</h2><p>把策略网络<span class="math inline">\(\pi(a|s;\theta)\)</span>看做动作的概率质量函数(或概率密度函数)。状态价值函数<span class="math inline">\(V_{\pi}(s)\)</span>可以写成：</p><p><span class="math inline">\(V_{\pi}(s) = \mathbb{E}_{A \sim\pi(\cdot|\theta)}[Q_{\pi}(s,A)] = \sum_{a \in A} \pi(a|s;\theta) \cdotQ_{\pi}(s,a).\)</span></p><p>状态价值<span class="math inline">\(V_{\pi}(s)\)</span>关于<span class="math inline">\(\theta\)</span>的梯度可以写作：</p><p><span class="math inline">\(\frac{\partial V_{\pi}(s)}{\partial\theta} = \frac{\partial}{\partial \theta} \sum_{a \in A}\pi(a|s;\theta) \cdot Q_{\pi}(s,a) = \sum_{a \in A} \frac{\partial\pi(a|s;\theta)  \cdot Q_{\pi}(s,a)}{\partial \theta}\)</span></p><p>上面第二个等式把求导放入连加里面；等式成立的原因是求导的对象<span class="math inline">\(\theta\)</span>与连加的对象<span class="math inline">\(u\)</span>不同。回忆一下链式法则：设<span class="math inline">\(z = f(x) \cdot g(x)\)</span>, 那么</p><p><span class="math inline">\(\frac{\partial z}{\partial x} =\frac{\partial f(x)}{\partial x} \cdot g(x) + f(x) \cdot \frac{\partialg(x)}{\partial x}\)</span>.</p><p>应用链式法则，公式 (7.1) 中的梯度可以写作：</p><p><span class="math inline">\(\begin{align*}\frac{\partial V_{\pi}(s)}{\partial \theta} &amp;= \sum_{a \in\mathcal{A}} \frac{\partial \pi(a \mid s; \theta)}{\partial \theta}\cdot Q_{\pi}(s, a) + \sum_{a \in \mathcal{A}} \pi(a \mid s; \theta)\cdot \frac{\partial Q_{\pi}(s, a)}{\partial \theta} \\&amp;= \sum_{a \in \mathcal{A}} \frac{\partial \pi(a \mid s;\theta)}{\partial \theta} \cdot Q_{\pi}(s, a) + \underbrace{E_{A \sim\pi(\cdot \mid s; \theta)}}_{\text{设为 } x} \left[ \frac{\partialQ_{\pi}(s, A)}{\partial \theta} \right].\end{align*}\)</span></p><p>上面公式最右边一项<span class="math inline">\(x\)</span>的分析非常复杂，此处不具体分析了。由上面的公式可得：</p><p><span class="math inline">\(\begin{align*}\frac{\partial V_{\pi}(s)}{\partial \theta} &amp;= \sum_{A \in\mathcal{A}} \frac{\partial \pi(A \mid S; \theta)}{\partial \theta}\cdot Q_{\pi}(S, A) + x \\&amp;= \sum_{A \in \mathcal{A}} \pi(A \mid S; \theta) \cdot\frac{1}{\pi(A \mid S; \theta)} \cdot \frac{\partial \pi(A \mid S;\theta)}{\partial \theta} \cdot Q_{\pi}(S, A) + x \\&amp;= \sum_{A \in \mathcal{A}} \pi(A \mid S; \theta) \cdot\frac{\partial \ln \pi(A \mid S; \theta)}{\partial \theta} \cdotQ_{\pi}(S, A) + x.\end{align*}\)</span></p><p><span class="math inline">\(\frac{\partial V_{\pi}(s)}{\partial\theta} = \mathbb{E}_{A \sim \pi(\cdot|\theta)} \left[ \frac{\partial\ln \pi(A|S;\theta)}{\partial \theta} \cdot Q_{\pi}(S,A) \right] + x.\quad (7.2)\)</span></p><p>公式中红色标出的<span class="math inline">\(\pi(A|S;\theta)\)</span>被看做概率质量函数，因此连加可以写成期望的形式。由目标函数的定义<span class="math inline">\(J(\theta) =\mathbb{E}_S[V_{\pi}(S)]\)</span>可得：</p><p><span class="math inline">\(\frac{\partial J(\theta)}{\partial\theta} = \mathbb{E}_S \left[ \frac{\partial V_{\pi}(S)}{\partial\theta} \right] = \mathbb{E}_S \left[ \mathbb{E}_{A \sim\pi(\cdot|\theta)} \left[ \frac{\partial \ln \pi(A|S;\theta)}{\partial\theta} \cdot Q_{\pi}(S,A) \right] \right] +\mathbb{E}_S[x].\)</span></p><p>不严谨的证明通常忽略掉<span class="math inline">\(x\)</span>,于是得到定理 7.1。</p><h2 id="近似策略梯度">近似策略梯度</h2><p>先复习一下前两小节的内容。策略学习可以表述为这样一个优化问题：</p><p><span class="math inline">\(\max_{\theta} \left\{ J(\theta)\triangleq \mathbb{E}_S \left[ V_{\pi}(S) \right] \right\}.\)</span></p><p>求解这个最大化问题最简单的算法就是梯度上升：</p><p><span class="math inline">\(\theta \leftarrow \theta + \beta \cdot\nabla_{\theta} J(\theta).\)</span></p><p>其中的<span class="math inline">\(\nabla_{\theta}J(\theta)\)</span>是策略梯度。策略梯度定理证明：</p><p><span class="math inline">\(\nabla_{\theta} J(\theta) = \mathbb{E}_S\left[ \mathbb{E}_{A \sim \pi(\cdot|\theta)} \left[ Q_{\pi}(S,A) \cdot\nabla_{\theta} \ln \pi(A|S;\theta) \right] \right].\)</span></p><p>解析求出这个期望是不可能的，因为我们并不知道状态<span class="math inline">\(S\)</span>概率密度函数；即使我们知道<span class="math inline">\(S\)</span>的概率密度函数，能够通过连加或者定积分求出期望，我们也不愿意这样做，因为连加或者定积分的计算量非常大。</p><p>回忆一下，第 2章介绍了期望的蒙特卡洛近似方法，可以将这种方法用于近似策略梯度。每次从环境中观测到一个状态<span class="math inline">\(s\)</span>, 它相当于随机变量<span class="math inline">\(S\)</span>的观测值。然后再根据当前的策略网络(策略网络的参数必须是最新的) 随机抽样得出一个动作：</p><p><span class="math inline">\(a \sim \pi(\cdot | s;\theta).\)</span></p><p>计算随机梯度：</p><p><span class="math inline">\(\boldsymbol{g}(s,a;\theta) \triangleqQ_{\pi}(s,a) \cdot \nabla_{\theta} \ln \pi(a|s;\theta).\)</span></p><p>很显然，<span class="math inline">\(\boldsymbol{g}(s,a;\theta)\)</span>是策略梯度<span class="math inline">\(\nabla_{\theta} J(\theta)\)</span>的无偏估计：</p><p><span class="math inline">\(\nabla_{\theta} J(\theta) = \mathbb{E}_S\left[ \mathbb{E}_{A \sim \pi(\cdot|\theta)} \left[\boldsymbol{g}(S,A;\theta) \right] \right].\)</span></p><p>于是我们得到下面的结论：</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-3-Policy-based-RL/1733104886461-fef380bf-3837-4b5c-a44a-649a5cac301f.png"></p><p>对无偏估计的解释：ChatGPT</p><p>在统计学和概率论中，一个估计量如果在多次独立重复采样下的期望值等于被估计的参数的真实值，那么这个估计量被称为<strong>无偏估计</strong>。换句话说，无偏估计的期望值与被估计参数的真实值相等，不存在系统性的估计偏差。</p><p>形式上，对于估计量 (<span class="math inline">\(\hat{\theta}\)</span>) 和真实参数 (<span class="math inline">\(\theta\)</span>)，如果满足：</p><p><span class="math inline">\(\mathbb{E}[\hat{\theta}] =\theta,\)</span></p><p>其中，(<span class="math inline">\(\mathbb{E}[\cdot]\)</span>)表示期望值，那么估计量 (<span class="math inline">\(\hat{\theta}\)</span>) 就是无偏估计。</p><p>无偏性是一个重要的性质，因为它意味着在长期的统计学意义上，估计量不会系统性地高估或低估真实参数值。然而，无偏性并不意味着在单次估计中估计值一定会非常接近真实值。方差和均方误差也是评价估计量性能的重要指标。</p><p>在实际应用中，研究人员通常希望使用无偏估计，因为它们在统计学理论中更容易处理。但并非所有估计都能找到无偏的形式，有时可能需要权衡无偏性与其他性质（例如方差）来选择合适的估计方法。</p><p>应用上述结论，我们可以做随机梯度上升来更新<span class="math inline">\(\theta\)</span>, 使得目标函数<span class="math inline">\(J(\theta)\)</span>逐渐增长：</p><p><span class="math inline">\(\theta \leftarrow \theta + \beta \cdot\boldsymbol{g}(s,a;\theta).\)</span></p><p>此处的<span class="math inline">\(\beta\)</span>是学习率，需要手动调整。但是这种方法仍然不可行，我们计算不出<span class="math inline">\(\boldsymbol{g}(s,a;\theta)\)</span>,原因在于我们不知道动作价值函数<span class="math inline">\(Q_{\pi}(s,a)\)</span>。在后面两节中，我们用两种方法对<span class="math inline">\(Q_{\pi}(s,a)\)</span>做近似：一种方法是 REINFORCE,用实际观测的回报<span class="math inline">\(u\)</span>近似<span class="math inline">\(Q_{\pi}(s,a)\)</span>; 另一种方法是actor-critic,用神经网络<span class="math inline">\(q(s,a;\boldsymbol{w})\)</span>近似<span class="math inline">\(Q_{\pi}(s,a)\)</span>。</p><h2 id="reinforce">REINFORCE</h2><p>策略梯度方法用<span class="math inline">\(\nabla_{\theta}J(\theta)\)</span>的近似来更新策略网络参数<span class="math inline">\(\theta\)</span>,从而增大目标函数。上一节中，我们推导出策略梯度<span class="math inline">\(\nabla_{\theta}J(\theta)\)</span>的无偏估计，即下面的随机梯度：</p><p><span class="math inline">\(\boldsymbol{g}(s,a;\theta) \triangleqQ_{\pi}(s,a) \cdot \nabla_{\theta} \ln \pi(a|s;\theta).\)</span></p><p>但是其中的动作价值函数<span class="math inline">\(Q_{\pi}\)</span>是未知的、导致无法直接计算<span class="math inline">\(\boldsymbol{g}(s,a;\theta)\)</span>。REINFORCE进一步对<span class="math inline">\(Q_{\pi}\)</span>做蒙特卡洛近似，把它替换成回报<span class="math inline">\(u\)</span>。</p><p><strong>REINFORCE</strong> <strong>的简化推导</strong></p><p>设一局游戏有<span class="math inline">\(n\)</span>步，一局中的奖励记作<span class="math inline">\(R_1, \cdots, R_n\)</span>。回忆一下，<span class="math inline">\(t\)</span>时刻的折扣回报定义为：</p><p><span class="math inline">\(U_t = \sum_{k=t}^n \gamma^{k-t} \cdotR_k.\)</span></p><p>而动作价值定义为<span class="math inline">\(U_t\)</span>的条件期望：</p><p><span class="math inline">\(Q_{\pi}(s_t, a_t) = \mathbb{E}[U_t | S_t= s_t, A_t = a_t].\)</span></p><p>我们可以用蒙特卡洛近似上面的条件期望。从时刻<span class="math inline">\(t\)</span>开始，智能体完成一局游戏，观测到全部奖励<span class="math inline">\(r_t, \cdots, r_n\)</span>, 然后可以计算出<span class="math inline">\(u_t = \sum_{k=t}^n \gamma^{k-t} \cdotr_k\)</span>。因为<span class="math inline">\(u_t\)</span>是随机变量<span class="math inline">\(U_t\)</span>的观测值，所以<span class="math inline">\(u_t\)</span>是上面公式中期望的蒙特卡洛近似。在实践中，可以用<span class="math inline">\(u_t\)</span>代替<span class="math inline">\(Q_{\pi}(s_t, a_t)\)</span>, 那么随机梯度<span class="math inline">\(\boldsymbol{g}(s_t, a_t;\theta)\)</span>可以近似成：</p><p><span class="math inline">\(\tilde{\boldsymbol{g}}(s_t, a_t; \theta)= u_t \cdot \nabla_{\theta} \ln \pi(a_t | s_t; \theta).\)</span></p><p><span class="math inline">\(\tilde{\boldsymbol{g}}\)</span>是<span class="math inline">\(\boldsymbol{g}\)</span>的无偏估计，所以也是策略梯度<span class="math inline">\(\nabla_{\theta}J(\theta)\)</span>的无偏估计；<span class="math inline">\(\tilde{\boldsymbol{g}}\)</span>也是一种随机梯度。</p><p>我们可以用反向传播计算出<span class="math inline">\(\ln\pi\)</span>关于<span class="math inline">\(\theta\)</span>的梯度，而且可以实际观测到<span class="math inline">\(u_t\)</span>, 于是我们可以实际计算出随机梯度<span class="math inline">\(\tilde{\boldsymbol{g}}\)</span>的值。有了随机梯度的值，我们可以做随机梯度上升更新策略网络参数<span class="math inline">\(\theta\)</span>:</p><p><span class="math inline">\(\theta \leftarrow \theta + \beta \cdot\tilde{\boldsymbol{g}}(s_t, a_t; \theta).\)</span></p><p>根据上述推导，我们得到了训练策略网络的算法，即 REINFORCE。</p><p><strong>训练流程</strong></p><p>当前策略网络的参数是<span class="math inline">\(\theta_{\text{now}}\)</span>。REINFORCE执行下面的步骤对策略网络的参数做一次更新：</p><ol type="1"><li>用策略网络<span class="math inline">\(\theta_{\text{now}}\)</span>控制智能体从头开始玩一局游戏，得到一条轨迹(trajectory):<span class="math inline">\(s_1, a_1, r_1, s_2, a_2, r_2,\cdots, s_n, a_n, r_n\)</span>.</li><li>计算所有的回报：<span class="math inline">\(u_t = \sum_{k=t}^n\gamma^{k-t} \cdot r_k, \forall t=1, \cdots, n\)</span>.</li><li>用<span class="math inline">\(\{(s_t,a_t)\}_{t=1}^n\)</span>作为数据，做反向传播计算：<span class="math inline">\(\nabla_{\theta} \ln \pi(a_t | s_t;\theta_{\text{now}}), \forall t=1, \cdots, n\)</span>.</li><li>做随机梯度上升更新策略网络参数：<span class="math inline">\(\theta_{\text{new}} \leftarrow \theta_{\text{now}}+ \beta \cdot \sum_{t=1}^n \gamma^{t-1} \cdot u_t \cdot \nabla_{\theta}\ln \pi(a_t | s_t; \theta_{\text{now}})\)</span>.</li></ol><p>注：在算法最后一步中，随机梯度前面乘以系数<span class="math inline">\(\gamma^{t-1}\)</span>。为什么需要这个系数呢？原因是这样的：前面REINFORCE的推导是简化的，而非严谨的数学推导；按照我们简化的推导，不应该乘以系数<span class="math inline">\(\gamma^{t-1}\)</span><font style="color:rgb(6, 6, 7);">。当进行严格的数学推导的时候，得出的REINFORCE 算法需要系数 </font><span class="math inline">\(\gamma^{t-1}\)</span><font style="color:rgb(6, 6, 7);">。</font></p><p><font style="color:rgb(6, 6, 7);">注：REINFORCE 属于同策略(on-policy), 要求行为策略 (behavior policy) 与目标策略 (target policy)相同，两者都必须是策略网络 </font><span class="math inline">\(\pi(a|s;\theta_{\text{now}})\)</span><font style="color:rgb(6, 6, 7);">,其中 </font><span class="math inline">\(\theta_{\text{now}}\)</span><font style="color:rgb(6, 6, 7);">是策略网络当前的参数。所以经验回放不适用于 REINFORCE。</font></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>RL</category>
      
      <category>DRL-王树森</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.2 value based RL</title>
    <link href="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-2-Value-based-RL/"/>
    <url>/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-2-Value-based-RL/</url>
    
    <content type="html"><![CDATA[<h1 id="复习">复习</h1><ol type="1"><li>在学习DQN之前，首先复习一些基础知识。在一局游戏中，把从起始到结束的所有奖励记作：<span class="math inline">\(R_1, \cdots, R_t, \cdots, R_n\)</span>。</li><li>定义折扣率<span class="math inline">\(\gamma \in [0,1]\)</span>。折扣回报的定义是：</li></ol><p><span class="math inline">\(U_t = R_t + \gamma \cdot R_{t+1} +\gamma^2 \cdot R_{t+2} + \cdots + \gamma^{n-t} \cdot R_n\)</span>。</p><ol start="3" type="1"><li>在游戏尚未结束的<span class="math inline">\(t\)</span>时刻，<span class="math inline">\(U_t\)</span>是一个未知的随机变量，其随机性来自于<span class="math inline">\(t\)</span>时刻之后的所有状态与动作。<strong>动作价值函数</strong>的定义是：</li></ol><p><span class="math inline">\(Q_{\pi}(s_t, a_t) = \mathbb{E}[U_t | S_t= s_t, A_t = a_t]\)</span>,</p><ul><li>公式中的期望消除了t tt 时刻之后的所有状态<span class="math inline">\(S_{t+1},\cdots,S_n\)</span>与所有动作<span class="math inline">\(A_{t+1},\cdots,A_n\)</span></li></ul><ol start="4" type="1"><li>最优动作价值函数用最大化消除策略<span class="math inline">\(\pi\)</span>：<span class="math inline">\(Q^*(s_t,a_t) = \max_{\pi} Q_{\pi}(s_t, a_t), \forall s_t \in \mathcal{S}, a_t\in \mathcal{A}\)</span>。</li><li>可以这样理解<span class="math inline">\(Q^*\)</span>: 已知<span class="math inline">\(s_t\)</span>和<span class="math inline">\(a_t\)</span>, 不论未来采取什么样的策略<span class="math inline">\(\pi\)</span>, 回报<span class="math inline">\(U_t\)</span>的期望不可能超过<span class="math inline">\(Q^*\)</span>。</li><li>最优动作价值函数的用途：假如我们知道<span class="math inline">\(Q^*\)</span>, 我们就能用它做控制。<ol type="1"><li>举个例子，超级玛丽游戏中的动作空间是<span class="math inline">\(A =\{左，右，上\}\)</span>。</li><li>给定当前状态<span class="math inline">\(s_t\)</span>,智能体该执行哪个动作呢？</li><li>假设我们已知<span class="math inline">\(Q^*\)</span>函数，那么我们就让<span class="math inline">\(Q^*\)</span>给三个动作打分，</li><li>比如：<span class="math inline">\(Q^*(s_t, 左) = 370, Q^*(s_t, 右) =-21, Q^*(s_t, 上) = 610\)</span>。</li></ol></li><li>这三个值是什么意思呢？ 1.<span class="math inline">\(Q^*(s_t, 左) =370\)</span>的意思是：如果现在智能体选择向左走，不论之后采取什么策略<span class="math inline">\(\pi\)</span>, 那么回报<span class="math inline">\(U_t\)</span>的期望最多不会超过 370。<ol start="2" type="1"><li>同理，其他两个最优动作价值也是回报的期望的上界。</li><li>根据<span class="math inline">\(Q^*\)</span>的评分，智能体应该选择向上跳，因为这样可以最大化回报<span class="math inline">\(U_t\)</span>的期望。</li></ol></li></ol><h1 id="dqn">DQN</h1><ul><li>我们希望知道<span class="math inline">\(Q^*\)</span>,因为它就像是先知一般，可以预见未来，在<span class="math inline">\(t\)</span>时刻就预见<span class="math inline">\(t\)</span>到<span class="math inline">\(n\)</span>时刻之间的累计奖励的期望。</li><li>假如我们有<span class="math inline">\(Q^*\)</span>这位先知，我们就遵照先知的指导，最大化未来的累计奖励。</li><li>然而在实践中我们不知道<span class="math inline">\(Q^*\)</span>的函数表达式。是否有可能近似出<span class="math inline">\(Q^*\)</span>这位先知呢？</li><li>对于超级玛丽这样的游戏，学出来一个“先知”并不难。假如让我们重复玩超级玛丽一亿次，那我们就会像先知一样，看到当前状态，就能准确判断出当前最优的动作是什么。</li><li>这说明只要有足够多的“经验”, 就能训练出超级玛丽中的“先知”。</li></ul><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-2-Value-based-RL/1733056273160-335a712a-e5a2-4b64-8301-8eef4e81d266.png"></p><ol type="1"><li>最优动作价值函数的近似：<ol type="1"><li>在实践中，近似学习“先知”<span class="math inline">\(Q^*\)</span>最有效的办法是深度Q网络(deep Qnetwork, 缩写 DQN), 记作<span class="math inline">\(Q(s, a;\boldsymbol{w})\)</span>, 其结构如图所述。</li><li>其中的<span class="math inline">\(\boldsymbol{w}\)</span>表示神经网络中的参数。首先随机初始化<span class="math inline">\(\boldsymbol{w}\)</span>, 随后用“经验”去学习<span class="math inline">\(\boldsymbol{w}\)</span>。</li><li>学习的目标是：对于所有的<span class="math inline">\(s\)</span>和<span class="math inline">\(a\)</span>, DQN 的预测<span class="math inline">\(Q(s, a; \boldsymbol{w})\)</span>尽量接近<span class="math inline">\(Q^*(s,a)\)</span>。后面几节的内容都是如何学习<span class="math inline">\(\boldsymbol{w}\)</span>!</li></ol></li></ol><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-2-Value-based-RL/1733057850676-68df9942-0f13-4c49-bbb7-9a1debcb3004.png"></p><ol start="2" type="1"><li>可以这样理解 DQN 的表达式<span class="math inline">\(Q(s, a;\boldsymbol{w})\)</span>。<ol type="1"><li>DQN 的输出是离散动作空间<span class="math inline">\(A\)</span>上的每个动作的 Q值，即给每个动作的评分，分数越高意味着动作越好。</li><li>举个例子，动作空间是<span class="math inline">\(A =\{左，右，上\}\)</span>, 那么动作空间的大小等于<span class="math inline">\(|A| = 3\)</span>, 那么 DQN 的输出是 3维的向量，记作<span class="math inline">\(\hat{q}\)</span>,向量每个元素对应一个动作。</li><li>在图 4.1 中，DQN 的输出是 4.<span class="math inline">\(q^1 = Q(s,左; \boldsymbol{w}) = 370, q^2 = Q(s, 右; \boldsymbol{w}) = -21, q^3 =Q(s, 上; \boldsymbol{w}) = 610\)</span>。</li></ol></li><li>总结一下，DQN 的输出是<span class="math inline">\(|A|\)</span>维的向量<span class="math inline">\(\hat{q}\)</span>,包含所有动作的价值。而我们常用的符号<span class="math inline">\(Q(s, a;\boldsymbol{w})\)</span>是标量，是动作<span class="math inline">\(a\)</span>对应的动作价值，是向量<span class="math inline">\(\hat{q}\)</span>中的一个元素。</li><li>用DQN玩游戏：agent每次采取的action是使得Q函数取最大的那个动作，一直玩下去。下图的顺序是从左往右看。</li></ol><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-2-Value-based-RL/1733058037862-263e2333-6531-46b3-a8cd-0d44aec06129.png"></p><ol start="5" type="1"><li>DQN 的梯度：在训练 DQN 的时候，需要对 DQN 关于神经网络参数<span class="math inline">\(\boldsymbol{w}\)</span>求梯度。用<span class="math inline">\(\nabla_{w} Q(s, a; w) \triangleq \frac{\partialQ(s, a; w)}{\partial w}\)</span></li></ol><ul><li>表示函数值<span class="math inline">\(Q(s, a;\boldsymbol{w})\)</span>关于参数<span class="math inline">\(\boldsymbol{w}\)</span>的梯度。因为函数值<span class="math inline">\(Q(s, a;\boldsymbol{w})\)</span>是一个实数，所以梯度的形状与<span class="math inline">\(\boldsymbol{w}\)</span>完全相同。</li><li>如果<span class="math inline">\(\boldsymbol{w}\)</span>是<span class="math inline">\(d \times 1\)</span>的向量，那么梯度也是<span class="math inline">\(d \times 1\)</span>的向量。如果<span class="math inline">\(\boldsymbol{w}\)</span>是<span class="math inline">\(d_1 \times d_2\)</span>的矩阵，那么梯度也是<span class="math inline">\(d_1 \times d_2\)</span>的矩阵。如果<span class="math inline">\(\boldsymbol{w}\)</span>是<span class="math inline">\(d_1 \times d_2 \timesd_3\)</span>的张量，那么梯度也是<span class="math inline">\(d_1 \timesd_2 \times d_3\)</span>的张量。</li></ul><ol start="6" type="1"><li>给定观测值<span class="math inline">\(s\)</span>和<span class="math inline">\(a\)</span>, 比如<span class="math inline">\(a =左\)</span>, 可以用反向传播计算出梯度<span class="math inline">\(\nabla_{\boldsymbol{w}}Q( s, 左;\boldsymbol{w})\)</span>。<ol type="1"><li>在编程实现的时候，TensorFlow 和PyTorch 可以对 DQN输出向量的一个元素(比如<span class="math inline">\(Q( s, 左;\boldsymbol{w})\)</span>这个元素) 关于变量<span class="math inline">\(\boldsymbol{w}\)</span>自动求梯度，得到的梯度的形状与<span class="math inline">\(\boldsymbol{w}\)</span>完全相同。</li></ol></li></ol><h2 id="时间差分td算法">时间差分（TD）算法</h2><h3 id="驾车时间预测的例子">驾车时间预测的例子</h3><ol type="1"><li>假设我们有一个模型<span class="math inline">\(Q(s, d;\boldsymbol{w})\)</span>, 其中<span class="math inline">\(s\)</span>是起点，<span class="math inline">\(d\)</span>是终点，<span class="math inline">\(\boldsymbol{w}\)</span>是参数。<ol type="1"><li>模型<span class="math inline">\(Q\)</span>可以预测开车出行的时间开销。</li><li>这个模型一开始不准确，甚至是纯随机的。</li><li>但是随着很多人用这个模型，得到更多数据、更多训练，这个模型就会越来越准，会像谷歌地图一样准。</li></ol></li><li>我们该如何训练这个模型呢？<ol type="1"><li>在用户出发前，用户告诉模型起点<span class="math inline">\(s\)</span>和终点<span class="math inline">\(d\)</span>, 模型做一个预测<span class="math inline">\(\hat{q} = Q(s, d; \boldsymbol{w})\)</span>。</li><li>当用户结束行程的时候，把实际驾车时间<span class="math inline">\(y\)</span>反馈给模型。</li><li>两者之差<span class="math inline">\(\hat{q} -y\)</span>反映出模型是高估还是低估了驾驶时间，以此来修正模型，使得模型的估计更准确。</li></ol></li><li>假设我是个用户，我要从北京驾车去上海。从北京出发之前，我让模型做预测，模型告诉我总车程是14 小时：</li></ol><p><span class="math inline">\(\hat{q} \triangleq Q(“北京”, “上海”;\boldsymbol{w}) = 14\)</span>。</p><ol start="4" type="1"><li>当我到达上海，我知道自己花的实际时间是 16小时，并将结果反馈给模型；见图 4.2。</li></ol><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-2-Value-based-RL/1733058574342-3aa93422-c020-4430-91d7-f0aebee71156.png"></p><ol start="5" type="1"><li>可以用梯度下降对模型做一次更新，具体做法如下。把我的这次旅程作为一组训练数据：</li></ol><p><span class="math inline">\(s = “北京”, d = “上海”, \hat{q} = 14, y =16\)</span>。</p><ol start="6" type="1"><li>我们希望估计值<span class="math inline">\(\hat{q} = Q(s, d;\boldsymbol{w})\)</span>尽量接近真实观测到的<span class="math inline">\(y\)</span>, 所以用两者差的平方作为损失函数：</li></ol><p><span class="math inline">\(L(\boldsymbol{w}) = \frac{1}{2} [Q(s, d;\boldsymbol{w}) - y]^2\)</span>。</p><ol start="7" type="1"><li>用链式法则计算损失函数的梯度，得到：</li></ol><p><span class="math inline">\(\nabla_{\boldsymbol{w}}L(\boldsymbol{w})= (\hat{q} - y) \cdot \nabla_{\boldsymbol{w}}Q(s, d;\boldsymbol{w})\)</span>。</p><ol start="8" type="1"><li>然后做一次梯度下降更新模型参数<span class="math inline">\(\boldsymbol{w}\)</span>：</li></ol><p><span class="math inline">\(\boldsymbol{w} \leftarrow \boldsymbol{w}- \alpha \cdot \nabla_{\boldsymbol{w}}L(\boldsymbol{w})\)</span>，</p><ul><li>此处的<span class="math inline">\(\alpha\)</span>是学习率，需要手动调整。在完成一次梯度下降之后，如果再让模型做一次预测，那么模型的预测值</li></ul><p><span class="math inline">\(Q(&quot;北京&quot;, &quot;上海&quot;;\boldsymbol{w})\)</span></p><ul><li>会比原先更接近<span class="math inline">\(y = 16\)</span>。</li></ul><h3 id="td算法">TD算法</h3><ul><li>接着上文驾车时间的例子。出发前模型估计全程时间为<span class="math inline">\(\hat{q} =14\)</span>小时；模型建议的路线会途径济南。我从北京出发，过了<span class="math inline">\(r =4.5\)</span>小时，我到达济南。此时我再让模型做一次预测，模型告诉我</li></ul><p><span class="math inline">\(\hat{q}&#39; \triangleqQ(&quot;济南&quot;, &quot;上海&quot;; \boldsymbol{w}) =11\)</span>。</p><ul><li>见图 4.3的描述。假如此时我的车坏了，必须要在济南修理，我不得不取消此次行程。<ul><li>我没有完成旅途，那么我的这组数据是否能帮助训练模型呢？</li><li>其实是可以的，用到的算法叫做 <strong>时间差分 (temporal difference,缩写 TD)</strong>。</li></ul></li></ul><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-2-Value-based-RL/1733058721318-ba8539cc-dae0-42cb-833f-5090f4c3f4e4.png"></p><ul><li>下面解释 TD 算法的原理。<ul><li>回顾一下我们已有的数据：模型估计从北京到上海一共需要<span class="math inline">\(\hat{q} = 14\)</span>小时，我实际用了<span class="math inline">\(r = 4.5\)</span>小时到达济南，模型估计还需要<span class="math inline">\(\tilde{q}&#39; =11\)</span>小时从济南到上海。</li><li>到达济南时，根据模型最新估计，整个旅程的总时间为：<br><span class="math inline">\(\hat{y} \triangleq r + \hat{q}&#39; = 4.5 +11 = 15.5\)</span>。</li></ul></li><li>TD 算法将<span class="math inline">\(\hat{y} = 15.5\)</span>称为<strong>TD 目标 (TD target)</strong>, 它比最初的预测<span class="math inline">\(\hat{q} = 14\)</span>更可靠。<ul><li>最初的预测<span class="math inline">\(\hat{q} =14\)</span>纯粹是估计的，没有任何事实的成分。</li><li>TD 目标<span class="math inline">\(\hat{y} =15.5\)</span>也是个估计，但其中有事实的成分：其中的<span class="math inline">\(r = 4.5\)</span>就是实际的观测。</li></ul></li><li>基于以上讨论，我们认为 TD 目标<span class="math inline">\(\hat{y} =15.5\)</span>比模型最初的估计值<span class="math inline">\(Q(“北京”,“上海”; \boldsymbol{w}) = 14\)</span>更可靠，所以可以用<span class="math inline">\(\hat{y}\)</span>对模型做“修正”。<ul><li>我们希望估计值<span class="math inline">\(\hat{q} = Q(s, d;\boldsymbol{w})\)</span>尽量接近 TD 目标<span class="math inline">\(\hat{y}\)</span>,所以用两者差的平方作为损失函数：<br><span class="math inline">\(L(\boldsymbol{w}) = \frac{1}{2} [Q(“北京”,“上海”; \boldsymbol{w}) - \hat{y}]^2\)</span>。</li></ul></li><li>此处把<span class="math inline">\(\hat{y}\)</span>看做常数，尽管它依赖于<span class="math inline">\(\boldsymbol{w}\)</span>。计算损失函数的梯度：</li></ul><p><span class="math inline">\(\nabla_{\boldsymbol{w}}L(\boldsymbol{w})= (\hat{q} - \hat{y}) \cdot \nabla_{\boldsymbol{w}}Q(“北京”, “上海”;\boldsymbol{w})\)</span>，</p><ul><li>此处的<span class="math inline">\(\delta = \hat{q} - \hat{y} = 14 -15.5 = -1.5\)</span>称作 <strong>TD 误差 (TDerror)</strong>。做一次梯度下降更新模型参数<span class="math inline">\(\boldsymbol{w}\)</span>：<br><span class="math inline">\(\boldsymbol{w} \leftarrow \boldsymbol{w} -\alpha \cdot \delta \cdot \nabla_{\boldsymbol{w}}Q(“北京”, “上海”;\boldsymbol{w})\)</span>。</li><li>如果你仍然不理解 TD算法，那么请换个角度来思考问题。模型估计从北京到上海全程需要<span class="math inline">\(\hat{q} =14\)</span>小时，模型还估计从济南到上海需要<span class="math inline">\(\vec{q}&#39; =11\)</span>小时。这就相当于模型做了这样的估计：从北京到济南需要的时间为<span class="math inline">\(\hat{q} - \hat{q}&#39; = 14 - 11 =3\)</span>。</li><li>而我真实花费<span class="math inline">\(r =4.5\)</span>小时从北京到济南。模型的估计与我的真实观测之差为<span class="math inline">\(\delta = 3 - 4.5 = -1.5\)</span>。这就是 TD误差！以上分析说明 TD 误差<span class="math inline">\(\delta\)</span>就是模型估计与真实观测之差。TD算法的目的是通过更新参数<span class="math inline">\(\boldsymbol{w}\)</span>使得损失<span class="math inline">\(L(\boldsymbol{w}) = \frac{1}{2}\delta^2\)</span>减小。</li></ul><h3 id="用td训练dqn">用TD训练DQN</h3><ul><li>TD算法是一种在线学习算法，可以逐步更新值函数，而不需要等到回合结束。</li><li>视频中用到的例子是从纽约到亚特兰大，途径华盛顿，但是道理都是一样的。</li></ul><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-2-Value-based-RL/1733058879180-fb0c4d82-30c6-46fa-90ba-70b1f4fd5c45.png"></p><ul><li>如何把TD算法用到DQN？和驾车的例子很像，等式左边是 t 时刻的 Q的估计，等式右边是一个实际观测值加一项关于 t+1 时刻的 Q 估计。</li></ul><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-2-Value-based-RL/1733058956641-3238eaca-6639-4dc9-bca7-6e7ef5d7960e.png"></p><ol type="1"><li>等式<span class="math inline">\(U_t = R_t + \gamma \cdotU_{t+1}\)</span></li></ol><ul><li>这个等式反映了相邻两个折扣回报之间的关系：t 时刻的折扣回报<span class="math inline">\(U_t\)</span>等于 t 时刻的奖励<span class="math inline">\(R_t\)</span>加上折扣因子<span class="math inline">\(\gamma\)</span>乘以 t+1 时刻的折扣回报<span class="math inline">\(U_{t+1}\)</span>。</li></ul><ol start="2" type="1"><li>得来的过程如下：</li></ol><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-2-Value-based-RL/1733059049529-0201225d-62af-4aea-8538-1a7646a506fd.png"></p><p><span class="math inline">\(Q(s_t, a_t; \mathbf{w}) \approx\mathbb{E}[R_t + \gamma \cdot Q(S_{t+1}, A_{t+1};\mathbf{w})]\)</span>。这个公式两边是两个估计（estimate）</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-2-Value-based-RL/1733059063482-983ffd67-cd1d-45e2-8336-c7d95144144e.png"></p><ol start="3" type="1"><li>左边是 prediction，右边是 TD target。</li></ol><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-2-Value-based-RL/1733059077203-f8091934-1717-4d41-9ad2-c33bfdf701a9.png"></p><ol start="4" type="1"><li>使用TD算法训练DQN的过程如下图：下图中的 t+1 时刻的 Q 为什么可以写成max 的形式？是因为 t+1 时刻的 action<span class="math inline">\(a_{t+1}\)</span>就是选择 t 时刻使得 Q 最大的那个action。</li></ol><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-2-Value-based-RL/1733059096305-e0111d8e-c366-485c-b832-f2cc309dafa5.png"></p><ol start="5" type="1"><li>下面是王树森书中具体的推导过程：</li></ol><ul><li>下面我们推导训练 DQN 的 TD 算法（严格地讲，此处推导的是“Q 学习算法”,它属于 TD 算法的一种。本节就称其为 TD 算法）。回忆一下回报的定义<span class="math inline">\(U_t = \sum_{k=t}^n \gamma^{k-t} \cdotR_k\)</span>,<span class="math inline">\(U_{t+1} = \sum_{k=t+1}^n\gamma^{k-t-1} \cdot R_k\)</span>。由<span class="math inline">\(U_t\)</span>和<span class="math inline">\(U_{t+1}\)</span>的定义可得：</li></ul><p><span class="math inline">\(U_t = R_t + \gamma \cdot \sum_{k=t+1}^n\gamma^{k-t-1} \cdot R_k = U_{t+1}\)</span>。</p><ul><li>回忆一下，最优动作价值函数可以写成</li></ul><p><span class="math inline">\(Q^*(s_t, a_t) = \max_{\pi} \mathbb{E}[U_t | S_t = s_t, A_t = a_t]\)</span>。</p><ul><li>从公式出发，经过一系列数学推导 ,可以得到下面的定理。这个定理是最优贝尔曼方程 (optimal Bellman equations)的一种形式。</li></ul><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-2-Value-based-RL/1733059200306-8b0a564c-d901-467a-8802-7891c27ac149.png"></p><ul><li>最优贝尔曼方程具体公式如下：</li></ul><p><span class="math inline">\(Q^*(s_t, a_t) = \mathbb{E}{S{t+1} \simp(\cdot | s_t, a_t)} [R_t + \gamma \cdot \max_{A \in \mathcal{A}}Q^*(S_{t+1}, A) | S_t = s_t, A_t = a_t]\)</span>。</p><ul><li>贝尔曼方程的右边是个期望，我们可以对期望做蒙特卡洛近似。<ul><li>当智能体执行动作<span class="math inline">\(a_t\)</span>之后，环境通过状态转移函数<span class="math inline">\(p(s_{t+1} | s_t, a_t)\)</span>计算出新状态<span class="math inline">\(s_{t+1}\)</span>。奖励<span class="math inline">\(R_t\)</span>最多只依赖于<span class="math inline">\(S_t\)</span>,<span class="math inline">\(A_t\)</span>,<span class="math inline">\(S_{t+1}\)</span>。那么当我们观测到<span class="math inline">\(s_t\)</span>,<span class="math inline">\(a_t\)</span>,<span class="math inline">\(s_{t+1}\)</span>时，则奖励<span class="math inline">\(R_t\)</span>也被观测到，记作<span class="math inline">\(r_t\)</span>。有了四元组<span class="math inline">\((s_t, a_t, r_t, s_{t+1})\)</span>,</li><li>我们可以计算出</li></ul></li></ul><p><span class="math inline">\(r_t + \gamma \cdot \max_{a \in\mathcal{A}} Q^*(s_{t+1}, a)\)</span>。</p><ul><li>它可以看做是下面这项期望的蒙特卡洛近似：</li></ul><p><span class="math inline">\(\mathbb{E}_{S_{t+1} \sim p(\cdot | s_t,a_t)} [R_t + \gamma \cdot \max_{A \in \mathcal{A}} Q^*(S_{t+1}, A) | S_t= s_t, A_t = a_t]\)</span>。</p><ul><li>由定理和上述的蒙特卡洛近似可得：</li></ul><p><span class="math inline">\(Q^*(s_t, a_t) \approx r_t + \gamma \cdot\max_{a \in \mathcal{A}} Q^*(s_{t+1}, a)\)</span>。</p><ul><li>这是不是很像驾驶时间预测问题？左边的<span class="math inline">\(Q^*(s_t,a_t)\)</span>就像是模型预测“北京到上海”的总时间，<span class="math inline">\(r_t\)</span>像是实际观测的“北京到济南”的时间，<span class="math inline">\(\gamma \cdot \max_{a \in \mathcal{A}} Q^*(s_{t+1},a)\)</span>相当于模型预测剩余路程“济南到上海”的时间。见图 4.4中的类比。</li></ul><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-2-Value-based-RL/1733059350133-4450f049-cc1c-4a70-9dff-cb5bf2cdaf9e.png"></p><ol start="6" type="1"><li>把公式中的最优动作价值函数<span class="math inline">\(Q^*(s,a)\)</span>替换成神经网络<span class="math inline">\(Q(s, a;\boldsymbol{w})\)</span>, 得到：<br><span class="math inline">\(Q(s_t, a_t; \boldsymbol{w}) \approx r_t +\gamma \cdot \max_{a \in \mathcal{A}} Q(s_{t+1}, a;\boldsymbol{w})\)</span>。</li></ol><ul><li>左边的<span class="math inline">\(\hat{q}_t \triangleq Q(s_t, a_t;\boldsymbol{w})\)</span>是神经网络在 t时刻做出的预测，其中没有任何事实成分。右边的 TD 目标<span class="math inline">\(\hat{y}_t\)</span>是神经网络在 t+1时刻做出的预测，它部分基于真实观测到的奖励<span class="math inline">\(r_t\)</span>。 +<span class="math inline">\(\hat{q}_t\)</span>和<span class="math inline">\(\hat{y}_t\)</span>两者都是对最优动作价值<span class="math inline">\(Q^*(s_t, a_t)\)</span>的估计，但是<span class="math inline">\(\hat{y}_t\)</span>部分基于事实，因此比<span class="math inline">\(\hat{q}_t\)</span>更可信。应当鼓励<span class="math inline">\(\hat{q}_t \triangleq Q(s_t, a_t;\boldsymbol{w})\)</span>接近<span class="math inline">\(\hat{y}_t\)</span>。定义损失函数：</li></ul><p><span class="math inline">\(L(\boldsymbol{w}) = \frac{1}{2} [Q(s_t,a_t; \boldsymbol{w}) - \hat{y}_t]^2\)</span>。</p><ul><li>假装<span class="math inline">\(\hat{y}_t\)</span>是常数（实际上<span class="math inline">\(\hat{y}_t\)</span>依赖于<span class="math inline">\(\boldsymbol{w}\)</span>, 但是我们假装<span class="math inline">\(\hat{y}_t\)</span>是常数）, 计算<span class="math inline">\(L\)</span>关于<span class="math inline">\(\boldsymbol{w}\)</span>的梯度：<br><span class="math inline">\(\nabla_{\boldsymbol{w}}L(\boldsymbol{w}) =(\hat{q}_t - \hat{y}_t) \cdot \nabla_{\boldsymbol{w}}Q(s_t, a_t;\boldsymbol{w})\)</span>。</li><li>做一步梯度下降，可以让<span class="math inline">\(\hat{q}_t\)</span>更接近<span class="math inline">\(\hat{y}_t\)</span>：<br><span class="math inline">\(\boldsymbol{w} \leftarrow \boldsymbol{w} -\alpha \cdot \delta_t \cdot \nabla_{\boldsymbol{w}}Q(s_t, a_t;\boldsymbol{w})\)</span>。</li><li>这个公式就是训练 DQN 的 TD 算法。</li><li>总结一下：最优行动价值函数是未知的，DQN算法就是用神经网络近似这个最优行动价值函数。</li></ul><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-2-Value-based-RL/1733059461690-35cc7ae3-b425-4ba0-896a-f163089f497a.png"></p><ol start="7" type="1"><li>TD算法具体流程如下：</li></ol><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-2-Value-based-RL/1733059475690-f46bbaf8-c631-4638-9333-1e8e418a8123.png"></p><ol start="8" type="1"><li>书中介绍的训练流程</li></ol><ul><li>首先总结上面的结论。给定一个四元组<span class="math inline">\((s_t,a_t, r_t, s_{t+1})\)</span>, 我们可以计算出 DQN 的预测值<span class="math inline">\(\hat{q}_t = Q(s_t, a_t; \boldsymbol{w})\)</span>,以及 TD 目标和 TD 误差：<br><span class="math inline">\(\hat{y}_t = r_t + \gamma \cdot \max_{a \in\mathcal{A}} Q(s_{t+1}, a; \boldsymbol{w})\)</span>和<span class="math inline">\(\delta_t = \hat{q}_t - \hat{y}_t\)</span>。</li><li>TD 算法用这个公式更新 DQN 的参数：<br><span class="math inline">\(\boldsymbol{w} \leftarrow \boldsymbol{w} -\alpha \cdot \delta_t \cdot \nabla_{\boldsymbol{w}}Q(s_t, a_t;\boldsymbol{w})\)</span>。</li><li>注意，算法所需数据为四元组<span class="math inline">\((s_t, a_t,r_t, s_{t+1})\)</span>, 与控制智能体运动的策略<span class="math inline">\(\pi\)</span>无关。这就意味着可以用任何策略控制智能体与环境交互，同时记录下算法运动轨迹，作为训练数据。因此，DQN的训练可以分割成两个独立的部分：收集训练数据、更新参数<span class="math inline">\(\boldsymbol{w}\)</span>。</li></ul><ol start="9" type="1"><li><strong>收集训练数据</strong>：</li></ol><ul><li>我们可以用任何策略函数<span class="math inline">\(\pi\)</span>去控制智能体与环境交互，这个<span class="math inline">\(\pi\)</span>就叫做行为策略 (behaviorpolicy)。比较常用的是<span class="math inline">\(\epsilon\)</span>-greedy 策略：<br><span class="math inline">\(a_t = \left\{ \begin{array}{ll} \arg\max_aQ(s_t, a; \boldsymbol{w}), &amp; \text{以概率 } (1 - \epsilon); \\\text{均匀抽取 } A \text{ 中的一个动作}, &amp; \text{以概率 } \epsilon.\end{array} \right.\)</span></li><li>把智能体在一局游戏中的轨迹记作：<br><span class="math inline">\(s_1, a_1, r_1, s_2, a_2, r_2, \cdots, s_n,a_n, r_n\)</span>。</li><li>把一条轨迹划分成<span class="math inline">\(n\)</span>个<span class="math inline">\((s_t, a_t, r_t,s_{t+1})\)</span>这种四元组，存入数组，这个数组叫做经验回放数组 (replaybuffer)。</li></ul><ol start="10" type="1"><li><strong>更新 DQN 参数</strong><span class="math inline">\(\boldsymbol{w}\)</span>：</li></ol><ul><li>随机从经验回放数组中取出一个四元组，记作<span class="math inline">\((s_j, a_j, r_j, s_{j+1})\)</span>。</li><li>设 DQN 当前的参数为<span class="math inline">\(\boldsymbol{w}_{\text{now}}\)</span>,执行下面的步骤对参数做一次更新，得到新的参数<span class="math inline">\(\boldsymbol{w}_{\text{new}}\)</span>。<ol type="1"><li>对 DQN 做正向传播，得到 Q 值：<br><span class="math inline">\(\hat{q}_j = Q(s_j, a_j;\boldsymbol{w}_{\text{now}})\)</span>和<span class="math inline">\(\hat{q}_{j+1} = \max_{a \in \mathcal{A}}Q(s_{j+1}, a; \boldsymbol{w}_{\text{now}})\)</span>。</li><li>计算 TD 目标和 TD 误差：<br><span class="math inline">\(\hat{y}_j = r_j + \gamma \cdot\hat{q}_{j+1}\)</span>和<span class="math inline">\(\delta_j = \hat{q}_j- \hat{y}_j\)</span>。</li><li>对 DQN 做反向传播，得到梯度：<br><span class="math inline">\(\boldsymbol{g}_j = \nabla_{\boldsymbol{w}}Q(s_j, a_j; \boldsymbol{w}_{\text{now}})\)</span>。</li><li>做梯度下降更新 DQN 的参数：<br><span class="math inline">\(\boldsymbol{w}_{\text{new}} \leftarrow\boldsymbol{w}_{\text{now}} - \alpha \cdot \delta_j \cdot\boldsymbol{g}_j\)</span>。</li></ol></li></ul><p>智能体收集数据、更新 DQN参数这两者可以同时进行。可以在智能体每执行一个动作之后，对<span class="math inline">\(\boldsymbol{w}\)</span>做几次更新。也可以在每完成一<font style="color:rgb(6, 6, 7);">局游戏之后，对</font><span class="math inline">\(\boldsymbol{w}\)</span><font style="color:rgb(6, 6, 7);">做几次更新。</font></p><h4 id="注意"><font style="color:rgb(6, 6, 7);">注意</font></h4><p><font style="color:rgb(6, 6, 7);">上面介绍用 TD 算法训练 DQN,更准确地说，我们用的 TD 算法叫做 Q 学习算法 (Q-learning)。TD算法是一大类算法，常见的有 Q 学习和 SARSA。Q学习的目的是学到最优动作价值函数 </font><span class="math inline">\(Q^*\)</span><font style="color:rgb(6, 6, 7);">, 而SARSA 的目的是学习动作价值函数 </font><span class="math inline">\(Q_{\pi}\)</span><font style="color:rgb(6, 6, 7);">。后面会介绍SARSA 算法。</font></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>RL</category>
      
      <category>DRL-王树森</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.1 DRL基础</title>
    <link href="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-1-%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-1-%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="概率论复习">概率论复习</h1><h2 id="随机变量">随机变量</h2><ol type="1"><li>随机变量是概率论和统计学中的一个重要概念，它用来描述随机试验的结果。</li><li>随机变量可以分为两大类：离散型随机变量和连续型随机变量。<ol type="1"><li>离散型随机变量：这种随机变量的取值是可数的，通常是整数。例如，抛一枚骰子，随机变量可以是骰子的点数，取值范围为1到6。离散型随机变量的概率分布可以通过概率质量函数（ProbabilityMass Function，PMF）来描述，它给出了随机变量每个可能取值的概率。</li><li>连续型随机变量：这种随机变量的取值是不可数的，通常是实数。例如，测量一件物品的长度，随机变量可以是任意实数值。连续型随机变量的概率分布可以通过概率密度函数（ProbabilityDensityFunction，PDF）来描述，它表示在某一点附近的概率密度，而实际概率则是通过对概率密度函数进行积分得到。</li></ol></li><li>无论是离散型还是连续型随机变量，它们都可以用来描述随机现象的不确定性，以及在概率论和统计学中进行推断和分析。</li><li>在使用随机变量时，我们通常关注以下几个方面：<ol type="1"><li>分布函数（Cumulative Distribution Function，CDF）：描述随机变量小于或等于某个特定值的概率。</li><li>期望值（Expectation）：表示随机变量的平均值，反映了分布的中心位置。</li><li>方差（Variance）：衡量随机变量取值的分散程度，即分布的宽窄程度。</li></ol></li><li>随机变量和概率密度函数或概率质量函数的概念在概率论、统计学、以及应用领域如机器学习等方面都扮演着关键的角色。</li></ol><h2 id="概率密度函数">概率密度函数</h2><p>概率密度函数（Probability DensityFunction，简称PDF）是描述随机变量在各个取值上的概率分布的数学函数。对于连续型随机变量，概率密度函数是定义在整个实数轴上的非负函数，其满足以下两个条件：</p><ol type="1"><li>对于任意实数x，概率密度函数f(x)都是非负的：<span class="math inline">\(f(x) \geq 0\)</span></li><li>整个实数轴上的概率密度函数的积分等于1：<span class="math inline">\(\int_{-\infty}^{\infty} f(x) \, dx =1\)</span></li></ol><p>这两个条件确保了概率密度函数对于所有可能的取值都提供了非负的概率，并且整个概率空间的总和是1。</p><p>对于一个连续型随机变量X，它落在某个区间a ,b上的概率可以通过对概率密度函数在该区间上的积分来计算：<span class="math inline">\(P(a \leq X \leq b) = \int_{a}^{b} f(x) \,dx\)</span></p><p>需要注意的是，概率密度函数并不直接给出具体的概率值，而是在某个取值范围内的概率密度。概率密度函数的图形在某个区间上的曲线下方的面积表示该区间内的概率。</p><p>常见的概率密度函数包括正态分布、指数分布、均匀分布等。每种分布有其特定的数学形式和性质，适用于不同类型的随机现象建模。</p><h2 id="数学期望">数学期望</h2><p>数学期望（或均值）是随机变量的一个重要性质，它用来描述随机变量的平均值。对于一个离散型随机变量X，其数学期望（期望值）表示为E(X)，定义如下：</p><p><span class="math inline">\(E(X) = \sum_i x_i \cdot P(X =x_i)\)</span></p><p>对于一个连续型随机变量X，其数学期望表示为E(X)，定义如下：</p><p><span class="math inline">\(E(X) = \int_{-\infty}^{\infty} x \cdotf(x) \, dx\)</span></p><p>其中，<span class="math inline">\(x_i\)</span>是离散型随机变量X的可能取值，<span class="math inline">\(P(X =x_i)\)</span>是相应取值的概率。对于连续型随机变量X，f(x)是其概率密度函数。</p><p>数学期望的直观理解是随机变量在长期重复试验中的平均值。它是一个对分布中心位置的度量，反映了随机变量的集中趋势。</p><p>数学期望具有一些性质，例如：</p><ol type="1"><li>线性性质： 对于常数a和b以及随机变量X、Y，有<span class="math inline">\(E(aX + bY) = aE(X) + bE(Y)\)</span></li><li>独立性质： 如果X和Y是相互独立的随机变量，则<span class="math inline">\(E(XY) = E(X)E(Y)\)</span></li></ol><p>数学期望在概率论和统计学中有广泛的应用，它不仅用于描述随机变量的平均值，还在推断、决策理论等领域中发挥着重要作用。</p><h2 id="随机抽样">随机抽样</h2><p>随机抽样是一种用来选择样本的方法，其中每个个体有相等的机会被选中，从而确保样本是代表总体的。随机抽样是统计学中的基本概念，它有助于减小选择偏差，使样本更具有代表性，从而更好地反映总体的特征。</p><p>以下是一些常见的随机抽样方法：</p><ol type="1"><li>简单随机抽样：在简单随机抽样中，每个个体被选中的概率是相等的，且每个样本的选择是独立的。这通常通过随机数生成器来实现，确保每个个体都有等概率地进入样本。</li><li>分层随机抽样：将总体划分为若干层（或称为分层），然后在每个层内进行简单随机抽样。这样可以确保每个子群体在样本中都有代表性，特别适用于总体内存在明显差异的情况。</li><li>系统随机抽样：选择一个随机的起始点，然后按照一个固定的步长或间隔进行抽样。这种方法适用于总体中个体的排列是有规律的情况。</li><li>整群抽样：将总体划分为若干群，然后随机选择一些群，再从选中的群中抽取所有个体。这种方法适用于总体内群与群之间存在相似性，但群内个体差异较大的情况。</li><li>多阶段抽样：将抽样过程分为多个阶段，每个阶段在前一阶段的基础上进行抽样。这种方法适用于总体内存在层级结构的情况。</li></ol><p>随机抽样的目的是确保样本是随机的、无偏的，从而使样本结果对总体具有代表性。这有助于推断性统计分析，使得通过样本的结果能够对总体的特征进行推断。</p><h1 id="强化学习专业术语">强化学习专业术语</h1><h2 id="state-和-action">state 和 action</h2><p>在强化学习中，状态（state）和动作（action）是两个关键的概念，它们用于描述智能体（agent）与环境（environment）之间的交互和学习过程。</p><ol type="1"><li>状态（State）：状态是描述系统或环境的特定瞬时条件的表示。在强化学习中，状态是智能体观察到的关键信息，它包含了有关环境的所有必要信息，以便智能体可以做出决策。状态可以是离散的或连续的，具体取决于问题的性质。智能体的策略和动作通常依赖于当前的状态。</li><li>动作（Action）：动作是智能体基于当前状态所采取的行为或决策。在强化学习中，智能体从可选的动作中选择一个来影响环境，并进入新的状态。动作可以是离散的，例如在棋盘游戏中的移动一枚棋子，也可以是连续的，例如在机器人控制中的连续运动。</li></ol><p>在强化学习的框架中，智能体与环境之间的互动通常可以描述为一个序列的状态、动作、奖励（reward）和下一个状态。这被称为马尔可夫决策过程（MarkovDecision Process，MDP）。</p><p>奖励（Reward）：每个动作执行后，智能体会收到一个奖励信号，表示该动作的好坏程度。奖励是智能体学习的驱动力，其目标是最大化累积奖励。</p><p>智能体的目标是通过学习从状态到动作的映射，即策略，以最大化期望累积奖励。这个学习过程可以通过不同的强化学习算法来实现，如Q学习、深度Q网络（DQN）、策略梯度方法等。</p><p>总之，状态描述了环境的当前情况，动作是智能体对当前状态的响应，而奖励是系统提供的反馈，用于指导智能体学习正确的行为。这三个元素共同构成了强化学习中的核心概念。</p><h2 id="policy">policy</h2><p>在强化学习中，策略（policy）是智能体（agent）在特定状态下选择动作的规则或策略函数。策略定义了从环境的状态到智能体选择的动作的映射。形式上，对于某一状态(s)，策略可以表示为：<span class="math inline">\(\pi(a|s)\)</span></p><p>其中，(<span class="math inline">\(\pi\)</span>)是策略函数，它告诉我们在状态 (s) 下选择动作 (a)的概率。这可以是一个确定性策略（确定性地选择一个动作）或一个概率性策略（以一定概率选择不同的动作）。</p><p>强化学习中的目标是学习一个最优策略，使得智能体在与环境的交互中获得最大的累积奖励。学习最优策略的方法主要有两类：</p><ol type="1"><li>值函数方法（Value Function Methods）：这类方法通过估计每个状态或状态动作对的值来指导策略的更新。值函数可以是状态值函数（V-function）或动作值函数（Q-function）。根据值函数，可以选择使值最大化的动作。</li><li>直接策略优化方法（Direct Policy Optimization Methods）：这类方法直接对策略进行优化，通过参数化的策略函数来寻找最优的策略。常见的方法包括策略梯度方法，其中通过梯度上升更新策略的参数，使得累积奖励增加。</li></ol><p>一些常见的策略表示方式包括：</p><ol type="1"><li>确定性策略： (<span class="math inline">\(\pi(s) =a\)</span>)，即在每个状态下直接选择一个确定的动作。</li><li>概率性策略： (<span class="math inline">\(\pi(a|s)\)</span>)，即在每个状态下以一定的概率分布选择不同的动作。</li><li>参数化策略：使用一组参数化的函数来表示策略，例如神经网络。这种策略可以通过学习参数的方式进行优化。</li></ol><p>强化学习中策略的选择对于智能体在环境中的表现至关重要。在学习过程中，智能体通过不断尝试不同的策略，根据奖励信号来更新策略，从而逐渐优化其行为。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-1-%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/1733038505321-c20b5b78-b478-4b86-9f5f-5bc94f7b2ad8.png"></p><h2 id="reward">reward</h2><p>在强化学习中，奖励（reward）是环境提供给智能体（agent）的一个信号，用于评估智能体在特定状态下采取特定动作的好坏。奖励是智能体学习和改进其策略的主要驱动力。</p><p>奖励的作用是引导智能体朝着在特定环境下取得更好结果的方向学习。智能体的目标通常是最大化累积奖励，而奖励信号则在每个时间步鼓励或惩罚智能体的行为。</p><p>强化学习中的奖励具有以下一些重要性质：</p><ol type="1"><li>即时奖励（Immediate Reward）：指的是在智能体执行一个动作后立即获得的奖励。即时奖励有助于智能体快速学习适应环境。</li><li>延迟奖励（Delayed Reward）：指的是与智能体的动作相对应但不是立即获得的奖励。例如，智能体在迷宫中走了一段路程后才获得奖励。延迟奖励要求智能体具备长期规划和记忆能力。</li><li>稀疏奖励（Sparse Reward）：指的是在许多状态下，奖励为零或非常小。这可能使得智能体面临挑战，因为它需要在大量无奖励的情况下学会正确的行为。</li><li>稠密奖励（Dense Reward）：指的是在许多状态下，奖励都有非零值。稠密奖励有助于更频繁地提供反馈，促使智能体更快地调整其策略。</li></ol><p>在强化学习任务中，设计有效的奖励结构对于训练稳定、高效的智能体至关重要。合理的奖励设置可以帮助克服挑战，引导智能体学到期望的行为。不同的强化学习问题可能需要不同的奖励设计，以便平衡即时奖励和长期目标，以及稀疏和稠密奖励之间的关系。</p><h2 id="state-transition">state transition</h2><p>在强化学习中，状态转移（statetransition）是指智能体从一个状态转移到另一个状态的过程。状态转移是强化学习中马尔可夫决策过程（MarkovDecisionProcess，MDP）的一部分，其中智能体与环境互动，并根据其采取的动作和环境的反馈来改变状态。</p><p>具体而言，状态转移可以通过一个转移概率函数来表示。对于一个离散时间步(t)，状态 (<span class="math inline">\(s_t\)</span>)，和动作 (<span class="math inline">\(a_t\)</span>)，状态转移函数 (P) 给出了下一个状态(<span class="math inline">\(s_{t+1}\)</span>) 的概率分布：</p><p><span class="math inline">\(P(s_{t+1} | s_t, a_t)\)</span></p><p>这个概率分布表示在当前状态 (<span class="math inline">\(s_t\)</span>)下，执行动作 (<span class="math inline">\(a_t\)</span>)后转移到下一个状态 (<span class="math inline">\(s_{t+1}\)</span>)的概率。在马尔可夫决策过程中，状态转移满足马尔可夫性质，即下一个状态的概率只依赖于当前状态和执行的动作。</p><p>状态转移概率是强化学习算法中的重要组成部分，因为它影响了智能体对环境的理解和学习。智能体根据状态转移的概率分布来估计在不同状态下采取不同动作的结果，从而选择最优的策略来最大化累积奖励。</p><p>在连续状态空间中，状态转移函数可能被替代为状态转移密度函数，通常用概率密度函数来表示状态转移到某个区域的概率。这在连续时间的强化学习问题中很常见。</p><p>总的来说，状态转移是描述强化学习问题中智能体与环境之间交互的重要概念，对于智能体的决策和学习过程至关重要。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-1-%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/1733038769556-3d1641ce-3033-4937-88b8-261c8bf78f77.png"></p><h2 id="rl中的agent和environment的交互">RL中的agent和environment的交互</h2><p>agent采取行动<span class="math inline">\(a_{t}\)</span>，环境会将状态变成<span class="math inline">\(s_{t+1}\)</span>,并且给一个奖励<span class="math inline">\(r_{t}\)</span></p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-1-%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/1733038880989-9bfb59c4-3fde-4c23-a862-a9b6f1af81e5.png"></p><p>让我们通过《超级马里奥兄弟》（Super MarioBros.）这个游戏来解释强化学习中的几个重要概念。</p><ol type="1"><li>状态（State）：在《超级马里奥兄弟》中，状态可以是游戏中马里奥所处的具体位置、当前的生命值、关卡的时间等。每一个瞬时的游戏状态都可以被看作一个状态，它描述了游戏的当前情况。</li><li>动作（Action）：动作是智能体（玩家或马里奥）可以执行的操作，如向左移动、向右跳跃等。在马里奥游戏中，玩家通过按键或操纵杆来执行这些动作，每个动作对应着不同的玩家输入。</li><li>奖励（Reward）：奖励是智能体根据其动作在特定状态下获得的反馈信号。在《超级马里奥兄弟》中，奖励可以是吃到蘑菇增加生命值，通过管道到达新的区域，或者躲避敌人而保持生命等。获得奖励有助于玩家最终完成关卡。</li><li>状态转移（State Transition）：状态转移描述了智能体从一个状态到另一个状态的过程。在游戏中，这可以是玩家控制马里奥移动，穿越管道，跳跃到新的平台等。状态转移与玩家的动作和当前状态密切相关。</li><li>策略（Policy）：在马里奥游戏中，策略是指玩家在特定状态下选择的动作的规则。例如，当马里奥面临一个深坑时，策略可能是选择跳跃以避免掉入坑中。策略可以随着游戏的进行而调整，以最大化累积的奖励。</li><li>环境（Environment）：游戏环境包括了马里奥、敌人、平台、管道等所有与玩家交互的元素。智能体（玩家）与环境互动，智能体的动作影响环境的状态，并产生奖励信号。</li></ol><p>强化学习的目标是学习一个策略，使得在给定状态下选择动作的智能体能够最大化累积奖励，从而高效地完成任务，比如通关关卡。通过理解这些概念，我们可以将强化学习的思想应用于《超级马里奥兄弟》这样的游戏中，以让智能体学会优秀的玩家策略。</p><h2 id="两种随机性">两种随机性</h2><ol type="1"><li>动作的随机性</li></ol><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-1-%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/1733038908727-edcac5c5-b037-4458-9ab1-2d819516a0a0.png"></p><ol start="2" type="1"><li>状态的随机性</li></ol><p>环境用状态转移函数算出概率p，然后随机抽样得到下一个状态<span class="math inline">\(S^{&#39;}\)</span></p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-1-%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/1733039713112-9d5cb7e9-dfad-4218-936a-b4285c59dda2.png"></p><p>这两者的随机性分别来自策略函数和状态转移函数</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-1-%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/1733039734348-1d93db40-e4e4-47e4-979e-fafdc8976d0f.png"></p><h2 id="trajectory">trajectory</h2><p>Trajectory（轨迹）在强化学习中指的是智能体（agent）在环境中执行一系列动作的序列，从初始状态开始，通过与环境的交互，经过一系列状态和动作，最终达到终止状态或满足某个结束条件。Trajectory记录了智能体在环境中的轨迹，描述了其行为的历史。</p><p>一个典型的强化学习轨迹可以用如下表示：</p><p><span class="math inline">\((s_0, a_0, r_1, s_1, a_1, r_2, s_2,\ldots, s_{T-1}, a_{T-1}, r_T, s_T)\)</span></p><p>其中：</p><ul><li>(<span class="math inline">\(s_t\)</span>) 是在时间步 (t)时的状态（state）。</li><li>(<span class="math inline">\(a_t\)</span>) 是在时间步 (t)时智能体选择的动作（action）。</li><li>(<span class="math inline">\(r_{t+1}\)</span>) 是在执行动作 (<span class="math inline">\(a_t\)</span>) 后智能体获得的奖励（reward）。</li><li>(<span class="math inline">\(s_{t+1}\)</span>) 是在执行动作 (<span class="math inline">\(a_t\)</span>)后环境转移到的下一个状态。</li><li><ol start="20" type="A"><li>表示轨迹的结束时刻。</li></ol></li></ul><p>Trajectory包含了智能体与环境的交互历史，对于理解智能体在学习过程中是如何与环境互动的至关重要。在强化学习的许多算法中，学习的目标是通过分析轨迹，优化策略以最大化累积奖励。一些算法如蒙特卡洛方法和时序差分方法都涉及到对轨迹的分析和利用。</p><p>轨迹的长度可以因任务的性质而异，可能是有限的，也可能是无限的（例如，在一个连续的控制问题中）。对轨迹的理解有助于研究智能体的行为模式、评估学习算法的性能，并改进智能体的决策策略。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-1-%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/1733039910750-c4e990c2-8bac-4e15-b85b-142380acc786.png"></p><h2 id="return-和-discounted-return">return 和 discounted return</h2><p>回报（return）是指从当前时刻开始，直到本回合结束的所有奖励的总和，因此回报也被称为累计奖励（cumulativefuture reward）。将时刻 (t) 的回报表示为随机变量 (<span class="math inline">\(U_t\)</span>)。如果一回合游戏结束，已经观测到所有奖励，那么将回报记作(<span class="math inline">\(u_t\)</span>)。设本回合在时刻 (n)结束。定义回报为：</p><p><span class="math inline">\(U_{t} = R_{t} + R_{t+1} + R_{t+2} +R_{t+3} + \ldots + R_{n}\)</span></p><p>回报的应用主要在于它代表了未来获得的奖励总和，因此智能体的目标是让回报尽量大，即越大越好。强化学习的目标是找到一个策略，使得回报的期望最大化，这个策略被称为最优策略（optimumpolicy）。</p><p>强化学习的目标是最大化回报，而不是最大化当前的奖励。以下棋为例，玩家的目标是赢得一局比赛（回报），而不仅仅是吃掉对方当前的一个棋子（奖励）。</p><p>在马尔可夫决策过程（MDP）中，通常使用折扣回报（discountedreturn），对未来的奖励进行折扣。折扣回报的定义如下：</p><p><span class="math inline">\(U_{t} = R_{t} + \gamma \cdot R_{t+1} +\gamma^{2} \cdot R_{t+2} + \gamma^{3} \cdot R_{t+3} +\ldots\)</span></p><p>其中，(<span class="math inline">\(\gamma \in\)</span>[0,1])被称为折扣率。对于越久远的未来，奖励打的折扣越大。这种折扣考虑了时间的因素，使得在计算回报时更加关注即时奖励。</p><p>return: cumulative future reward</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-1-%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/1733040109848-0a1a6339-1242-4144-a870-c97634256a09.png"></p><p>discounted return：cumulative discounted future reward</p><p>未来的reward比现在的reward价值低，所以会加一个折扣因子。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-1-%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/1733040130341-63512a21-c157-4e10-8302-77532c65e1a0.png"></p><p>return的随机性</p><p>discredounted return依赖于<span class="math inline">\(S_t,{A_t},S_{t+1},{A_{t+1}},\cdots,{S_n},{A_n}.\)</span>即return依赖于从t时刻开始的状态和行动</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-1-%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/1733040197542-89477349-5b59-448f-b3dc-d0ea5e9eb60d.png"></p><h2 id="value-functions">value functions</h2><p>action-value function Q(s, a)</p><p>在t 时刻，假如我们知道<span class="math inline">\(U_{t}\)</span>的值，我们就知道游戏是快赢了还是快输了。然而在t 时刻我们并不知道<span class="math inline">\(U_{t}\)</span>的值，因为此时<span class="math inline">\(U_{t}\)</span>仍然是个随机变量。在 t时刻，我们不知道<span class="math inline">\(U_{t}\)</span>的值，而我们又想预判<span class="math inline">\(U_{t}\)</span>的值从而知道局势的好坏。该怎么办呢？解决方案就是对<span class="math inline">\(U_{t}\)</span>求期望，消除掉其中的随机性。</p><p>假设我们已经观测到状态<span class="math inline">\(s_{t}\)</span>，而且做完决策，选中动作<span class="math inline">\(a_{t}\)</span>。那么<span class="math inline">\(U_{t}\)</span>中的随机性来自于 t + 1时刻起的所有的状态和动作：</p><p><span class="math inline">\(S_{t+1}, A_{t+1}, \quad S_{t+2}, A_{t+2},\quad \ldots, \quad S_n, A_n.\)</span></p><p>对<span class="math inline">\(U_t\)</span>关于变量<span class="math inline">\(S_{t+1},A_{t+1},\cdots,S_n,A_n\)</span>求条件期望，得到</p><p><span class="math inline">\(Q_{\pi}(s_{t},a_{t})=\mathbb{E}_{S_{t+1},A_{t+1},\cdots,S_{n},A_{n}}\bigg[U_{t}\bigg|S_{t}=s_{t},A_{t}=a_{t}\bigg].\)</span></p><p>期望中的<span class="math inline">\(S_t=s_t\)</span>和<span class="math inline">\(A_t=a_t\)</span>是条件，意思是已经观测到<span class="math inline">\(S_t\)</span>与<span class="math inline">\(A_t\)</span>的值。条件期望的结果<span class="math inline">\(Q_\pi(s_t,a_t)\)</span>被称作动作价值函数(action-value function)。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-1-%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/1733041025664-87ceab77-561e-4a79-8eba-06774dd45b63.png"></p><p>动作价值函数<span class="math inline">\(Q_\pi(s_t,a_t)\)</span>依赖于<span class="math inline">\(s_t\)</span>与<span class="math inline">\(a_t\)</span>, 而不依赖于<span class="math inline">\(t+1\)</span>时刻及其之后的状态和动作，因为随机变量<span class="math inline">\(S_{t+1},A_{t+1},\cdots,S_n,A_n\)</span>都被期望消除了。由于动作<span class="math inline">\(A_{t+1},\cdots,A_n\)</span>的概率质量函数都是<span class="math inline">\(\pi\)</span>,公式中的期望依赖于<span class="math inline">\(\pi\)</span>;用不同的<span class="math inline">\(\pi\)</span>, 求期望得出的结果就会不同。因此<span class="math inline">\(Q_\pi(s_t,a_t)\)</span>依赖于π,这就是为什么动作价值函数有下标 π。</p><p>综上所述，t时刻的动作价值函数<span class="math inline">\(Q_\pi(s_t,a_t)\)</span>依赖于以下三个因素：</p><ul><li>第一，当前状态<span class="math inline">\(s_t\)</span>。当前状态越好，那么价值<span class="math inline">\(Q_\pi(s_t,a_t)\)</span>越大，也就是说回报的期望值越大。在超级玛丽的游戏中，如果玛丽奥当前已经接近终点，那么<span class="math inline">\(Q_\pi(s_t,a_t)\)</span>就非常大。</li><li>第二，当前动作<span class="math inline">\(a_t\)</span>。智能体执行的动作越好，那么价值<span class="math inline">\(Q_\pi(s_t,a_t)\)</span>越大。举个例子，如果玛丽奥做正常的动作，那么<span class="math inline">\(Q_\pi(s_t,a_t)\)</span>就比较正常。如果玛丽奥的动作<span class="math inline">\(a_t\)</span>是跳下悬崖，那么<span class="math inline">\(Q_\pi(s_t,a_t)\)</span>就会非常小。</li><li>第三，策略函数π。策略决定未来的动作<span class="math inline">\(A_{t+1},A_{t+2},\cdots,A_n\)</span>的好坏：策略越好，那么<span class="math inline">\(Q_\pi(s_t,a_t)\)</span>就越大。举个例子，顶级玩家相当于好的策略π,新手相当于差的策略。让顶级玩家操作游戏，回报的期望非常高。换新手操作游戏，从相同的状态出发，回报的期望会很低。</li></ul><p><strong>optimal action-value function</strong>最优动作价值函数</p><p>怎么样才能排除掉策略 π的影响，只评价当前状态和动作的好坏呢？解决方案就是最优动作价值函数(optimal action-value function):</p><p><span class="math inline">\(Q_{\star}(s_{t},a_{t})\:=\:\operatorname*{max}_{\pi}\:Q_{\pi}(s_{t},a_{t}),\quad\forall\:s_{t}\in\mathcal{S},\quada_{t}\in\mathcal{A}.\)</span></p><p>意思就是有很多种策略函数π可供选择，而我们选择最好的策略函数：</p><p><span class="math inline">\(\pi^{\star}\:=\:\operatorname*{argmax}_{\pi}\:Q_{\pi}(s_{t},a_{t}),\quad\forall\:s_{t}\in\mathcal{S},\quada_{t}\in\mathcal{A}.\)</span></p><p>最优动作价值函数<span class="math inline">\(Q_\star(s_t,a_t)\)</span>只依赖于<span class="math inline">\(s_t\)</span>和<span class="math inline">\(a_t\)</span>, 而与策略 π 无关。</p><p>最优动作价值函数<span class="math inline">\(Q_{\star}\)</span>非常有用，它就像是一个先知，能指引智能体做出正确决策。比如玩超级玛丽，给定当前状态<span class="math inline">\(s_t\)</span>,智能体该执行动作空间<span class="math inline">\(\mathcal{A}=\)</span>{左，右，上}中的哪个动作呢？假设我们已知<span class="math inline">\(Q_{\star}\)</span>函数，那么我们就让<span class="math inline">\(Q_{\star}\)</span>给三个动作打分，比如：</p><p><span class="math inline">\(Q_{\star}(s_{t},\:\text{左})\:=\:130,\quadQ_{\star}(s_{t},\:\text{右})\:=\:-50,\quadQ_{\star}(s_{t},\:\text{上})\:=\:296.\)</span></p><p>这三个值是什么意思呢？</p><p><span class="math inline">\(Q_\star ( s_t, 左) =130\)</span>的意思是：如果现在智能体选择向左走，那么不管以后智能体用什么策略函数π,回报<span class="math inline">\(U_t\)</span>的期望最多不会超过130。同理，如果现在向右走，则回报的期望最多不超过-50。如果现在向上跳，则回报的期望最多不超过296。</p><p>智能体应该执行哪个动作呢？毫无疑问，智能体当然应该向上跳，这样才能有希望获得尽量高的回报。</p><p><strong>state-value funciton </strong>状态价值函数</p><p>假设 AI 用策略函数 π 下围棋。AI 想知道当前状态<span class="math inline">\(s_t\)</span>(即棋盘上的格局)是否对自已有利，以及自己和对手的胜算各有多大。该用什么来量化双方的胜算呢？答案是状态价值函数(state-value function):</p><p><span class="math inline">\(V_{\pi}(s_{t}) = \mathbb{E}_{A_{t} \sim\pi(\cdot \mid s_{t})} \left[ Q_{\pi}(s_{t}, A_{t}) \right] \\= \sum_{a\in A} \pi(a \mid s_{t}) \cdot Q_{\pi}(s_{t}, a).\)</span></p><p>公式里把动作<span class="math inline">\(A_t\)</span>作为随机变量，然后关于<span class="math inline">\(A_t\)</span>求期望，把<span class="math inline">\(A_t\)</span>消掉。得到的状态价值函数<span class="math inline">\(V_\pi(s_t)\)</span>只依赖于策略 π 与当前状态<span class="math inline">\(s_t\)</span>, 不依赖于动作。</p><p>状态价值函数<span class="math inline">\(V_{\pi}(s_t)\)</span>也是回报<span class="math inline">\(U_t\)</span>的期望：</p><p><span class="math inline">\(V_\pi(s_t)~=~\mathbb{E}_{A_t,S_{t+1},A_{t+1},\cdots,S_n,A_n}\left[U_t\Big|S_t=s_t\right].\)</span></p><p>期望消掉了<span class="math inline">\(U_t\)</span>依赖的随机变量<span class="math inline">\(A_t,S_{t+1},A_{t+1},\cdots,S_n,A_n\)</span>。状态价值越大，就意味着回报的期望越大。用状态价值可以衡量策略π与状态<span class="math inline">\(s_t\)</span>的好坏。</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-1-%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/1733043600217-49583593-72fa-4d78-af72-b83537f36023.png"></p><p>上面的期望计算：对所有可能的动作按照策略 π 的概率进行加权求和</p><p>Understanding the Value Functions</p><ul><li>Action-value function:<span class="math inline">\(Q_\pi(s,\color{red}{a})=\mathbb{E}\left[U_t|S_t=s,\color{red}{A_t=a}\right].\)</span></li><li>Given policy π ,<span class="math inline">\(Q_{\pi}(s,\color{red}{\alpha})\)</span>evaluateshow good it is for an agent to pick action<span class="math inline">\(\color{blue}{a}\)</span>while being in states.</li><li>State-value function:<span class="math inline">\(V_{\pi}(s)=\mathbb{E}_{\color{red}{A}}\left[Q_{\pi}(s,A)\right]\)</span></li><li>For fixed policy π ,<span class="math inline">\(V_{\pi}(s)\)</span>evaluates how good thesituation is in state s. +<span class="math inline">\(\mathbb{E}_S[V_\pi(S)]\)</span>evaluates how goodthe policy π is.</li></ul><p>AI如何控制agent？</p><p>两种方法：</p><p>policy-based RL 和 value-based RL</p><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-1-%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/1733043910681-4e0dd925-e3af-4601-93cf-d3fd43a09cb9.png"></p><p>Policy-based Reinforcement Learning（基于策略的强化学习）和Value-based ReinforcementLearning（基于值的强化学习）是强化学习中两种主要的方法，它们在解决问题的策略和价值函数的表示上有所不同。</p><p>Policy-based RL (基于策略的强化学习):</p><p>特点：</p><ul><li>直接学习最优策略，而不是通过价值函数间接得到。</li><li>策略通常表示为一个参数化的概率分布，例如高斯分布。</li><li>直接优化策略参数以最大化累积奖励。</li><li>在连续动作空间和高维状态空间中表现良好，适用于非确定性策略。</li></ul><p>优势：</p><ul><li>可以处理高度非线性和连续动作空间。</li><li>收敛性更好，特别适用于大规模、高维度的问题。</li></ul><p>缺点：</p><ul><li>训练通常更为计算密集。</li><li>对样本效率要求较高。</li></ul><p>Value-based RL (基于值的强化学习):</p><p>特点：</p><ul><li>通过价值函数（通常是状态值函数或动作值函数）来评估动作或状态的好坏。</li><li>通常使用贝尔曼方程来更新价值函数。</li><li>通过最优值函数来选择最优动作。</li></ul><p>优势：</p><ul><li>通常更为稳定，对样本效率的要求较低。</li><li>在有限状态、离散动作的问题中表现良好。</li></ul><p>缺点：</p><ul><li>对于连续动作空间和高维状态空间的处理可能不够灵活。</li><li>可能会收敛到局部最优解，特别是在非线性问题上。</li></ul><p>共同点：</p><ul><li>目标是学习一个在不同状态或状态-动作对上的策略，以最大化累积奖励。</li><li>两者都依赖于策略评估和改进的迭代过程。</li></ul><p>结论：</p><ul><li>选择基于策略的方法还是基于值的方法通常取决于具体问题的性质和对问题的建模方式。在实际应用中，有时会结合两者，使用Actor-Critic等混合方法，以发挥它们的优势并弥补彼此的不足。</li></ul><h2 id="summary">summary</h2><p><img src="/2024/12/04/DRL-%E7%8E%8B%E6%A0%91%E6%A3%AE/1-1-%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/1733044015508-8c2e1424-1677-47cf-8fac-7b19ea83c0a3.png"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>RL</category>
      
      <category>DRL-王树森</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. 初探强化学习</title>
    <link href="/2024/11/29/%E5%8A%A8%E6%89%8B%E5%AD%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/1-%E5%88%9D%E6%8E%A2%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/11/29/%E5%8A%A8%E6%89%8B%E5%AD%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/1-%E5%88%9D%E6%8E%A2%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="强化学习简介">1. 强化学习简介</h1><h2 id="两种人工智能任务类型">1.1 两种人工智能任务类型</h2><ol type="1"><li>预测型任务<ol type="1"><li>根据数据预测所需输出（有监督学习）</li><li>生成数据实例（无监督学习）</li></ol></li><li>决策型任务<ol type="1"><li>在动态环境中采取行动（强化学习）<ol type="1"><li>转变到新的状态</li><li>获得即时奖励</li><li>随着时间的推移最大化累计奖励 (Learning from interaction in atrial-and-error manner)</li></ol></li></ol></li></ol><h2 id="强化学习定义">1.2 强化学习定义</h2><ol type="1"><li>通过从交互中学习来实现目标的计算方法</li></ol><p><img src="/2024/11/29/%E5%8A%A8%E6%89%8B%E5%AD%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/1-%E5%88%9D%E6%8E%A2%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20241129165412336.png"></p><ol start="2" type="1"><li>三个方面：<ol type="1"><li>感知：在某种程度上感知环境的状态</li><li>行动：可以采取行动来影响状态或者达到目标</li><li>目标：随着时间推移最大化累积奖励</li></ol></li></ol><h2 id="强化学习交互过程">1.3 强化学习交互过程</h2><p><img src="/2024/11/29/%E5%8A%A8%E6%89%8B%E5%AD%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/1-%E5%88%9D%E6%8E%A2%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20241129165606063.png"></p><h2 id="强化学习系统要素">1.4 强化学习系统要素</h2><ol type="1"><li>历史（History）是观察、行动和奖励的序列</li></ol><figure><img src="/2024/11/29/%E5%8A%A8%E6%89%8B%E5%AD%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/1-%E5%88%9D%E6%8E%A2%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20241129165858441.png" alt="image-20241129165858441"><figcaption aria-hidden="true">image-20241129165858441</figcaption></figure><ul><li><p>即，一直到时间t 为止的所有可观测变量</p></li><li><p>根据这个历史可以决定接下来会发生什么</p><ul><li>智能体选择行动</li><li>环境选择观察和奖励</li></ul></li></ul><ol start="2" type="1"><li>状态（state）是一种用于确定接下来会发生的事情（行动、观察、奖励）的信息</li></ol><ul><li>状态是关于历史的函数S<sub>t</sub>= 𝑓(𝐻𝑡)</li></ul><ol start="3" type="1"><li>策略（Policy）是学习智能体在特定时间的行为方式</li></ol><ul><li>是从状态到行动的映射</li><li>确定性策略（Deterministic Policy）</li></ul><p><img src="/2024/11/29/%E5%8A%A8%E6%89%8B%E5%AD%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/1-%E5%88%9D%E6%8E%A2%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20241129170233940.png"></p><ul><li>随机策略（Stochastic Policy）</li></ul><p><img src="/2024/11/29/%E5%8A%A8%E6%89%8B%E5%AD%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/1-%E5%88%9D%E6%8E%A2%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20241129170244901.png"></p><ol start="4" type="1"><li>奖励（Reward）R(𝑠,𝑎)</li></ol><ul><li>一个定义强化学习目标的标量</li><li>能立即感知到什么是“好”的</li></ul><ol start="5" type="1"><li>价值函数（Value Function）</li></ol><ul><li>状态价值是一个标量，用于定义对于长期来说什么是 “好”的</li><li>价值函数是对于未来累积奖励的预测<ul><li>用于评估在给定的策略下，状态的好坏</li></ul></li></ul><p><img src="/2024/11/29/%E5%8A%A8%E6%89%8B%E5%AD%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/1-%E5%88%9D%E6%8E%A2%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20241129170348176.png"></p><ol start="6" type="1"><li><p>环境的模型（Model）用于模拟环境的行为</p></li><li><p>预测下一个状态(状态转移)</p></li></ol><p><img src="/2024/11/29/%E5%8A%A8%E6%89%8B%E5%AD%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/1-%E5%88%9D%E6%8E%A2%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20241129170621857.png"></p><ol start="2" type="1"><li>预测下一个（立即）奖励（奖励函数）</li></ol><p><img src="/2024/11/29/%E5%8A%A8%E6%89%8B%E5%AD%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/1-%E5%88%9D%E6%8E%A2%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20241129170644835.png"></p><h2 id="强化学习智能体分类">1.5 强化学习智能体分类</h2><ol type="1"><li>基于模型的强化学习<ol type="1"><li>策略（和/或）价值函数</li><li>环境模型</li><li>比如：上述迷宫游戏，围棋等奖励</li></ol></li><li>模型无关的强化学习<ol type="1"><li>策略（和/或）价值函数</li><li>没有环境模型</li><li>比如：Atari游戏的通用策略</li></ol></li></ol><h2 id="强化学习的方法分类">1.6 强化学习的方法分类</h2><ol type="1"><li>基于价值：知道什么是好的什么是坏的<ol type="1"><li>没有策略（隐含）</li><li>价值函数</li></ol></li></ol><p><img src="/2024/11/29/%E5%8A%A8%E6%89%8B%E5%AD%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/1-%E5%88%9D%E6%8E%A2%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20241129171233751.png"></p><ol start="2" type="1"><li>基于策略：知道怎么行动<ol type="1"><li>策略</li><li>没有价值函数</li></ol></li><li>Actor-Critic：学生听老师的<ol type="1"><li>策略</li><li>价值函数</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>RL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kimi指令精读论文</title>
    <link href="/2024/11/29/tools/kimi%E8%AF%BB%E8%AE%BA%E6%96%87/"/>
    <url>/2024/11/29/tools/kimi%E8%AF%BB%E8%AE%BA%E6%96%87/</url>
    
    <content type="html"><![CDATA[<h1 id="安装zetore-和-浏览器插件">1. 安装zetore 和 浏览器插件</h1><ol type="1"><li>安装Zotero6和Google浏览器插件Zotero Connector</li><li>设置语言<ol type="1"><li>编辑-&gt;首选项-&gt;高级-&gt;常规</li><li>选择中文简体</li></ol></li><li>设置文件存储位置</li><li>新建分类</li><li>导入文献<ol type="1"><li>英文文献，点击zotero插件即可<ol type="1"><li>doi</li></ol></li><li>中文<ol type="1"><li>安装茉莉花插件 <a href="https://zotero-zh.netlify.app/plugins/#search=Jasminum">https://zotero-zh.netlify.app/plugins/#search=Jasminum</a>选择对应的zotero版本</li><li>打开工具-&gt;附加组件，将下载好的茉莉花插件拖入即可</li><li>更新应用插件和浏览器插件</li></ol></li></ol></li><li>移动条目<ol type="1"><li>长按shift拖动即可移动到其他分组</li></ol></li></ol><h1 id="kimi指令精读论文">2. kimi指令精读论文</h1><ol type="1"><li>指令1请你阅读并理解这篇文献，然后将该篇文章的标题作为一级标题，将摘要和各个大标题作为二级标题，将小标题作为三级标题将小标题下每一部分内容作为四级标题，给我以markdown的语言输出中文的翻译。去掉致谢和参考文献的部分。</li><li>指令2请你以该篇文章的标题为一级标题，分别以1该篇文章的研究目的、“2该篇文章的研究方法”、“3该篇文章的研究内容、“4该篇文章的最大创新点、“5.该篇文章给我们的启发”为二级标题。总结的这五部分内容作为三级表题，拾我总结后以narkdownl的语言输出。</li><li>指令3请你对该文章中的所有的图例和表例技照顺序给我依次翻译成中文。</li><li>指令4这是图X,请你结合该篇文章内容，首先给我介绍每个图中的横坐标和纵坐标各自表示的含义，然后针对每一个图给我详细的解释，</li><li>指令5我对”X内容不是很理解，请你用通俗的语言给我解释，并给我举出一个实例以上我更加深刻的理解。</li></ol><h1 id="辅助工具">3. 辅助工具</h1><ol type="1"><li><p>quillbot 英文润色</p></li><li><p>grammarly 英语语法</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
      <category>阅读论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kimi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10. std::atomic</title>
    <link href="/2024/11/27/cpp-%E5%A4%9A%E7%BA%BF%E7%A8%8B/10-std-atomic/"/>
    <url>/2024/11/27/cpp-%E5%A4%9A%E7%BA%BF%E7%A8%8B/10-std-atomic/</url>
    
    <content type="html"><![CDATA[<p><code>std::atomic</code> 是 C++11标准库中的一个模板类，用于实现多线程环境下的原子操作。它提供了一种线程安全的方式来访问和修改共享变量，可以避免多线程环境中的数据竞争问题。</p><p><code>std::atomic</code> 的使用方式类似于普通的 C++变量，但是它的操作是原子性的。也就是说，在多线程环境下，多个线程同时对同一个<code>std::atomic</code> 变量进行操作时，不会出现数据竞争问题。</p><p>以下是一些常用的 <code>std::atomic</code> 操作：</p><p>\1. <code>load()</code>：将 <code>std::atomic</code>变量的值加载到当前线程的本地缓存中，并返回这个值。</p><p>\2. <code>store(val)</code>：将 <code>val</code> 的值存储到<code>std::atomic</code> 变量中，并保证这个操作是原子性的。</p><p>\3. <code>exchange(val)</code>：将 <code>val</code> 的值存储到<code>std::atomic</code> 变量中，并返回原先的值。</p><p>4.<code>compare_exchange_weak(expected, val)</code> 和<code>compare_exchange_strong(expected, val)</code>：比较<code>std::atomic</code> 变量的值和 <code>expected</code>的值是否相同，如果相同，则将 <code>val</code> 的值存储到<code>std::atomic</code> 变量中，并返回 <code>true</code>；否则，将<code>std::atomic</code> 变量的值存储到 <code>expected</code> 中，并返回<code>false</code>。</p><p>以下是一个示例，演示了如何使用 <code>std::atomic</code>进行原子操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br>std::atomic&lt;<span class="hljs-type">int</span>&gt; count = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; ++i) &#123;<br>        count++;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(increment)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(increment)</span></span>;<br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; count &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个 <code>std::atomic&lt;int&gt;</code>类型的变量 <code>count</code>，并将其初始化为0。然后，我们启动两个线程分别执行 <code>increment</code>函数，这个函数的作用是将 <code>count</code>变量的值加一，执行一百万次。最后，我们在主线程中输出 <code>count</code>变量的值。由于 <code>count</code> 变量是一个 <code>std::atomic</code>类型的变量，因此对它进行操作是原子性的，不会出现数据竞争问题。在这个示例中，最终输出的<code>count</code> 变量的值应该是 2000000</p><p>原子性数据效率更高。</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++11 多线程编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9.异步并发—— async future packaged_task promise</title>
    <link href="/2024/11/27/cpp-%E5%A4%9A%E7%BA%BF%E7%A8%8B/9-%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%20async%20future%20packaged_task%20promise/"/>
    <url>/2024/11/27/cpp-%E5%A4%9A%E7%BA%BF%E7%A8%8B/9-%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%20async%20future%20packaged_task%20promise/</url>
    
    <content type="html"><![CDATA[<p><strong>1. async 、 future</strong></p><p>是C++11引入的一个函数模板，用于异步执行一个函数，并返回一个std::future对象，表示异步操作的结果。使用std::async可以方便地进行异步编程，避免了手动创建线程和管理线程的麻烦。下面是一个使用std::async的案例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 模拟一个耗时的计算</span><br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::future&lt;<span class="hljs-type">int</span>&gt; future_result <br>    = std::<span class="hljs-built_in">async</span>(std::launch::async, calculate);<br>    <span class="hljs-comment">// 在这里可以做其他的事情</span><br>    <span class="hljs-type">int</span> result = future_result.<span class="hljs-built_in">get</span>(); <span class="hljs-comment">// 获取异步操作的结果</span><br>    std::cout &lt;&lt; result &lt;&lt; std::endl; <span class="hljs-comment">// 输出42</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子中，我们使用std::async函数异步执行了一个耗时的计算，这个计算可以在另一个线程中执行，不会阻塞主线程。同时，我们也避免了手动创建线程和管理线程的麻烦。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)<br>&#123;<br>i++;<br>&#125;<br><span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::future&lt;<span class="hljs-type">int</span>&gt; future_result = std::<span class="hljs-built_in">async</span>(std::launch::async, func);<br>cout &lt;&lt; <span class="hljs-built_in">func</span>() &lt;&lt; endl;<br><br>cout &lt;&lt; future_result.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2. packaged_task</strong></p><p>在C++中，packaged_task是一个类模板，用于将一个可调用对象（如函数、函数对象或Lambda表达式）封装成一个异步操作，并返回一个std::future对象，表示异步操作的结果。packaged_task可以方便地将一个函数或可调用对象转换成一个异步操作，供其他线程使用。</p><p>以下是packaged_task的基本用法：</p><p>\1. 定义可调用对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里定义了一个函数calculate，用于将两个整数相加。 \2.创建packaged_task对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::packaged_task&lt;<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>&gt; <span class="hljs-title">task</span><span class="hljs-params">(calculate)</span></span>;<br>std::future&lt;<span class="hljs-type">int</span>&gt; future_result = task.<span class="hljs-built_in">get_future</span>();<br></code></pre></td></tr></table></figure><p>这里创建了一个packaged_task对象，将函数calculate封装成异步操作，并返回一个std::future对象，表示异步操作的结果。</p><p>\3. 在其他线程中执行异步操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(std::move(task), <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>t.<span class="hljs-built_in">join</span>();<br></code></pre></td></tr></table></figure><p>这里创建了一个新的线程，并在这个线程中执行异步操作。由于packaged_task对象是可移动的，因此需要使用std::move()函数将task对象转移至新线程中执行。</p><p>\4. 获取异步操作的结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> result = future_result.<span class="hljs-built_in">get</span>();<br>std::cout &lt;&lt; result &lt;&lt; std::endl; <span class="hljs-comment">// 输出3</span><br></code></pre></td></tr></table></figure><p>在主线程中，我们可以使用future_result.get()方法获取异步操作的结果，并输出到控制台。在这个例子中，我们成功地将一个函数calculate封装成了一个异步操作，并在其他线程中执行。通过packaged_task和future对象，我们可以方便地实现异步编程，使得代码更加简洁和易于维护。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)<br>&#123;<br>i++;<br>&#125;<br><span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">std::packaged_task&lt;<span class="hljs-title">int</span><span class="hljs-params">()</span>&gt; <span class="hljs-title">task</span><span class="hljs-params">(func)</span></span>;<br><span class="hljs-keyword">auto</span> future_result = task.<span class="hljs-built_in">get_future</span>();<br><br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(std::move(task))</span></span>;<br>cout &lt;&lt; <span class="hljs-built_in">func</span>() &lt;&lt; endl;<br><br>t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>cout &lt;&lt; future_result.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3. promise</strong></p><p>在C++中，promise是一个类模板，用于在一个线程中产生一个值，并在另一个线程中获取这个值。promise通常与future和async一起使用，用于实现异步编程。</p><p>以下是promise的基本用法： \1. 创建promise对象 std::promise<int>p;</int></p><p>这里创建了一个promise对象，用于产生一个整数值。</p><p>\2. 获取future对象 std::future<int> f = p.get_future();</int></p><p>通过promise对象的get_future()方法，可以获取与之关联的future对象，用于在另一个线程中获取promise对象产生的值。</p><p>\3. 在其他线程中设置值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">([&amp;p]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    p.set_value(<span class="hljs-number">42</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span></span>;<br>t.<span class="hljs-built_in">join</span>();<br></code></pre></td></tr></table></figure><p>这里创建了一个新的线程，并在这个线程中，使用promise对象的set_value()方法设置一个整数值42。</p><p>\4. 在主线程中获取值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> result = f.<span class="hljs-built_in">get</span>();<br>std::cout &lt;&lt; result &lt;&lt; std::endl; <span class="hljs-comment">// 输出42</span><br></code></pre></td></tr></table></figure><p>在主线程中，我们可以使用future对象的get()方法获取promise对象产生的值，并输出到控制台。</p><p>在这个例子中，我们成功地使用promise和future对象实现了跨线程的值传递。通过promise和future对象，我们可以方便地实现异步编程，避免了手动创建线程和管理线程的麻烦。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(std::promise&lt;<span class="hljs-type">int</span>&gt;&amp; f)</span> </span>&#123;<br>f.<span class="hljs-built_in">set_value</span>(<span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::promise&lt;<span class="hljs-type">int</span>&gt; f;<br><span class="hljs-keyword">auto</span> future_result = f.<span class="hljs-built_in">get_future</span>();<br><br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func, std::ref(f))</span></span>;<br><br>t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br><br>cout &lt;&lt; future_result.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++11 多线程编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8. C++11 跨平台线程池</title>
    <link href="/2024/11/27/cpp-%E5%A4%9A%E7%BA%BF%E7%A8%8B/8-Cpp11%20%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2024/11/27/cpp-%E5%A4%9A%E7%BA%BF%E7%A8%8B/8-Cpp11%20%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>跨平台线程池实现</strong></p><p>它使用 C++11 标准库中的std::thread、std::mutex、std::condition_variable、std::function 和std::queue 等组件实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">ThreadPool</span>(<span class="hljs-type">int</span> numThreads) : <span class="hljs-built_in">stop</span>(<span class="hljs-literal">false</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numThreads; ++i) &#123;<br>        threads.<span class="hljs-built_in">emplace_back</span>([<span class="hljs-keyword">this</span>] &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                std::unique_lock&lt;std::mutex&gt; <span class="hljs-built_in">lock</span>(mutex);<br>                condition.<span class="hljs-built_in">wait</span>(lock, [<span class="hljs-keyword">this</span>] &#123; <span class="hljs-keyword">return</span> stop || !tasks.<span class="hljs-built_in">empty</span>(); &#125;);<br>                <span class="hljs-keyword">if</span> (stop &amp;&amp; tasks.<span class="hljs-built_in">empty</span>()) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                std::function&lt;<span class="hljs-built_in">void</span>()&gt; <span class="hljs-built_in">task</span>(std::<span class="hljs-built_in">move</span>(tasks.<span class="hljs-built_in">front</span>()));<br>                tasks.<span class="hljs-built_in">pop</span>();<br>                lock.<span class="hljs-built_in">unlock</span>();<br>                <span class="hljs-built_in">task</span>();<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br>~<span class="hljs-built_in">ThreadPool</span>() &#123;<br>    &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex)</span></span>;<br>        stop = <span class="hljs-literal">true</span>;<br>    &#125;<br>    condition.<span class="hljs-built_in">notify_all</span>();<br>    <span class="hljs-keyword">for</span> (std::thread&amp; thread : threads) &#123;<br>        thread.<span class="hljs-built_in">join</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> </span>&#123;<br>    <span class="hljs-function">std::function&lt;<span class="hljs-title">void</span><span class="hljs-params">()</span>&gt; <span class="hljs-title">task</span><span class="hljs-params">(std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...))</span></span>;<br>    &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex)</span></span>;<br>        tasks.<span class="hljs-built_in">emplace</span>(std::<span class="hljs-built_in">move</span>(task));<br>    &#125;<br>    condition.<span class="hljs-built_in">notify_one</span>();<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>std::vector&lt;std::thread&gt; threads;<br>std::queue&lt;std::function&lt;<span class="hljs-type">void</span>()&gt;&gt; tasks;<br>std::mutex mutex;<br>std::condition_variable condition;<br><span class="hljs-type">bool</span> stop;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">ThreadPool <span class="hljs-title">pool</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; ++i) &#123;<br>        pool.<span class="hljs-built_in">enqueue</span>([i] &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Task &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; is running in thread &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; std::endl;<br>            std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Task &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; is done&quot;</span> &lt;&lt; std::endl;<br>        &#125;);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们同样定义了一个 ThreadPool类，并且在构造函数中创建了指定数目的线程。在每个线程中，我们不断地从任务队列中获取任务并执行，直到线程池被停止。在enqueue() 函数中，我们将任务封装成一个 std::function对象，并将它添加到任务队列中。在 ThreadPool的析构函数中，我们等待所有线程执行完成后再停止所有线程。</p><p>在主函数中，我们创建了一个 ThreadPool 对象，并向任务队列中添加了 8个任务。每个任务会输出一些信息，并且在执行完后等待 1秒钟。由于线程池中有 4 个线程，因此这 8个任务会被分配到不同的线程中执行。在任务执行完成后，程序会退出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">ThreadPool</span>(<span class="hljs-type">int</span> numThreads) :<span class="hljs-built_in">stop</span>(<span class="hljs-literal">false</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numThreads; i++) &#123;<br>threads.<span class="hljs-built_in">emplace_back</span>([<span class="hljs-keyword">this</span>] &#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>std::unique_lock&lt;std::mutex&gt; <span class="hljs-built_in">lock</span>(mtx);<br>condition.<span class="hljs-built_in">wait</span>(lock, [<span class="hljs-keyword">this</span>] &#123;<br><span class="hljs-keyword">return</span> !tasks.<span class="hljs-built_in">empty</span>() || stop;<br>&#125;);<br><span class="hljs-keyword">if</span> (stop &amp;&amp; tasks.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>std::function&lt;<span class="hljs-built_in">void</span>()&gt; <span class="hljs-built_in">task</span>(std::<span class="hljs-built_in">move</span>(tasks.<span class="hljs-built_in">front</span>()));<br>tasks.<span class="hljs-built_in">pop</span>();<br>lock.<span class="hljs-built_in">unlock</span>();<br><span class="hljs-built_in">task</span>();<br>&#125;<br>&#125;);<br>&#125;<br>&#125;<br><br>~<span class="hljs-built_in">ThreadPool</span>() &#123;<br>&#123;<br><span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>stop = <span class="hljs-literal">true</span>;<br>&#125;<br><br><br>condition.<span class="hljs-built_in">notify_all</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; t : threads) &#123;<br>t.<span class="hljs-built_in">join</span>();<br>&#125;<br>&#125;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">F</span>, <span class="hljs-keyword">class</span>... Args&gt;<span class="hljs-comment">//函数模板里右值引用是万能引用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> </span>&#123;<br>std::function&lt;<span class="hljs-type">void</span>()&gt; task = <br>std::<span class="hljs-built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);<br>&#123;<br><span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>tasks.<span class="hljs-built_in">emplace</span>(std::<span class="hljs-built_in">move</span>(task));<br>&#125;<br>condition.<span class="hljs-built_in">notify_one</span>();<br><br>&#125;<br><br><br><span class="hljs-keyword">private</span>:<br>std::vector&lt;std::thread&gt; threads;<br>std::queue&lt;std::function&lt;<span class="hljs-type">void</span>()&gt;&gt; tasks;<br><br>std::mutex mtx;<br>std::condition_variable condition;<br><br><span class="hljs-type">bool</span> stop;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">ThreadPool <span class="hljs-title">pool</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>pool.<span class="hljs-built_in">enqueue</span>([i] &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;task : &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; is running&quot;</span> &lt;&lt; std::endl;<br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));<br>std::cout &lt;&lt; <span class="hljs-string">&quot;task : &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; is done&quot;</span> &lt;&lt; std::endl;<br>&#125;);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++11 多线程编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.condition_variable 与其使用场景</title>
    <link href="/2024/11/27/cpp-%E5%A4%9A%E7%BA%BF%E7%A8%8B/7-condition_variable%E4%B8%8E%E5%85%B6%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <url>/2024/11/27/cpp-%E5%A4%9A%E7%BA%BF%E7%A8%8B/7-condition_variable%E4%B8%8E%E5%85%B6%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<p>std::condition_variable 的步骤如下：</p><ol type="1"><li>创建一个 std::condition_variable 对象。</li><li>创建一个互斥锁 std::mutex 对象，用来保护共享资源的访问。</li><li>在需要等待条件变量的地方使用 std::unique_lock<std::mutex>对象锁定互斥锁并调用std::condition_variable::wait()、std::condition_variable::wait_for() 或std::condition_variable::wait_until() 函数等待条件变量。</std::mutex></li><li>在其他线程中需要通知等待的线程时，调用std::condition_variable::notify_one() 或std::condition_variable::notify_all() 函数通知等待的线程。</li></ol><p><strong>生产者与消费者模型</strong></p><p>下面是一个简单的生产者-消费者模型的案例，其中使用了<code>std::condition_variable</code> 来实现线程的等待和通知机制：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br>std::mutex g_mutex;<br>std::condition_variable g_cv;<br>std::queue&lt;<span class="hljs-type">int</span>&gt; g_queue;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Producer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        &#123;            <br>            <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(g_mutex)</span></span>;<br>            g_queue.<span class="hljs-built_in">push</span>(i);            <br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Producer: produced &quot;</span> &lt;&lt; i &lt;&lt; std::endl;<br>        &#125;<br>        g_cv.<span class="hljs-built_in">notify_one</span>();        <br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">100</span>));<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Consumer</span><span class="hljs-params">()</span> </span>&#123;    <br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;        <br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(g_mutex)</span></span>;<br>        g_cv.<span class="hljs-built_in">wait</span>(lock, []() &#123; <span class="hljs-keyword">return</span> !g_queue.<span class="hljs-built_in">empty</span>(); &#125;);        <br>        <span class="hljs-type">int</span> value = g_queue.<span class="hljs-built_in">front</span>();<br>        g_queue.<span class="hljs-built_in">pop</span>();        <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Consumer: consumed &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <br>    <span class="hljs-function">std::thread <span class="hljs-title">producer_thread</span><span class="hljs-params">(Producer)</span></span>;    <br>    <span class="hljs-function">std::thread <span class="hljs-title">consumer_thread</span><span class="hljs-params">(Consumer)</span></span>;<br>    producer_thread.<span class="hljs-built_in">join</span>();<br>    consumer_thread.<span class="hljs-built_in">join</span>();    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>std::condition_variable</code>可以实现线程的等待和通知机制，从而在多线程环境中实现同步操作。在生产者-消费者模型中，使用<code>std::condition_variable</code>可以让消费者线程等待生产者线程生产数据后再进行消费，避免了数据丢失或者数据不一致的问题。</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++11 多线程编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.std::call_once与其使用场景</title>
    <link href="/2024/11/27/cpp-%E5%A4%9A%E7%BA%BF%E7%A8%8B/6-std-call_once%E4%B8%8E%E5%85%B6%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <url>/2024/11/27/cpp-%E5%A4%9A%E7%BA%BF%E7%A8%8B/6-std-call_once%E4%B8%8E%E5%85%B6%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<p>单例设计模式是一种常见的设计模式，用于确保某个类只能创建一个实例。由于单例实例是全局唯一的，因此在多线程环境中使用单例模式时，需要考虑线程安全的问题。</p><p>下面是一个简单的单例模式的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> Singleton instance;<br>    <span class="hljs-keyword">return</span> instance;<br>&#125;    <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setData</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br>    m_data = data;<br>&#125;    <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> m_data;<br>&#125;<span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">Singleton</span>() &#123;&#125;<br><span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;    <br><span class="hljs-type">int</span> m_data = <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在这个单例类中，我们使用了一个静态成员函数 getInstance()来获取单例实例，该函数使用了一个静态局部变量 instance来存储单例实例。由于静态局部变量只会被初始化一次，因此该实现可以确保单例实例只会被创建一次。</p><p>但是，该实现并不是线程安全的。如果多个线程同时调用 getInstance()函数，可能会导致多个对象被创建，从而违反了单例模式的要求。此外，如果多个线程同时调用setData() 函数来修改单例对象的数据成员m_data，可能会导致数据不一致或不正确的结果。</p><p>为了解决这些问题，我们可以使用 std::call_once来实现一次性初始化，从而确保单例实例只会被创建一次。下面是一个使用std::call_once 的单例实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    std::<span class="hljs-built_in">call_once</span>(m_onceFlag, &amp;Singleton::init);<br>    <span class="hljs-keyword">return</span> *m_instance;<br>&#125;    <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setData</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br>    m_data = data;<br>&#125;    <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;        <br>    <span class="hljs-keyword">return</span> m_data;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">Singleton</span>() &#123;&#125;<br><span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;    <br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    m_instance.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> Singleton);<br>&#125;    <br><span class="hljs-type">static</span> std::unique_ptr&lt;Singleton&gt; m_instance;    <br><span class="hljs-type">static</span> std::once_flag m_onceFlag;    <br><span class="hljs-type">int</span> m_data = <span class="hljs-number">0</span>;<br>&#125;;<br>std::unique_ptr&lt;Singleton&gt; Singleton::m_instance;<br>std::once_flag Singleton::m_onceFlag;<br></code></pre></td></tr></table></figure><p>在这个实现中，我们使用了一个静态成员变量 m_instance来存储单例实例，使用了一个静态成员变量 m_onceFlag来标记初始化是否已经完成。在 getInstance() 函数中，我们使用std::call_once 来调用 init() 函数，确保单例实例只会被创建一次。在 init()函数中，我们使用了 std::unique_ptr 来创建单例实例。</p><p>使用 std::call_once可以确保单例实例只会被创建一次，从而避免了多个对象被创建的问题。此外，使用std::unique_ptr 可以确保单例实例被正确地释放，避免了内存泄漏的问题。</p><p><code>std::call_once</code> 是 C++11标准库中的一个函数，用于确保某个函数只会被调用一次。其函数原型如下：</p><p>template&lt;class Callable, class... Args&gt;</p><p>void call_once(std::once_flag&amp; flag, Callable&amp;&amp; func,Args&amp;&amp;... args);</p><p>其中，<code>flag</code> 是一个 <code>std::once_flag</code>类型的对象，用于标记函数是否已经被调用；<code>func</code>是需要被调用的函数或可调用对象；<code>args</code>是函数或可调用对象的参数。</p><p><code>std::call_once</code> 的作用是，确保在多个线程中同时调用<code>call_once</code> 时，只有一个线程能够成功执行 <code>func</code>函数，而其他线程则会等待该函数执行完成。</p><p>使用 <code>std::call_once</code> 的过程中，需要注意以下几点：</p><p>\1. <code>flag</code> 参数必须是一个 <code>std::once_flag</code>类型的对象，并且在多次调用 <code>call_once</code> 函数时需要使用同一个<code>flag</code> 对象。</p><p>\2. <code>func</code>参数是需要被调用的函数或可调用对象。该函数只会被调用一次，因此应该确保该函数是幂等的。</p><p>\3. <code>args</code> 参数是 <code>func</code>函数或可调用对象的参数。如果 <code>func</code>函数没有参数，则该参数可以省略。</p><p>\4. <code>std::call_once</code> 函数会抛出<code>std::system_error</code> 异常，如果在调用 <code>func</code>函数时发生了异常，则该异常会被传递给调用者。</p><p>使用 <code>std::call_once</code>可以在多线程环境中实现一次性初始化，避免了多个线程同时初始化的问题。例如，在单例模式中，可以使用<code>std::call_once</code> 来保证单例实例只会被创建一次。</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++11 多线程编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.lock_guard 与 std::unique_lock</title>
    <link href="/2024/11/27/cpp-%E5%A4%9A%E7%BA%BF%E7%A8%8B/5-lock_guard%E4%B8%8Estd-unique_lock/"/>
    <url>/2024/11/27/cpp-%E5%A4%9A%E7%BA%BF%E7%A8%8B/5-lock_guard%E4%B8%8Estd-unique_lock/</url>
    
    <content type="html"><![CDATA[<p><strong>lock_guard</strong></p><p>std::lock_guard 是 C++标准库中的一种互斥量封装类，用于保护共享数据，防止多个线程同时访问同一资源而导致的数据竞争问题。</p><p>std::lock_guard 的特点如下：</p><ul><li>当构造函数被调用时，该互斥量会被自动锁定。</li><li>当析构函数被调用时，该互斥量会被自动解锁。</li><li>std::lock_guard对象不能复制或移动，因此它只能在局部作用域中使用。</li></ul><p><strong>std::unique_lock</strong></p><p>std::unique_lock 是 C++标准库中提供的一个互斥量封装类，用于在多线程程序中对互斥量进行加锁和解锁操作。它的主要特点是可以对互斥量进行更加灵活的管理，包括延迟加锁、条件变量、超时等。</p><p>std::unique_lock 提供了以下几个成员函数：</p><ul><li><p>lock()：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则当前线程会被阻塞，直到互斥量被成功加锁。</p></li><li><p>try_lock()：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则函数立即返回false，否则返回 true。</p></li><li><p>try_lock_for(const std::chrono::duration&lt;Rep, Period&gt;&amp;rel_time)：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则当前线程会被阻塞，直到互斥量被成功加锁，或者超过了指定的时间。</p></li><li><p>try_lock_until(const std::chrono::time_point&lt;Clock,Duration&gt;&amp;abs_time)：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则当前线程会被阻塞，直到互斥量被成功加锁，或者超过了指定的时间点。</p></li><li><p>unlock()：对互斥量进行解锁操作。</p></li></ul><p>除了上述成员函数外，std::unique_lock 还提供了以下几个构造函数：</p><ul><li>unique_lock() noexcept =default：默认构造函数，创建一个未关联任何互斥量的 std::unique_lock对象。</li><li>explicit unique_lock(mutex_type&amp; m)：构造函数，使用给定的互斥量m 进行初始化，并对该互斥量进行加锁操作。</li><li>unique_lock(mutex_type&amp; m, defer_lock_t)noexcept：构造函数，使用给定的互斥量 m进行初始化，但不对该互斥量进行加锁操作。</li><li>unique_lock(mutex_type&amp; m, try_to_lock_t)noexcept：构造函数，使用给定的互斥量 m进行初始化，并尝试对该互斥量进行加锁操作。如果加锁失败，则创建的std::unique_lock 对象不与任何互斥量关联。</li><li>unique_lock(mutex_type&amp; m, adopt_lock_t)noexcept：构造函数，使用给定的互斥量 m进行初始化，并假设该互斥量已经被当前线程成功加锁。</li></ul><p>std::unique_lock使用非常灵活方便，上述操作的使用方式将会在课程视频中作详细介绍。</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++11 多线程编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4. 互斥量死锁</title>
    <link href="/2024/11/27/cpp-%E5%A4%9A%E7%BA%BF%E7%A8%8B/4-%E4%BA%92%E6%96%A5%E9%87%8F%E6%AD%BB%E9%94%81/"/>
    <url>/2024/11/27/cpp-%E5%A4%9A%E7%BA%BF%E7%A8%8B/4-%E4%BA%92%E6%96%A5%E9%87%8F%E6%AD%BB%E9%94%81/</url>
    
    <content type="html"><![CDATA[<p>假设有两个线程 T1 和 T2，它们需要对两个互斥量 mtx1 和 mtx2进行访问，而且需要按照以下顺序获取互斥量的所有权：</p><p>- T1 先获取 mtx1 的所有权，再获取 mtx2 的所有权。</p><p>- T2 先获取 mtx2 的所有权，再获取 mtx1 的所有权。</p><p>如果两个线程同时执行，就会出现死锁问题。因为 T1 获取了 mtx1的所有权，但是无法获取 mtx2 的所有权，而 T2 获取了 mtx2的所有权，但是无法获取 mtx1的所有权，两个线程互相等待对方释放互斥量，导致死锁。</p><p>为了解决这个问题，可以让两个线程按照相同的顺序获取互斥量的所有权。例如，都先获取mtx1 的所有权，再获取 mtx2 的所有权，或者都先获取 mtx2 的所有权，再获取mtx1 的所有权。这样就可以避免死锁问题。</p><p>以下是按照第二种方案修改后的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br>std::mutex mtx1, mtx2;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;    <br>    mtx<span class="hljs-number">2.l</span>ock();    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread 1 locked mutex 2&quot;</span> &lt;&lt; std::endl;    <br>    mtx<span class="hljs-number">1.l</span>ock();    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread 1 locked mutex 1&quot;</span> &lt;&lt; std::endl;    <br>    mtx<span class="hljs-number">1.</span><span class="hljs-built_in">unlock</span>();    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread 1 unlocked mutex 1&quot;</span> &lt;&lt; std::endl;    <br>    mtx<span class="hljs-number">2.</span><span class="hljs-built_in">unlock</span>();    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread 1 unlocked mutex 2&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;    <br>    mtx<span class="hljs-number">2.l</span>ock();    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread 2 locked mutex 2&quot;</span> &lt;&lt; std::endl;    <br>    mtx<span class="hljs-number">1.l</span>ock();    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread 2 locked mutex 1&quot;</span> &lt;&lt; std::endl;    <br>    mtx<span class="hljs-number">1.</span><span class="hljs-built_in">unlock</span>();    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread 2 unlocked mutex 1&quot;</span> &lt;&lt; std::endl;<br>    mtx<span class="hljs-number">2.</span><span class="hljs-built_in">unlock</span>();    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread 2 unlocked mutex 2&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func1)</span></span>;    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func2)</span></span>;    <br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();    <br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，T1 先获取 mtx2 的所有权，再获取 mtx1 的所有权，而 T2也是先获取 mtx2 的所有权，再获取 mtx1的所有权，这样就避免了死锁问题。</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++11 多线程编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3. 互斥量解决多线程数据共享问题</title>
    <link href="/2024/11/27/cpp-%E5%A4%9A%E7%BA%BF%E7%A8%8B/3-%E4%BA%92%E6%96%A5%E9%87%8F%E8%A7%A3%E5%86%B3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98/"/>
    <url>/2024/11/27/cpp-%E5%A4%9A%E7%BA%BF%E7%A8%8B/3-%E4%BA%92%E6%96%A5%E9%87%8F%E8%A7%A3%E5%86%B3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="数据共享问题分析">数据共享问题分析</h3><p>在多个线程中共享数据时，需要注意线程安全问题。如果多个线程同时访问同一个变量，并且其中至少有一个线程对该变量进行了写操作，那么就会出现数据竞争问题。数据竞争可能会导致程序崩溃、产生未定义的结果，或者得到错误的结果。</p><p>为了避免数据竞争问题，需要使用同步机制来确保多个线程之间对共享数据的访问是安全的。常见的同步机制包括互斥量、条件变量、原子操作等。</p><p>以下是一个简单的数据共享问题的示例代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-type">int</span> shared_data = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; ++i) &#123;<br>        shared_data++;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func)</span></span>;<br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;shared_data = &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中，定义了一个名为 shared_data的全局变量，并在两个线程中对其进行累加操作。在 main函数中，创建了两个线程，并分别调用了 func 函数。在 func 函数中，对shared_data 变量进行了累加操作。</p><p>由于 shared_data变量是全局变量，因此在两个线程中共享。对于这种共享的情况，需要使用互斥量等同步机制来确保多个线程之间对共享数据的访问是安全的。如果不使用同步机制，就会出现数据竞争问题，导致得到错误的结果。</p><h3 id="互斥量概念">互斥量概念</h3><p>互斥量（mutex）是一种用于实现多线程同步的机制，用于确保多个线程之间对共享资源的访问互斥。互斥量通常用于保护共享数据的访问，以避免多个线程同时访问同一个变量或者数据结构而导致的数据竞争问题。</p><p>互斥量提供了两个基本操作：lock() 和 unlock()。当一个线程调用 lock()函数时，如果互斥量当前没有被其他线程占用，则该线程获得该互斥量的所有权，可以对共享资源进行访问。如果互斥量当前已经被其他线程占用，则调用lock() 函数的线程会被阻塞，直到该互斥量被释放为止。</p><p>上面的代码中，使用互斥量 mtx 来确保多个线程对 shared_data变量的访问是安全的。在 func 函数中，先调用 mtx.lock()来获取互斥量的所有权，然后对 shared_data 变量进行累加操作，最后再调用mtx.unlock() 来释放互斥量的所有权。这样就可以确保多个线程之间对shared_data 变量的访问是安全的。</p><h3 id="案例代码">案例代码</h3><p>以下是一个综合了创建多个线程和数据共享问题解决方案的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-type">int</span> shared_data = <span class="hljs-number">0</span>;<br>std::mutex mtx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; ++i) &#123;<br>        mtx.<span class="hljs-built_in">lock</span>();<br>        shared_data++;        <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; n <br>            &lt;&lt; <span class="hljs-string">&quot; increment shared_data to &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;<br>        mtx.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func, <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func, <span class="hljs-number">2</span>)</span></span>;<br><br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Final shared_data = &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中，定义了一个名为 shared_data 的全局变量，并使用互斥量 mtx来确保多个线程对其进行访问时的线程安全。在两个线程中，分别调用了 func函数，并传递了不同的参数。在 func 函数中，先获取互斥量的所有权，然后对shared_data变量进行累加操作，并输出变量的当前值。最后再释放互斥量的所有权。</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++11 多线程编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.线程函数中的数据未定义错误</title>
    <link href="/2024/11/27/cpp-%E5%A4%9A%E7%BA%BF%E7%A8%8B/2-%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9C%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF/"/>
    <url>/2024/11/27/cpp-%E5%A4%9A%E7%BA%BF%E7%A8%8B/2-%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9C%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<p>\1. 传递临时变量的问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span> </span>&#123;<br>    x += <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(foo, <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// 传递临时变量</span><br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个名为<code>foo</code>的函数，它接受一个整数引用作为参数，并将该引用加1。然后，我们创建了一个名为<code>t</code>的线程，将<code>foo</code>函数以及一个临时变量<code>1</code>作为参数传递给它。这样会导致在线程函数执行时，临时变量<code>1</code>被销毁，从而导致未定义行为。</p><p>解决方案是将变量复制到一个持久的对象中，然后将该对象传递给线程。例如，我们可以将<code>1</code>复制到一个<code>int</code>类型的变量中，然后将该变量的引用传递给线程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span> </span>&#123;<br>    x += <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; <span class="hljs-comment">// 将变量复制到一个持久的对象中</span><br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(foo, std::ref(x))</span></span>; <span class="hljs-comment">// 将变量的引用传递给线程</span><br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>\2. 传递指针或引用指向局部变量的问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>* ptr)</span> </span>&#123;<br>    std::cout &lt;&lt; *ptr &lt;&lt; std::endl; <span class="hljs-comment">// 访问已经被销毁的指针</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(foo, &amp;x)</span></span>; <span class="hljs-comment">// 传递指向局部变量的指针</span><br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个名为<code>foo</code>的函数，它接受一个整型指针作为参数，并输出该指针所指向的整数值。然后，我们创建了一个名为<code>t</code>的线程，将<code>foo</code>函数以及指向局部变量<code>x</code>的指针作为参数传递给它。这样会导致在线程函数执行时，指向局部变量<code>x</code>的指针已经被销毁，从而导致未定义行为。</p><p>解决方案是将指针或引用指向堆上的变量，或使用<code>std::shared_ptr</code>等智能指针来管理对象的生命周期。例如，我们可以使用<code>new</code>运算符在堆上分配一个整数变量，并将指针指向该变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>* ptr)</span> </span>&#123;<br>    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;<br>    <span class="hljs-keyword">delete</span> ptr; <span class="hljs-comment">// 在使用完指针后，需要手动释放内存</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span>* ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 在堆上分配一个整数变量</span><br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(foo, ptr)</span></span>; <span class="hljs-comment">// 将指针传递给线程</span><br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>\3. 传递指针或引用指向已释放的内存的问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span> </span>&#123;<br>    std::cout &lt;&lt; x &lt;&lt; std::endl; <span class="hljs-comment">// 访问已经被释放的内存</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span>* ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(foo, *ptr)</span></span>; <span class="hljs-comment">// 传递已经释放的内存</span><br>    <span class="hljs-keyword">delete</span> ptr;<br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个名为<code>foo</code>的函数，它接受一个整数引用作为参数，并输出该引用的值。然后，我们创建了一个名为<code>t</code>的线程，将<code>foo</code>函数以及一个已经被释放的指针所指向的整数值作为参数传递给它解决方案是确保在线程函数执行期间，被传递的对象的生命周期是有效的。例如，在主线程中创建并初始化对象，然后将对象的引用传递给线程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span> </span>&#123;<br>    std::cout &lt;&lt; x &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(foo, std::ref(x))</span></span>; <span class="hljs-comment">// 将变量的引用传递给线程</span><br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个名为<code>x</code>的整数变量，并初始化为<code>1</code>。然后，我们创建了一个名为<code>t</code>的线程，将<code>foo</code>函数以及变量<code>x</code>的引用作为参数传递给它。这样可以确保在线程函数执行期间，变量<code>x</code>的生命周期是有效的。</p><p>\4. 类成员函数作为入口函数，类对象被提前释放</p><p>错误示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() <br>        &lt;&lt; <span class="hljs-string">&quot; started&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-comment">// do some work</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() <br>        &lt;&lt; <span class="hljs-string">&quot; finished&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(&amp;MyClass::func, &amp;obj)</span></span>;<br>    <span class="hljs-comment">// obj 被提前销毁了，会导致未定义的行为</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中，在创建线程之后，obj对象立即被销毁了，这会导致在线程执行时无法访问 obj对象，可能会导致程序崩溃或者产生未定义的行为。</p><p>为了避免这个问题，可以使用 std::shared_ptr来管理类对象的生命周期，确保在线程执行期间对象不会被销毁。具体来说，可以在创建线程之前，将类对象的指针封装在一个std::shared_ptr对象中，并将其作为参数传递给线程。这样，在线程执行期间，即使类对象的所有者释放了其所有权，std::shared_ptr仍然会保持对象的生命周期，直到线程结束。</p><p>以下是使用 std::shared_ptr 修复上面错误的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() <br>        &lt;&lt; <span class="hljs-string">&quot; started&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-comment">// do some work</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() <br>        &lt;&lt; <span class="hljs-string">&quot; finished&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::shared_ptr&lt;MyClass&gt; obj = std::<span class="hljs-built_in">make_shared</span>&lt;MyClass&gt;();<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(&amp;MyClass::func, obj)</span></span>;<br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中，使用 std::make_shared 创建了一个 MyClass类对象，并将其封装在一个 std::shared_ptr 对象中。然后，将std::shared_ptr 对象作为参数传递给线程。这样，在线程执行期间，即使 obj对象的所有者释放了其所有权，std::shared_ptr仍然会保持对象的生命周期，直到线程结束。</p><p>5.入口函数为类的私有成员函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">myThreadFunc</span><span class="hljs-params">(MyClass* obj)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">privateFunc</span><span class="hljs-params">()</span></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> <br>        &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; <span class="hljs-string">&quot; privateFunc&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myThreadFunc</span><span class="hljs-params">(MyClass* obj)</span> </span>&#123;<br>    obj-&gt;<span class="hljs-built_in">privateFunc</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj;<br>    <span class="hljs-function">std::thread <span class="hljs-title">thread_1</span><span class="hljs-params">(myThreadFunc, &amp;obj)</span></span>;<br>    thread_<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中，将 myThreadFunc 定义为 MyClass类的友元函数，并在函数中调用 privateFunc函数。在创建线程时，需要将类对象的指针作为参数传递给线程。</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++11 多线程编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. C++11 Thead线程库的基本使用</title>
    <link href="/2024/11/27/cpp-%E5%A4%9A%E7%BA%BF%E7%A8%8B/1-Cpp11-Thead%E7%BA%BF%E7%A8%8B%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/11/27/cpp-%E5%A4%9A%E7%BA%BF%E7%A8%8B/1-Cpp11-Thead%E7%BA%BF%E7%A8%8B%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>Thread库</p><ol type="1"><li>创建线程</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printHelloworld</span><span class="hljs-params">(std::string msg)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; msg &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//1. 创建线程</span><br><span class="hljs-function">std::thread <span class="hljs-title">thread1</span><span class="hljs-params">(printHelloworld, <span class="hljs-string">&quot;Hello Thread&quot;</span>)</span></span>;<br>    <span class="hljs-comment">//2. 主程序等待线程执行完毕</span><br>thread<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    <span class="hljs-comment">//3. 分离线程 </span><br>thread<span class="hljs-number">1.</span><span class="hljs-built_in">detach</span>();<br>    <span class="hljs-comment">//4. joinable</span><br>    <span class="hljs-type">bool</span> isJoin = thread<span class="hljs-number">1.</span><span class="hljs-built_in">joinable</span>();<br><span class="hljs-keyword">if</span> (isJoin)<br>&#123;<br>thread<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>join()是阻塞的</li></ol><figure><img src="/2024/11/27/cpp-%E5%A4%9A%E7%BA%BF%E7%A8%8B/1-Cpp11-Thead%E7%BA%BF%E7%A8%8B%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/1708781270952-530255cf-7869-4d4d-bbff-f292eba59e23.gif" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>本文详细介绍C++11Thead线程库的基本使用，包括如何创建线程、启动线程、等待线程完成以及如何分离线程等。<strong>创建线程</strong></p><p>要创建线程，我们需要一个可调用的函数或函数对象，作为线程的入口点。在C++11中，我们可以使用函数指针、函数对象或lambda表达式来实现。创建线程的基本语法如下：</p><p>#include <thread>std::thread t(function_name, args...);</thread></p><p><code>function_name</code>是线程入口点的函数或可调用对象</p><p><code>args...</code>是传递给函数的参数</p><p>创建线程后，我们可以使用<code>t.join()</code>等待线程完成，或者使用<code>t.detach()</code>分离线程，让它在后台运行。</p><p>例如，下面的代码创建了一个线程，输出一条消息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_message</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello, world!&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(print_message)</span></span>;<br>    t.<span class="hljs-built_in">join</span>();    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个名为<code>print_message</code>的函数，它输出一条消息。然后，我们创建了一个名为<code>t</code>的线程，将<code>print_message</code>函数作为入口点。最后，我们使用<code>t.join()</code>等待线程完成。</p><p><strong>传递参数</strong></p><p>我们可以使用多种方式向线程传递参数，例如使用函数参数、全局变量、引用等。如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_message</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> </span><br><span class="hljs-function"></span>&#123;    <br>    std::cout &lt;&lt; message &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span> </span><br><span class="hljs-function"></span>&#123;    <br>    ++x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;    <br>    std::string message = <span class="hljs-string">&quot;Hello, world!&quot;</span>;    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(print_message, message)</span></span>;    <br>    t.<span class="hljs-built_in">join</span>();    <br>    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(increment, std::ref(x))</span></span>;    <br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();    <br>    std::cout &lt;&lt; x &lt;&lt; std::endl;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在第一个例子中，我们使用了一个字符串作为函数参数，传递给线程。在第二个例子中，我们使用了一个引用来传递一个整数变量。需要注意的是，当我们使用引用传递参数时，我们需要使用<code>std::ref</code>来包装引用，否则编译器会报错。</p><p><strong>等待线程完成</strong></p><p>当我们创建一个线程后，我们可能需要等待它完成，以便获取线程的执行结果或执行清理操作。我们可以使用<code>t.join()</code>方法来等待线程完成。例如，下面的代码创建了两个线程，等待它们完成后输出一条消息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_message</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> </span><br><span class="hljs-function"></span>&#123;    <br>    std::cout &lt;&lt; message &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(print_message, <span class="hljs-string">&quot;Thread 1&quot;</span>)</span></span>;    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(print_message, <span class="hljs-string">&quot;Thread 2&quot;</span>)</span></span>;    <br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();    <br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;All threads joined&quot;</span> &lt;&lt; std::endl;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们创建了两个线程<code>t1</code>和<code>t2</code>，它们都调用<code>print_message</code>函数输出一条消息。然后，我们使用<code>t1.join()</code>和<code>t2.join()</code>等待它们完成。最后，我们输出一条消息，表示所有线程都已经完成。</p><p><strong>分离线程</strong></p><p>有时候我们可能不需要等待线程完成，而是希望它在后台运行。这时候我们可以使用<code>t.detach()</code>方法来分离线程。例如，下面的代码创建了一个线程，分离它后输出一条消息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_message</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> </span><br><span class="hljs-function"></span>&#123;    <br>    std::cout &lt;&lt; message &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(print_message, <span class="hljs-string">&quot;Thread 1&quot;</span>)</span></span>;    <br>    t.<span class="hljs-built_in">detach</span>();    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread detached&quot;</span> &lt;&lt; std::endl;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个名为<code>t</code>的线程，调用<code>print_message</code>函数输出一条消息。然后，我们使用<code>t.detach()</code>方法分离线程，让它在后台运行。最后，我们输出一条消息，表示线程已经被分离。</p><p>需要注意的是，一旦线程被分离，就不能再使用<code>t.join()</code>方法等待它完成。而且，我们需要确保线程不会在主线程结束前退出，否则可能会导致未定义行为。</p><p><strong>joinable()</strong></p><p>joinable()方法返回一个布尔值，如果线程可以被join()或detach()，则返回true，否则返回false。如果我们试图对一个不可加入的线程调用join()或detach()，则会抛出一个std::system_error异常。</p><p>下面是一个使用joinable()方法的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread started&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(foo)</span></span>;<br>    <span class="hljs-keyword">if</span> (t.<span class="hljs-built_in">joinable</span>()) &#123;<br>        t.<span class="hljs-built_in">join</span>();<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread joined&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>常见错误（将在后续文章中详解以下错误的解决方案）</strong></p><p>在使用C++11线程库时，有一些常见的错误需要注意。例如：</p><p>-忘记等待线程完成或分离线程：如果我们创建了一个线程，但没有等待它完成或分离它，那么在主线程结束时，可能会导致未定义行为。</p><p>-访问共享数据时没有同步：如果我们在多个线程中访问共享数据，但没有使用同步机制，那么可能会导致数据竞争、死锁等问题。</p><p>-异常传递问题：如果在线程中发生了异常，但没有处理它，那么可能会导致程序崩溃。因此，我们应该在线程中使用try-catch块来捕获异常，并在适当的地方处理它。</p><p><strong>总结</strong></p><p>C++11提供了一个强大的线程库，即std::thread。它可以在C++程序中创建和管理线程，提供了一种更加现代化的方式来处理多线程编程。在本文中，我们介绍了std::thread库的基本使用，包括如何创建、启动和管理线程，以及如何等待线程完成和分离线程。同时，我们也提到了一些常见的错误，需要注意避免。</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++11 多线程编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>google_style_guide</title>
    <link href="/2024/11/27/cpp/google_style_guide/"/>
    <url>/2024/11/27/cpp/google_style_guide/</url>
    
    <content type="html"><![CDATA[<h2 id="头文件">1.头文件</h2><p>通常每一个.cc文件都有一个对应的.h文件.也有一些常见例外,如单元测试代码和只包含main()函数的.cc文件</p><h3 id="self-contained头文件">1.1Self-contained头文件</h3><p>所有头文件要能够自给自足。换言之，用户和重构工具不需要为特别场合而包含额外的头文件。</p><p>详言之，一个头文件要有1.2.#define保护，统统包含它所需要的其它头文件，也不要求定义任何特别symbols.</p><p>不过有一个例外，即一个文件并不是self-contained的，而是作为文本插入到代码某处。或者，文件内容实际上是其它头文件的特定平台（platform-specific）扩展部分。这些文件就要用.inc文件扩展名。</p><p>如果.h文件声明了一个模板或内联函数，同时也在该文件加以定义。凡是有用到这些的.cc文件，就得统统包含该头文件，否则程序可能会在构建中链接失败。不要把这些定义放到分离的-inl.h文件里（译者注：过去该规范曾提倡把定义放到-inl.h里过）。</p><p>有个例外：如果某函数模板为所有相关模板参数显式实例化，或本身就是某类的一个私有成员，那么它就只能定义在实例化该模板的.cc文件里。</p><h3 id="define保护">1.2define保护</h3><p>所有头文件都应该有#define保护来防止头文件被多重包含,命名格式当是:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">PROJECT</span>&gt;</span>_<span class="hljs-tag">&lt;<span class="hljs-name">PATH</span>&gt;</span>_<span class="hljs-tag">&lt;<span class="hljs-name">FILE</span>&gt;</span>_H_<br></code></pre></td></tr></table></figure><p>为保证唯一性,头文件的命名应该基于所在项目源代码树的全路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">#ifndefFOO_BAR_BAZ_H_<br>#defineFOO_BAR_BAZ_H_<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span><span class="hljs-comment">//FOO_BAR_BAZ_H_</span></span><br></code></pre></td></tr></table></figure><h3 id="前置声明">1.3前置声明</h3><p>尽可能地避免使用前置声明。使用#include包含需要的头文件即可。</p><p>所谓「前置声明」（forwarddeclaration）是类、函数和模板的纯粹声明，没伴随着其定义.</p><p>优点：</p><ul><li>前置声明能够节省编译时间，多余的#include会迫使编译器展开更多的文件，处理更多的输入。</li><li>前置声明能够节省不必要的重新编译的时间。#include使代码因为头文件中无关的改动而被重新编译多次。</li></ul><p>缺点：</p><ul><li>前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。</li><li>前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其API.例如扩大形参类型，加个自带默认参数的模板形参等等。</li><li>前置声明来自命名空间std::的symbol时，其行为未定义。</li><li>很难判断什么时候该用前置声明，什么时候该用#include。极端情况下，用前置声明代替#include甚至都会暗暗地改变代码的含义：</li><li>前置声明了不少来自头文件的symbol时，就会比单单一行的include冗长。</li><li>仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）会使代码变得更慢更复杂</li></ul><p>结论：</p><ul><li>尽量避免前置声明那些定义在其他项目中的实体.</li><li>函数：总是使用#include.</li><li>类模板：优先使用#include.</li></ul><p>至于什么时候包含头文件，参见1.5.#include的路径及顺序。</p><h3 id="内联函数">1.4内联函数</h3><p>只有当函数只有10行甚至更少时才将其定义为内联函数.</p><p>定义:当函数被声明为内联函数之后,编译器会将其内联展开,而不是按通常的函数调用机制进行调用.</p><p>优点:只要内联的函数体较小,内联该函数可以令目标代码更加高效.对于存取函数以及其它函数体比较短,性能关键的函数,鼓励使用内联.</p><p>缺点:滥用内联将导致程序变得更慢.内联可能使目标代码量或增或减,这取决于内联函数的大小.内联非常短小的存取函数通常会减少代码大小,但内联一个相当大的函数将戏剧性的增加代码大小.现代处理器由于更好的利用了指令缓存,小巧的代码往往执行更快。</p><p>结论:</p><ul><li><p>一个较为合理的经验准则是,不要内联超过10行的函数.谨慎对待析构函数,析构函数往往比其表面看起来要更长,因为有隐含的成员和基类析构函数被调用!</p></li><li><p>另一个实用的经验准则:内联那些包含循环或switch语句的函数常常是得不偿失(除非在大多数情况下,这些循环或switch语句从不被执行)</p></li></ul><p>有些函数即使声明为内联的也不一定会被编译器内联,这点很重要;比如虚函数和递归函数就不会被正常内联.通常,递归函数不应该声明成内联函数.（YuleFox注:递归调用堆栈的展开并不像循环那么简单,比如递归层数在编译时可能是未知的,大多数编译器都不支持内联递归函数).虚函数内联的主要原因则是想把它的函数体放在类定义内,为了图个方便,抑或是当作文档描述其行为,比如精短的存取函数.</p><h3 id="include的路径及顺序">1.5#include的路径及顺序</h3><p>使用标准的头文件包含顺序可增强可读性,避免隐藏依赖:相关头文件,C库,C++库,其他库的.h,本项目内的.h.</p><p>项目内头文件应按照项目源代码目录树结构排列,避免使用UNIX特殊的快捷目录.(当前目录)或..(上级目录).例如,google-awesome-project/src/base/logging.h应该按如下方式包含</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;base/logging.h&quot;</span></span><br></code></pre></td></tr></table></figure><p>又如,dir/foo.cc或dir/foo_test.cc的主要作用是实现或测试dir2/foo2.h的功能,foo.cc中包含头文件的次序如下:</p><ol type="1"><li>dir2/foo2.h(优先位置,详情如下)</li><li>C系统文件</li><li>C++系统文件</li><li>其他库的.h文件</li><li>本项目内.h文件</li></ol><p>这种优先的顺序排序保证当dir2/foo2.h遗漏某些必要的库时，dir/foo.cc或dir/foo_test.cc的构建会立刻中止。因此这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是维护其他包的人们。</p><p>按字母顺序分别对每种类型的头文件进行二次排序是不错的主意。</p><p>您所依赖的符号(symbols)被哪些头文件所定义，您就应该包含（include）哪些头文件，前置声明(forwarddeclarations)情况除外。</p><p>例外：有时，平台特定（system-specific）代码需要条件编译（conditionalincludes），这些代码可以放到其它includes之后。当然，您的平台特定代码也要够简练且独立，比如：</p><h3 id="tips">tips</h3><ol type="1"><li>避免多重包含是学编程时最基本的要求;</li><li>前置声明是为了降低编译依赖，防止修改一个头文件引发多米诺效应;</li><li>内联函数的合理使用可提高代码执行效率;</li><li>-inl.h可提高代码可读性(一般用不到吧:D);</li><li>标准化函数参数顺序可以提高可读性和易维护性(对函数参数的堆栈空间有轻微影响,我以前大多是相同类型放在一起);</li><li>包含文件的名称使用.和..虽然方便却易混乱,使用比较完整的项目路径看上去很清晰,很条理,包含文件的次序除了美观之外,最重要的是可以减少隐藏依赖,使每个头文件在“最需要编译”(对应源文件处:D)的地方编译,有人提出库文件放在最后,这样出错先是项目内的文件,头文件都放在对应源文件的最前面,这一点足以保证内部错误的及时发现了</li><li>原来还真有项目用#includes来插入文本，且其文件扩展名.inc看上去也很科学。</li><li>Google已经不再提倡-inl.h用法。</li><li>注意，前置声明的类是不完全类型（incompletetype），我们只能定义指向该类型的指针或引用，或者声明（但不能定义）以不完全类型作为参数或者返回类型的函数。毕竟编译器不知道不完全类型的定义，我们不能创建其类的任何对象，也不能声明成类内部的数据成员。</li><li>类内部的函数一般会自动内联。所以某函数一旦不需要内联，其定义就不要再放在头文件里，而是放到对应的.cc文件里。这样可以保持头文件的类相当精炼，也很好地贯彻了声明与定义分离的原则。</li><li>在#include中插入空行以分割相关头文件,C库,C++库,其他库的.h和本项目内的.h是个好习惯。</li></ol><h2 id="作用域">2.作用域</h2><h3 id="命名空间">2.1命名空间</h3><p>鼓励在.cc文件内使用匿名命名空间或static声明.使用具名的命名空间时,其名称可基于项目名或相对路径.禁止使用using指示（using-directive）。禁止使用内联命名空间（inlinenamespace）。</p><p>定义:命名空间将全局作用域细分为独立的,具名的作用域,可有效防止全局作用域的命名冲突.</p><p>优点:</p><ul><li><p>虽然类已经提供了（可嵌套的）命名轴线(YuleFox注:将命名分割在不同类的作用域内),命名空间在这基础上又封装了一层.</p></li><li><p>举例来说,两个不同项目的全局作用域都有一个类Foo,这样在编译或运行时造成冲突.如果每个项目将代码置于不同命名空间中,project1::Foo和project2::Foo作为不同符号自然不会冲突.</p></li><li><p>内联命名空间会自动把内部的标识符放到外层作用域，比如：</p></li><li><p>```c++ namespaceX{ inlinenamespaceY{ voidfoo(); } //namespaceY }//namespaceX <figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><br><span class="hljs-bullet">-</span> <span class="hljs-string">X::Y::foo()与X::foo()彼此可代替。内联命名空间主要用来保持跨版本的ABI兼容性。</span><br><br><span class="hljs-attribute">缺点</span><span class="hljs-punctuation">:</span><br><span class="hljs-punctuation"></span><br><span class="hljs-bullet">-</span> <span class="hljs-string">命名空间具有迷惑性,因为它们使得区分两个相同命名所指代的定义更加困难。</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">内联命名空间很容易令人迷惑，毕竟其内部的成员不再受其声明所在命名空间的限制。内联命名空间只在大型版本控制里有用。</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">有时候不得不多次引用某个定义在许多嵌套命名空间里的实体，使用完整的命名空间会导致代码的冗长。</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">在头文件中使用匿名空间导致违背C++的唯一定义原则(OneDefinitionRule(ODR)).</span><br><br>结论:根据下文将要提到的策略合理使用命名空间.<br><br><span class="hljs-bullet">-</span> <span class="hljs-string">遵守命名空间命名中的规则。</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-string">像之前的几个例子中一样，在命名空间的最后注释出命名空间的名字。</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-string">用命名空间把文件包含,gflags的声明/定义,以及类的前置声明以外的整个源文件封装起来,以区别于其它命名空间:</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-string">```c++</span><br>  <span class="hljs-attribute">//.h文件</span><br><span class="hljs-attribute">  namespacemynamespace&#123;</span><br><span class="hljs-attribute">  //所有声明都置于命名空间中</span><br><span class="hljs-attribute">  //注意不要使用缩进</span><br><span class="hljs-attribute">  classMyClass&#123;</span><br><span class="hljs-attribute">  public</span><span class="hljs-punctuation">:</span><br>  ...<br>  voidFoo();<br>  &#125;;<br>  &#125;//namespacemynamespace<br>  <br></code></pre></td></tr></table></figure></p></li><li><p>```c++ //.cc文件 namespacemynamespace{ //函数定义都置于命名空间中voidMyClass::Foo(){ ... } }//namespacemynamespace <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>- 更复杂的.cc文件包含更多,更复杂的细节,比如gflags或<span class="hljs-keyword">using</span>声明。<br><br>- ```c++<br>  <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;a.h&quot;</span></span><br>  <span class="hljs-built_in">DEFINE_FLAG</span>(<span class="hljs-type">bool</span>,someflag,<span class="hljs-literal">false</span>,<span class="hljs-string">&quot;dummyflag&quot;</span>);<br>  namespacea&#123;<br>  ...codefora...<span class="hljs-comment">//左对齐</span><br>  &#125;<span class="hljs-comment">//namespace</span><br></code></pre></td></tr></table></figure></p></li></ul><h3 id="匿名命名空间和静态变量">2.2匿名命名空间和静态变量</h3><ul><li><p>在.cc文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为static。但是不要在.h文件中这么做。</p></li><li><p>定义:所有置于匿名命名空间的声明都具有内部链接性，函数和变量可以经由声明为static拥有内部链接性，这意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。</p></li><li><p>匿名命名空间的声明和具名的格式相同，在最后注释上namespace:</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span>&#123;<br>...<br>&#125;<span class="hljs-comment">//namespace</span><br></code></pre></td></tr></table></figure><h3 id="非成员函数静态成员函数和全局函数">2.3非成员函数、静态成员函数和全局函数</h3><ul><li>使用静态成员函数或命名空间内的非成员函数,尽量不要用裸的全局函数.将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关.</li><li>某些情况下,非成员函数和静态成员函数是非常有用的,将非成员函数放在命名空间内可避免污染全局作用域.</li><li>将非成员函数和静态成员函数作为新类的成员或许更有意义,当它们需要访问外部资源或具有重要的依赖关系时更是如此.</li><li>有时,把函数的定义同类的实例脱钩是有益的,甚至是必要的.这样的函数可以被定义成静态成员,或是非成员函数.非成员函数不应依赖于外部变量,应尽量置于某个命名空间内.相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类,不如使用2.1.命名空间。举例而言，对于头文件myproject/foo_bar.h,应当使用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">namespacemyproject&#123;<br>namespacefoo_bar&#123;<br><span class="hljs-built_in">voidFunction1</span>();<br><span class="hljs-built_in">voidFunction2</span>();<br>&#125;<span class="hljs-comment">//namespacefoo_bar</span><br>&#125;<span class="hljs-comment">//namespacemyproject</span><br><br><span class="hljs-comment">//而不是</span><br>namespacemyproject&#123;<br>classFooBar&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">staticvoidFunction1</span>();<br><span class="hljs-built_in">staticvoidFunction2</span>();<br>&#125;;<br>&#125;<span class="hljs-comment">//namespacemyproject</span><br><br></code></pre></td></tr></table></figure><h3 id="局部变量">2.4局部变量</h3><ul><li>将函数变量尽可能置于最小作用域内,并在变量声明时进行初始化</li><li>应使用初始化的方式替代声明再赋值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">intj=<span class="hljs-built_in">g</span>();<span class="hljs-comment">//好——初始化时声明</span><br><br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//用花括号初始化更好</span><br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br><br>vector&lt;<span class="hljs-type">int</span>&gt;v=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<span class="hljs-comment">//好——v一开始就初始化</span><br></code></pre></td></tr></table></figure><ul><li><p>属于if,while和for语句的变量应当在这些语句中正常地声明，这样子这些变量的作用域就被限制在这些语句中了</p></li><li><p>Warning:有一个例外,如果变量是一个对象,每次进入作用域都要调用其构造函数,每次退出作用域都要调用其析构函数.这会导致效率降低.</p></li><li><p>在循环作用域外面声明这类变量要高效的多</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">Foof;<span class="hljs-comment">//构造函数和析构函数只调用1次</span><br><span class="hljs-keyword">for</span>(inti=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000000</span>;++i)&#123;<br>f.<span class="hljs-built_in">DoSomething</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="静态和全局变量">2.5静态和全局变量</h3><ul><li>禁止定义静态储存周期非POD变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中的静态变量执行时的构造和析构顺序是未明确的，这将导致代码的不可移植。</li><li>禁止使用类的静态储存周期变量：由于构造和析构函数调用顺序的不确定性，它们会导致难以发现的bug。不过constexpr变量除外，毕竟它们又不涉及动态初始化或析构。</li><li>静态生存周期的对象，即包括了全局变量，静态变量，静态类成员变量和函数静态变量，都必须是原生数据类型(POD:PlainOldData):即int,char和float,以及POD类型的指针、数组和结构体</li><li>静态变量的构造函数、析构函数和初始化的顺序在C++中是只有部分明确的，甚至随着构建变化而变化，导致难以发现的bug.所以除了禁用类类型的全局变量，我们也不允许用函数返回值来初始化POD变量，除非该函数（比如getenv()或getpid()）不涉及任何全局变量。函数作用域里的静态变量除外，毕竟它的初始化顺序是有明确定义的，而且只会在指令执行到它的声明那里才会发生。</li><li>同一个编译单元内是明确的，静态初始化优先于动态初始化，初始化顺序按照声明顺序进行，销毁则逆序。不同的编译单元之间初始化和销毁顺序属于未明确行为</li><li>我们只允许POD类型的静态变量，即完全禁用vector(使用C数组替代)和string(使用constchar[])。</li><li>上文提及的静态变量泛指静态生存周期的对象,包括:全局变量,静态变量,静态类成员变量,以及函数静态变量</li></ul><h3 id="tips-1">2.6Tips</h3><ol type="1"><li>cc中的匿名命名空间可避免命名冲突,限定作用域,避免直接使用using关键字污染命名空间;</li><li>嵌套类符合局部使用原则,只是不能在其他头文件中前置声明,尽量不要public;</li><li>尽量不用全局函数和全局变量,考虑作用域和命名空间限制,尽量单独形成编译单元;</li><li>多线程中的全局变量(含静态成员变量)不要使用class类型(含STL容器),避免不明确行为导致的bug.</li><li>作用域的使用,除了考虑名称污染,可读性之外,主要是为降低耦合,提高编译/执行效率.</li><li>注意「using指示（using-directive）」和「using声明（using-declaration）」的区别。</li><li>匿名命名空间说白了就是文件作用域，就像Cstatic声明的作用域一样，后者已经被C++标准提倡弃用。</li><li>局部变量在声明的同时进行显式值初始化，比起隐式初始化再赋值的两步过程要高效，同时也贯彻了计算机体系结构重要的概念「局部性（locality）」。</li><li>注意别在循环犯大量构造和析构的低级错误。</li></ol><h2 id="类">3.类</h2><h3 id="构造函数的职责">3.1构造函数的职责</h3><ul><li><p>不要在构造函数中调用虚函数,也不要在无法报出错误时进行可能失败的初始化.</p></li><li><p>如果在构造函数内调用了自身的虚函数,这类调用是不会重定向到子类的虚函数实现.即使当前没有子类化实现,将来仍是隐患.</p></li><li><p>在没有使程序崩溃(因为并不是一个始终合适的方法)或者使用异常(因为已经被禁用了)等方法的条件下,构造函数很难上报错误</p></li><li><p>如果执行失败,会得到一个初始化失败的对象,这个对象有可能进入不正常的状态,必须使用boolIsValid()或类似这样的机制才能检查出来,然而这是一个十分容易被疏忽的方法.</p></li><li><p>构造函数的地址是无法被取得的,因此,举例来说,由构造函数完成的工作是无法以简单的方式交给其他线程的</p></li></ul><h3 id="隐式类型转换">3.2隐式类型转换</h3><ul><li><p>不要定义隐式类型转换.对于转换运算符和单参数构造函数,请使用explicit关键字</p></li><li><p>explicit关键字可以用于构造函数或(在C++11引入)类型转换运算符,以保证只有当目的类型在调用点被显式写明时才能进行类型转换,例如使用cast</p></li><li><p>不能以一个参数进行调用的构造函数不应当加上explicit.接受一个std::initializer_list作为参数的构造函数也应当省略explicit,以便支持拷贝初始化(例如MyTypem={1,2};)</p></li></ul><h3 id="可拷贝类型和可移动类型">3.3可拷贝类型和可移动类型</h3><ul><li><p>如果你的类型需要,就让它们支持拷贝/移动.否则,就把隐式产生的拷贝和移动函数禁用</p></li><li><p>如果需要就让你的类型可拷贝/可移动.作为一个经验法则,如果对于你的用户来说这个拷贝操作不是一眼就能看出来的,那就不要把类型设置为可拷贝.如果让类型可拷贝,一定要同时给出拷贝构造函数和赋值操作的定义,反之亦然.如果让类型可移动,同时移动操作的效率高于拷贝操作,那么就把移动的两个操作(移动构造函数和赋值操作)也给出定义.如果类型不可拷贝,但是移动操作的正确性对用户显然可见,那么把这个类型设置为只可移动并定义移动的两个操作</p></li><li><p>如果你的类不需要拷贝/移动操作,请显式地通过在public域中使用=delete或其他手段禁用之.</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//MyClassisneithercopyablenormovable.</span><br><span class="hljs-built_in">MyClass</span>(constMyClass&amp;)=<span class="hljs-keyword">delete</span>;<br>MyClass&amp;<span class="hljs-keyword">operator</span>=(constMyClass&amp;)=<span class="hljs-keyword">delete</span>;<br></code></pre></td></tr></table></figure><h3 id="结构体vs类">3.4结构体vs类</h3><ul><li>仅当只有数据成员时使用struct,其它一概使用class</li></ul><h3 id="继承">3.5继承</h3><ul><li><p>使用组合(YuleFox注:这一点也是GoF在&lt;&gt;里反复强调的)常常比使用继承更合理.如果使用继承的话,定义为public继承</p></li><li><p>当子类继承基类时,子类包含了父基类所有数据及操作的定义.C++实践中,继承主要用于两种场合:实现继承,子类继承父类的实现代码;接口继承,子类仅继承父类的方法名称.</p></li><li><p>必要的话,析构函数声明为virtual.如果你的类有虚函数,则析构函数也应该为虚函数.</p></li><li><p>对于可能被子类访问的成员函数,不要过度使用protected关键字.注意,数据成员都必须是私有的</p></li><li><p>对于重载的虚函数或虚析构函数,使用override,或(较不常用的)final关键字显式地进行标记</p></li></ul><h3 id="多重继承">3.6多重继承</h3><ul><li>真正需要用到多重实现继承的情况少之又少.只在以下情况我们才允许多重继承:最多只有一个基类是非抽象类;其它基类都是以Interface为后缀的纯接口类.</li></ul><h3 id="接口">3.7接口</h3><ul><li>接口是指满足特定条件的类,这些类以Interface为后缀(不强制)</li><li>当一个类满足以下要求时,称之为纯接口:<ul><li>只有纯虚函数(”=0”)和静态函数(除了下文提到的析构函数).</li><li>没有非静态数据成员.</li><li>没有定义任何构造函数.如果有,也不能带有参数,并且必须为protected</li><li>如果它是一个子类,也只能从满足上述条件并以Interface为后缀的类继承.</li></ul></li><li>接口类不能被直接实例化,因为它声明了纯虚函数.为确保接口类的所有实现可被正确销毁,必须为之声明虚析构函数</li><li>以Interface为后缀可以提醒其他人不要为该接口类增加函数实现或非静态数据成员.这一点对于多重继承尤其重要.</li><li>只有在满足上述条件时,类才以Interface结尾,但反过来,满足上述需要的类未必一定以Interface结尾.</li></ul><h3 id="运算符重载">3.8运算符重载</h3><ul><li><p>除少数特定环境外,不要重载运算符.也不要创建用户定义字面量</p></li><li><p>C++允许用户通过使用operator关键字对内建运算符进行重载定义,只要其中一个参数是用户定义的类型.operator关键字还允许用户使用operator""定义新的字面运算符,并且定义类型转换函数,例如operatorbool().</p></li></ul><h3 id="存取控制">3.9存取控制</h3><ul><li>将所有数据成员声明为private,除非是staticconst类型成员(遵循常量命名规则).出于技术上的原因,在使用GoogleTest时我们允许测试固件类中的数据成员为protected</li></ul><h3 id="声明顺序">3.10声明顺序</h3><ul><li><p>将相似的声明放在一起,将public部分放在最前</p></li><li><p>类定义一般应以public:开始,后跟protected:,最后是private:.省略空部分</p></li><li><p>在各个部分中,建议将类似的声明放在一起,并且建议以如下的顺序:类型(包括typedef,using和嵌套的结构体与类),常量,工厂函数,构造函数,赋值运算符,析构函数,其它函数,数据成员.</p></li></ul><h3 id="tips-2">tips</h3><ol type="1"><li>不在构造函数中做太多逻辑相关的初始化;</li><li>编译器提供的默认构造函数不会对变量进行初始化,如果定义了其他构造函数,编译器不再提供,需要编码者自行提供默认构造函数;</li><li>为避免隐式转换,需将单参数构造函数声明为explicit;</li><li>为避免拷贝构造函数,赋值操作的滥用和编译器自动生成,可将其声明为private且无需实现;</li><li>仅在作为数据集合时使用struct;</li><li>组合&gt;实现继承&gt;接口继承&gt;私有继承,子类重载的虚函数也要声明virtual关键字,虽然编译器允许不这样做;</li><li>避免使用多重继承,使用时,除一个基类含有实现外,其他基类均为纯接口;</li><li>接口类类名以Interface为后缀,除提供带实现的虚析构函数,静态成员函数外,其他均为纯虚函数,不定义非静态数据成员,不提供构造函数,提供的话,声明为protected;</li><li>为降低复杂性,尽量不重载操作符,模板,标准类中使用时提供文档说明;</li><li>存取函数一般内联在头文件中;</li><li>声明次序:public-&gt;protected-&gt;private;</li><li>函数体尽量短小,紧凑,功能单一;</li></ol><h2 id="函数">4.函数</h2><h3 id="输入和输出">4.1输入和输出</h3><p>我们倾向于按值返回，否则按引用返回。避免返回指针，除非它可以为空</p><h3 id="编写简短函数">4.2.编写简短函数</h3><p>我们倾向于编写简短,凝练的函数</p><p>如果函数超过40行,可以思索一下能不能在不影响程序结构的前提下对其进行分割.</p><h3 id="引用参数">4.3.引用参数</h3><p>所有按引用传递的参数必须加上const.</p><h3 id="函数重载">4.4.函数重载</h3><p>若要使用函数重载,则必须能让读者一看调用点就胸有成竹,而不用花心思猜测调用的重载函数到底是哪一种.这一规则也适用于构造函数</p><p>如果重载函数的目的是为了支持不同数量的同一类型参数,则优先考虑使用std::vector以便使用者可以用列表初始化指定参数.</p><h3 id="缺省参数">4.5.缺省参数</h3><p>只允许在非虚函数中使用缺省参数,且必须保证缺省参数的值始终一致.缺省参数与函数重载遵循同样的规则.一般情况下建议使用函数重载,尤其是在缺省函数带来的可读性提升不能弥补下文中所提到的缺点的情况下.</p><h3 id="函数返回类型后置语法">4.6.函数返回类型后置语法</h3><p>只有在常规写法(返回类型前置)不便于书写或不便于阅读时使用返回类型后置语法</p><p>C++11引入了这一新的形式.现在可以在函数名前使用auto关键字,在参数列表之后后置返回类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">autofoo</span>(intx)-&gt;<span class="hljs-type">int</span>;<br></code></pre></td></tr></table></figure><ul><li>后置返回类型为函数作用域.对于像int这样简单的类型,两种写法没有区别.但对于复杂的情况,例如类域中的类型声明或者以函数参数的形式书写的类型,写法的不同会造成区别</li><li>后置返回类型是显式地指定Lambda表达式的返回值的唯一方式.某些情况下,编译器可以自动推导出Lambda表达式的返回类型,但并不是在所有的情况下都能实现.即使编译器能够自动推导,显式地指定返回类型也能让读者更明了</li><li>有时在已经出现了的函数参数列表之后指定返回类型,能够让书写更简单,也更易读,尤其是在返回类型依赖于模板参数时.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;classT,classU&gt;<span class="hljs-built_in">autoadd</span>(Tt,Uu)-&gt;<span class="hljs-keyword">decltype</span>(t+u);<br></code></pre></td></tr></table></figure><h2 id="来自google的奇技">5.来自Google的奇技</h2><h3 id="所有权与智能指针">5.1.所有权与智能指针</h3><p>动态分配出的对象最好有单一且固定的所有主,并通过智能指针传递所有权</p><p>所有权是一种登记／管理动态内存和其它资源的技术.动态分配对象的所有主是一个对象或函数,后者负责确保当前者无用时就自动销毁前者.所有权有时可以共享,此时就由最后一个所有主来负责销毁它.甚至也可以不用共享,在代码中直接把所有权传递给其它对象</p><p>智能指针是一个通过重载*和-&gt;运算符以表现得如指针一样的类</p><p>智能指针类型被用来自动化所有权的登记工作,来确保执行销毁义务到位.</p><p>std::unique_ptr是C++11新推出的一种智能指针类型,用来表示动态分配出的对象的独一无二的所有权;当std::unique_ptr离开作用域时,对象就会被销毁.std::unique_ptr不能被复制,但可以把它移动（move）给新所有主.std::shared_ptr同样表示动态分配对象的所有权,但可以被共享,也可以被复制;对象的所有权由所有复制者共同拥有,最后一个复制者被销毁时,对象也会随着被销毁</p><p>如果必须使用动态分配,那么更倾向于将所有权保持在分配者手中.如果其他地方要使用这个对象,最好传递它的拷贝,或者传递一个不用改变所有权的指针或引用.倾向于使用std::unique_ptr来明确所有权传递</p><h3 id="cpplint">5.2.Cpplint</h3><p>使用cpplint.py检查风格错误</p><p>cpplint.py是一个用来分析源文件,能检查出多种风格错误的工具.它不并完美,甚至还会漏报和误报,但它仍然是一个非常有用的工具.在行尾加//NOLINT,或在上一行加//NOLINTNEXTLINE,可以忽略报错.某些项目会指导你如何使用他们的项目工具运行cpplint.py.如果你参与的项目没有提供,你可以单独下载cpplint.py.</p><h3 id="tips-3">tips：</h3><ol type="1"><li>把智能指针当成对象来看待的话,就很好领会它与所指对象之间的关系了.</li><li>原来Rust的Ownership思想是受到了C++智能指针的很大启发啊.</li><li>scoped_ptr和auto_ptr已过时.现在是shared_ptr和uniqued_ptr的天下了.</li><li>按本文来说,似乎除了智能指针,还有其它所有权机制,值得留意.</li><li>ArchLinux用户注意了,AUR有对cpplint打包</li></ol><h2 id="其他c特性">6.其他c++特性</h2><h3 id="引用参数-1">6.1.引用参数</h3><p>所有按引用传递的参数必须加上const.</p><h3 id="右值引用">6.2.右值引用</h3><p>只在定义移动构造函数与移动赋值操作时使用右值引用.不要使用std::forward</p><p>右值引用是一种只能绑定到临时对象的引用的一种,其语法与传统的引用语法相似.例如,voidf(string&amp;&amp;s);声明了一个其参数是一个字符串的右值引用的函数.</p><p>用于定义移动构造函数(使用类的右值引用进行构造的函数)使得移动一个值而非拷贝之成为可能.</p><p>例如,如果v1是一个vector,则autov2(std::move(v1))将很可能不再进行大量的数据复制而只是简单地进行指针操作,在某些情况下这将带来大幅度的性能提升.</p><p>右值引用使得编写通用的函数封装来转发其参数到另外一个函数成为可能,无论其参数是否是临时对象都能正常工作.</p><p>右值引用能实现可移动但不可拷贝的类型,这一特性对那些在拷贝方面没有实际需求,但有时又需要将它们作为函数参数传递或塞入容器的类型很有用.要高效率地使用某些标准库类型,例如std::unique_ptr,std::move是必需的</p><h3 id="函数重载-1">6.3.函数重载</h3><p>若要用好函数重载，最好能让读者一看调用点（callsite）就胸有成竹，不用花心思猜测调用的重载函数到底是哪一种。该规则适用于构造函数。</p><h3 id="缺省参数-1">6.4.缺省参数</h3><p>我们不允许使用缺省函数参数，少数极端情况除外。尽可能改用函数重载。</p><h3 id="变长数组和alloca">6.5.变长数组和alloca()</h3><ul><li>我们不允许使用变长数组和alloca().</li><li>变长数组具有浑然天成的语法.变长数组和alloca()也都很高效.</li><li>变长数组和alloca()不是标准C++的组成部分.更重要的是,它们根据数据大小动态分配堆栈内存,会引起难以发现的内存越界bugs:“在我的机器上运行的好好的,发布后却莫名其妙的挂掉了”</li><li>改用更安全的分配器（allocator），就像std::vector或std::unique_ptr</li></ul><h3 id="友元">6.6.友元</h3><p>我们允许合理的使用友元类及友元函数</p><h3 id="异常">6.7.异常</h3><p>我们不使用C++异常</p><h3 id="运行时类型识别">6.8.运行时类型识别</h3><p>我们禁止使用RTTI.</p><ul><li>RTTI允许程序员在运行时识别C++类对象的类型.它通过使用typeid或者dynamic_cast完成.</li></ul><h3 id="类型转换">6.9.类型转换</h3><ul><li><p>使用C++的类型转换,如static_cast&lt;&gt;().不要使用inty=(int)x或inty=int(x)等转换方式</p></li><li><p>用static_cast替代C风格的值转换,或某个类指针需要明确的向上转换为父类指针时.</p></li><li><p>用const_cast去掉const限定符.</p></li><li><p>用reinterpret_cast指针类型和整型或其它指针之间进行不安全的相互转换.仅在你对所做一切了然于心时使用.</p></li><li><p>至于dynamic_cast参见6.8.运行时类型识别.</p></li></ul><h3 id="流">6.10.流</h3><ul><li><p>流用来替代printf()和scanf().</p></li><li><p>优点:有了流,在打印时不需要关心对象的类型.不用担心格式化字符串与参数列表不匹配(虽然在gcc中使用printf也不存在这个问题).流的构造和析构函数会自动打开和关闭对应的文件.</p></li><li><p>缺点:流使得pread()等功能函数很难执行.如果不使用printf风格的格式化字符串,某些格式化操作(尤其是常用的格式字符串%.*s)用流处理性能是很低的.流不支持字符串操作符重新排序(%1s),而这一点对于软件国际化很有用.</p></li><li><p>结论:不要使用流,除非是日志接口需要.使用printf之类的代替.使用流还有很多利弊,但代码一致性胜过一切.不要在代码中使用流.</p></li></ul><h3 id="前置自增和自减">6.11.前置自增和自减</h3><p>对于迭代器和其他模板对象使用前缀形式(++i)的自增,自减运算符.</p><p>不考虑返回值的话,前置自增(++i)通常要比后置自增(i++)效率更高</p><h3 id="const用法">6.12.const用法</h3><p>我们强烈建议你在任何可能的情况下都要使用const.此外有时改用C++11推出的constexpr更好。</p><p>关键字mutable可以使用,但是在多线程中是不安全的,使用时首先要考虑线程安全.</p><h3 id="constexpr用法">6.13.constexpr用法</h3><ul><li><p>在C++11里，用constexpr来定义真正的常量，或实现常量初始化。</p></li><li><p>变量可以被声明成constexpr以表示它是真正意义上的常量，即在编译时和运行时都不变。函数或构造函数也可以被声明成constexpr,以用来定义constexpr变量。</p></li><li><p>如今constexpr就可以定义浮点式的真·常量，不用再依赖字面值了；也可以定义用户自定义类型上的常量；甚至也可以定义函数调用所返回的常量。</p></li></ul><h3 id="整型">6.14.整型</h3><ul><li><p>C++内建整型中,仅使用int.如果程序中需要不同大小的变量,可以使用中长度精确的整型,如int16_t.</p></li><li><p>使用断言来指出变量为非负数,而不是使用无符号型!</p></li></ul><h3 id="位下的可移植性">6.15.64位下的可移植性</h3><ul><li><p>代码应该对64位和32位系统友好.处理打印,比较,结构体对齐时应切记</p></li><li><p>你要非常小心的对待结构体对齐,尤其是要持久化到磁盘上的结构体(Yang.Y注:持久化-将数据按字节流顺序保存在磁盘文件或数据库中).在64位系统中,任何含有int64_t/uint64_t成员的类/结构体,缺省都以8字节在结尾对齐.如果32位和64位代码要共用持久化的结构体,需要确保两种体系结构下的结构体对齐一致.大多数编译器都允许调整结构体对齐</p></li></ul><h3 id="预处理宏">6.16.预处理宏</h3><ul><li>使用宏时要非常谨慎,尽量以内联函数,枚举和常量代替之</li><li>如果你要宏,尽可能遵守:<ul><li>不要在.h文件中定义宏.</li><li>在马上要使用时才进行#define,使用后要立即#undef.</li><li>不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称；</li><li>不要试图使用展开后会导致C++构造不稳定的宏,不然也至少要附上文档说明其行为.</li><li>不要用##处理函数，类和变量的名字。</li></ul></li></ul><h3 id="nullptr和null">6.17.0,nullptr和NULL</h3><p>整数用0,实数用0.0,指针用nullptr或NULL,字符(串)用'\0'.整数用0,实数用0.0,这一点是毫无争议的.对于指针(地址值),到底是用0,NULL还是nullptr.C++11项目用nullptr;C++03项目则用NULL,毕竟它看起来像指针。实际上，一些C++编译器对NULL的定义比较特殊，可以输出有用的警告，特别是sizeof(NULL)就和sizeof(0)不一样。字符(串)用'\0',不仅类型正确而且可读性好。</p><h3 id="sizeof">6.18.sizeof</h3><p>Tip:尽可能用sizeof(varname)代替sizeof(type).</p><p>使用sizeof(varname)是因为当代码中变量类型改变时会自动更新.您或许会用sizeof(type)处理不涉及任何变量的代码，比如处理来自外部或内部的数据格式，这时用变量就不合适了</p><h3 id="auto">6.19.auto</h3><ul><li><p>用auto绕过烦琐的类型名，只要可读性好就继续用，别用在局部变量之外的地方。</p></li><li><p>它涉及到C++鲜为人知的坑：WhyisvectornotaSTLcontainer?）也有大同小异的陷阱</p></li><li><p>auto只能用在局部变量里用。别用在文件作用域变量，命名空间作用域变量和类数据成员里。永远别列表初始化auto变量。</p></li></ul><h3 id="列表初始化">6.20.列表初始化</h3><ul><li><p>你可以用列表初始化。早在C++03里，聚合类型（aggregatetypes）就已经可以被列表初始化了，比如数组和不自带构造函数的结构体：</p></li><li><p>C++11中，该特性得到进一步的推广，任何对象类型都可以被列表初始化</p></li><li><p>千万别直接列表初始化auto变量</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">autod=&#123;<span class="hljs-number">1.23</span>&#125;;<span class="hljs-comment">//d即是std::initializer_list&lt;double&gt;</span><br>autod=<span class="hljs-type">double</span>&#123;<span class="hljs-number">1.23</span>&#125;;<span class="hljs-comment">//善哉--d即为double,并非std::initializer_list.</span><br></code></pre></td></tr></table></figure><h3 id="lambda表达式">6.21.Lambda表达式</h3><ul><li>适当使用lambda表达式。别用默认lambda捕获，所有捕获都要显式写出来。</li><li>Lambda表达式是创建匿名函数对象的一种简易途径，常用于把函数当参数传，例如：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::<span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),[](intx,inty)&#123;<br><span class="hljs-built_in">returnWeight</span>(x)&lt;<span class="hljs-built_in">Weight</span>(y);<br>&#125;);<br><br></code></pre></td></tr></table></figure><h3 id="模板编程">6.22.模板编程</h3><ul><li>不要使用复杂的模板编程</li><li>模板编程指的是利用c++模板实例化机制是图灵完备性,可以被用来实现编译时刻的类型判断的一系列编程技巧</li></ul><h3 id="boost库">6.23.Boost库</h3><ul><li>只使用Boost中被认可的库.</li><li>Boost代码质量普遍较高,可移植性好,填补了C++标准库很多空白,如型别的特性,更完善的绑定器,更好的智能指针</li></ul><h3 id="c11">6.24.C++11</h3><ul><li>适当用C++11（前身是C++0x）的库和语言扩展，在贵项目用C++11特性前三思可移植性。</li></ul><h3 id="tips-4">tips</h3><ol type="1"><li>实际上，缺省参数会改变函数签名的前提是改变了它接收的参数数量，比如把voida()改成voida(intb=0),开发者改变其代码的初衷也许是，在不改变「代码兼容性」的同时，又提供了可选int参数的余地，然而这终究会破坏函数指针上的兼容性，毕竟函数签名确实变了。</li><li>此外把自带缺省参数的函数地址赋值给指针时，会丢失缺省参数信息。</li><li>我还发现滥用缺省参数会害得读者光只看调用代码的话，会误以为其函数接受的参数数量比实际上还要少。</li><li>friend实际上只对函数／类赋予了对其所在类的访问权限，并不是有效的声明语句。所以除了在头文件类内部写friend函数／类，还要在类作用域之外正式地声明一遍，最后在对应的.cc文件加以定义。</li><li>本风格指南都强调了「友元应该定义在同一文件内，避免代码读者跑到其它文件查找使用该私有成员的类」。那么可以把其声明放在类声明所在的头文件，定义也放在类定义所在的文件。</li><li>由于友元函数／类并不是类的一部分，自然也不会是类可调用的公有接口，于是我主张全集中放在类的尾部，即的数据成员之后，参考声明顺序。</li><li>对使用C++异常处理应具有怎样的态度？非常值得一读。</li><li>注意初始化const对象时，必须在初始化的同时值初始化。</li><li>用断言代替无符号整型类型，深有启发。</li><li>auto在涉及迭代器的循环语句里挺常用。</li><li>ShouldthetrailingreturntypesyntaxstylebecomethedefaultfornewC++11programs?讨论了auto与尾置返回类型一起用的全新编码风格，值得一看。</li></ol><h2 id="命名约定">7.命名约定</h2><h3 id="通用命名规则">7.1.通用命名规则</h3><ul><li>函数命名,变量命名,文件命名要有描述性;少用缩写</li></ul><h3 id="文件命名">7.2.文件命名</h3><ul><li>文件名要全部小写,可以包含下划线(<em>)或连字符(-),依照项目的约定.如果没有约定,那么“</em>”更好</li></ul><h3 id="类型命名">7.3.类型命名</h3><ul><li>类型名称的每个单词首字母均大写,不包含下划线:MyExcitingClass,MyExcitingEnum</li></ul><h3 id="变量命名">7.4.变量命名</h3><ul><li><p>变量(包括函数参数)和数据成员名一律小写,单词之间用下划线连接.类的成员变量以下划线结尾,但结构体的就不用,如:a_local_variable,a_struct_data_member,a_class_data_member_.</p></li><li><p>普通变量命名全小写或者用下划线，不要混合大小写</p></li><li><p>类数据成员，和普通变量名一样，但是要在最后接下划线：stringtable_name_</p></li><li><p>结构体变量，和普通变量名一样</p></li></ul><h3 id="常量命名">7.5.常量命名</h3><ul><li>声明为constexpr或const的变量,或在程序运行期间其值始终保持不变的,命名时以“k”开头,大小写混合</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">constintkDaysInWeek=<span class="hljs-number">7</span>;<br></code></pre></td></tr></table></figure><ul><li>所有具有静态存储类型的变量(例如静态变量或全局变量,参见存储类型)都应当以此方式命名.对于其他存储类型的变量,如自动变量等,这条规则是可选的.如果不采用这条规则,就按照一般的变量命名规则.</li></ul><h3 id="函数命名">7.6.函数命名</h3><ul><li><p>常规函数使用大小写混合,取值和设值函数则要求与变量名匹配:MyExcitingFunction(),</p></li><li><p>一般来说,函数名的每个单词首字母大写(即“驼峰变量名”或“帕斯卡变量名”),没有下划线.对于首字母缩写的单词,更倾向于将它们视作一个单词进行首字母大写(例如,写作StartRpc()而非StartRPC())</p></li><li><p>同样的命名规则同时适用于类作用域与命名空间作用域的常量</p></li><li><p>取值和设值函数的命名与变量一致.一般来说它们的名称与实际的成员变量对应,但并不强制要求.例如intcount()与voidset_count(intcount).</p></li></ul><h3 id="命名空间命名">7.7.命名空间命名</h3><ul><li>命名空间以小写字母命名.最高级命名空间的名字取决于项目名称.要注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突.</li><li>注意不使用缩写作为名称的规则同样适用于命名空间.命名空间中的代码极少需要涉及命名空间的名称,因此没有必要在命名空间中使用缩写</li></ul><h3 id="枚举命名">7.8.枚举命名</h3><ul><li>枚举的命名应当和常量或宏一致:kEnumName或是ENUM_NAME</li><li>单独的枚举值应该优先采用常量的命名方式.但宏方式的命名也可以接受</li></ul><h3 id="宏命名">7.9.宏命名</h3><ul><li>你并不打算使用宏,对吧?如果你一定要用,像这样命名:MY_MACRO_THAT_SCARES_SMALL_CHILDREN</li></ul><h3 id="命名规则的特例">7.10.命名规则的特例</h3><ul><li>如果你命名的实体与已有C/C++实体相似,可参考现有命名策略.</li><li>bigopen():函数名,参照open()的形式</li><li>uint:typedef</li><li>bigpos:struct或class,参照pos的形式</li><li>sparse_hash_map:STL型实体;参照STL命名约定</li><li>LONGLONG_MAX:常量,如同INT_MAX</li></ul><h2 id="注释">8.注释</h2><h3 id="注释风格">8.1.注释风格</h3><p>使用//或/**/,统一就好.</p><h3 id="文件注释">8.2.文件注释</h3><p>在每一个文件开头加入版权公告.文件注释描述了该文件的内容.如果一个文件只声明,或实现,或测试了一个对象,并且这个对象已经在它的声明处进行了详细的注释,那么就没必要再加上文件注释.除此之外的其他文件都需要文件注释.</p><p>法律公告和作者信息</p><p>​每个文件都应该包含许可证引用.为项目选择合适的许可证版本.(比如,Apache2.0,BSD,LGPL,GPL)如果你对原始作者的文件做了重大修改,请考虑删除原作者信息.</p><p>文件内容</p><p>​如果一个.h文件声明了多个概念,则文件注释应当对文件的内容做一个大致的说明,同时说明各概念之间的联系.一个一到两行的文件注释就足够了,对于每个概念的详细文档应当放在各个概念中,而不是文件注释中.</p><p>不要在.h和.cc之间复制注释,这样的注释偏离了注释的实际意义</p><h3 id="类注释">8.3.类注释</h3><p>每个类的定义都要附带一份注释,描述类的功能和用法,除非它的功能相当明显</p><h3 id="函数注释">8.4.函数注释</h3><p>函数声明处的注释描述函数功能;定义处的注释描述函数实现</p><p>基本上每个函数声明处前都应当加上注释,描述函数的功能和用途.只有在函数的功能简单而明显时才能省略这些注释(例如,简单的取值和设值函数).注释使用叙述式(“Opensthefile”)而非指令式(“Openthefile”);注释只是为了描述函数,而不是命令函数做什么.通常,注释不会描述函数如何工作.那是函数定义部分的事情.</p><p>函数声明处注释的内容:</p><ul><li><p>函数的输入输出.</p></li><li><p>对类成员函数而言:函数调用期间对象是否需要保持引用参数,是否会释放这些参数</p></li><li><p>函数是否分配了必须由调用者释放的空间.</p></li><li><p>参数是否可以为空指针.</p></li><li><p>是否存在函数使用上的性能隐患.</p></li><li><p>如果函数是可重入的,其同步前提是什么?</p></li></ul><h3 id="变量注释">8.5.变量注释</h3><ul><li><p>通常变量名本身足以很好说明变量用途.某些情况下,也需要额外的注释说明</p></li><li><p>类数据成员</p><ul><li>每个类数据成员(也叫实例变量或成员变量)都应该用注释说明用途.如果有非变量的参数(例如特殊值,数据成员之间的关系,生命周期等)不能够用类型与变量名明确表达,则应当加上注释.然而,如果变量类型与变量名已经足以描述一个变量,那么就不再需要加上注释.</li><li>特别地,如果变量可以接受NULL或-1等警戒值,须加以说明</li></ul></li><li><p>全局变量和数据成员一样,所有全局变量也要注释说明含义及用途,以及作为全局变量的原因.</p></li></ul><h3 id="实现注释">8.6.实现注释</h3><p>对于代码中巧妙的,晦涩的,有趣的,重要的地方加以注释.</p><h3 id="标点拼写和语法">8.7.标点,拼写和语法</h3><p>注意标点,拼写和语法;写的好的注释比差的要易读的多.</p><h3 id="todo注释">8.8.TODO注释</h3><p>对那些临时的,短期的解决方案,或已经够好但仍不完美的代码使用TODO注释.</p><p>TODO注释要使用全大写的字符串TODO,在随后的圆括号里写上你的名字,邮件地址,bugID,或其它身份标识和与这一TODO相关的issue.主要目的是让添加注释的人(也是可以请求提供更多细节的人)可根据规范的TODO格式进行查找.添加TODO注释并不意味着你要自己来修正,因此当你加上带有姓名的TODO时,一般都是写上自己的名字.</p><h3 id="弃用注释">8.9.弃用注释</h3><ul><li>通过弃用注释（DEPRECATEDcomments）以标记某接口点已弃用.</li><li>您可以写上包含全大写的DEPRECATED的注释,以标记某接口为弃用状态.注释可以放在接口声明前,或者同一行.</li><li>在DEPRECATED一词后,在括号中留下您的名字,邮箱地址以及其他身份标识.</li><li>弃用注释应当包涵简短而清晰的指引,以帮助其他人修复其调用点.在C++中,你可以将一个弃用函数改造成一个内联函数,这一函数将调用新的接口.</li><li>仅仅标记接口为DEPRECATED并不会让大家不约而同地弃用,您还得亲自主动修正调用点（callsites）,或是找个帮手.</li><li>修正好的代码应该不会再涉及弃用接口点了,着实改用新接口点.如果您不知从何下手,可以找标记弃用注释的当事人一起商量.</li></ul><h3 id="tips-5">tips</h3><ol type="1"><li>关于注释风格,很多C++的coders更喜欢行注释,Ccoders或许对块注释依然情有独钟,或者在文件头大段大段的注释时使用块注释;</li><li>文件注释可以炫耀你的成就,也是为了捅了篓子别人可以找你;</li><li>注释要言简意赅,不要拖沓冗余,复杂的东西简单化和简单的东西复杂化都是要被鄙视的</li><li>对于Chinesecoders来说,用英文注释还是用中文注释,itisaproblem,但不管怎样,注释是为了让别人看懂,难道是为了炫耀编程语言之外的你的母语或外语水平吗；</li><li>注释不要太乱,适当的缩进才会让人乐意看.但也没有必要规定注释从第几列开始(我自己写代码的时候总喜欢这样),UNIX/LINUX下还可以约定是使用tab还是space,个人倾向于space;</li><li>TODO很不错,有时候,注释确实是为了标记一些未完成的或完成的不尽如人意的地方,这样一搜索,就知道还有哪些活要干,日志都省了</li></ol><h2 id="格式">9.格式</h2><h3 id="行长度">9.1行长度</h3><ul><li><p>每一行代码字符数不超过80.</p></li><li><p>包含长路径的#include语句可以超出80列</p></li><li><p>头文件保护可以无视该原则.</p></li></ul><h3 id="非ascii字符">9.2非ASCII字符</h3><ul><li><p>尽量不使用非ASCII字符,使用时必须使用UTF-8编码</p></li><li><p>即使是英文,也不应将用户界面的文本硬编码到源代码中,因此非ASCII字符应当很少被用到.特殊情况下可以适当包含此类字符</p></li></ul><h3 id="空格还是制表位">9.3空格还是制表位</h3><ul><li>只使用空格,每次缩进2个空格.</li><li>我们使用空格缩进.不要在代码中使用制表符.你应该设置编辑器将制表符转为空格</li></ul><h3 id="函数声明与定义">9.4函数声明与定义</h3><ul><li><p>返回类型和函数名在同一行,参数也尽量放在同一行,如果放不下就对形参分行,分行方式与函数调用一致.</p></li><li><p>如果同一行文本太多,放不下所有参数:</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">ReturnTypeClassName::<span class="hljs-built_in">ReallyLongFunctionName</span>(Typepar_name1,Typepar_name2,<br>Typepar_name3)&#123;<br><span class="hljs-built_in">DoSomething</span>();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">ReturnTypeLongClassName::<span class="hljs-built_in">ReallyReallyReallyLongFunctionName</span>(<br>Typepar_name1,<span class="hljs-comment">//4spaceindent</span><br>Typepar_name2,<br>Typepar_name3)&#123;<br><span class="hljs-built_in">DoSomething</span>();<span class="hljs-comment">//2spaceindent</span><br>...<br>&#125;<br><br></code></pre></td></tr></table></figure><p>注意以下几点:</p><ul><li>使用好的参数名.</li><li>只有在参数未被使用或者其用途非常明显时,才能省略参数名.</li><li>如果返回类型和函数名在一行放不下,分行.</li><li>如果返回类型与函数声明或定义分行了,不要缩进.</li><li>左圆括号总是和函数名在同一行.</li><li>函数名和左圆括号间永远没有空格.</li><li>圆括号与参数间没有空格.</li><li>左大括号总在最后一个参数同一行的末尾处,不另起新行.</li><li>右大括号总是单独位于函数最后一行,或者与左大括号同一行.</li><li>右圆括号和左大括号间总是有一个空格.</li><li>所有形参应尽可能对齐.</li><li>缺省缩进为2个空格.</li><li>换行后的参数保持4个空格的缩进</li></ul><h3 id="lambda表达式-1">9.5.Lambda表达式</h3><p>Lambda表达式对形参和函数体的格式化和其他函数一致;捕获列表同理,表项用逗号隔开</p><p>若用引用捕获,在变量名和&amp;之间不留空格</p><h3 id="函数调用">9.6.函数调用</h3><p>要么一行写完函数调用,要么在圆括号里对参数分行,要么参数另起一行且缩进四格.如果没有其它顾虑的话,尽可能精简行数,比如把多个参数适当地放在同一行里.</p><h3 id="列表初始化格式">9.7.列表初始化格式</h3><p>您平时怎么格式化函数调用,就怎么格式化列表初始化</p><h3 id="条件语句">9.8条件语句</h3><p>倾向于不在圆括号内使用空格.关键字if和else另起一行</p><p>注意所有情况下if和左圆括号间都有个空格.右圆括号和左大括号之间也要有个空格</p><h3 id="循环和开关选择语句">9.9循环和开关选择语句</h3><p>switch语句可以使用大括号分段,以表明cases之间不是连在一起的.在单语句循环里,括号可用可不用.空循环体应使用{}或continue.</p><p>空循环体应使用{}或continue,而不是一个简单的分号</p><h3 id="指针和引用表达式">9.10指针和引用表达式</h3><p>句点或箭头前后不要有空格.指针/地址操作符(*,&amp;)之后不能有空格.</p><h3 id="布尔表达式">9.11布尔表达式</h3><p>如果一个布尔表达式超过标准行宽,断行方式要统一一下</p><p>逻辑与(&amp;&amp;)操作符总位于行尾:</p><h3 id="函数返回值">9.12函数返回值</h3><p>不要在return表达式里加上非必须的圆括号.</p><h3 id="变量及数组初始化">9.13变量及数组初始化</h3><p>用=,()和{}均可</p><h3 id="预处理指令">9.14预处理指令</h3><p>预处理指令不要缩进,从行首开始</p><h3 id="类格式">9.15类格式</h3><p>访问控制块的声明依次序是public:,protected:,private:,每个都缩进1个空格</p><ul><li>所有基类名应在80列限制下尽量与子类名放在同一行.</li><li>关键词public:,protected:,private:要缩进1个空格.</li><li>除第一个关键词(一般是public)外,其他关键词前要空一行.如果类比较小的话也可以不空.</li><li>这些关键词后不要保留空行.</li><li>public放在最前面,然后是protected,最后是private.</li><li>关于声明顺序的规则请参考声明顺序一节</li></ul><h3 id="构造函数初始值列表">9.16构造函数初始值列表</h3><p>构造函数初始化列表放在同一行或按四格缩进并排多行</p><h3 id="命名空间格式化">9.17命名空间格式化</h3><p>命名空间内容不缩进</p><p>命名空间不要增加额外的缩进层次,</p><p>声明嵌套命名空间时,每个命名空间都独立成行.</p><h3 id="水平留白">9.18水平留白</h3><p>水平留白的使用根据在代码中的位置决定.永远不要在行尾添加没意义的留白.</p><p>通用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">voidf</span>(boolb)&#123;<span class="hljs-comment">//左大括号前总是有空格.</span><br>...<br>inti=<span class="hljs-number">0</span>;<span class="hljs-comment">//分号前不加空格.</span><br><span class="hljs-comment">//列表初始化中大括号内的空格是可选的.</span><br><span class="hljs-comment">//如果加了空格,那么两边都要加上.</span><br>intx[]=&#123;<span class="hljs-number">0</span>&#125;;<br>intx[]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-comment">//继承与初始化列表中的冒号前后恒有空格.</span><br>classFoo:publicBar&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//对于单行函数的实现,在大括号内加上空格</span><br><span class="hljs-comment">//然后是函数实现</span><br><span class="hljs-built_in">Foo</span>(intb):<span class="hljs-built_in">Bar</span>(),<span class="hljs-built_in">baz_</span>(b)&#123;&#125;<span class="hljs-comment">//大括号里面是空的话,不加空格.</span><br><span class="hljs-built_in">voidReset</span>()&#123;baz_=<span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//用空格把大括号与实现分开.</span><br>...<br></code></pre></td></tr></table></figure><p>循环和条件语句</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(b)&#123;<span class="hljs-comment">//if条件语句和循环语句关键字后均有空格.</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//else前后有空格.</span><br>&#125;<br><span class="hljs-keyword">while</span>(test)&#123;&#125;<span class="hljs-comment">//圆括号内部不紧邻空格.</span><br><span class="hljs-keyword">switch</span>(i)&#123;<br><span class="hljs-keyword">for</span>(inti=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)&#123;<br><span class="hljs-keyword">switch</span>(i)&#123;<span class="hljs-comment">//循环和条件语句的圆括号里可以与空格紧邻.</span><br><span class="hljs-keyword">if</span>(test)&#123;<span class="hljs-comment">//圆括号,但这很少见.总之要一致.</span><br><span class="hljs-keyword">for</span>(inti=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)&#123;<br><span class="hljs-keyword">for</span>(;i&lt;<span class="hljs-number">5</span>;++i)&#123;<span class="hljs-comment">//循环里内;后恒有空格,;前可以加个空格.</span><br><span class="hljs-keyword">switch</span>(i)&#123;<br>case1:<span class="hljs-comment">//switchcase的冒号前无空格.</span><br>...<br>case2:<span class="hljs-keyword">break</span>;<span class="hljs-comment">//如果冒号有代码,加个空格</span><br></code></pre></td></tr></table></figure><p>操作符</p><ul><li>赋值值运算符前后总是有空格.</li><li>圆括号内部没有紧邻空格</li><li>参数和一元操作符之间不加空格</li></ul><p>模板和转换</p><ul><li><p>尖括号(<and>)不与空格紧邻,&lt;前没有空格,&gt;和(之间也没有</and></p></li><li><div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>  vector<span class="op">&lt;</span>string<span class="op">&gt;</span>x<span class="op">;</span></span><span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  y<span class="op">=</span><span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">char</span><span class="op">*&gt;(</span>x<span class="op">);</span></span><span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">//在类型与指针操作符之间留空格也可以,但要保持一致.</span></span><span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  vector<span class="op">&lt;</span><span class="dt">char</span> <span class="op">*&gt;</span>x<span class="op">;</span></span></code></pre></div></li></ul><h3 id="垂直留白">9.19垂直留白</h3><p>垂直留白越少越好</p><p>这不仅仅是规则而是原则问题了:不在万不得已,不要使用空行.尤其是:两个函数定义之间的空行不要超过2行,函数体首尾不要留空行,函数体中也不要随意添加空行.</p><p>基本原则是:同一屏可以显示的代码越多,越容易理解程序的控制流.当然,过于密集的代码块和过于疏松的代码块同样难看,这取决于你的判断.但通常是垂直留白越少越好.</p><p>下面的规则可以让加入的空行更有效:</p><ul><li>函数体内开头或结尾的空行可读性微乎其微.</li><li>在多重if-else块里加空行或许有点可读性</li></ul><h3 id="tips-6">tips</h3><ol type="1"><li>对于代码格式,因人,系统而异各有优缺点,但同一个项目中遵循同一标准还是有必要的;</li><li>行宽原则上不超过80列,把22寸的显示屏都占完,怎么也说不过去;</li><li>尽量不使用非ASCII字符,如果使用的话,参考UTF-8格式(尤其是UNIX/Linux下,Windows下可以考虑宽字符),尽量不将字符串常量耦合到代码中,比如独立出资源文件,这不仅仅是风格问题了;</li><li>UNIX/Linux下无条件使用空格,MSVC的话使用Tab也无可厚非;</li><li>函数参数,逻辑条件,初始化列表:要么所有参数和函数名放在同一行,要么所有参数并排分行;</li><li>除函数定义的左大括号可以置于行首外,包括函数/类/结构体/枚举声明,各种语句的左大括号置于行尾,所有右大括号独立成行;</li><li>./-&gt;操作符前后不留空格,*/&amp;不要前后都留,一个就可,靠左靠右依各人喜好;</li><li>预处理指令/命名空间不使用额外缩进,类/结构体/枚举/函数/语句使用缩进;</li><li>初始化用=还是()依个人喜好,统一就好;</li><li>return不要加();</li><li>水平/垂直留白不要滥用,怎么易读怎么来.</li><li>关于UNIX/Linux风格为什么要把左大括号置于行尾(.cc文件的函数实现处,左大括号位于行首),我的理解是代码看上去比较简约,想想行首除了函数体被一对大括号封在一起之外,只有右大括号的代码看上去确实也舒服;Windows风格将左大括号置于行首的优点是匹配情况一目了然.</li><li>80行限制事实上有助于避免代码可读性失控,比如超多重嵌套块,超多重函数调用等等.</li><li>Linux上设置好了Locale就几乎一劳永逸设置好所有开发环境的编码,不像奇葩的Windows.</li><li>Google强调有一对if-else时,不论有没有嵌套,都要有大括号.Apple正好有栽过跟头.</li><li>其实我主张指针／地址操作符与变量名紧邻,int<em>a,bvsint</em>a,b,新手会误以为前者的b是int*变量,但后者就不一样了,高下立判.</li><li>在这风格指南里我才刚知道C++原来还有所谓的Alternativeoperatorrepresentations,大概没人用吧.</li><li>注意构造函数初始值列表（ConstructerInitializerList）与列表初始化（InitializerList）是两码事,我就差点混淆了它们的翻译.</li><li>事实上,如果您熟悉英语本身的书写规则,就会发现该风格指南在格式上的规定与英语语法相当一脉相承.比如普通标点符号和单词后面还有文本的话,总会留一个空格;特殊符号与单词之间就不用留了,比如if(true)中的圆括号与true.</li><li>本风格指南没有明确规定void函数里要不要用return语句,不过就Google开源项目leveldb并没有写;此外从Isablankreturnstatementattheendofafunctionwhosreturntypeisvoidnecessary?来看,return;比return;更约定俗成（事实上cpplint会对后者报错,指出分号前有多余的空格）,且可用来提前跳出函数栈.</li></ol><h2 id="规则特例">10.规则特例</h2><ul><li>使用MicrosoftVisualC++进行编译时,将警告级别设置为3或更高,并将所有警告(warnings)当作错误(errors)处理.</li><li>不要使用#pragmaonce;而应该使用Google的头文件保护规则.头文件保护的路径应该相对于项目根目录</li></ul>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>google_style</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9. 杂项讨论</title>
    <link href="/2024/11/27/effective-cpp/9-%E6%9D%82%E9%A1%B9%E8%AE%A8%E8%AE%BA/"/>
    <url>/2024/11/27/effective-cpp/9-%E6%9D%82%E9%A1%B9%E8%AE%A8%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="不要轻忽编译器的警告">53. 不要轻忽编译器的警告</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">class B&#123;<br>public:<br>    virtual void f() const;<br>&#125;<br><br>class D&#123;<br>    public:<br>    virtual void f();<br>&#125;<br></code></pre></td></tr></table></figure><p>希望D::f重新定义virtual函数B::f，B的f是个const成员函数，而D中未被声明为const</p><ol type="1"><li>严肃对待编译器发出的警告信息。</li><li>不要过度依赖编译器的报警能力，不同编译器的警告信息可能不同</li></ol><h2 id="让自己熟悉包括tr1在内的标准程序库">54.让自己熟悉包括TR1在内的标准程序库</h2><ol type="1"><li><p>TR1表示“Technical Report 1"</p></li><li><p>TR1组件实例</p></li><li><ol type="1"><li>智能指针 trl::shared_ptr和tr1::weak_ptr</li></ol></li><li><ol type="1"><li><ol type="1"><li>前者作用如内置指针，但会记录有多少个tr1::shared_ptrs共同指向同一个对象。这就是引用计数referencecountering。一旦最后一个这样的指针被销毁，也就是一旦某对象的引用次数变成，这个对象会被自动删除。这在非环形数据结构中防止资源泄露很有帮助，</li><li>如果两个或者多个对象内含trl::shared_ptrs并形成环状，这个唤醒会造成每个对象的引用次数都超过0，即使指向这个环形的所有指针都已被销毁</li><li>这就是有trl::weak_ptrs的原因，并不参与引用计数的计算；当最后一个指向对象的trl:shared_ptr被销毁，纵使还有个trl::weak_ptr继续指向同一对象，该对象仍会被删除，该情况下的weak_ptr被自动标示无效</li></ol></li></ol></li><li><p>trl::function</p></li><li><ol type="1"><li>表示任何可调用物（任何函数或者函数对象），只要签名符合目标</li><li>假设想注册一个callback函数</li><li>void registerCallback(std::stringfunc(int));参数名称func可有可无，可以这样声明voidregisterCallback(std::string (int));std::string(int)是函数签名trl::function是上述的函数有可能更富弹性地接受任何可调用五，只要这个可调用五接受一个int或任何可悲转换为int的东西，并返回一个string或这和可被转换为string的东西</li><li>trl::function是个template，以其目标函数的签名为参数</li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">void registerCallback(std::tr1::function&lt;std::string (int)&gt; func);<br>//只要该可调用物的签名与std::string(int)一致<br></code></pre></td></tr></table></figure><ol type="1"><li><p>tr1::bind</p></li><li><ol type="1"><li>能够做STL绑定器bind1st和bind2nd所做的每一件事，而又更多</li><li>与前任绑定器不同的是，tr1::bind可以和const及non-const成员函数协同运作，可以和by-reference参数协同运作</li><li>不需要特殊协助就可以处理函数指针，所以我们调用tr1::bind之前不必再被什么ptr_fun,men_fun或者mem_fun_ref搞得一团混乱。</li><li>tr1::bind是第二代绑定工具，比前一代好很多</li></ol></li><li><p>彼此互不相干的独立机能：</p></li><li><ol type="1"><li>hash tables：</li></ol></li><li><ol type="1"><li><ol type="1"><li>用来实现sets，multisets，maps和multi-maps</li><li>每个新容器的接口都是其前任对应容器塑模而成</li><li>名称tr1::unordered_set, tr1::unordered_multiset, tr1::unordered_map,tr1::unordered_multimap</li><li>这些名字强调他们和set，multiset, map或者multimap不同，以hanshu为基础的这些TR1容器内的元素并无任何可预期的次序</li></ol></li></ol></li><li><ol type="1"><li>正则表达式</li></ol></li><li><ol type="1"><li><ol type="1"><li>包括正则表达式为基础的字符串查找和替换，</li><li>或者从某个匹配字符串到另一匹配字符串的注意迭代等</li></ol></li></ol></li><li><ol type="1"><li>Tuples（变量组），这是标准程序库中pair template的新一代制品。</li></ol></li><li><ol type="1"><li><ol type="1"><li>pair只能有两个对象</li><li>tr1::tuple可以持有任意个数的对象。</li></ol></li></ol></li><li><ol type="1"><li>tr1::array，本质上是个STL化的数组，即一个支持成员函数如begin和end的数组，不过tr1::array的大小固定，并不适用动态内存</li><li>tr1::mem_fn</li></ol></li><li><ol type="1"><li><ol type="1"><li>这是个语句构造上与成员函数指针一样的东西</li><li>纳入并扩充了c++98的mem_fun和mem_fun_ref的能力</li></ol></li></ol></li><li><ol type="1"><li>tr1::reference_wrapper</li></ol></li><li><ol type="1"><li><ol type="1"><li>让reference的行为更像对象的设施</li><li>可以造成容器“犹如持有reference”，实际上，容器只能吃有对象或指针</li></ol></li></ol></li><li><ol type="1"><li>随机数生成工具，大大超越了rand</li><li>数学特殊函数，包括laguerre多项式，Bessel函数，完全椭圆积分以及更多数学函数</li><li>C99兼容扩充。</li></ol></li><li><ol type="1"><li><ol type="1"><li>这是一大堆函数和模板，用来将许多新的c99程序库特性带进C++</li></ol></li></ol></li><li><p>更精巧的template编程</p></li><li><ol type="1"><li>Type traits</li></ol></li><li><ol type="1"><li><ol type="1"><li>一组trait classes，用来一同类型的编译期信息</li><li>给予一个类型T，TR1的typetraits可以指出T是否是个内置类型，是否一同virtual析构函数，是否是个emptyclass，可隐式转换为其他类型U</li><li>也可以显现该给定类型之适当齐位，这对定制型内存分配器而言是关键信息。</li></ol></li></ol></li><li><ol type="1"><li>tr1::result_of</li></ol></li><li><ol type="1"><li><ol type="1"><li>这是个template，用来推导函数调用的返回类型</li><li>在编写templates时，能够referto函数调用动作返回的对象的类型往往很重要，但是该类型有可能以复杂的方式却决于函数的参数类型</li><li>result_of使得”refer to函数返回类型“变得十分容易</li></ol></li></ol></li><li><p>C++标准程序库的主要机能由STL、iostreams、locales组成，并包含C99标准程序库</p></li></ol><h2 id="让自己熟悉boost">55. 让自己熟悉Boost</h2><ol type="1"><li><p>字符串与文本处理</p></li><li><ol type="1"><li>覆盖具备类型安全的printf-like格式化动作、正则表达式，以及语汇单元切割和解析</li></ol></li><li><p>容器，覆盖”接口与STL相似且大小固定“的数组、大小可变的bitsets以及多维数组</p></li><li><p>函数对象与高级编程</p></li><li><ol type="1"><li>覆盖若干被用爱作为TR1机能基础的程序库。其中一个有趣的程序库是Lambda，可以随时随地创建函数对象</li><li></li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">using namespace boost::lambda;<br>std::vector&lt;int&gt; v;<br><br>std::for_each(v.begin(),v.end()),<br>    std::cout &lt;&lt; _1 *2 + 10 &lt;&lt; &quot;\n&quot;);<br></code></pre></td></tr></table></figure><ol type="1"><li><p>泛型编程，覆盖一大组traits classes</p></li><li><p>模板元编程</p></li><li><ol type="1"><li>覆盖一个针对编译期assertions而写的程序库，以及BoostMPL程序库，提供了极好的东西，其中支持编译器实物诸如types的STL-like数据结构等</li><li></li><li>数学和数值</li></ol></li><li><ol type="1"><li><ol type="1"><li>包括有理数，八元数和四元数、公约数和少见的多重运算、随机数</li></ol></li></ol></li><li><ol type="1"><li>正确性和测试</li></ol></li><li><ol type="1"><li><ol type="1"><li>覆盖用来将隐式模板接口形式化的程序库，以及针对"测试有限"编程形态而设计的措施</li></ol></li></ol></li><li><ol type="1"><li>数据结构</li></ol></li><li><ol type="1"><li><ol type="1"><li>覆盖类型安全的unions，以及tuple程序库（是TR1同类机能的基础）</li></ol></li></ol></li><li><ol type="1"><li>语言见的支持</li></ol></li><li><ol type="1"><li><ol type="1"><li>包括允许C++和python之间的无缝互操作性</li></ol></li></ol></li><li><ol type="1"><li>内存</li></ol></li><li><ol type="1"><li><ol type="1"><li>覆盖Pool程序库，用来做出高效率而区块大小固定的分配器以及多变化的智能指针，包括（但不仅仅是）TR1智能指针。</li><li>另有一个non-TR1智能指针是scoped_array，是个auto_ptr-like智能指针，用来动态分配数组</li></ol></li></ol></li><li><ol type="1"><li>杂项</li></ol></li><li><ol type="1"><li><ol type="1"><li>包括CRC检验、日期和时间的处理，在文件系统上来回移动等等</li></ol></li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">typedef boost::mpl::list&lt;float, double, long double&gt; floats;<br>typedef boost::mpl::push_front&lt;floats, int&gt;::type types;<br></code></pre></td></tr></table></figure><p>这样的容器类型常被成为typelists</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>effective c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8. 定制new和delete</title>
    <link href="/2024/11/27/effective-cpp/8-%E5%AE%9A%E5%88%B6new%E5%92%8Cdelete/"/>
    <url>/2024/11/27/effective-cpp/8-%E5%AE%9A%E5%88%B6new%E5%92%8Cdelete/</url>
    
    <content type="html"><![CDATA[<h2 id="了解new-handler的行为">49. 了解new-handler的行为</h2><ol type="1"><li>当operatornew无法满足某一内存分配需求时，它会抛出异常。以前它会返回一个u1指针，某些旧式编译器目前也还那么做。</li><li>当operatornew抛出异常以反映一个未获满足的内存需求之前，它会先调用一个客户指定的错误处理函数，一个所谓的new_handler。</li><li>为了指定这个“用以处理内存不足”的函数，客户必须调用set newhandler，那是声明于<new>的个标准程序库函数：</new></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> std&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*new_handler)</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">new_handler <span class="hljs-title">set_new_handler</span><span class="hljs-params">(new_handler p)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>set_new_handler的参数是个指针，指向operatornew无法分配足够内存时该被调用的函数。其返回值也是个指针，指向set newhandler被调用前正在执行（但马上就要被替换)的那个new-handler函数。</li><li>设计良好的new-handler函数必须做以下事情：</li><li>让更多内存可被使用。这便造成operatornew内的下一次内存分配动作可能成功。实现此策略的一个做法是，程序一开始执行就分配一大块内存，而后当new-handler第一次被调用，将它们释还给程序使用。</li><li>安装另一个new-handler。如果目前这个new-handler无法取得更多可用内存，或许它知道另外哪个new-handler有此能力。果真如此，目前这个new-handler就可以安装另外那个new-handler以替换自己（只要调用setnew handler)。下次当operatornew调用new-handler,`调用的将是最新安装的那个。（这个旋律的变奏之一是让new-handler修改自己的行为，于是当它下次被调用，就会做某些不同的事。为达此目的，做法之一是令new-handler修改“会影响new-handler行为”的static数据、namespace数据或global数据。)</li><li>卸除new-handler,也就是将null指针传给set newhandler。一旦没有安装任何new-handler, operatornew会在内存分配不成功时抛出异常。</li><li>抛出bad alloc(或派生自bad alloc)的异常。这样的异常不会被operatornew捕捉，因此会被传播到内存索求处。</li><li>不返回，通常调用abort或exit。</li><li>C++并不支持class专属之new-handlers,但其实也不需要。你可以自己实现出这种行为。只需令每一个class提供自己的setnew handler和operator,new即可。其中set newhandler使客户得以指定class专属的new-handler(就像标准的set newhandler允许客户指定global new-handler),至于operatornew.则确保在分配class对象内存的过程中以class专属之new-handler替换globalnew-handler。</li><li>set_new_handler允许客户指定一个函数，在内存分配无法获得满足时被调用。</li><li>Nothrownew是一个颇为局限的工具，因为它只适用于内存分配；后继的构造函数调用还是可能抛出异常。</li></ol><h2 id="了解new和delete的合理替换时机">50.了解new和delete的合理替换时机</h2><ol type="1"><li>为什么替换编译器提供的operator new或operator delete呢？</li><li><strong>用来检测运用上的错误。</strong>如果将“new所得内存”delete掉却不幸失败，会导致内存泄漏(memoryleaks)。如果在“new所得内存”身上多次delete则会导致不确定行为。如果operatornew持有一串动态分配所得地址，而operatordelete将地址从中移走，倒是很容易检测出上述错误用法。</li><li>为了强化效能。编译器所带的operator new和operatordelete主要用于一般目的，它们不但可被长时间执行的程序（例如网页服务器，webservers)接受，也可被执行时间少于一秒的程序接受。它们必须处理一系列需求，包括大块内存、小块内存、大小混合型内存。它们必须接纳各种分配形态，范围从程序存活期间的少量区块动态分配，到大数量短命对象的持续分配和归还。它们必须考虑破碎问题(fragmentation),这最终会导致程序无法满足大区块内存要求，即使彼时有总量足够但分散为许多小区块的自由内存。</li><li>现实存在这么些个对内存管理器的要求，因此编译器所带的operatornews和operatordeletes采取中庸之道也就不令人惊讶了。它们的工作对每个人都是适度地好，但不对特定任何人有最佳表现。如果你对你的程序的动态内存运用型态有深刻的了解，通常可以发现，定制版之peratornew和operatordelete性能胜过缺省版本。说到胜过，我的意思是它们比较快，有时甚至快很多，而且它们需要的内存比较少，最高可省50%。对某些（虽然不是所有）应用程序而言，将旧有的（编译器自带的）new和delete替换为定制版本，是获得重大效能提升的办法之一。</li><li>为了收集使用上的统计数据。在一头栽进定制型news和定制型deletes之前，理当先收集你的软件如何使用其动态内存。分配区块的大小分布如何？寿命分布如何？它们倾向于以FIFO(先进先出)次序或LFO(后进先出)次序或随机次序来分配和归还？它们的运用型态是否随时间改变，也就是说你的软件在不同的执行阶段有不同的分配/归还形态吗？任何时刻所使用的最大动态分配量(高水位)是多少？自行定义operatornew和operator delete使我们得以轻松收集到这些信息。</li><li>另一个选择是开放源码(opensource)领域中的内存管理器。它们对许多平台都可用，你可以下载并试试。Boost程序库（见条款55）的Pool就是这样一个分配器，它对于最常见的“分配大量小型对象”很有帮助。</li><li>为了增加分配和归还的速度。泛用型分配器往往（虽然并不总是）比定制型分配器慢，特别是当定制型分配器专门针对某特定类型之对象而设计时。Class专属分配器是“区块尺寸固定”之分配器实例，例如Boost提供的Pool程序库便是。如果你的程序是个单线程程序，但你的编译器所带的内存管理器具备线程安全，你或许可以写个不具线程安全的分配器而大幅改善速度。当然，在获得'operatornew和operatordelete有加快程序速度的价值”这个结论之前，首先请分析你的程序，确认程序瓶颈的确发生在那些内存函数身上。</li><li>为了降低缺省内存管理器带来的空间额外开销。泛用型内存管理器往往（虽然并非总是)不只比定制型慢，它们往往还使用更多内存，那是因为它们常常在每一个分配区块身上招引某些额外开销。针对小型对象而开发的分配器（例如Boost的Pool程序库)本质上消除了这样的额外开销。</li><li>为了弥补缺省分配器中的非最佳齐位(suboptimalalignment)。一如先前所说，在x86体系结构.上doubles的访问最是快速一如果它们都是8-byte齐位。但是编译器自带的operatornews并不保证对动态分配而得的doubles采取8-byte齐位。这种情况下，将缺省的operatornew替换为一个8-byte齐位保证版，可导致程序效率大幅提升。</li><li>为了将相关对象成簇集中。如果你知道特定之某个数据结构往往被一起使用，而你又希望在处理这些数据时将“内存页错误”(pagefaults)的频率降至最低，那么为此数据结构创建另一个heap就有意义，这么一来它们就可以被成簇集中在尽可能少的内存页(pages）.上。new和delete的“placement版本”（见条款52)有可能完成这样的集簇行为。</li><li>为了获得非传统的行为。有时候你会希望operatorsnew和delete做编译器附带版没做的某些事情。例如你可能会希望分配和归还共享内存(sharedmemory)内的区块，但唯一能够管理该内存的只有CAPI函数，那么写下一个定制版new和delete(很可能是placement版本，见条款52),你便得以为CAPI穿上一件C+外套。你也可以写一个自定的operatordelete,在其中将所有归还内存内容覆盖为0，藉此增加应用程序的数据安全性。</li><li>有许多理由需要写个自定的new和delete,包括改善效能、对heap运用错误进行调试、收集heap使用信息。</li></ol><h2 id="编写new和delete时需固守常规">51.编写new和delete时需固守常规</h2><ol type="1"><li>让我们从operator new开始。实现一致性operatornew必得返回正确的值，内存不足时必得调用new-handling函数（见条款49)，必须有对付零内存需求的准备，还需避免不慎掩盖正常形式的new一虽然这比较偏近class的接口要求而非实现要求。正常形式的new描述于条款52。</li><li>operatornew的返回值十分单纯。如果它有能力供应客户申请的内存，就返回一个指针指向那块内存。如果没有那个能力，就遵循条款49描述的规则，并抛出一个badalloc异常。</li><li>然而其实也不是非常单纯，因为operatornew实际上不只一次尝试分配内存，并在每次失败后调用new-handling函数。这里假设new-handling函数也许能够做某些动作将某些内存释放出来。只有当指向new-handling函数的指针是null,operatornew才会抛出异常。</li><li>奇怪的是C++规定，即使客户要求0 bytes,.operatornew也得返回一个合法指针。纹种看以格异的行为甘中是为了简化语言其他部分。下面是个non-memberoperator new伪码(pseudocode):</li></ol><figure><img src="/2024/11/27/effective-cpp/8-%E5%AE%9A%E5%88%B6new%E5%92%8Cdelete/1707576288326-fe376eff-029d-4cef-911d-3bf1a5f603ae.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/effective-cpp/8-%E5%AE%9A%E5%88%B6new%E5%92%8Cdelete/1707576313400-f019e1ad-e896-431d-a91f-364ef447f553.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>你也可能带着怀疑的眼光斜睨这份伪码(pseudocode)，因为其中将new-handling函数指针设为null而后又立刻恢复原样。那是因为我们很不幸地没有任何办法可以直接取得new-handling函数指针，所以必须调用setnewhandler找出它来。拙劣，但有效一至少对单线程程序而言。若在多线程环境中你或许需要某种机锁(lock)以便安全处置new-handling函数背后的(global)数据结构。</li><li>operatornew应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就该调用new-handler。.它也应该有能力处理0bytes申请。Class专属版本则还应该处理“比正确大小更大的（错误）申请”。</li><li>operatordelete应该在收到null指针时不做任何事。Class专属版本则还应该处理“比正确大小更大的（错误）申请”。</li></ol><h2 id="写了placement-new还要写placement-delete">52. 写了placementnew还要写placement delete</h2><ol type="1"><li><figure><img src="/2024/11/27/effective-cpp/8-%E5%AE%9A%E5%88%B6new%E5%92%8Cdelete/1707574119356-fc7d6c39-f7f8-4fd4-93b7-34f75da1094a.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>这个版本的new已被纳入C++标准程序库，你只要#include<new>就可以取用它。这个new的用途之一是负责在vector的未使用空间上创建对象。它同时也是最早的placementnew版本。实际上它正是这个函数的命名根据：一个特定位置上的new。以上说明意味术语placementnew有多重定义。当人们谈到placementnew,大多数时候他们谈的是此一特定版本，也就是“唯一额外实参是个void*”，少数时候才是指接受任意额外实参之operatornew。上下文语境往往也能够使意义不明确的含糊话语清晰起来，但了解这一点相当重要：一般性术语"placement</new></li><li>placement delete只有在“伴随placementnew调用而触发的构造函数”出现异常时才会被调用。对着一个指针（例如上述的pw)施行delete绝不会导致调用placementdelete。不，绝对不会。</li><li>当你写一个placement operator new,请确定也写出了对应的placementoperatordelete。如果没有这样做，你的程序可能会发生隐微而时断时续的内存泄漏。</li><li>当你声明placement new和placementdelete,请确定不要无意识（非故意）地遮掩了它们的正常版本。</li></ol>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>effective c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7. 模板与泛型编程</title>
    <link href="/2024/11/27/effective-cpp/7-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/11/27/effective-cpp/7-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="了解隐式接口和编译期多态">41. 了解隐式接口和编译期多态</h2><ol type="1"><li>面向对象编程世界总以显示接口和运行期多态解决问题</li><li>由于w的类型被声明为Widget,所以w必须支持Widget接口。我们可以在源码中找出这个接口（例如在idget的.h文件中），看看它是什么样子，所以我称此为一个显式接口(explicitinterface），也就是它在源码中明确可见。</li><li>由于Widget的某些成员函数是virtual,w对那些函数的调用将表现出运行期多态(runtimepolymorphism)，也就是说将于运行期根据w的动态类型（见条款37)决定究竞调用哪一个函数。</li><li>纵使你从未用过templates，应该不陌生“运行期多态”和“编译期多态”之间的差异，因为它类似于“哪一个重载函数该被调用”（发生在编译期)和“哪一个virtual函数该被绑定”（发生在运行期）之间的差异。</li><li>通常显式接口由函数的签名式（也就是函数名称、参数类型、返回类型）构成。</li><li>隐式接口就完全不同了。它并不基于函数签名式，而是由有效表达式(validexpressions)组成。再次看看doProcessing template一开始的条件：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doProcessing</span><span class="hljs-params">(T &amp;w)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(w.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">20</span>&amp;&amp; w!=someNastyWIdget&#123;<br>        &#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><p>T(w的类型)的隐式接口看来好像有这些约束：</p></li><li><ol type="1"><li>它必须提供一个名为size的成员函数，该函数返回一个整数值。</li><li>它必须支持一个operator!=函数，用来比较两个T对象。这里我们假设someNastywidget的类型为T。</li><li>真要感谢操作符重载(operatoroverloading)带来的可能性，这两个约束都不需要满足</li></ol></li><li><p>classes和templates都支持接口(interfaces)和多态(polymorphism)。</p></li><li><p>对classes而言接口是显式的(explicit),以函数签名为中心。多态则是通过virtual函数发生于运行期。</p></li><li><p>对template参数而言，接口是隐式的(implicit).,奠基于有效表达式。多态则是通过template具现化和函数重载解析(functionoverloading resolution)发生于编译期。</p></li></ol><h2 id="了解typename的双重意义">42. 了解typename的双重意义</h2><ol type="1"><li>当我们声明template类型参数，class和typename的意义完全相同</li><li>C++并不总是把class和typename视为等价。有时候你一定得使用typename，为了解其时机，我们必须先谈谈你可以在template内指涉(referto).的两种名称</li><li>template内出现的名称如果相依于某个template参数，称之为从属名称(dependentnames)。如果从属名称在class内呈嵌套状，我们称它为嵌套从属名称(nesteddependent name)。</li><li>int是一个并不倚赖任何template参数的名称。这样的名称是谓非从属名称(non-dependentnames).。</li><li>嵌套从属名称有可能导致解析(parsing)困难。</li><li>如果解析器在template中遭遇一个嵌套从属名称，它便假设这名称不是个类型，除非你告诉它是。所以缺省情况下嵌套从属名称不是类型。</li><li>若要矫正这个形势，我们必须告诉C++说c:constiterator是个类型。只要紧临它之前放置关键字typename即可：</li><li>一般性规则很简单：任何时候当你想要在template中指涉一个嵌套从属类型名称，就必须在紧临它的前一个位置放上关键字typename。</li><li>typename只被用来验明嵌套从属类型名称；其他名称不该有它存在。</li></ol><figure><img src="/2024/11/27/effective-cpp/7-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/1707556429425-d318e2cd-59e8-435d-a4e9-52a7b2da947b.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>“typename必须作为嵌套从属类型名称的前缀词”这一规则的例外是，typename不可以出现在baseclasses list内的嵌套从属类型名称之前，也不可在member initializationlist(成员初值列)中作为base class修饰符.</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2024/png/35229143/1707556584352-036c9314-8409-40b5-81f6-bb6831b15ed9.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>让我们看看最后一个typename例子，那是你将在真实程序中看到的代表性例子。假设我们正在撰写一个functiontemplate,它接受一个迭代器，而我们打算为该迭代器指涉的对象做一份local复件（副本）temp。我们可以这么写：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">workWithIterator</span><span class="hljs-params">(IterT iter)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">typename</span> std::iterator_traits&lt;IterT&gt;::<span class="hljs-function">value_type <span class="hljs-title">temp</span><span class="hljs-params">(*iter)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>标准traitsclass（见条款47)的一种运用，相当于说“类型为IterT之对象所指之物的类型"，这个语句声明一个local变量(temp),使用IterT对象所指物的相同类型，并将temp初始化为iter所指物。如果IterT是vector<int>::iterator,temp的类型就是int。如果IterT是list<string>::iterator,temp的类型就是string。由于std:iterator_traits.<IterT>:valuetype是个嵌套从属类型名称(value type被嵌套于iteratortraits<IterT>之内而IterT是个template参数)，所以我们必须在它之前放置typename。</IterT></IterT></string></int></li><li>声明template参数时，前缀关键字class和typename可互换。</li><li>请使用关键字typename标识嵌套从属类型名称；但不得在base classlists(基类列)或member initialization list(成员初值列)内以它作为baseclass修饰符。</li></ol><h2 id="学习处理模板化基类内的名称">43. 学习处理模板化基类内的名称</h2><ol type="1"><li>注意class定义式最前头的"template&lt;&gt;”语法象征这既不是template也不是标准class,而是个特化版的MsgSendertemplate,在template实参是CompanyZ时被使用。这是所谓的模板全特化(totaltemplate,specialization)：templateMsgSender针对类型CompanyZ特化了，而且其特化是全面性的，也就是说一旦类型参数被定义为CompanyZ,再没有其他template参数可供变化。</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2024/png/35229143/1707557788872-b88bf5fe-ff55-47ab-b2de-89c7aabf83d1.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>令C++“不进入templatized base classes观察”的行为失效。</li><li>第一是在base class函数调用动作之前加上 this-&gt;</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2024/png/35229143/1707558520152-2b05a9ba-7882-4f12-99ac-4428f4c2dabb.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>第二是使用using声明式。如果你已读过条款33，这个解法应该会令你感到熟悉。条款33描述using声明式如何将“被掩盖的baseclass名称”带入一个derivedclass作用域内。我们可以这样写下sendClearMsg:</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2024/png/35229143/1707558218801-2272b813-1508-4dd1-bf00-d3ebf10af457.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>第三个做法是，明白指出被调用的函数位于base class内：</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2024/png/35229143/1707558357624-cd637eca-fa50-485b-981d-5ee66fc4e5f8.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>但这往往是最不让人满意的一个解法，因为如果被调用的是virtual函数，上述的明确资格修饰(explicitqualification)会关闭“virtual绑定行为”。</li><li>可在derived class templates内通过"this-&gt;"指涉base classtemplates内的成员名称，或藉由一个明白写出的“baseclass资格修饰符”完成。</li></ol><h2 id="将与参数无关的代码抽离templates">44.将与参数无关的代码抽离templates</h2><ol type="1"><li>Templates是节省时间和避免代码重复的一个奇方妙法。</li><li>如果你不小心，使用templates可能会导致代码膨胀：其二进制码带着重复（或几乎重复）的代码、数据，或两者。其结果有可能源码看起来合身而整齐，但目标码(objectcode)却不是那么回事。</li><li>共性与变性分析(commonality and variability analysis）。</li><li>如果你正在编写某个class,而你明白其中某些部分和另一个class的某些部分相同，你也不会重复这共同的部分。取而代之的是你会把共同部分搬移到新clss去，然后使用继承或复合（见条款32,38,39)，令原先的classes取用这共同特性。而原classes的互异部分（变异部分）仍然留在原位置不动。</li><li>编写templates时，也是做相同的分析，以相同的方式避免重复，但其中有个窍门。在non-template代码中，重复十分明确：你可以“看”到两个函数或两个classes之间有所重复。然而在template代码中，重复是隐晦的：毕竟只存在一份template源码，所以你必须训练自己去感受当template被具现化多次时可能发生的重复。</li><li>Templates生成多个classes和多个函数，所以任何template代码都不该与某个造成膨胀的template参数产生相依关系。</li><li>因非类型模板参数(non-type templateparameters)而造成的代码膨胀，往往可消除，做法是以函数参数或class成员变量替换template参数。</li><li>因类型参数(typeparameters)而造成的代码膨胀，往往可降低，做法是让带有完全相同二进制表述(binaryrepresentations)的具现类型(instantiation types)共享实现码。</li></ol><h2 id="运用成员函数模板接受所有兼容类型">45.运用成员函数模板接受所有兼容类型</h2><ol type="1"><li>所谓智能指针(Smartpointers)是“行为像指针”的对象，并提供指针没有的机能</li><li>例如条款13曾经提及std:auto_ptr和trl:sharedptr如何能够被用来在正确时机自动删除heap-based资源。STL容器的迭代器几乎总是智能指针：无疑地你不会奢望使用"+"将一个内置指针从linkedlist的某个节点移到另一个节点，但这在list:iterators身上办得到。</li><li>真实指针做得很好的一件事是，支持隐式转换(implicitconversions)。Derived class指针可以隐式转换为baseclass指针，“指向non-const对象”的指针可以转换为“指向cost对象”…等等。</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2024/png/35229143/1707564816041-88e0ddec-3c52-4448-b23c-16ed9a536175.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>但如果想在用户自定的智能指针中模拟上述转换，稍稍有点麻烦</li><li>Templates和泛型编程(Generic Programming)</li><li>为SmartPtr写一个构造函数，而是为它写一个构造模板。这样的模板(templates)是所谓memberfunction templates(常简称为nembertemplates),其作用是为class生成函数：</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2024/png/35229143/1707565419364-bae288b3-bb45-49b0-9116-b0698e6010b7.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>以上代码的意思是，对任何类型T和任何类型U,这里可以根据SmartPtr<U>生成一个SmartPtr<T>，因为Smartptr<T>有个构造函数接受个SmartPtr<U>参数。这一类构造函数根据对象u创建对象t(例如根据SmartPtr<U>创建一个SmartPtr<T>),而u和v的类型是同一个template的不同具现体，有时我们称之为泛化(generalized)copy构造函数。</T></U></U></T></T></U></li><li>泛化copy构造函数并未被声明为explicit。那是蓄意的，因为原始指针类型之间的转换（例如从derivedclass指针转为baseclass指针）是隐式转换，无需明白写出转型动作(cst),所以让智能指针仿效这种行径也属合理。在模板化构造函数(templatizedconstructor)中略去explicit就是为了这个目的。</li><li>member functiontemplates（成员函数模板)的效用不限于构造函数，它们常扮演的另一个角色是支持赋值操作。</li><li>从某个shared ptr类型隐式转换至另一个sharedptr类型是被允许的，但从某个内置指针或从其他智能指针类型进行隐式转换则不被认可（如果是显式转换如cast强制转型动作倒是可以)</li><li>请使用member functiontemplates（成员函数模板)生成“可接受所有兼容类型”的函数。</li><li>如果你声明membertemplates用于“泛化copy构造”或“泛化assignment操作”，你还是需要声明正常的copy构造函数和copyassignment操作符。</li></ol><h2 id="需要类型转换时请为模板定义非成员函数">46.需要类型转换时请为模板定义非成员函数</h2><ol type="1"><li>这项技术的一个趣味点是，我们虽然使用friend,却与friend的传统用途“访问class的non-public成分”毫不相千。为了让类型转换可能发生于所有实参身上，我们需要一个non-member函数（条款24)；为了令这个函数被自动具现化，我们需要将它声明在class内部；而在class内部声明non-member函数的唯一办法就是：令它成为一个friend。</li><li>一如条款30所说，定义于class内的函数都暗自成为inline,包括像operator<em>这样的friend函数。你可以将这样的inline声明所带来的冲击最小化，做法是令perator</em>不做任何事情，只调用一个定义于class外部的辅助函数。在本条款的例子中，这样做并没有太大意义，因为operator*已经是个单行函数，但对更复杂的函数而言，那么做也许就有价值。“令friend函数调用辅助函数”的做法的确值得细究一番。</li><li>当我们编写一个classtemplate，而它所提供之“与此template相关的”函数支持“所有参数之隐式类型转换”时，请将那些函数定义为“classtemplate内部的friend函数”。</li></ol><h2 id="请使用traits-classes表现类型信息">47. 请使用traitsclasses表现类型信息</h2><ol type="1"><li>STL主要由“用以表现容器、迭代器和算法”的templates构成，但也覆盖若干工具性templates,其中一个名为advance,.用来将某个迭代器移动某个给定距离：</li></ol><figure><img src="/2024/11/27/effective-cpp/7-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/1707567010785-05677fc7-3ce9-4fe3-8c08-40846e028338.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>randomaccess迭代器支持迭代器算术运算，只耗费常量时间，因此如果面对这种迭代器，我们希望运用其优势。</li><li>这种做法首先必须判断iter是否为randomaccess迭代器，也就是说需要知道类型IterT是否为randomaccess迭代器分类。换句话说我们需要取得类型的某些信息。那就是traits让你得以进行的事：它们允许你在编译期间取得某些类型信息。</li><li>Traits并不是C++关键字或一个预先定义好的构件；它们是一种技术，也是一个C++程序员共同遵守的协议。这个技术的要求之一是，它对内置(built-in)类型和用户自定义(user-defined)类型的表现必须一样好。举个例子，如果上述advance收到的实参是一个指针（例如constchar*)和一个int,上述advance仍然必须有效运作，那意味traits技术必须也能够施行于内置类型如指针身上。</li><li>“traits必须能够施行于内置类型”意味“类型内的嵌套信息(nestinginformation)”这种东西出局了，因为我们无法将信息嵌套于原始指针内。因此类型的traits信息必须位于类型自身之外。标准技术是把它放进一个template及其或多个特化版本中。这样的templates在标准程序库中有若干个，其中针对迭代器者被命名为iterator_traits:</li></ol><figure><img src="/2024/11/27/effective-cpp/7-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/1707568377223-8b9c5bf1-0c40-4613-8c3f-147a892e4293.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li><p>现在，你应该知道如何设计并实现一个traits class了：</p></li><li><ol type="1"><li>确认若干你希望将来可取得的类型相关信息。例如对迭代器而言，我们希望将来可取得其分类(category)。</li><li>为该信息选择一个名称（例如iterator_category)。</li><li>提供一个template和一组特化版本（例如稍早说的teratortraits)，内含你希望支持的类型相关信息。</li></ol></li><li><p>现在我们可以总结如何使用一个traits class了：</p></li><li><ol type="1"><li>建立一组重载函数（身份像劳工）或函数模板（例如doAdvance),彼此间的差异只在于各自的t红aits参数。令每个函数实现码与其接受之traits信息相应和。</li><li>建立一个控制函数（身份像工头）或函数模板（例如advance)，它调用上述那些“劳工函数”并传递traitsclass所提供的信息。</li></ol></li><li><p>Traits广泛用于标准程序库。其中当然有上述讨论的iteratortraits,.除了供应iterator_category还供应另四份迭代器相关信息（其中最有用的是valuetype,见条款42)。此外还有chartraits用来保存字符类型的相关信息，以及numericlimits用来保存数值类型的相关信息，例如某数值类型可表现之最小值和最大值等等；命名为numericlimits有点让人惊讶，因为traitsclasses的名称常以"traits”结束，但numeric_limits却没有遵守这种风格。</p></li><li><p>TR1(条款54)导入许多新的traits classes用以提供类型信息，包括isfundamental<T>(判断T是否为内置类型)，isarray<T>(判断T是否为数组类型)，以及is baseof&lt;T1,T2&gt;(T1和T2相同，抑或r1是T2的baseclass)。总计TR1一共为标准C+添加了50个以上的traits classes。</T></T></p></li><li><p>Traitsclasses使得“类型相关信息”在编译期可用。它们以templates和“templates特化”完成实现。</p></li><li><p>整合重载技术(overloading)后，traitsclasses有可能在编译期对类型执行if...else测试。</p></li></ol><h2 id="认识template元编程">48. 认识template元编程</h2><ol type="1"><li><p>TMP有两个伟大的效力。</p></li><li><ol type="1"><li>第一，它让某些事情更容易。如果没有它，那些事情将是困难的，甚至不可能的。</li><li>第二，由于templatemetaprograms执行于C++编译期，因此可将工作从运行期转移到编译期。</li></ol></li><li><p>这导致的一个结果是，某些错误原本通常在运行期才能侦测到，现在可在编译期找出来。另一个结果是，使用TMP的C++程序可能在每一方面都更高效：较小的可执行文件、较短的运行期、较少的内存需求。然而将工作从运行期移转至编译期的另一个结果是，编译时间变长了。是的，程序如果使用TMP,其编译时间可能远长于不使用TMP的对应版本。</p></li><li><p>条款47指出，这个typeid-based解法的效率比traits解法低，因为在此方案中，(1)类型测试发生于运行期而非编译期，(2)“运行期类型测试”代码会出现在（或说被连接于)可执行文件中。实际上这个例子正可彰显TMP如何能够比“正常的”C++程序更高效，因为traits解法就是TMP。别忘了，traits引发“编译期发生于类型身上的if.…else计算”。</p></li><li><p>TMP已被证明是个“图灵完全”(Turing-complete)机器，意思是它的威力大到足以计算任何事物。使用TMP你可以声明变量、执行循环、编写及调用函数…但这般构件相对于“正常的”C++对应物看起来很是不同，例如条款47展示的TMPif..else条件句是藉由templates和其特化体表现出来。不过那毕竟是汇编语言层级的TMP。针对TMP而设计的程序库（例如Boost'sMPL,见条款55）提供更高层级的语法一一尽管目前还不足以让你误以为那是“正常的”C++。</p></li><li><p>TMP并没有真正的循环构件，所以循环效果系藉由递归(recursion.)完成。TMP主要是个“函数式语言”(functionallanguage),而递归之于这类语言就像电视之于美国通俗文化一样地无法分割。TMP的递归甚至不是正常种类，因为TMP循环并不涉及递归函数调用，而是涉及“递归模板具现化”(recursivetemplate instantiation）。</p></li></ol><figure><img src="/2024/11/27/effective-cpp/7-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/1707571832635-303bc108-4be6-44ec-8d7b-81cdabc631b0.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>Templatemetaprogramming(TMP,模板元编程)可将工作由运行期移往编译期，因而得以实现早期错误侦测和更高的执行效率。</li><li>TMP可被用来生成“基于政策选择组合”(based on combinations of policychoices.)的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码。</li></ol>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>effective c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6. 继承和面向对象设计</title>
    <link href="/2024/11/27/effective-cpp/6-%E7%BB%A7%E6%89%BF%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/"/>
    <url>/2024/11/27/effective-cpp/6-%E7%BB%A7%E6%89%BF%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="确定你的public继承塑模出is-a关系">32.确定你的public继承塑模出is-a关系</h2><ol type="1"><li>“public继承”意味is-a</li><li>is-a并非是唯-存在于classes之间的关系。另两个常见的关系是has-a(有一个)和is-implemented-in-terms-of(根据某物实现出)。</li><li>“public继承”意味is-a。适用于baseclasses身上的每一件事情一定也适用于derivedclasses身上，因为每一个derived class对象也都是一个base class对象。</li></ol><h2 id="避免遮掩继承而来的名称">33. 避免遮掩继承而来的名称</h2><ol type="1"><li><p>baseclass内的某物（也许是个成员函数、typedef、或成员变量）时，编译器可以找出我们所指涉的东西，因为derivedclasses继承了声明于base classes内的所有东西。实际运作方式是，derivedclass作用域被嵌套在base class作用域内</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/effective-cpp/6-%E7%BB%A7%E6%89%BF%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/1707472078740-a22bc7ef-2776-4539-b414-6ec3f0d680bb.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>有时候你并不想继承baseclasses的所有函数，这是可以理解的。</p></li><li><ol type="1"><li>在public继承下，这绝对不可能发生，因为它违反了public继承所暗示的“base和derivedclasses之间的isa关系”。（这也就是为什么上述using声明式被放在derivedclass的public区域的原因：base class内的public名称在publicly derivedclass内也应该是public。)</li><li>然而在private继承之下（见条款39)它却可能是有意义的。例如假设Derived以private形式继承Base,而Derived唯想继承的mf1是那个无参数版本。using声明式在这里派不上用场，因为using声明式会令继承而来的某给定名称之所有同名函数在derivedclass中都可见。不，我们需要不同的技术，即一个简单的转交函数(forwardingfunction)</li><li><figure><img src="/2024/11/27/effective-cpp/6-%E7%BB%A7%E6%89%BF%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/1707476895583-0a89d8bb-a633-4917-8512-b92d034b8377.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><figure><img src="/2024/11/27/effective-cpp/6-%E7%BB%A7%E6%89%BF%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/1707476841476-416c6a76-60d6-412c-895d-d675ff490a57.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><p>inline转交函数(forwardingfunction)的另一个用途是为那些不支持using声明式（注：这并非正确行为）的老旧编译器另辟一条新路，将继承而得的名称汇入derivedclass作用域内。</p></li><li><p>derived classes内的名称会遮掩baseclasses内的名称。在public继承下从来没有人希望如此。</p></li><li><p>为了让被遮掩的名称再见天日，可使用using声明式或转交函数(forwardingfunctions)</p></li></ol><h2 id="区分接口继承和实现继承">34. 区分接口继承和实现继承</h2><ol type="1"><li><p>public继承由函数接口继承和函数实现继承</p></li><li><p>身为class设计者，有时候你会希望</p></li><li><ol type="1"><li>derived classes只继承成员函数的接口（也就是声明)；</li><li>有时候你又会希望derivedclasses同时继承函数的接口和实现，但又希望能够覆写(override)它们所继承的实现；</li><li>又有时候你希望derivedclasses同时继承函数的接口和实现，并且不允许覆写任何东西。</li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">error</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; msg)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">objectID</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span>: <span class="hljs-keyword">public</span> Shape&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ellipse</span>: <span class="hljs-keyword">public</span> Shape&#123;&#125;;<br></code></pre></td></tr></table></figure><ol type="1"><li><p>Shape是个抽象class;:它的purevirtual函数draw使它成为一个抽象class。所以客户不能够创建Shapeclass的实体，只能创建其derivedclasses的实体。尽管如此，Shape还是强烈影响了所有以public形式继承它的derivedclasses,因为：</p></li><li><ol type="1"><li>成员函数的接口总是会被继承。purevirtual函数有两个最突出的特性：它们必须被任何“继承了它们”的具象class重新声明，而且它们在抽象class中通常没有定义。把这两个性质摆在一起，你就会明白：</li><li>声明一个pure virtual函数的目的是为了让derivedclasses只继承函数接口。</li><li>令人意外的是，我们竟然可以为purevirtual函数提供定义。也就是说你可以为Shape::draw供应一份实现代码，C++并不会发出怨言，但调用它的唯一途径是“调用时明确指出其class名称”：</li><li><figure><img src="/2024/11/27/effective-cpp/6-%E7%BB%A7%E6%89%BF%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/1707526635349-d4f46534-4348-464c-b582-814b87939a8c.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>可以为简朴的impure virtual 函数提供更平常更安全的缺省实现</li></ol></li><li><p>简朴的impure virtual函数背后的故事和purevirtual函数有点不同。一如往常，derived classes继承其函数接口，但impurevirtual函数会提供一份实现代码，derivedclasses可能覆写(override)它。</p></li><li><p>声明简朴的（非纯）impure virtual函数的目的，是让derivedclasses继承该函数的接口和缺省实现。</p></li><li><p>可以“提供缺省实现给derivedclasses,但除非它们明白要求否则免谈”。此间技俩在于切断“virtual函数接口”和其“缺省实现”之间的连接。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Airplane</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">defaultFly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span></span>;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Airplane::defaultFly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span></span><br><span class="hljs-function"></span>&#123;<br>    缺省行为，将飞机飞至指定目的地<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>若想使用缺省实现（例如ModelA和ModelB),可以在其fly函数中对defaultFly做一个inline调用</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelA</span>: <span class="hljs-keyword">public</span> Airplane&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span> </span>&#123;<span class="hljs-built_in">defaultFly</span>(destination)&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ol type="1"><li>现在Modelcclass不可能意外继承不正确的fly实现代码了，因为Airplane中的purevirtual函数迫使ModelC必须提供自己的fly版本：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelC</span>: <span class="hljs-keyword">public</span> Airplane&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span></span>;<br>&#125;;<br><br><span class="hljs-type">void</span> ModelC:<span class="hljs-built_in">fly</span>(<span class="hljs-type">const</span> Airport&amp; destination)<br>&#123;<br>    将C型飞机飞至指定的目的地<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>pure virtual函数必须在derivedclasses中重新声明，但它们也可以拥有自己的实现</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Airplane</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Airplane::fly</span><span class="hljs-params">(cosnt Airport&amp; destiantion)</span></span><br><span class="hljs-function"></span>&#123;<br>    缺省行为<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelA</span>: <span class="hljs-keyword">public</span> Airplane&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span></span><br><span class="hljs-function">    </span>&#123;<br>        Airplane::<span class="hljs-built_in">fly</span>(destination);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelC</span>: <span class="hljs-keyword">public</span> Airplane&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ModelC::fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span></span><br><span class="hljs-function"></span>&#123;<br>    飞指定地点<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><p>如果成员函数是个non-virtual函数，意味是它并不打算在derivedclasses中有不同的行为。实际上一个non-virtual成员函数所表现的不变性(invariant),凌驾其特异性（specialization),因为它表示不论derivedclass变得多么特异化，它的行为都不可以改变。就其自身而言：</p></li><li><ol type="1"><li>声明non-virtual函数的目的是为了令derivedclasses继承函数的接口及一份强制性实现。</li></ol></li><li><p>purevirtual函数、simple(impure)virtual函数、non-virtual函数之间的差异，使你得以精确指定你想要derivedclasses继承的东西：只继承接口，或是继承接口和一份缺省实现，或是继承接口和一份强制实现。</p></li><li><p>第一个错误是将所有函数声明为non-virtual。.这使得derivedclasses没有余裕空间进行特化工作。</p></li><li><p>如果你关心virtual函数的成本，请容许我介绍所谓的80-20法则（也可见条款30)。这个法则说，一个典型的程序有80号的执行时间花费在20%的代码身上。此一法则十分重要，因为它意味，平均而言你的函数调用中可以有80号是virtual而不冲击程序的大体效率。所以当你担心是否有能力负担virtual函数的成本之前，请先将心力放在那举足轻重的20号代码上头，它才是真正的关键。</p></li><li><p>另一个常见错误是将所有成员函数声明为virtual。有时候这样做是正确的，例如条款31的Interfaceclasses。然而这也可能是class设计者缺乏坚定立场的前兆。某些函数就是不该在derivedclass中被重新定义，果真如此你应该将那些函数声明为non-virtual。.没有人有权利妄称你的class适用于任何人任何事任何物而他们只需花点时间重新定义你的函数就可以享受一切。如果你的不变性(invariant)凌驾特异性(specialization).，别害怕说出来。</p></li><li><p>接口继承和实现继承不同。在public继承之下，derivedclasses总是继承base class的接口。</p></li><li><p>pure virtual函数只具体指定接口继承。</p></li><li><p>简朴的（非纯）impurevirtual函数具体指定接口继承及缺省实现继承。</p></li><li><p>non-virtual函数具体指定接口继承以及强制性实现继承。</p></li></ol><h2 id="考虑virtual函数以外的其他选择">35.考虑virtual函数以外的其他选择</h2><ol type="1"><li><strong>藉由Non-Virtual Interface手法实现TemplateMethod模式</strong></li><li>直接在class定义式内呈现成员函数，那也就让它们全都暗自成了inline。</li><li>这一基本设计，也就是“令客户通过publicnon-virtual成员函数间接调用private virtual函数”，称为non-virtualinterface(NVI)手法。它是所谓TemplateMethod设计模式（与C+templates并无关联）的一个独特表现形式。</li><li>NVI手法的一个优点隐身在上述代码注释“做一些事前工作”和“做一些事后工作”之中。那些注释用来告诉你当时的代码保证在“virtual函数进行真正工作之前和之后”被调用。</li><li>在NVI手法下其实没有必要让virtual函数一定得是private。某些class继承体系要求derivedclass在virtual函数的实现内必须调用其baseclass的对应兄弟，而为了让这样的调用合法，virtual函数必须是protected,不能是private。有时候virtual函数甚至一定得是public(例如具备多态性质的baseclasses的析构函数一见条款7)，这么一来就不能实施NVI手法了。</li><li><strong>藉由Function Pointers实现Strategy模式</strong></li><li>同一人物类型之不同实体可以有不同的健康计算函数。</li></ol><figure><img src="/2024/11/27/effective-cpp/6-%E7%BB%A7%E6%89%BF%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/1707530940516-84b197b8-7e89-4800-a3ee-0dab8bc0b127.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>某己知人物之健康指数计算函数可在运行期变更。</li><li>实际上任何时候当你将class内的某个机能（也许取道自某个成员函数）替换为class外部的某个等价机能（也许取道自某个non-membernon-friend函数或另一个cass的non-friend成员函数)，这都是潜在争议点。</li><li>唯一能够解决“需要以non-member函数访问class的non-public成分”的办法就是：弱化class的封装。运用函数指针替换virtual函数，其优点（像是“每个对象可各自拥有自己的健康计算函数”和“可在运行期改变计算函数”)是否足以弥补缺点（例如可能必须降低GameCharacter封装性)，是你必须根据每个设计情况的不同而抉择的。</li><li><strong>藉由trl:function完成Strategy模式</strong></li><li>一日习惯了templates以及它们对隐式接口（见条款41)的使用，基于函数指针的做法看起来便过分苛刻而死板了。</li><li>如果我们不再使用函数指针（如前例的healthFunc),而是改用一个类型为tr1::unction的对象，这些约束就全都挥发不见了。就像条款54所说，这样的对象可持有（保存)任何可调用物(callableentity,也就是函数指针、函数对象、或成员函数指针)，只要其签名式兼容于需求端。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> std::tr1::function&lt;<span class="hljs-type">int</span> (<span class="hljs-type">const</span> GameCharacter&amp;)&gt; HealthCalcFunc;<br></code></pre></td></tr></table></figure><ol type="1"><li>tr1::function像一般的函数指针，这个tr1::function类型产生的对象可以持有任何与此签名式兼容的可调用物。所谓兼容，就是这个可调用物的参数可被隐式转换为constGameCharacter&amp;，而其返回类型可被隐式转换为int。</li></ol><figure><img src="/2024/11/27/effective-cpp/6-%E7%BB%A7%E6%89%BF%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/1707532060759-2bde1f88-4e85-4cc5-a399-2d7e09a552da.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li><strong>古典的Strategy模式</strong></li></ol><figure><img src="/2024/11/27/effective-cpp/6-%E7%BB%A7%E6%89%BF%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/1707532579120-22de152a-6b54-4379-bed2-10cd45c99d1a.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/effective-cpp/6-%E7%BB%A7%E6%89%BF%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/1707532676304-dc836a59-a083-478f-8354-18ceacc6e742.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>本条款的根本忠告是，当你为解决问题而寻找某个设计方法时，不妨考虑virtual函数的替代方案。下面快速重点复习我们验证过的几个替代方案：</li><li>使用non-virtual interface(NVI)手法，那是TemplateMethod设计模式的一种特殊形式。它以publicnon-virtual成员函数包裹较低访问性(private或protected)的virtual函数。</li><li>将virtual函数替换为“函数指针成员变量”，这是Strategy设计模式的一种分解表现形式。</li><li>以trl:function成员变量替换virtual函数，因而允许使用任何可调用物(callableentity)搭配一个兼容于需求的签名式。这也是Strategy设计模式的某种形式。</li><li>将继承体系内的virtual函数替换为另一个继承体系内的virtual函数。这是Strategy设计模式的传统实现手法。</li><li>virtual函数的替代方案包括NVI手法及Strategy设计模式的多种形式。NⅥ手法自身是一个特殊形式的TemplateMethod设计模式。</li><li>将机能从成员函数移到clss外部函数，带来的一个缺点是，非成员函数无法访问class的non-public成员。</li><li>trl:function对象的行为就像一般函数指针。这样的对象可接纳“与给定之目标签名式(targetsignature)兼容”的所有可调用物(callable entities)。</li></ol><h2 id="绝不重新定义继承而来的non-virtual函数">36.绝不重新定义继承而来的non-virtual函数</h2><ol type="1"><li>绝对不要重新定义继承而来的non-virtual函数。</li></ol><h2 id="绝不重新定义继承而来的缺省参数值">37.绝不重新定义继承而来的缺省参数值</h2><ol type="1"><li>继承一个带有缺省参数值的virtual函数</li><li>virtual函数系动态绑定，而缺省参数值却是静态绑定。静态绑定又各前期绑定，earlybinding;动态绑定又名后期绑定，late binding。</li><li>virtual函数是动态绑定，而缺省参数值却是静态绑定。意思是你可能会在“调用一个定义于derivedclass内的virtual函数”的同时，却使用base class为它所指定的缺省参数值</li><li>条款35列了不少virtual函数的替代设计，其中之一是NVI(non-virtualinterface)手法：令base class内的一个public non-virtual函数调用privatevirtual函数，后者可被derivedclasses重新定义。这里我们可以让non-virtual函数指定缺省参数，而privatevirtual函数负责真正的工作：</li></ol><figure><img src="/2024/11/27/effective-cpp/6-%E7%BB%A7%E6%89%BF%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/1707533914463-b881606c-63c1-42e5-b931-dc0cd789ac15.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定，而virtual函数一你唯一应该覆写的东西一却是动态绑定。</li></ol><h2 id="通过符合塑模出has-a或根据某物实现出">38.通过符合塑模出has-a或根据某物实现出</h2><ol type="1"><li>复合(composition)这个术语有许多同义词，包括la四yering（分层)，containment(内含)，aggregation(聚合）和embedding(内嵌)。</li><li>当复合发生于应用域内的对象之间，表现出hasa的关系；当它发生于实现域内则是表现is-implemented-in-terms-of的关系</li><li>比较麻烦的是区分is-a(是一种)和is-implemented-in-terms.-of(根据某物实现出)这两种对象关系。</li><li>复合(composition)的意义和public继承完全不同。</li><li>在应用域(applicationdomain),复合意味has-a(有一个)。在实现域(implementationdomain.),复合意味is-implemented-.in-terms-of(根据某物实现出)。</li></ol><h2 id="明智而审慎地使用private继承">39.明智而审慎地使用private继承</h2><ol type="1"><li>如果classes之间的继承关系是private,编译器不会自动将一个derivedclass对象（例如Student)转换为一个baseclass对象（例如Person)。这和public继承的情况不同。</li><li>第二条规则是，由private base class继承而来的所有成员，在derivedclass中都会变成private属性，纵使它们在baseclass中原本是protected或public属性。</li><li>Private继承意味is-implemented-in-terms-of(根据某物实现出)，这个事实有点令人不安，因为条款38才刚指出复合(composition)的意义也是这样。你如何在两者之间取舍？答案很简单：尽可能使用复合，必要时才使用private继承。何时才是必要？主要是当protected成员和/或virtual函数牵扯进来的时候。其实还有一种激进情况，那是当空间方面的利害关系足以踢翻private继承的支柱时。</li></ol><figure><img src="/2024/11/27/effective-cpp/6-%E7%BB%A7%E6%89%BF%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/1707537572173-10f98648-129a-40e0-9e2a-41cc51d576cb.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/effective-cpp/6-%E7%BB%A7%E6%89%BF%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/1707537803594-b7aabf0a-f774-4507-9cbd-025c9830f8ce.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>用复合取而代之，在Widget内声明一个嵌套式privateclass，后者以public形式继承Timer并重新定义onTick,</li></ol><figure><img src="/2024/11/27/effective-cpp/6-%E7%BB%A7%E6%89%BF%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/1707537869955-7d7f3471-2af4-4f93-a8c8-b7f220d266c3.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>稍早我曾谈到，private继承主要用于“当一个意欲成为derivedclass者想访问一个意欲成为baseclass者的protected成分，或为了重新定义一或多个virtual函数”。但这时候两个classes之间的概念关系其实是is-implemented-in-terms-of(根据某物实现出)而非is-a。然而我也说过，有一种激进情况涉及空间最优化，可能会促使你选择“private继承”而不是“继承加复合”。</li><li>这个激进情况真是有够激进，只适用于你所处理的clss不带任何数据时。这样的classes没有non-static成员变量，没有virtual函数（因为这种函数的存在会为每个对象带来一个ptr,见条款7)，也没有virtualbase classes(因为这样的baseclasses也会招致体积上的额外开销，见条款40)。于是这种所谓的emptyclasses对象不使用任何空间，因为没有任何隶属对象的数据需要存储。然而由于技术上的理由，C++裁定凡是独立（非附属）对象都必须有非零大小，所以如果你这样做：</li></ol><figure><img src="/2024/11/27/effective-cpp/6-%E7%BB%A7%E6%89%BF%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/1707538435846-92a3eed4-f3de-4ef2-b328-4a62be1096f1.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>几乎可以确定sizeof(HoldsAnInt)=sizeof(int)。这是所谓的EBO(empy baseoptimization;空白基类最优化)，我试过的所有编译器都有这样的结果。如果你是一个程序库开发人员，而你的客户非常在意空间，那么值得注意EBO。另外还值得知道的是，EBO一般只在单一继承（而非多重继承）下才可行，统治C++对象布局的那些规则通常表示EBO无法被施行于“拥有多个base”的derivedclasses身上。</li><li>现实中的"empty"classes并不真的是empty。虽然它们从未拥有non-static成员变量，却往往内含typedefs,enums,.static成员变量，或non-virtual函数。STL就有许多技术用途的emptyclasses,其中内含有用的成员（通常是ypedefs),包括base classesunary_function和binaryfunction,这些是“用户自定义之函数对象”通常会继承的classes.感谢EBO的广泛实践，使这样的继承很少增加derivedclasses的大小。</li><li>尽管如此，让我们回到根本。大多数classes并非empy,所以EBO很少成为private继承的正当理由。更进一步说，大多数继承相当于isa,这是指public继承，不是private继承。复合和private继承都意味is-implemented-.in-terms-of,但复合比较容易理解，所以无论什么时候，只要可以，你还是应该选择复合。</li><li>当你面对“并不存在is-a关系”的两个classes,其中一个需要访问另一个的protected成员，或需要重新定义其一或多个virtual函数，private继承极有可能成为正统设计策略。即便如此你也已经看到，一个混合了public继承和复合的设计，往往能够释出你要的行为，尽管这样的设计有较大的复杂度。“明智而审慎地使用private继承”意味，在考虑过所有其他方案之后，如果仍然认为private继承是“表现程序内两个classes之间的关系”的最佳办法，这才用它。</li><li>Private继承意味is-implemented-in-termsof(根据某物实现出)。它通常比复合(composition)的级别低。但是当derivedclass需要访问protected baseclass的成员，或需要重新定义继承而来的virtual函数时，这么设计是合理的。</li><li>和复合(composition)不同，private继承可以造成emptybase最优化。这对致力于“对象尺寸最小化”的程序库开发者而言，可能很重要。</li></ol><h2 id="明智而审慎地使用多重继承">40. 明智而审慎地使用多重继承</h2><ol type="1"><li>多重继承(multiple inheritance;ML)，单一继承(singleinheritance;SI)</li><li>当MI进入设计景框，程序有可能从一个以上的baseclasses继承相同名称（如函数、typedef等等）。那会导致较多的歧义(ambiguity)</li><li>注意此例之中对checkOut的调用是歧义（模棱两可）的，即使两个函数之中只有一个可取用(一个类内的checkOut是public，另一个类内的却是private)。这与C++用来解析(resolving)重载函数调用的规则相符：在看到是否有个函数可取用之前，C++首先确认这个函数对此调用之言是最佳匹配。找出最佳匹配函数后才检验其可取用性。本例的两个checkOuts有相同的匹配程度(译注：因此才造成歧义)，没有所谓最佳匹配.因此ElectronicGadget::checkOut的可取用性也就从未被编译器审查。</li><li>为了解决这个歧义，你必须明白指出你要调用哪-个baseclass内的函数：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mp.BorrowableItem:<span class="hljs-built_in">checkOut</span>();<br></code></pre></td></tr></table></figure><ol type="1"><li>多重继承的意思是继承1个以上的base classes,但这些baseclasses并不常在继承体系中义有更高级的baseclasses,因为那会导致要命的“钻石型多重继承”：</li></ol><figure><img src="/2024/11/27/effective-cpp/6-%E7%BB%A7%E6%89%BF%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/1707549791781-4e9c1ae9-f68c-4de5-9778-6e1c08f0fa75.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>令所有直接继承自它的classes采用“virtual继承</li></ol><figure><img src="/2024/11/27/effective-cpp/6-%E7%BB%A7%E6%89%BF%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/1707549889972-ccb09a69-7fae-41ef-bbb7-43bf7c28d4ce.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li><p>C++标准程序库内含一个多重继承体系，classtemplates,名称分别是basic_ios, basic_istream,basic_ostream和basic_iostream</p></li><li><p>从正确行为的观点看，public继承应该总是virtual。</p></li><li><p>规则很简单：任何时候当你使用public继承，请改用virtualpublic继承.</p></li><li><p>为避免继承得来的成员变量重复，编译器必须提供若干幕后戏法，而其后果是：使用virtual继承的那些classes所产生的对象往往比使用non-virtual继承的兄弟们体积大，访问virtualbase classes的成员变量时，也比访问non-virtual baseclasses的成员变量速度慢。种种细节因编译器不同而异，但基本重点很清楚：你得为virtual继承付出代价。</p></li><li><p>virtual继承的成本还包括其他方面。支配“virtual baseclasses初始化”的规则比起non-virtual bases的情况远为复杂且不直观。virtualbase的初始化责任是由继承体系中的最低层(nostderived)class负责，这暗示</p></li><li><ol type="1"><li>(1)classes若派生自virtual bases而需要初始化，必须认知其virtualbases一一不论那些bases距离多远，</li><li>(2)当一个新的derived class加入继承体系中，它必须承担其virtualbases(不论直接或间接)的初始化责任。</li></ol></li><li><p>我对virtual baseclasses(亦相当于对virtual继承)的忠告很简单。</p></li><li><ol type="1"><li>第一，非必要不使用virtual bases。平常请使用non-virtual继承。</li><li>第二，如果你必须使用virtual baseclasses,尽可能避免在其中放置数据。这么一来你就不需担心这些classes身上</li></ol></li></ol><figure><img src="/2024/11/27/effective-cpp/6-%E7%BB%A7%E6%89%BF%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/1707551059636-152e5f8e-fd50-4248-80b3-b5461267d06b.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/effective-cpp/6-%E7%BB%A7%E6%89%BF%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/1707551092898-8edf0efb-f1aa-4349-8d90-7069f57ffcc4.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>多重继承比单一继承复杂。它可能导致新的歧义性，以及对virtual继承的需要。</li><li>virtual继承会增加大小、速度、初始化（及赋值）复杂度等等成本。如果virtualbaseclasses不带任何数据，将是最具实用价值的情况。</li><li>多重继承的确有正当用途。其中一个情节涉及“public继承某个Interfaceclass”和“private继承某个协助实现的class”的两相组合。</li></ol>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>effective c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5. 实现</title>
    <link href="/2024/11/27/effective-cpp/5-%E5%AE%9E%E7%8E%B0/"/>
    <url>/2024/11/27/effective-cpp/5-%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="尽可能延后变量定义式的出现时间">26.尽可能延后变量定义式的出现时间</h2><ol type="1"><li>当定义了一个变量而其类型带有一个构造函数或析构函数，那么当程序的控制流(controlflow)到达这个变量定义式时，你便得承受构造成本；当这个变量离开其作用域时，你便得承受析构成本。即使这个变量最终并未被使用，仍需耗费这些成本，所以你应该尽可能避免这种情形。</li><li>这让我们联想起本条款所谓“尽可能延后”的真正意义。你不只应该延后变量的定义，直到非得使用该变量的前一刻为止，甚至应该尝试延后这份定义直到能够给它初值实参为止。如果这样，不仅能够避免构造（和析构）非必要对象，还可以避免无意义的default构造行为。更深一层说，以“具明显意义之初值”将变量初始化，还可以附带说明变量的目的。</li><li>循环</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Widget w;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>    w = i;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>    Widget w;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>如果classes的一个赋值成本低于一组构造+析构成本，做法A大体而言比较高效。尤其当n值很大的时候。否则做法B或许较好。</li><li>此外做法A造成名称w的作用域（覆盖整个循环）比做法B更大，有时那对程序的可理解性和易维护性造成冲突。</li><li>因此除非(1)你知道赋值成本比“构造+析构”成本低，(2)你正在处理代码中效率高度敏感(performance-sensitive)的部分，否则你应该使用做法B。</li><li>尽可能延后变量定义式的出现时间，这样做可增加程序的清晰度并改善程序效率</li></ol><h2 id="尽量少做转型动作">27. 尽量少做转型动作</h2><ol type="1"><li><p>旧式转型</p></li><li><ol type="1"><li><ol start="20" type="A"><li>expression</li></ol></li><li>T(expression)</li></ol></li><li><p>新式转型</p></li><li><ol type="1"><li>const_cast<T> (expression)</T></li><li>dynamic_cast<T> (expression)</T></li><li>reinterpret_cast<T> (expression)</T></li><li>static_cast<T> (expression)</T></li></ol></li><li><p>const_cast通常被用来将对象的常量性转除，它也是唯一有此能力的C+-style转型操作符</p></li><li><p>dynamic_cast主要用来执行“安全向下转型”(safedowncasting),也就是用来决定某对象是否归属继承体系中的某个类型。它是唯一一无法由旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作</p></li><li><p>reinterpret_cast意图执行低级转型，实际动作（及结果）可能取决于编译器，这也就表示它不可移植。例如将一个pointertoint转型为一个int。这一类转型在低级代码以外很少见。本书只使用一次，那是在讨论如何针对原始内存(rawmemory)写出一个调试用的分配器(debuggingallocator)时，见条款50。</p></li><li><p>static_cast用来强迫隐式转换(implicitconversions),例如将non-const对象转为const对象（就像条款3所为），或将int转为double等等。它也可以用来执行上述多种转换的反向转换，例如将void*指针转为typed指针，将pointer-to-base转为pointer-to-derived。.但它无法将const转为non-const一这个只有const_cast才办得到。</p></li><li><p>使用旧式转型的时机是，当我要调用一个explicit构造函数将一个对象传递给一个函数时。</p></li><li><p>如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_casts。如果有个设计需要转型动作，试着发展无需转型的替代设计</p></li><li><p>如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需将转型放进他们自己的代码内</p></li><li><p>宁可使用C++-style新式转型，不要使用就是转型。前者很容易辨识出来，而且也比较有着分门别类的职掌。</p></li></ol><h2 id="避免返回handles指向对象内部成分">28.避免返回handles指向对象内部成分</h2><ol type="1"><li>避免返回handles（包括references、指针、迭代器）指向对象内部。遵守这个条款可增加封装性，帮助const成员函数的行为像个const，并将发生“虚吊号码牌”的可能性降至最低。</li></ol><h2 id="为异常安全而努力是值得的">29. 为”异常安全“而努力是值得的</h2><ol type="1"><li>异常安全函数即使发生异常也不会泄露资源或允许任何数据结构破坏。这样的函数区分为三种可能的保证：基本型，强烈型，不抛异常型</li><li>基本承诺：如果异常被抛出，程序内的任何事物仍然保持在有效状态下。没有任何对象或数据结构会因此而败坏，所有对象都处于一种内部前后一致的状态</li><li>强烈保证：如果异常被抛出，程序状态不改变。调用这样的函数需有这样的认知：如果函数成功，就是完全成功，如果函数失败，程序会回复到“调用函数之前”的状态。</li><li>不抛掷(nothrow)保证，承诺绝不抛出异常，因为它们总是能够完成它们原先承诺的功能。作用于内置类型（例如ints,指针等等）身上的所有操作都提供nothrow保证。这是异常安全码中一个必不可少的关键基础材料。</li><li>异常安全码(Exception-safecode)必须提供上述三种保证之一。如果它不这样做，它就不具备异常安全性。因此，我们的抉择是，该为我们所写的每一个函数提供哪一种保证？除非面对不具异常安全性的传统代码（我将在本条款末尾讨论那种情况)，否则你应该只在一种情况下才不提供任何异常安全保证：你那“天才班”需求分析团队确认你的应用程序有“泄漏资源”并“在执行过程中带着败坏数据”的需要。</li><li>有个一般化的设计策略很典型地会导致强烈保证，很值得熟悉它。这个策略被称为copyandswap。原则很简单：为你打算修改的对象（原件）做出一份副本，然后在那副本身上做一切必要修改。若有任何修改动作抛出异常，原对象仍保持未改变状态。待所有改变都成功后，再将修改过的那个副本和原对象在一个不抛出异常的操作中置换(swap)。</li><li>实现上通常是将所有“隶属对象的数据”从原对象放进另一个对象内，然后赋予原对象一个指针，指向那个所谓的实现对象(implementationobject,.即副本)。</li><li>copy-and-swap的关键在于“修改对象数据的副本，然后在一个不抛异常的函数中将修改后的数据和原件置换”，因此必须为每一个即将被改动的对象做出一个副本，那得耗用你可能无法（或无意愿）供应的时间和空间。</li><li>如果系统内有一个（惟有一个）函数不具备异常安全性，整个系统就不具备异常安全性，因为调用那个（不具备异常安全性的）函数有可能导致资源泄漏或数据结构败坏。</li><li>强烈保证往往能够以copy-and-swap实现出来，但“强烈保证”并非对所有函数都可实现或具备实现意义</li><li>函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者。</li></ol><h2 id="透彻了解inlining的里里外外">30. 透彻了解inlining的里里外外</h2><ol type="1"><li>在一台内存有限的机器上，过度热衷inlining会造成程序体积太大（对可用空间而言）。即使拥有虚内存，inline造成的代码膨胀亦会导致额外的换页行为(paging)，降低指令高速缓存装置的击中率(instructioncache hit rate)，以及伴随这些而来的效率损失。</li><li>换个角度说，如果inline函数的本体很小，编译器针对“函数本体”所产出的码可能比针对“函数调用”所产出的码更小。果真如此，将函数inlining确实可能导致较小的目标码(objectcode)和较高的指令高速缓存装置击中率！</li><li>声明inline函数的做法则是在其定义式前加上关键字inline</li><li>inline函数通常一定被置于头文件内，因为大多数建置环境(buildenvironments).在编译过程中进行inlining,而为了将一个“函数调用”替换为“被调用函数的本体”，编译器必须知道那个函数长什么样子。某些建置环境可以在连接期完成inlining,少量建置环境如基于，NETCLI(Common Language Infrastructure;公共语言基础设施)的托管环境(managedenvironments)竞可在运行期完成inlining。然而这样的环境毕竟是例外，不是通例。Inlining在大多数C+程序中是编译期行为。</li><li>Templates通常也被置于头文件内，因为它一旦被使用，编译器为了将它具现化，需要知道它长什么样子。</li><li>Template的具现化与inlining无关。如果你正在写一个template而你认为所有根据此template具现出来的函数都应该inlined,请将此template声明为inline</li><li>大多数编译器拒绝太过复杂（例如带有循环或者递归）的函数inling，而所有对virtual函数的调用也都会使inlining落空</li><li>virtual意味“等待，直到运行期才确定调用哪个函数”，而inline意味“执行前，先将调用动作替换为被调用函数的本体”。如果编译器不知道该调用哪个函数，你就很难责备它们拒绝将函数本体inlining。</li><li>程序库设计者必须评估“将函数声明为inline”的冲击：inline函数无法随着程序库的升级而升级。换句话说如果f是程序库内的一个inline函数，客户将“f函数本体”编进其程序中，一旦程序库设计者决定改变￡，所有用到￡的客户端程序都必须重新编译。这往往是大家不愿意见到的。然而如果f是non-inline函数，旦它有任何修改，客户端只需重新连接就好，远比重新编译的负担少很多。如果程序库采取动态连接，升级版函数甚至可以不知不觉地被应用程序吸纳。</li><li>大部分调试器面对inline函数都束手无策。</li><li>将大多数inlining限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。</li><li>不要只因为function templates出现在头文件，就将它们声明为inline</li></ol><h2 id="将文件间的编译依存关系降至最低">31.将文件间的编译依存关系降至最低</h2><ol type="1"><li>C++并没有把“将接口从实现中分离”这事做得很好</li><li>class定义式包括class接口，实现细目（eg: std::string theName;)</li><li>将Person类分割为两个class，一个只提供接口，另一个负责实现该接口</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br><span class="hljs-keyword">private</span>:<br>    std::tr1::shared_ptr&lt;PersonImpl&gt; pImpl;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>在这里，main class(Person)只内含个指针成员（这里使用trl:sharedptr,见条款13),指向其实现类(PersonImpl)。这般设计常被称为pimplidiom。这种classes内的指针名称往往就是pImpl</li><li>这个分离的关键在于以“声明的依存性”替换“定义的依存性”，那正是编译依存性最小化的本质：现实中让头文件尽可能自我满足，万一做不到，则让它与其他文件内的声明式（而非定义式）相依。其他每一件事都源自于这个简单的设计策略：</li><li>如果使用object references 或者objectpointers可以完成任务，就不要使用objects。你可以只靠一个类型声明式就定义出指向该类型的references和pointers，如果定义某类型的objects，就需要用到该类型的定义式</li><li>如果能够，尽量以class声明式替换class定义式。当你声明一个函数而它用到某个class时，你并不需要该class的定义；纵使函数以byvalue方式传递该类型的参数（或返回值）亦然</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>;<br><span class="hljs-function">Date <span class="hljs-title">today</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearAppointment</span><span class="hljs-params">(Date d)</span></span>;<br></code></pre></td></tr></table></figure><ol type="1"><li>为声明式和定义式提供不同的头文件。为了促进严守上述准则，需要两个头文件，一个用于声明式，一个用于定义式。当然，这些文件必须保持一致性，如果有个声明式被改变了，两个文件都得改变。因此程序库客户应该总是#include一个声明文件而非前置声明若干函数，程序库作者也应该提供这两个头文件。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;datefwd.h&quot;</span> <span class="hljs-comment">//声明但未定义class Date</span></span><br><span class="hljs-function">Date <span class="hljs-title">today</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearAppointment</span><span class="hljs-params">(Date d)</span></span>;<br></code></pre></td></tr></table></figure><ol type="1"><li>"datefwd.h"，命名方式取法c++标准程序库头文件的<iosfwd>。<iosfwd>深具启发意义的另一个原因是，它分外彰显“本条款适用于templates也话用于non-templates”。</iosfwd></iosfwd></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Person.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;PersonImpl.h&quot;</span></span><br>Person::<span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> std::string&amp;name):<span class="hljs-built_in">pImpl</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">PersonImpl</span>(name))&#123;&#125;<br><span class="hljs-function">std::string <span class="hljs-title">Person::name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> pImpl-&gt;name;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>Person构造函数以new调用PersonImpl构造函数，以及Person::name函数内调用PersonImpl::name。让Person变成一个Handleclass并不会改变它做的事，只会改变它做事的方法</li><li>另一个制作Handle class方法是，令Person成为一种特殊的abstract baseclass（抽象基类），称为interfaceclass。这种class的目的是详细一一描述derivedclasses的接口，因此它通常不带成员变量，也没有构造函数，只有一个virtual析构函数（见条款7）以及一组purevirtual函数，用来叙述整个接口。</li><li>在Handle classes身上，成员函数必须通过implementationpointer取得对象数据。那会为每一次访问增加一层间接性。而每一个对象消耗的内存数量必须增加implementationppinter的大小。最后，implementation pointer必须初始化（在Handleclass构造函数内)，指向一个动态分配得来的implementationobject,,所以你将蒙受因动态内存分配（及其后的释放动作)而来的额外开销，以及遭遇badal1oc异常（内存不足）的可能性。</li><li>至于Interfaceclasses,由于每个函数都是virtual,所以你必须为每次函数调用付出一个间接跳跃(indirectjump)成本（见条款7）。此外Interfaceclass派生的对象必须内含一个vptr(virtual tablepointer,再次见条款7)，这个指针可能会增加存放对象所需的内存数量一实际取决于这个对象除了Interfaceclass之外是否还有其他virtual函数来源。</li><li>最后，不论Handle classes或Interfaceclasses,一旦脱离inline函数都无法有太大作为。条款30解释过为什么函数本体为了被inlined必须（很典型地）置于头文件内，但Handleclasses和Interfaceclasses正是特别被设计用来隐藏实现细节如函数本体。</li><li>支持“编译依存性最小化”的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是Handleclasses和Interface classes</li><li>程序库头文件应该以“完全且仅有声明式”的形式存在。这种做法不论是否涉及templates都适用。</li></ol>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>effective c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4. 设计与声明</title>
    <link href="/2024/11/27/effective-cpp/4-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E/"/>
    <url>/2024/11/27/effective-cpp/4-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h2 id="让接口容易被正确使用不易被误用">18.让接口容易被正确使用，不易被误用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Date</span>(<span class="hljs-type">int</span> month, <span class="hljs-type">int</span> day, <span class="hljs-type">int</span> year);<br>&#125;;<br></code></pre></td></tr></table></figure><ol type="1"><li>函数接口 可能以错误的次序传递参数，或者传递一个无效的月份或天数</li><li>导入简单的外覆类型来区别天数，月份等</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Day</span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Day</span><span class="hljs-params">(<span class="hljs-type">int</span> d)</span></span><br><span class="hljs-function">:val(d)&#123;</span>&#125;<br><span class="hljs-type">int</span> val;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Month</span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Month</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span></span><br><span class="hljs-function">:val(m)&#123;</span>&#125;<br><span class="hljs-type">int</span> val;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Year</span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Year</span><span class="hljs-params">(<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">:val(y)&#123;</span>&#125;<br><span class="hljs-type">int</span> val;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>令Day，Month，Year成为成熟且经充分锻炼的类并封装内部数据，比简单使用structs好</li><li>限制正确的类型的取值，比较安全的方法时预定义所有有效的Months，以函数替换对象，表现某个特定月份，因为non-localstatic对象的初始化次序可能出现问题</li></ol><figure><img src="/2024/11/27/effective-cpp/4-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E/1707183478622-e5fdf8f5-23a5-4374-9a5e-78ff04c69f48.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>预防客户错误的另一个办法是，限制类型内什么是可做，什么是不能做。常见的限制是加上const。条款3：以const修饰operator*的返回类型可阻止客户因用户自定义类型而犯错</li><li>除非有好理由，否则应该尽量令你的types的行为于内置types一致</li><li>避免无端与内置类型不兼容，真正的理由是为了提供行为一致的接口。STL容器的接口十分一致，这使得它们非常容易被调用</li><li>较佳接口的设计原则是令函数返回一个智能指针，事实上，返回tr1::shared_ptr让接口设计者阻止资源泄露的错误</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::<span class="hljs-function">tr1::shared_ptr&lt;Investment&gt; <span class="hljs-title">createInvestment</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><ol type="1"><li>假设类设计者期许"从createInvestment取得Investment*指针"的客户将该指针传递给一个名为getRidOfInvestment的函数，而不是直接使用delete。这样一个接口又开启通往另一个客户错误的大门，该错误是"企图使用错误的资源析构机制"，设计者可以设计一个返回将getRidOfInvestment绑定为删除器"的tr1::shared_ptr</li><li>tr1::shared_ptr提供的某个构造函数接受两个实参：一个是被管理的指针，另一个是引用次数变成0时将被调用的删除器。这启发我们创建一个nulltr1::shared_ptr并以getRidOfInvestment作为删除器</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::tr1::shared_ptr&lt;Investment&gt;<span class="hljs-built_in">pInv</span>(<span class="hljs-built_in">static_cast</span>&lt;Investment*&gt;(<span class="hljs-number">0</span>),getRidOfInvestment);<br></code></pre></td></tr></table></figure><ol type="1"><li>tr1::shared_ptr有一个特别好的性质是，它会自动使用它的“每个指针专属的删除器”，因而消除另一个潜在的客户错误：所谓的“cross-DLLproblem"。这个问题发生于对象在动态链接程序库DLL中被new创建，却在另一个DLL内被delete销毁，在许多平台上，这一类跨DLL之new/delete成对使用会导致运行期错误。</li><li>好的接口很容易被正确使用，不容易被误用。你应该在你的所有接口中努力达成这些性质。</li><li>“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。</li><li>“阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。</li><li>trl::shared_ptr支持定制型删除器(customdeleter)。这可防范DLL问题，可被用来自动解除互斥锁（mutexes;见条款14)等等。</li></ol><h2 id="设计class犹如设计type">19. 设计class犹如设计type</h2><ol type="1"><li><p>新type对象应该如何被创建和销毁？（第八章）</p></li><li><p>对象的初始化和对象的赋值该有什么样的差别？（条款四）</p></li><li><p>新type的对象如果被passed by value(以值传递)，意味着什么？copy构造函数用来定义一个type的pass-by-value如何实现</p></li><li><p>什么是新type的”合法值“</p></li><li><p>你的新type需要配合某个继承图系吗？</p></li><li><ol type="1"><li>如果继承自某些既有的类，就会受到那些类的设计的束缚，特别是他们的函数时virtual或non-virtual的影响（条款34和36）</li><li>如果允许其他类继承你的class，那会影响你所声明的函数，尤其是析构函数是否为virtual（条款7）</li></ol></li><li><p>你的新type需要什么杨的转换</p></li><li><ol type="1"><li>如果允许T1隐式转换为T2，就必须在classT1内写一个类型转换函数（operator T2）或者在classT2内写一个non-explicit-one-argument（可被单一实参调用）的构造函数，如果只允许explicit狗在函数存在，就得写专门负责转换的函数，且不得为类型转换操作符（typeconversionoperators）或者non-explicit-one-argument构造函数。（条款15）</li></ol></li><li><p>什么样的操作符和函数对此新type而言时合理的？</p></li><li><ol type="1"><li>决定于将为class声明哪些函数，其中某些该是member函数，某些则否（见条款23，24，46）</li></ol></li><li><p>什么样的标准函数应该驳回？</p></li><li><ol type="1"><li>那些正是你必须声明为private者（条款6）</li></ol></li><li><p>谁该取用新type的成员</p></li><li><ol type="1"><li>决定哪个成员为public，哪个为protected，哪个为private</li><li>决定哪一个类或者函数应该是friends，以及将它们嵌套于另一个之内是否合理</li></ol></li><li><p>什么是新type的”未声明接口“</p></li><li><ol type="1"><li>对效率、异常安全性（条款29）以及资源运用（例如多任务锁定和动态内存）提供何种保证，</li></ol></li><li><p>你的新type有多么一般化</p></li><li><ol type="1"><li>定义一个新的class template，定义一整个types家族</li></ol></li><li><p>你真的需要一个新type吗</p></li><li><ol type="1"><li>如果只是定义新的派生类以便为既有的class添加机能，说不定单纯定义一个或者多个non-member函数或者templates，更能达到目标</li></ol></li></ol><h2 id="宁以pass-by-reference-to-const替换pass-by-value">20.宁以pass-by-reference-to-const替换pass-by-value</h2><ol type="1"><li>缺省情况下C++以by value方式传递对象至函数</li><li>除非另外指定，否则函数参数都是以实际参数的副本为初值，而调用端所获得的亦是函数返回值的一个副本，这些副本是对象的copy构造函数产出，使得pass-by-value成为费时的操作。</li><li>如何回避所有的构造和析构动作？pass by reference-to-const</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">validateStudent</span><span class="hljs-params">(<span class="hljs-type">const</span> Student&amp; s)</span></span>;<br></code></pre></td></tr></table></figure><ol type="1"><li>这种传递方式效率高，没有任何构造函数和析构函数被调用，因为没有任何新对象被创建。const是重要的，</li><li>以byreference方式传递参数可以避免slicing（对象切割）问题。当一个派生类对象以byvalue方式传递并被视为一个基类对象，基类的copy构造函数会被调用，而造成此对象的行为像个派生类对象的那些特化性质全被切割掉了，仅仅留下一个基类对象，但这几乎不是想要的</li><li>references往往以指针实现出来，因此pass byreference意味真正传递的是指针。如果对象属于内置类型（int等），pass byvalue往往比pass byreference效率高。对于内置类型而言，有机会采用pass-by-value或pass-by-reference-to-const时，选择pass-by-value并非无道理。</li><li>同时也适用于STL迭代器和函数对象，因为它们习惯上被设计为passed byvalue</li><li>内置类型都相当小，对象小并不意味着其copy构造函数不昂贵。许多对象，包括大多数STL容器，内含的东西只比指针多一些，但复制这种对象却需要承担复制那些指针所指的每一样东西，那将非常昂贵</li><li>小型的用户自定义类型不必然成为pass by value优良候选人</li><li>尽量以pass-by-reference-to-const替换pass byvalue，前者通常高效，并可避免切割问题</li><li>以上规则并不适用内置类型，以及STL的迭代器和函数对象。对他们而言，pass-by-value往往比较适当。</li></ol><h2 id="必须返回对象时别妄想返回其reference">21.必须返回对象时，别妄想返回其reference</h2><ol type="1"><li>可能会传递一些references指向其实并不存在的对象</li><li>函数创建新对象的途径：在stack和heap空间创建</li><li>不能返回reference指向的local 对象，</li><li>若在heap内构造一个对象，返回指向的reference，同样有问题，delete该如何调用？</li><li>一个必须返回新对象的函数的正确写法是，让那个函数返回一个新对象</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>* (<span class="hljs-type">const</span> Rational &amp;lhs, <span class="hljs-type">const</span> Rational&amp; rhs)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.n * rhs.n, lhs.d * rhs.d);<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>需要承受operator *返回值的构造和析构成本</li><li>当你必须在“返回一个reference和返回一个object”之间抉择时，你的工作时挑出行为正确的那个</li><li>绝不要返回pointer或reference指向一个localstack对象，或者返回reference指向一个heap-allocated对象或返回pointer或reference指向一个localstatic对象而有可能同时需要多个这样的对象。条款4已经为“单线程环境中合理返回reference指向一个localstatic对象”提供一个设计实例。</li></ol><h2 id="将成员变量声明为private">22. 将成员变量声明为private</h2><ol type="1"><li>如果成员变量不是public，客户唯一能够访问对象的办法就是通过成员函数。如果public接口内的每样东西都是函数，客户就不需要打算访问class成员时迷惑的试着记住是否该使用小括号</li><li>如果通过函数访问成员变量，日后可改以某个计算替换这个成员变量，而class客户一点也不会知道class内部实现已经起了变换</li><li>将成员变量隐藏在函数接口的背后，可以为“所有可能的实现”提供弹性。例如这可以使得成员变量被读或被写时轻松通知其对象、可以验证class的验证条件以及函数的前提和时候状态、可以在多线程环境中执行同步控制等</li><li>封装的重要性。对客户隐藏成员变量，可以确保class的约束条件总是会获得维护</li><li>protected成员变量的论点类似。成员变量的封装性与“成员变量的内容改变时所破坏的代码数量”成反比。</li><li>假设有一个protected成员变量，而我们最终取消了它，所有使用它的派生类都会被破坏，同样缺少封装习惯。</li><li>从封装角度来说，只有两种访问权限：private（提供封装）和其他（不提供封装）</li><li>将成员变量声明为private。这可赋予客户访问数据的一致性，可细微划分访问控制、允诺约束条件获得保证，并提供class作者以充分的实现弹性</li><li>protected并不比public更具封装性。</li></ol><h2 id="宁以non-membernon-friend替换member函数">23.宁以non-member、non-friend替换member函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WebBrowser</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearCache</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearHistory</span><span class="hljs-params">()</span></span>;<br>    ```<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearEverythinng</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-comment">//non-member函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearBrowser</span><span class="hljs-params">(WebBrowser&amp; wb)</span></span><br><span class="hljs-function"></span>&#123;<br>    wb.<span class="hljs-built_in">clearCache</span>();<br>    wb.<span class="hljs-built_in">clearHistory</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>面向对象守则要求，数据以及操作数据的那些函数应该捆绑在一起，member函数时较好的选择。这是对基于对面向对象真实意义的一个误解。面向对象守则要求数据应该尽可能被封装。</li><li>如果member函数的封装性比non-member低。</li><li>愈多东西被封装，我们改变那些东西的能力就越大，这就是推崇封装的原因，它能使改变事物而只影响有限客户</li><li>能够访问private成员变量的函数只有class的member函数加上friend函数而已</li><li>如果在一个member函数和一个non-member,non-friend函数之间选择，而且两者提供相同机能，那么导致封装性较大的时non-membernon-friend函数，因为它并不增加“能够访问class内之private成分”的函数变量。</li><li>让clearBrowser成为一个non-member函数并位于WebBrowser所在的同一个namespace内</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> WebBrowserStuff&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebBrowser</span>&#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearBrowser</span><span class="hljs-params">(WebBrowser&amp; wb)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>namespace和classes不同，前者可以跨越多个源码文件而后者不能。</li><li>将所有便利函数放在多个头文件内但隶属同一个命名空间，意味着客户可以轻松扩展这一组便利函数。要做的是添加更多non-membernon-friend函数到此命名空间</li><li>宁可拿non-membernon-friend函数替换member函数，这样做可以增加封装性、包裹弹性和机能扩充性</li></ol><h2 id="若所有参数皆需类型转换请为此采用non-member函数">24.若所有参数皆需类型转换，请为此采用non-member函数</h2><ol type="1"><li>令classes支持隐式转换是个糟糕的主意，最常见的例外就是在建立数值类别时。假设设计一个class用来表现有理数，允许整数“隐式转换”合理。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Rational</span>(<span class="hljs-type">int</span> num1 = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> num2 = <span class="hljs-number">1</span>);<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">num1</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">num2</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">//const Rational operator* (const Rational&amp; rhs) const;</span><br>&#125;;<br><span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.<span class="hljs-built_in">num1</span>() * rhs.<span class="hljs-built_in">num1</span>(), lhs.<span class="hljs-built_in">num2</span>() * rhs.<span class="hljs-built_in">num2</span>());<br>&#125;<br>Rational result;<br>result = R1 * <span class="hljs-number">2</span>;<br>result = <span class="hljs-number">2</span> * R1;<br></code></pre></td></tr></table></figure><ol type="1"><li>member函数的反面时non-member函数，而不是friend函数</li><li>如果需要为某个函数的所有参数（包括被this指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是个non-member</li></ol><h2 id="考虑写出一个不抛异常的swap函数">25.考虑写出一个不抛异常的swap函数</h2><ol type="1"><li>swap函数原来只是STL的一部分，而后成为异常安全性编程的脊柱，以及用来处理自我复制的可能性的一个常见机制。还有非凡的复杂度。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> std&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">    <span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">T <span class="hljs-title">temp</span><span class="hljs-params">(a)</span></span>;<br>        a = b;<br>        b = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>主要类型T支持copying，缺省的swap实现代码会帮你置换类型T的对象</li><li>声明一个non-member函数调用member函数，</li><li>有些类型，swap的缺省行为会降低速度，如以指针指向一个对象，内含真正数据的类型，这种类型的常见表现形式是所谓的“pimpl手法”。</li><li>只要置换其Pimpl指针，将std::swap针对Widget特化</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> std&#123;<br>    <span class="hljs-keyword">template</span>&lt;&gt;<br>    <span class="hljs-type">void</span> <span class="hljs-built_in">swap</span>&lt;Widget&gt;(Widget&amp; a, Widget&amp; b)<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(a.pImpl, b.pImpl);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>template&lt;&gt;表示它是std::swap的一个全特化版本，函数名称之后的<Widget>表示这一特化版本系针对“T是Widget”而设计的。一般性的swaptemplate施行于Widgets身上便会启用这个版本。通常不能够改变std命名空间内的任何东西，但可以为标准templates制造特化版本，使它专属于我们自己的classes</Widget></li><li>令Widget声明一个名为swap的public成员函数做真正的置换工作，然后将std::swap特化</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&amp; other)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">using</span> std::swap;<br>        <span class="hljs-built_in">swap</span>(pImpl, other.pImpl);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">namespace</span> std&#123;<br>    <span class="hljs-keyword">template</span>&lt;&gt;<br>    <span class="hljs-type">void</span> <span class="hljs-built_in">swap</span>&lt;Widget&gt;(Widget&amp; a, Widget&amp; b)<br>    &#123;<br>        a.<span class="hljs-built_in">swap</span>(b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>这种做法不只能够通过编译，还与STL容器有一致性，因为所有STL容器都是有提供publicswap成员函数和std::swap特化版本（用以调用前者）</li><li>C++只允许对class template偏特化(partially specialize)，在functiontemplate偏特化行不通</li><li>当打算偏特化一个functiontemplate时，惯常做法是简单为它添加一个重载版本，声明一个non-memberswap让它调用member swap，但不再将那个non-memberswap声明为std::swap的特化版本或者重载版本。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">namesapce WidgetStuff&#123;<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>&#123;&#125;;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">    <span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        a.<span class="hljs-built_in">swap</span>(b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><p>C++的名称查找法则确保将找到global作用域T所在之命名空间内的任何T专属的swap。如果T是Widget并位于命名空间WidgetStuff内，编译器会使用“实参取决之查找规则”找出WidgetStuff内的swap。如果没有T专属之swap存在，编译器就使用std内的swap，这得感谢using表达式让std::swap在函数内曝光。即便如此编译器还是比较喜欢std::swap的T专属特化版，而非一般化的那个template，如果已针对T将std::swap特化，特化版会被编译器挑中。</p></li><li><p>首先，如果swap的缺省实现码对你的class或classtemplate提供可接受的效率，你不需要额外做任何事。任何尝试置换那种对象的人都会取得缺省版本，而那将有良好的运作。</p></li><li><p>其次，如果swap缺省实现版的效率不足（那几乎总是意味你的class或template使用了某种pimpl手法），试着做以下事情：</p></li><li><ol type="1"><li>提供一个publicswap成员函数，让他高效的置换你的类型的两个对象值，这个函数绝不该抛出异常</li><li>在你的class或template所在的命名空间内提供一个non-memberswap，并令它调用上述swap成员函数</li><li>如果你正在编写一个class（而非classtemplate），为你的class特化std::swap。并令它调用你的swap成员函数</li></ol></li><li><p>最后，如果你调用swap，请确定包含一个using声明式，以便让std::swap在你的函数内曝光可见，然后不加任何namespace修饰符，赤裸裸地调用swap</p></li><li><p>当std::swap对你的类型效率不高时，提供一个swap成员函数，并确定这个函数不抛出异常。</p></li><li><p>如果你提供一个member swap，也该提供一个non-memberswap用来调用前者。对于classes，（而非templates），也请特化std::swap</p></li><li><p>调用swap时应针对std::swap使用using声明式，然后调用swap并且不带任何“命名空间资格修饰”</p></li><li><p>为“用户定义类型”进行stdtemplates全特化是好的，但千万不要尝试在std内加入某些对std而言全新的东西</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>effective c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3. 资源管理</title>
    <link href="/2024/11/27/effective-cpp/3-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    <url>/2024/11/27/effective-cpp/3-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="以对象管理资源">13. 以对象管理资源</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Investment *pInv = <span class="hljs-built_in">createInvestment</span>();<br>···<br><span class="hljs-keyword">delete</span> pInv;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><p>可能无法执行delete</p></li><li><ol type="1"><li>在···中过早return</li><li>若delete位于某循环中，由于continue或者goto语句过早退出</li><li>···内抛出异常</li><li>泄露的不只是内含投资对象的那块内存，还包括那些投资对象所保存的任何资源</li></ol></li><li><p>为确保createInvestment返回的资源总是被释放，我们需要将这些资源放在对象内，当控制流离开f，该对象的析构函数会自动释放那些资源</p></li><li><p>实际上这正是隐身于本条款背后的半边想法，把资源放进对象内，我们便可以依赖c++的析构函数自动调用机制确保资源被释放</p></li><li><p>许多资源被动态分配于heap内而后被用于单一区块或函数内，他们应该在控制流离开那个区块或者函数时被释放，标准程序库提供的auto_ptr正是针对这种形式而设计的特制产品</p></li><li><p>auto_ptr是个”类指针对象“，也就是智能指针，其析构函数自动对齐所指对象调用delete</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::auto_ptr&lt;Investment&gt; <span class="hljs-title">pInv</span><span class="hljs-params">(createInvestment())</span></span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><p>两个想法</p></li><li><ol type="1"><li>获得资源后立刻放进管理对象内</li><li>管理对象运用析构函数确保资源被释放</li></ol></li><li><p>由于auto_ptr被销毁时会自动删除它所指之物，所以一定要注意别让给多个auto_ptr同时指向一个对象。</p></li><li><p>auto_ptrs有一个不寻常的性质，若通过copy构造函数或copyassignment操作符复制他们，他们会变成null，而赋值所得的指针将取得资源的唯一拥有权</p></li><li><p>收auto_ptrs管理的资源必须绝对没有一个以上的auto_ptr同时指向它，意味着auto_ptrs并非管理动态分配资源的神兵利器。</p></li><li><ol type="1"><li>例如：STL容器要求其元素发挥正常的复制行为，因此这些容器容不得auto_ptr</li></ol></li><li><p>auto_ptr的替代方案是”引用计数型智慧指针（reference-counting smartpointer RCSP)</p></li><li><ol type="1"><li>持续追踪共有多少对象指向某笔资源，并在无人指向它时自动删除该资源</li><li>类似于垃圾回收，但无法打破环状引用，例如两个其实已经没被使用的对象彼此互指，因而好像还处在“被使用"状态</li></ol></li><li><p>tr1::shared_ptr就是个RCSP</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::<span class="hljs-function">tr1::shared_ptr&lt;Investment&gt; <span class="hljs-title">pInv</span><span class="hljs-params">(createInvestment())</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>复制行为正常</li></ol><h2 id="在资源管理类中小心copying行为">14.在资源管理类中小心copying行为</h2><ol type="1"><li>资源取得时机便是初始化时机</li><li>并非所有资源都是heap_based，auto_ptr和tr1::shared_ptr这样的智能指针往往不适合作为资源掌管者，需要建立自己的资源管理类</li><li>例如，使用Capi函数处理Mutex的互斥锁现象，共有lock和unlock两函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lock</span><span class="hljs-params">(Mutex* pm)</span></span>;<span class="hljs-comment">//锁定pm所指的互斥器</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">(Mutex* pm)</span></span>;<span class="hljs-comment">//将互斥器解除锁定</span><br></code></pre></td></tr></table></figure><ol type="1"><li><ol type="1"><li>为确保绝不会忘记将一个被锁住的Mutex解锁，希望建立一个class用来管理机锁</li><li>这样的class的基本结构由RAII守则支配，也就是”资源在构造期间获得，在析构期间释放“</li></ol></li></ol><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Lock</span>&#123; public:    explicit <span class="hljs-type">Lock</span>(<span class="hljs-type">Mutex</span>* <span class="hljs-title">pm</span>):mutexPtr(<span class="hljs-title">pm</span>)    &#123;lock(<span class="hljs-title">mutexPtr</span>);&#125;//获得资源    ~<span class="hljs-type">Lock</span>() &#123;unlock(<span class="hljs-title">mutexPtr</span>);&#125; private:    mutex *mutexPtr; &#125;;</span><br></code></pre></td></tr></table></figure><figure><img src="/2024/11/27/effective-cpp/3-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/1706957067790-f5ba06f3-e9a3-4361-abcc-20e810519b61.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li><ol type="1"><li>当一个RAII对象被复制，会发生什么事?</li></ol></li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">Lock <span class="hljs-built_in">ml1</span>(&amp;m);<span class="hljs-comment">//锁定m Lock ml2(ml1);//将ml1复制到ml2身上，会发生什么是</span><br></code></pre></td></tr></table></figure><ol type="1"><li><ol type="1"><li><ol type="1"><li>禁止复制。许多时候允许RAII对象被复制并不合理，因为很少能够合理拥有”同步化基础器物“的副本。如果复制动作对RAIIclass并不合理，便应该禁止。条款6：如果coipying操作声明为private</li></ol></li></ol></li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Lock: <span class="hljs-symbol">private</span></span> <span class="hljs-symbol">Uncopyable</span>&#123; <span class="hljs-keyword">public</span>: &#125;;<br></code></pre></td></tr></table></figure><ol type="1"><li><ol type="1"><li><ol type="1"><li>对底层资源基础”引用计数法“。有时需要保有资源，直到它的最后一个使用者（某对象）被销毁。这种情况下复制RAII对象时，应该将该资源的”被引用数”递增。tr1::shared_ptr是如此。</li></ol></li></ol></li><li><ol type="1"><li><ol type="1"><li><ol type="1"><li>通常只要内含一个tr1::shared_ptr成员变量，RAIIclasses便可出现reference-counting copying行为。</li><li>如果Lock打算使用reference counting，可以改变mutexPtr类型，将Mutex*改为tr1::shared_ptr<Mutex>。然而不幸的是tr1::shared_ptr的缺省行为是“当引用次数为0时删除其所指物“，这不是我们所要的行为。当我们用上一个Mutex，我们想要做的释放动作是解除锁定而非删除</Mutex></li><li>幸运的是tr1::shared_ptr允许指定所谓的”删除器”，那是一个函数或者函数对象，当引用次数为0时便被调用（此技能并不存在于auto_ptr——它总是将其指针删除）。删除器对tr1::shared_ptr构造函数而言时可有可无的第二参数，<img src="/2024/11/27/effective-cpp/3-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/1706957885163-8a0df2e6-aa4f-4198-b2a1-3535512eecc7.png" alt="img"></li><li>本例Lockclass不声明析构函数，class析构函数会自动调用其non-static成员变量的析构函数。而mutexPtr的析构函数会在互斥器的引用次数为0时自动调用tr1::shared_ptr的删除器</li></ol></li></ol></li></ol></li><li><ol type="1"><li><ol type="1"><li>复制底部资源</li></ol></li></ol></li><li><ol type="1"><li><ol type="1"><li><ol type="1"><li>复制资源管理对象时，进行的时深度拷贝</li><li>某些标准字符串是由指向heap内存之指针构成。那种字符串对象内含一个指针指向一块heap内存。当这样一个字符串对象被复制，不论指针或其所指内存都会被制作出一个复件。这样的字符串展现深度复制行为</li></ol></li></ol></li></ol></li><li><ol type="1"><li><ol type="1"><li>转移底部资源的拥有权</li></ol></li></ol></li><li><ol type="1"><li><ol type="1"><li><ol type="1"><li>某些罕见场合下你可能希望确保永远只有一个RAII对象指向一个未加工资源，即使RAII对象被复制依然如此。此时资源的拥有权会从被复制物转移到目标物。这是auto_ptr奉行的复制意义</li><li>copying函数有可能被编译器自动创建出来，因此除非编译器所生版本做了你想做的事，否则你要自己i安歇他们</li></ol></li></ol></li></ol></li><li><p>tips：</p></li><li><ol type="1"><li>复制RAII对象把必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为</li><li>普遍而常见的RAII classcopying行为是，抑制copying、施行引用计数法。不过其他行为也都可能被实现</li></ol></li></ol><h2 id="在资源管理类中提供对原始资源的访问">15.在资源管理类中提供对原始资源的访问</h2><ol type="1"><li>资源管理类是对抗资源泄露的堡垒，在一个完美世界中依赖这样的classes处理和资源之间的所有互动，而不是直接处理原始资源</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::tr1::shared_ptr&lt;Investment&gt;<span class="hljs-built_in">pInv</span>(<span class="hljs-built_in">createInvestment</span>());<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dayHeld</span><span class="hljs-params">(<span class="hljs-type">const</span> Investment* pi)</span></span>;<br></code></pre></td></tr></table></figure><ol type="1"><li>需要一个函数可将RAIIclass对象转换为其所内含之原始资源。有两个做法可以达成目标：显示转换和隐式转换</li><li>显示转换tr1::shared_ptr和auto_ptr都提供一个get成员函数，用来执行显示转换，也就是它返回智能指针内部的原始指针（的复件）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> days = <span class="hljs-built_in">daysHeld</span>(pInv.<span class="hljs-built_in">get</span>());    <span class="hljs-comment">//将pInv内的原始指针传给daysHeld</span><br></code></pre></td></tr></table></figure><ol type="1"><li>就像几乎所有智能指针一样，tr1::shared_ptr和auto_ptr也重载了指针取值和操作符，它们允许隐式转换至底部原始指针</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Investment</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isTaxFree</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;<br><span class="hljs-function">Investment* <span class="hljs-title">createInvestment</span><span class="hljs-params">()</span></span>;<br><br>std::<span class="hljs-function">tr1::shared_ptr&lt;Investment&gt; <span class="hljs-title">pil</span><span class="hljs-params">(createInvestment())</span></span>;<span class="hljs-comment">//tr1::shared_ptr管理一笔资源</span><br><br><span class="hljs-type">bool</span> taxable1 = !(pil-&gt;<span class="hljs-built_in">isTaxFree</span>());<span class="hljs-comment">//经由operator-&gt;访问资源</span><br><span class="hljs-function">std::auto_ptr&lt;Investment&gt; <span class="hljs-title">pi2</span><span class="hljs-params">(createInvestment())</span></span>;<span class="hljs-comment">//令auto_ptr管理一笔资源</span><br><br><span class="hljs-type">bool</span> taxable2 = !((*pi2).<span class="hljs-built_in">isTaxFree</span>());<span class="hljs-comment">//经由operator*访问资源</span><br></code></pre></td></tr></table></figure><ol type="1"><li>取得RAII对象内的原始资源，提供一个隐式转换函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Front</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">FontHandle <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> f;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这使得客户每次使用API必须调用get</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">changeFontSize</span><span class="hljs-params">(FontHandle f, <span class="hljs-type">int</span> newSize)</span></span>;<br><span class="hljs-function">Font <span class="hljs-title">f</span><span class="hljs-params">(getFont())</span></span>;<br><span class="hljs-type">int</span> newFontSize;<br><span class="hljs-built_in">changeFontSize</span>(f.<span class="hljs-built_in">get</span>(),newFontSize);<span class="hljs-comment">//明白地将Font转换为FontHandle</span><br></code></pre></td></tr></table></figure><p>提供隐式函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Font</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">FontHandle</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-comment">//隐式转换函数</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> f;&#125;<br>&#125;;<br><br><span class="hljs-function">Font <span class="hljs-title">f</span><span class="hljs-params">(getFont())</span></span>;<br><span class="hljs-type">int</span> newFontSize;<br><span class="hljs-built_in">changeFontSize</span>(f,newFontSize);<br></code></pre></td></tr></table></figure><ol type="1"><li>但是这个隐式转换会增加错误发生机会，例如客户可能会在需要Font时意外创建一个FontHandle</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Font <span class="hljs-title function_">f1</span><span class="hljs-params">(getFont()</span>); <span class="hljs-type">FontHandle</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> f1; <span class="hljs-comment">// 原意要拷贝一个Font对象，却反而将f1隐式转换为其底部的FontHandle才复制它</span><br></code></pre></td></tr></table></figure><ol type="1"><li><p>以上程序有个FontHandle由Font对象f1管理，但那个FontHandle也可通过直接使用f2取得。那几乎不会有好下场，例如当f1被销毁，字体被释放，而f2因此成为"虚吊的"dangle。</p></li><li><p>是否该提供一个显示转换函数（例如get函数）将RAIIclass转换为其底部资源，或是应该提供隐式转换，答案主要取决于RAIIclass被设计执行的特定工件，以及它被使用的情况。最佳设计可能是坚持条款18的忠告”让接口容易被正确使用，不易被误用“。</p></li><li><p>通常显示转换函数如get是比较受欢迎的路子，因为它将非故意之类型转换的可能性最小化了，然而有时，隐式类型转换所带来的自然用法也会引发天秤倾斜</p></li><li><p>RAIIclass内的那个返回原始资源的函数，与”封装“发生矛盾，但一般而言不是什么设计灾难。RAIIclass并不是为了封装某物存在，它们的存在是为了确保一个特殊行为——资源释放——会发生。如果一定要，当然也可以在这基本功能之上再加一层资源封装，但并非必要。</p></li><li><p>也可以和身份松散的底层资源封装，获得真正的封装实现</p></li><li><ol type="1"><li>例如tr1::shared_ptr将它所有计数机构封装了起来，但还是让外界很容易访问其所内含的原始指针。就像多数设计良好的classes一样，它隐藏了客户不需要看的部分，但备妥客户需要的所有东西</li></ol></li><li><p>APIs往往要求访问原始资源，所以每一个RAIIclass应该提供一个取得其所管理之资源的办法</p></li><li><p>对原始资源的访问可能经由显示转换或隐式转换。一般而言显示转换比较安全，但隐式转换对客户比较方便</p></li></ol><h2 id="成对使用new和delete时采用相同形式">16.成对使用new和delete时采用相同形式</h2><ol type="1"><li><p>当使用new时，有两件事发生</p></li><li><ol type="1"><li>内存被分配出来，通过名为operator new的函数，</li><li>针对此内存会有一个或更多析构函数被调用</li></ol></li><li><p>当使用delete时，也有两件事发生</p></li><li><ol type="1"><li>针对此内存会有一个或更多析构函数被调用，然后内存才被释放</li></ol></li><li><p>即将被删除的指针，所指的是单一对象还是对象数组</p></li><li><ol type="1"><li>单一对象的内存布局一般而言不同于数组的内存布局</li><li>数组所用的内存通常还包括数组大小的记录，以便delete知道需要调用多少次析构函数，单一对象的内存则没有这笔记录。</li><li><figure><img src="/2024/11/27/effective-cpp/3-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/1707128830903-6f461996-372d-44ce-9519-3f32f4c53b41.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">delete</span> stringPtr1; <span class="hljs-regexp">//</span>删除一个对象 <span class="hljs-keyword">delete</span> [] stringPtr2; <span class="hljs-regexp">//</span>删除一个由对象组成的数组<br></code></pre></td></tr></table></figure><ol type="1"><li>调用new时使用[],必须在调用delete时也用[]，调用new时没有使用[],也不应该在对应delete时使用[]</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> std::string AddressLines[<span class="hljs-number">4</span>];<br>std::string* pal = <span class="hljs-keyword">new</span> AddressLines;<br><span class="hljs-keyword">delete</span> [] pal;<br></code></pre></td></tr></table></figure><ol type="1"><li>尽量不要对数组做typedefs动作，可将其改为vector<string></string></li></ol><h2 id="以独立语句将newed对象置入智能指针">17.以独立语句将newed对象置入智能指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">priority</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//揭示处理程序的优先权</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processWidget</span><span class="hljs-params">(std::str1::shared_ptr&lt;Widget&gt; pw, <span class="hljs-type">int</span> priority)</span></span>;<br><span class="hljs-comment">//在某动态分配所得的Widget上进行某些带有优先权的处理</span><br></code></pre></td></tr></table></figure><ol type="1"><li>由于”以对象管理资源“，processWidget决定对其动态分配得来的Widget运用智能指针（tr1::shared_ptr)</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">processWidget</span>(<span class="hljs-keyword">new</span> Widget, <span class="hljs-built_in">priority</span>());<span class="hljs-comment">//调用函数</span><br></code></pre></td></tr></table></figure><ol type="1"><li>不能通过编译，tr1::shared_ptr构造函数需要一个原始指针，但该构造函数是个explicit构造函数，无法进行隐式转换，要转换为智能指针</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">processWidget</span>(std::tr1::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> Widget, <span class="hljs-built_in">priority</span>());<br></code></pre></td></tr></table></figure><ol type="1"><li><p>虽然使用了对象管理式资源，却可能泄露资源</p></li><li><p>编译器在产出一个processWidget调用码之前，必须核算即将被传递的各个实参，</p></li><li><ol type="1"><li>第二个实参只是一个单纯的对priority函数的调用，</li><li>第一个实参std::tr1::shared_ptr<Widget>(new Widget)由两部分组成</Widget></li></ol></li><li><ol type="1"><li><ol type="1"><li>执行”new Widget"表达式</li><li>调用tr1::shared_ptr构造函数</li></ol></li></ol></li><li><ol type="1"><li>在调用processWidget之前，编译器必须创建代码</li></ol></li><li><ol type="1"><li><ol type="1"><li>调用priority</li><li>执行“new Widget"</li><li>调用tr1::shared_ptr构造函数</li></ol></li></ol></li><li><ol type="1"><li>newWidget执行于tr1::shared_ptr构造函数被调用之前，但priority的调用可以排在第一第二或者第三执行</li><li>万一priority调用异常，newWidget返回的指针将会遗失，因为它尚未被置入tr1::shared_ptr内，后者使我们用来防止资源泄露的</li><li>资源被创建和资源被转换为资源管理对象之间发生了异常干扰</li><li>避免方法：使用分离语句，分别写出</li></ol></li><li><ol type="1"><li><ol type="1"><li>创建Widget</li><li>将它置入一个智能指针内，然后再把那个智能指针传给processWidget</li></ol></li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::<span class="hljs-function">tr1::shared_ptr&lt;Widget&gt; <span class="hljs-title">pw</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget)</span></span>; <span class="hljs-built_in">processWidget</span>(pw, <span class="hljs-built_in">priority</span>());<span class="hljs-comment">//不会造成资源泄露</span><br></code></pre></td></tr></table></figure><ol type="1"><li>请记住，以独立语句将newed对象存储于智能指针内，如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄露</li></ol>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>effective c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2. 构造、析构、赋值运算</title>
    <link href="/2024/11/27/effective-cpp/2-%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E3%80%81%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/"/>
    <url>/2024/11/27/effective-cpp/2-%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E3%80%81%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="了解c默默编写并调用那些函数">5.了解c++默默编写并调用那些函数</h2><ol type="1"><li>在C++处理之后，emptyclass（空类）不再是个空类，如果没有声明，编译器就会为它声明一个copy构造函数，一个copyassignment 操作符和一个析构函数，所有这些函数都是public且inline的。</li><li>如果声明了一个构造函数，编译器不再为它创建default构造函数</li><li>在一个“内含reference成员”的class内支持赋值操作，必须自己定义copyassignment 操作符</li><li>在面对“内含const成员”，编译器处理与上相同</li><li>若某个base class将copyassignment操作符声明为private，编译器拒绝为其derived class生成一个copyassignment</li></ol><figure><img src="/2024/11/27/effective-cpp/2-%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E3%80%81%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/1706847938047-ed97f39e-ccba-4b41-bc3f-4f77783f656a.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h2 id="若不想使用编译器自动生成的函数就该明确拒绝">6.若不想使用编译器自动生成的函数，就该明确拒绝</h2><ol type="1"><li>将成员函数声明为private而且故意不实现他们，被用在c++iostream中阻止copying行为，copy构造函数和copyassignment操作符都被声明为private且没有定义。</li></ol><figure><img src="/2024/11/27/effective-cpp/2-%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E3%80%81%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/1706848020516-de923da9-e96d-46d1-ac2b-031376e32334.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>当客户企图拷贝对象时，连接器报错</li><li>为阻止对象被考不，唯一要做的时继承（私有继承）class不再声明拷贝构造函数和copy assignment运算符</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeForSale</span>: <span class="hljs-keyword">private</span> Uncopyable&#123;&#125;; <br></code></pre></td></tr></table></figure><ol type="1"><li>为驳回编译器自动提供的机能，可将相应的成员函数声明为private并且不予实现。使用像Uncopyable这样的baseclass也是一种做法。</li></ol><h2 id="为多态基类声明virtual析构函数">7.为多态基类声明virtual析构函数</h2><ol type="1"><li>当derived class对象经由一个base class指针被删除，而该baseclass带着一个non-virtual析构函数，i结果未有定义，实际执行时通常发生的是对象的derived成分没有被销毁。造成一个诡异的局部销毁现象对象。</li><li>给base class一个virtual析构函数，此后删除derived class对象</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeKeeper</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TimeKeeper</span>();<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">TimeKeeper</span>();<br>&#125;;<br></code></pre></td></tr></table></figure><ol type="1"><li><p>其他的virtual函数，目的是允许derivedclass的实现得以客制化</p></li><li><p>如果class不含virtual函数，通常表示它并不意图被用作一个baseclass。若令其析构函数为virtual，是个馊主意</p></li><li><p>virtual函数的实现细节不重要，重要的是class内含virtual函数，其对象体积会增加；在32位的计算机体系结构中将占用64位（为了存放两个ints）至96位（两个ints加上vptr）</p></li><li><p>心得：只有当class内含至少一个virtual函数，才为它声明virtual析构函数</p></li><li><p>即使class完全不带virtual函数，被非虚析构函数“咬伤”还是存在。</p></li><li><ol type="1"><li>例如：标准string不含任何virtual函数，但有时候程序员会错误地把它当作baseclass</li></ol></li><li><p>对任何不带virtual析构函数的class，包括所有STL容器，均禁止派生</p></li><li><p>有时class带一个pure virtual析构函数，可能颇为顺利、</p></li><li><ol type="1"><li>纯虚函数导致抽象类，不能被实例化，不能创建对象</li></ol></li><li><p>析构函数的运作方式是，最深层派生的class的析构函数最先被调用，然后其每一个baseclass的析构函数被调用</p></li><li><p>给base class一个virtual析构函数，只适用于带多态性质的base class上，这种基类的设计目的是为了用来通过基类接口处理派生类对象。</p></li><li><p>并非所有的基类设计目的都是为了多态，例如标准string和STL容器都不能被设计作为基类使用，更别提多态了</p></li><li><p>某些类设计目的是作为基类使用，但不是为了多态用途，不需要virtual析构函数</p></li></ol><h2 id="别让异常逃离析构函数">8. 别让异常逃离析构函数</h2><ol type="1"><li>C++并不禁止析构函数吐出异常，但它不鼓励你这样做，C++析构函数吐出异常，程序可能过早结束或者出现不明确行为</li><li>一个管理数据库管理的类</li></ol><figure><img src="/2024/11/27/effective-cpp/2-%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E3%80%81%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/1706848268744-ae573d2f-2d0f-41ff-88a3-35d1f35485cd.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>如果close抛出异常就结束程序，通常通过调用abort完成，如果程序遭遇一个”于析构期间发生的错误“后无法继续执行，”强迫结束程序“是个合理选项，它可以阻止异常从析构函数传播出去，调用abort可以抢先制”不明确行为“于死地</li></ol><figure><img src="/2024/11/27/effective-cpp/2-%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E3%80%81%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/1706848322270-e1d844c6-aef8-4c44-b286-4e9c8719d8ee.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li><p>吞下因调用close而发生的异常</p></li><li><ol type="1"><li>一般来说，将异常吞掉是个坏主意，因为它压制了”某些动作失败“的重要信息</li><li>然而有时吞下异常也比负担”草率结束程序“或”不明确行为带来的风险“好，是一个可行方案，程序能够继续可靠的执行</li></ol></li><li><p>重新设计DEConn接口，使其客户有机会对可能出现的问题作出反应。</p></li><li><ol type="1"><li>把调用close的责任从DEConn析构函数手上移到DBConn客户手上</li></ol></li><li><p>tips</p></li><li><ol type="1"><li>析构函数绝对不要吐出异常，如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下他们（不传播）或者结束程序。</li><li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作</li></ol></li></ol><h2 id="绝不在构造和析构过程中调用virtual函数">9.绝不在构造和析构过程中调用virtual函数</h2><ol type="1"><li>在基类构造期间virtual函数绝对不会下降到派生类阶层，取而代之的是，对象的作为就像隶属基类型一样，非正式的说法：在基类构造期间，virtual函数不是virtual函数</li><li>基类构造函数的执行更早于派生类构造函数，当基类构造函数执行时，派生类的成员变量尚未初始化，如果此期间调用的virtual函数下降到派生类阶层，派生类的函数必然取到local成员变量，而那些成员变量尚未初始化。</li><li>在派生类对象的基类构造期间，对下那个的类型是基类而不是派生类。不只virtual函数会被编译器解析至基类，若使用运行期类型信息（如dynamic_cast和typeid），也会把对象视为基类类型</li><li>相同道理也适用于析构函数，一旦派生类析构函数开始执行，对象内的派生类成员变量便呈现未定义值，c++视它们仿佛不在存在。进入基类析构函数后对象就成为一个基类对象，而c++的任何部分包括虚函数，dynamic_casts也这么看待它</li></ol><h2 id="令operator返回一个reference-to-this">10.令operator=返回一个reference to *this</h2><ol type="1"><li>连锁赋值，赋值操作符必须返回一个reference指向操作符的左侧实参</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Widget &amp; <span class="hljs-title">operator</span><span class="hljs-params">()</span></span>=(<span class="hljs-type">const</span> Widget&amp; rhs)<br>&#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">//返回左侧对象</span><br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>适用于所有赋值相关运算</li><li>这只是一个协议，并无强制性，但被所有内置类型和STL提供的类型所共同遵守</li></ol><h2 id="令operator中处理自我赋值">11. 令operator=中处理”自我赋值“</h2><ol type="1"><li>自我赋值发生在对象被赋值给自己时，看起来有点蠢，但合法</li><li>operator=实现代码</li></ol><figure><img src="/2024/11/27/effective-cpp/2-%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E3%80%81%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/1706848392574-df2d9ec6-d75b-42f1-a3dc-b99e7ac143ba.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>潜在的自我赋值</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">a[i] = a[j]; <span class="hljs-comment">// i==j</span><br>*px = *py; <span class="hljs-comment">//px和py指向同一个东西</span><br></code></pre></td></tr></table></figure><ol type="1"><li>这是别名带来的结果，所谓别名就是有一个以上的方法指称某对象。一般而言如果某段代码操作pointers或者references而它们被用来“指向多个相同类型的对象”，就需考虑这些对象是否为同一个。实际上两个对象只要来自同一个继承体系，它们甚至不需声明为相同类型就可鞥造成别名，因为一个基类的引用或指针可以指向一个派生类对象</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>:<span class="hljs-keyword">public</span> Base&#123;&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(<span class="hljs-type">const</span> Base&amp; rb, Derived* pd)</span></span>; <span class="hljs-comment">//rb 和*pd可能其实是同一对象</span><br></code></pre></td></tr></table></figure><ol type="1"><li>传统做法是由operator=最前面的一个证同测试达到自我赋值的检验目的</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)<br>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> == &amp;rhs) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br><br>    <span class="hljs-keyword">delete</span> pb;<br>    pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>前一版operator=不仅不具备“自我赋值安全性”，也不具备“异常安全性”，存在异常方面的麻烦。如果“newBitmap”导致异常，Widget最终会持有一个指针指向一块被删除的bitmap，这样的指针有害，你无法安全的删除他们，以及无法安全的读取他们</li><li>让operator=具备“异常安全性”会获得“自我赋值安全”的回报，因此对自我赋值的处理态度是倾向不管它，焦点放在实现异常安全性上。本条款只要你注意“许多时候一群精心安排的语句就可以导出一场安全（以及自我赋值安全的代码，再复制pb所指东西之前别删除pb</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)<br>&#123;<br>    Bitmap* pOrig = pb;<br>    pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);<br>    <span class="hljs-keyword">delete</span> pOrig;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><p>这个主题的另一个变奏曲是利用以下事实：</p></li><li><ol type="1"><li>某class的copy assignment操作符可能被声明为“以byvalue方式接受实参”</li><li>以by value方式传递东西会造成一份副本</li></ol></li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">Widget&amp; Widget::operator=(Widget <span class="hljs-built_in">rhs</span>)  //<span class="hljs-built_in">rhs</span>是被传对象的一份副本 &#123;//这里是pass by value    swap(<span class="hljs-built_in">rhs</span>);//将*this的数据和副本的数据进行互换    <span class="hljs-built_in">return</span> *this; &#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><ol type="1"><li>将copying动作从函数本体内移到函数参数构造阶段可令编译器有时生成更高效的代码</li></ol></li><li>确保当对象自我赋值时operator=有良好行为。其中技术包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序、以及copy-and-swap</li><li>确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。</li></ol><h2 id="复制对象时勿忘其每一个成分">12. 复制对象时勿忘其每一个成分</h2><ol type="1"><li>面向对象系统会将对象的内部封装起来，只留两个函数负责对象拷贝（复制），那便是带着适切名称的copy构造函数和copyassignment操作符，成为copying函数</li><li>如果为class添加一个成员变量，必须同时修改copying函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityCustomer</span>: <span class="hljs-keyword">public</span> Customer&#123;&#125;;<br>PriorityCustomer::<span class="hljs-built_in">PriorityCustomoer</span>(cosnt PriorityCustomer&amp; rhs):<span class="hljs-built_in">priority</span>(rhs.priority)<br>&#123;<br>    <span class="hljs-built_in">logCall</span>(<span class="hljs-string">&quot;PriorityCustomer copy constructor&quot;</span>);<br>&#125;<br>PriorityCustomer&amp; PriorityCustomer::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs)<br>&#123;<br>    <span class="hljs-built_in">logCall</span>(<span class="hljs-string">&quot;PriorityCustomer copy assignment operator&quot;</span>);<br>    priority = rhs.prioroty;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><p>在进行类继承时，copying函数复制了成员变量副本，但每个PriorityCustomer还内含它所继承的Customer成员变量副本，而那些变量却未被复制，PriorityCustomer的copy构造函数并没有指定实参传给其基类构造函数，（也就是说它在他的成员初值列中没有提到Customer。）因此PriorityCustomer对象的Customer成分会被不带实参之Customer狗仔函数（即default构造函数——必定有一个否则无法通过编译）初始化。default构造函数将针对name和lastTransaction执行缺省的初始化动作。</p></li><li><p>当编写一个copying函数</p></li><li><ol type="1"><li>复制所有local成员变量</li><li>调用所有base classes内适当的copying函数</li></ol></li><li><p>令copyassignment操作符调用copy构造函数是不合理的，因为这就像试图构造一个已经存在的对象。</p></li><li><p>令copy构造函数调用copyassignment操作符同样无意义。构造函数用来初始化新对象，而assignment操作符只施行于已初始化对象身上。</p></li><li><p>如果copy构造函数和copyassignment操作符有相近的代码，消除重复代码的做法是，建立一个新的成员函数给两者调用。这样的函数往往是private而且命名为init。这个策略可以安全消除copy构造函数和copyassignment操作符之间的代码重复</p></li><li><p>copying函数应该确保复制“对象内的所有成员变量”及“所有基类成分”</p></li><li><p>不要尝试以某个copying函数实现另一个copying函数。应该将共同机能放进第三个函数中，并由两个copying函数共同调用</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>effective c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. 让自己习惯C++</title>
    <link href="/2024/11/27/effective-cpp/1-%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC++/"/>
    <url>/2024/11/27/effective-cpp/1-%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC++/</url>
    
    <content type="html"><![CDATA[<h2 id="视c为一个语言联邦">1. 视C++为一个语言联邦</h2><ul><li>C语言</li><li>Object-Oriented C++</li><li>Template C++。这是C++的泛型编程</li><li>STL。STL是个template程序库，</li></ul><h2 id="尽量以constenuminline替换define">2.尽量以const,enum,inline替换#define</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ASPECT_RATIO 1.653</span><br></code></pre></td></tr></table></figure><ol type="1"><li>记号名称ASPECT_RATIO也许从未被编译器看见：也许在编译器开始处理源码之前它就被预处理器移走了。于是记号名称ASPECT_RATI0有可能没进入记号表(symboltable)内。</li><li>解决之道是以一个常量替换上述的宏(#define):</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">double</span> AspectRatio <span class="hljs-number">1.653</span>:<br></code></pre></td></tr></table></figure><ol type="1"><li><p>作为一个语言常量，AspectRatio肯定会被编译器看到，当然就会进入记号表内。此外对浮点常量(floatingpointconstant,就像本例)而言，使用常量可能比使用#define导致较小量的码，因为预处理器“盲目地将宏名称ASPECTRATIO替换为1.653”可能导致目标码(objectcode)出现多份1.653，若改用常量AspectRatio绝不会出现相同情况。</p></li><li><p>两种特殊情况</p></li><li><ol type="1"><li>定义常量指针，常量定义式放在头文件内，指针要声明为const，</li></ol></li></ol><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nim">//定义一个常量的<span class="hljs-type">char</span>*-based字符串，<span class="hljs-keyword">const</span>两次 <span class="hljs-keyword">const</span> <span class="hljs-type">char</span>* <span class="hljs-keyword">const</span> authorName = <span class="hljs-string">&quot;Scott&quot;</span>; //<span class="hljs-type">string</span>对象比<span class="hljs-type">char</span>*-based更合时宜，往往定义为 <span class="hljs-keyword">const</span> std::<span class="hljs-type">string</span> authorName(<span class="hljs-string">&quot;Scott&quot;</span>);<br></code></pre></td></tr></table></figure><ol type="1"><li><ol type="1"><li>class专属常量</li></ol></li><li><ol type="1"><li><ol type="1"><li>常量的作用域限制于class内，必须让其成为class的一个成员；为确保此常量纸多只有一个实体，必须让他成为一个static成员：</li></ol></li></ol></li></ol><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GamePlayer</span> </span>&#123; private: statin const <span class="hljs-keyword">int</span> NumTurns = <span class="hljs-number">5</span>;<span class="hljs-regexp">//</span>常量声明式 <span class="hljs-keyword">int</span> scores[Numturns]; &#125;; <span class="hljs-regexp">//</span>定义式 const <span class="hljs-keyword">int</span> GamePlayer::NumTurns; <br></code></pre></td></tr></table></figure><ol type="1"><li><ol type="1"><li><ol type="1"><li>C++要求对所使用的任何东西提供一个定义式，但如果他是个class专属常量又是static且为整数类型（int,char,bool)，则需要特殊处理。只要不取他们的地址，可以声明并使用而无需提供定义式</li><li>如果取某个class专属常量的地址，或者不取地址而编译器要坚持看到一个定义式，就要使用定义式</li><li>定义式放入实现文件而非头文件，由于声明时已经有初值，因此定义时不可以再设初值</li><li>我们无法利用#define创建一个class专属常量，因为#define不重视作用域</li><li>若编译器不预序static整数型class常量，可用枚举类型补偿</li></ol></li></ol></li></ol><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GamePlayer</span> </span>&#123; private: enum &#123; NumTurns = <span class="hljs-number">5</span>&#125;; <span class="hljs-keyword">int</span> scores[Numturns]; &#125;; <br></code></pre></td></tr></table></figure><ol type="1"><li><ol type="1"><li><ol type="1"><li>enumhack的行为更像是#define而不像const，因为取enum的地址不合法，如果不想让别人通过指针或者引用指向某个整数变量，enum可以实现。</li></ol></li></ol></li><li><p>define误用情况实现宏</p></li><li><ol type="1"><li>宏中的所有实参要加上小括号，否则回出问题，即使加了小括号，也会有问题</li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">callWithMax</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; a, <span class="hljs-type">const</span> T&amp; b)</span> </span>&#123;    <span class="hljs-built_in">f</span>(a &gt; b ? a : b); &#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><ol type="1"><li>对于形似函数的宏，最好改用inline函数替换#define</li></ol></li></ol><h2 id="尽可能使用const">3. 尽可能使用const</h2><ol type="1"><li>const允许指定一个语义约束（不被改动的对象），编译器会强制实施这项约束。</li><li>const在<em>左边，表示被指物是常量，如果在</em>右边，表示指针自身是常量，如果出现在型号两边，表示被指物和指针两者都是常量。</li><li>被指物是常量，const写在类型之前或者类型之后星号之前。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">const</span> Widget* pw)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(Widget <span class="hljs-type">const</span> * pw)</span></span>;<br></code></pre></td></tr></table></figure><ol type="1"><li>STL迭代器作用就像T*指针。不能指向不同的东西，但指向的东西的值可以改动</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator iter = vec.<span class="hljs-built_in">begin</span>();   <span class="hljs-comment">//iter作用类似T* const</span><br></code></pre></td></tr></table></figure><ol type="1"><li><ol type="1"><li>若希望所指的东西不能改变，，需要用const_iterator,类似于constT*指针</li></ol></li><li><p>const成员函数</p></li><li><ol type="1"><li>将const实施于成员函数的目的，是为了确认该成员函数可作用域const对象身上</li><li>它们使class接口比较容易被理解</li><li>使“操作const对象成为”可能</li><li>两个成员函数如果只是常量性不同，可以被重载</li><li>const对象大多用于passed by pointer-to-const或者passed byreference-to-const的传递结果</li><li>如果函数的返回类型是个内置类型，那么改动函数返回值从来就不合法</li><li>利用c++的一个与const相关的摆动场：mutable（可变的）,mutable释放掉non-static成员变量的bitwiseconstness约束</li><li><figure><img src="/2024/11/27/effective-cpp/1-%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC++/1706023482888-a652dfb6-7325-4073-a359-8a272e1add87.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>在const和non-const成员函数中避免重复</p></li><li><ol type="1"><li>const成员函数承诺绝不改变其对象的逻辑状态，如果在const函数内调用non-const函数，就会冒风险</li></ol></li><li><p>将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。</p></li><li><p>编译器强制实施bitwiseconstness，但你编写程序时应该使用“概念上的常量性”</p></li><li><p>当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复</p></li></ol><h2 id="确定对象使用前已先被初始化">4. 确定对象使用前已先被初始化</h2><ol type="1"><li><p>读取未初始化的值会导致不明确的行为。</p></li><li><ol type="1"><li>在某些平台上，读取未初始化的值，可能使程序终止</li><li>可能读入一些半随机的bits，污染了正在进行读取操作的那个对象，最终导致不可预知的程序行为，以及令人不愉快的调试过程</li></ol></li><li><p>永远在适用对象之前先将它初始化。对于无任何成员的内置类型，必须手工完成，确保每一个构造函数都将对象的每一个成员初始化</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* text = <span class="hljs-string">&quot;A C-style string&quot;</span>;<br><br><span class="hljs-type">double</span> d;<br>std::cin &gt;&gt; d;<br></code></pre></td></tr></table></figure><ol type="1"><li>注意赋值和初始化的区别，ABEntry构造函数的一个较佳写法是，使用所谓的成员初值列替换赋值动作：效率更高</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ABEntry::<span class="hljs-built_in">ABEntry</span>(<span class="hljs-type">const</span> std::string&amp; name):<span class="hljs-built_in">theName</span>(name)&#123;&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>对于大多数类型而言，比起先调用default狗在函数然后再调用copyassignment操作符，单只调用一次copy构造函数时比较高效的。</li><li>要default构造一个成员变量，可以使用成员初值列，只要指定无物作为初始化实参</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ABEntry::<span class="hljs-built_in">ABEntry</span>()<br>    :<span class="hljs-built_in">theName</span>(),<br>     <span class="hljs-built_in">numTimesConsulted</span>(<span class="hljs-number">0</span>)<span class="hljs-comment">//显式初始化为0</span><br>&#123;&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><p>编译器会为用户自定义类型之成员变量自动调用default构造函数——如果那些成员变量在成员初值列中没有被指定初值的话</p></li><li><p>规定总是在初值列中列出所有成员变量</p></li><li><p>有些情况，即使成员变量属于内置类型，也一定要使用初值列。如果成员变量时const或者references，就一定要使用初值，不能被赋值</p></li><li><p>总是使用成员初值列，这样做有时候绝对必要，且又往往比赋值更高效</p></li><li><p>许多类有多个构造函数，每个构造函数有自己的成员初值列，如果这种类存在许多成员变量或基类，多份成员初值列的存在就会导致重复。这种情况在初值列中遗漏那些“赋值表现像初始化一样好”的成员变量，改用它们的赋值操作，并将那些赋值操作移往某个函数（通常是private），供所有构造函数调用</p></li><li><p>c++有固定的成员初始化次序，基类更早于派生类被初始化，类成员变量总是以其声明次序被初始化，即使他们在成员初始列中以不同的次序出现。为避免一些晦涩错误，当在成员初值列中条列各个成员时，最好总是以其声明次序为次序（两个成员变量的初始化带有次序性，例如初始化array时要制定大小，因此代表大小的那个成员变量必须先有初值）。</p></li><li><p>non-local static对象</p></li><li><ol type="1"><li>static对象，寿命从被构造出来直到程序结束为止，因此stack和heap-based对象都被排除。包括global、定义于namespace作用域内、在calsses内、在函数内、在file作用域内被声明为static的对象。</li><li>函数内的static对象称为local static 对象，其他static对象称为non-localstatic对象。程序结束时static对象就会被自动销毁，也就是他们的析构函数会在main()结束时被自动调用。</li><li>编译单元是指产出单一目标文件的源码，时单一源码文件加上其所含入的头文件</li><li>如果某编译单元内的某个non-localstatic对象的初始化动作使用了另一编译单元内的某个non-localstatic对象，他所用到的这个对象可能尚未被初始化，因为C++对于定义于不同编译单元内的non-localstatic对象的初始化次序并无明确定义</li><li>将每个non-localstatic对象搬到自己的专属函数内（该对象在此函数内被声明为static）。这些函数返回一个reference指向它所包含的对象。然后用户调用这些函数。这是Singleton模式的一个常见实现手法。</li><li>函数内的localstatic对象会在该函数被调用、首次遇上该对象之定义式时被初始化。所以用函数调用（返回一个reference指向localstatic对象）替换直接访问non-localstatic对象，保证获得的references将指向一个历经初始化的对象。</li><li>更棒的是，如果从未调用non-localstatic对象的“仿真函数”，就绝不会引发构造和析构成本</li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSystem</span>&#123;&#125;;<br><span class="hljs-function">FileSystem&amp; <span class="hljs-title">tfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> FileSystem fs;<br>    <span class="hljs-keyword">return</span> fs;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Directory</span>&#123;&#125;;<br>Directory::<span class="hljs-built_in">Directory</span>()<br>&#123;<br>    std::<span class="hljs-type">size_t</span> disks = <span class="hljs-built_in">tfs</span>().<span class="hljs-built_in">numDisks</span>();<br>&#125;<br><br><span class="hljs-function">Directory&amp; <span class="hljs-title">tempDir</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> Directory td;<br>    <span class="hljs-keyword">return</span> td;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><p>这种结构下的reference-returning函数往往十分单纯：第一行定义并初始化一个localstatic对象，第二行返回它。如果频繁调用，可以使用inlining。</p></li><li><p>从另一个角度看，这些函数内含tataic对象，在多线程系统中带有不确定性。</p></li><li><p>任何一种non-conststatic对象，无论它是local还是non-local，在多线程环境下“等待某事发生”都会有麻烦。处理这个麻烦的一种做法是：在程序的单线程启动阶段手工调用所有reference-returning函数，这可以消除与初始化有关的“竞速形势”。</p></li><li><p>运用reference-returning函数防止“初始化次序问题”，前提是其中有着很一个对对象而言合理的初始化次序。如果有一个系统，其中对象A必须在对象B之前先初始化，但A的初始化能否成功却又受制于B是否已被初始化</p></li><li><p>在避免对象初始化之前过早地使用它们</p></li><li><ol type="1"><li>手工初始化内置型non-member对象</li><li>使用成员初值列对付对象的所有成分</li><li>在初始化次序不确定性氛围下加强你的设计（对不同编译单元定义的non-localstatic对象是一种折磨）</li></ol></li><li><p>对内置型对象进行手工初始化，因为c++不保证初始化它们</p></li><li><p>构造函数最好使用成员初值列，而不要在构造函数本体内使用赋值操作。初值列列出的成员变量，其排列次序应该和他们在class中的声明次序相同</p></li><li><p>为避免跨编译单元之初始化次序问题，用local static对象替换non-localstatic对象</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>effective c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>17. io、file</title>
    <link href="/2024/11/27/cpp-primer-plus/17-io%E3%80%81file/"/>
    <url>/2024/11/27/cpp-primer-plus/17-io%E3%80%81file/</url>
    
    <content type="html"><![CDATA[<h2 id="c输入和输出概述">17.1 C++输入和输出概述</h2><h3 id="流和缓冲区">17.1.1 流和缓冲区</h3><ul><li>C++程序把输入和输出看作字节流</li><li>streambuf类为缓冲区提供了内存，并提供了用于填充缓冲区、访问缓冲区内容、刷新缓冲区和管理缓冲区内存的类方法</li><li>iosbase类表示流的一般特征，如是否可读取、是二进制流还是文本流等：</li><li>ios类基于ios base,其中包括了一个指向streambuf对象的指针成员；</li><li>ostream类是从ios类派生而来的，提供了输出方法：</li><li>istream类也是从ios类派生而来的，提供了输入方法：</li><li>iostream类是基于istream和ostream类的，因此继承了输入方法和输出方法。</li></ul><p>C+的iostream类库管理了很多细节。例如，在程序中包含iostream文件将自动创建8个流对象(4个用于窄字符流，4个用于宽字符流)。</p><ul><li>cin对象对应于标准输入流。在默认情况下，这个流被关联到标准输入设备（通常为键盘）。wcin对象与此类似，但处理的是wchar_t类型。</li><li>cout对象与标准输出流相对应。在默认情况下，这个流被关联到标准输出设备（通常为显示器）。wcout对象与此类似，但处理的是wchar_t类型。</li><li>cerr对象与标准错误流相对应，可用于显示错误消息。在默认情况下，这个流被关联到标准输出设备（通常为显示器）。这个流没有被缓冲，这意味着信息将被直接发送给屏幕，而不会等到缓冲区填满或新的换行符。wcerr对象与此类似，但处理的是wchart类型。</li><li>clog对象也对应着标准错误流。在默认情况下，这个流被关联到标准输出设备（通常为显示器）。这个流被缓冲。wclog对象与此类似，但处理的是wchart类型。</li><li>对象代表流——这意味着什么呢？当iostream文件为程序声明一个cout对象时，该对象将包含存储了与输出有关的信息的数据成员，如显示数据时使用的字段宽度、小数位数、显示整数时采用的计数方法以及描述用来处理输出流的缓冲区的streambuf对象的地址。下面的语句通过指向的streambuf对象将字符串“Bjarnafree”中的字符放到cout管理的缓冲区中：<img src="/2024/11/27/cpp-primer-plus/17-io%E3%80%81file/1705237228595-bdc01ffb-ffa6-4208-8926-60c13c5b6abe.png" alt="img"></li></ul><h2 id="使用cout进行输出">17.2 使用cout进行输出</h2><ol type="1"><li>不要忘了，C++用指向字符串存储位置的指针来表示字符串。指针的形式可以是char数组名、显式的char指针或用引号括起的字符串。因此，下面所有的cout语句都显示字符串：</li></ol><figure><img src="/2024/11/27/cpp-primer-plus/17-io%E3%80%81file/1705245139233-1b798f50-772f-436a-9f16-88415e2056b4.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>对于其他类型的指针，C++将其对应于Vod*,并打印地址的数值表示。如果要获得字符串的地址，则必须将其强制转换为其他类型，如下面的代码片段所示：</li></ol><figure><img src="/2024/11/27/cpp-primer-plus/17-io%E3%80%81file/1705245175479-75b89dd8-fd6c-46c8-8810-34a63958facd.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>缓冲区</li></ol><ul><li>缓冲区为512的整数倍，输出到屏幕时，换行符发送到缓冲区将会刷新缓冲区</li><li>输入即将发生时刷新缓冲区</li><li>cout&lt;&lt;flush 刷新</li></ul><ol type="1"><li>用cout格式化</li></ol><ul><li><p>计数系统</p></li><li><ul><li>来看如何设置显示整数时使用的计数系统。要控制整数以十进制、十六进制还是八进制显示，可以使用dec、hex和oct控制符。例如，下面的函数调用将cout对象的计数系统格式状态设置为十六进制：hex(cout)以十六进制打印整数值，也可以cout&lt;&lt; hex;</li></ul></li><li><p>调整字段宽度</p></li><li><ul><li>widh()方法只影响将显示的下一个项目，然后字段宽度将恢复为默认值。右对齐</li></ul></li><li><p>填充字符</p></li><li><ul><li>cout用空格填充字段中未被使用的部分，可以用fill()成员函数来改变填充字符</li><li>cout.fill('*')</li></ul></li><li><p>设置浮点数的显示精度</p></li><li><ul><li>precision(2)精度设置为2</li></ul></li><li><p>打印末尾的0和小数点</p></li><li><ul><li>ios_base提供了setf()函数</li><li>cout.setf(ios_base::showpoint); cout显示末尾小数点</li></ul></li><li><p>再谈setf</p></li><li><ul><li><figure><img src="/2024/11/27/cpp-primer-plus/17-io%E3%80%81file/1705300561842-d11e82f0-3247-44b3-9d1b-f0bcf7cf2a37.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><figure><img src="/2024/11/27/cpp-primer-plus/17-io%E3%80%81file/1705300777494-e65f71b2-8751-47c6-b216-cd25af40e0a6.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><figure><img src="/2024/11/27/cpp-primer-plus/17-io%E3%80%81file/1705300787233-3bc3f62d-e9a5-4d70-9dcf-7ef7997eb842.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>调用setf()的效果可以通过unsetf()消除，后者的原型如下：</li><li>void unsetf(fmtflags mask);</li><li>其中，mask是位模式。mask中所有的位都设置为1，将使得对应的位被复位。也就是说，setf()将位设置为1，unsetf()将位恢复为0。例如：</li><li>默认模式：cout.setf(0,ios_base:floatfield);</li><li><figure><img src="/2024/11/27/cpp-primer-plus/17-io%E3%80%81file/1705302159803-125ed29f-5cbd-4aee-a679-eb3814c0b266.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ul></li><li><p>标准控制符</p></li><li><ul><li><figure><img src="/2024/11/27/cpp-primer-plus/17-io%E3%80%81file/1705302361934-b694ca9a-a7a2-4252-ac51-a1e2cf948d18.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><figure><img src="/2024/11/27/cpp-primer-plus/17-io%E3%80%81file/1705302453821-2f6354ea-1628-4804-bed9-cc2031c17e3a.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><figure><img src="/2024/11/27/cpp-primer-plus/17-io%E3%80%81file/1705302467106-79217348-497f-4fb3-80ac-65d0dff1c7ef.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ul></li><li><p>头文件iomanip</p></li><li><ul><li>常用setprecision()设置精度 setfill()填充字符 setw()字段宽度</li></ul></li></ul><h2 id="使用cin进行输入">17.3 使用cin进行输入</h2><ul><li><p>可以将hex、oct和dec控制符与cin一起使用，来指定将整数输入解释为十六进制、八进制和十进制格式</p></li><li><ul><li>cin &gt;&gt; hex;</li></ul></li><li><p>cin&gt;&gt;如何检查输入</p></li><li><ul><li><figure><img src="/2024/11/27/cpp-primer-plus/17-io%E3%80%81file/1705303363661-5c9b6cd4-5262-445c-b5fb-a948f7b3b952.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ul></li><li><p>流状态</p></li><li><ul><li>cin或cout对象包含一个描述流状态(stream state)的数据成员（从iosbase类那里继承的）。</li><li>流状态（被定义为iostate类型，而iostate是一种bitmask类型）由3个iosbase元素组成：eofbit、badbit或failbit,其中每个元素都是一位，可以是1（设置）或0（清除)。</li><li>当cin操作到达文件末尾时，它将设置eofbit:</li><li>当cin操作未能读取到预期的字符时，它将设置failbit。I/O失败（如试图读取不可访问的文件或试图写入写保护的磁盘），也可能将failbit设置为1。</li><li>在一些无法诊断的失败破坏流时，badbit元素将被设置（实现没有必要就哪些情况下设置failbit,哪些情况下设置badbit达成一致)。当全部3个状态位都设置为0时，说明一切顺利。</li><li><figure><img src="/2024/11/27/cpp-primer-plus/17-io%E3%80%81file/1705460694934-0372cfe8-71e9-4f33-b615-2da019862aad.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>设置状态</li></ul></li><li><ul><li><ul><li>clear（）方法将状态设置为它的参数。clear（）将使用默认参数0，清除三个状态位</li><li>clear(eofbit)状态设置为eofbit，其他两个状态位被清除</li><li>setstate()方法只影响参数中已设置的位，下面的调用将设置eofbit,而不会影响其他位setstate(eofbit);</li></ul></li></ul></li><li><p>getline()函数将对其输入中的定界字符#，而get()函数不会</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Limit = <span class="hljs-number">255</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::cin;<br><span class="hljs-keyword">using</span> std::endl;<br><span class="hljs-type">char</span> input[Limit];<br><br>cout &lt;&lt; <span class="hljs-string">&quot;Enter a string for getline() processing:\n&quot;</span>;<br>cin.<span class="hljs-built_in">getline</span>(input, Limit, <span class="hljs-string">&#x27;#&#x27;</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;Here is your input:\n&quot;</span>;<br>cout &lt;&lt; input &lt;&lt; <span class="hljs-string">&quot;\nDone with pase 1\n&quot;</span>;<br><br><span class="hljs-type">char</span> ch;<br>cin.<span class="hljs-built_in">get</span>(ch);<br>cout &lt;&lt; <span class="hljs-string">&quot;The next input character is &quot;</span> &lt;&lt; ch &lt;&lt; endl;<br><br><span class="hljs-keyword">if</span> (ch != <span class="hljs-string">&#x27;\n&#x27;</span>)<br>&#123;<br>cin.<span class="hljs-built_in">ignore</span>(Limit, <span class="hljs-string">&#x27;\n&#x27;</span>);<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;Enter a string for get() processing : \n&quot;</span>;<br>cin.<span class="hljs-built_in">get</span>(input, Limit, <span class="hljs-string">&#x27;#&#x27;</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;Here is your input:\n&quot;</span>;<br>cout &lt;&lt; input &lt;&lt; <span class="hljs-string">&quot;\nDone with phase 2\n&quot;</span>;<br><br>cin.<span class="hljs-built_in">get</span>(ch);<br>cout &lt;&lt; <span class="hljs-string">&quot;The next input chatacter is &quot;</span> &lt;&lt; ch &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure><img src="/2024/11/27/cpp-primer-plus/17-io%E3%80%81file/1705885194777-df6662fd-e5fb-41dd-a8a1-8c2b91f0bc4a.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp-primer-plus/17-io%E3%80%81file/1705885164889-75204fbc-874a-4e9c-a0e1-4ca564c490c1.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ul><li>其他方法</li><li>read()不会在输入后加上空值字符，因此不能将输入转换为字符串。</li><li>peek()函数返回输入中的下一个字符，但不愁去输入流中的字符。也就是说，他能查看下一个字符</li><li>gcount()方法返回最后一个非格式化抽取方法读取的字符数。这意味着字符是由get()、getline()、ignore()或者read()方法读取的，不是由抽取运算符&gt;&gt;读取的，抽取运算符对输入进行格式化，使之与特定的数据类型匹配，速度比strlen（）慢</li><li>putback()函数将一个字符插入到输入字符串中，被插入的字符将是下一条输入语句读取的第一个字符。</li></ul><h2 id="文件输入和输出">17.4 文件输入和输出</h2><h3 id="文件输入">1. 文件输入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>string filename;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;Enter name for new file: &quot;</span>;<br>cin &gt;&gt; filename;<br><br><span class="hljs-function">ofstream <span class="hljs-title">fout</span><span class="hljs-params">(filename.c_str())</span></span>;<br><br>fout &lt;&lt; <span class="hljs-string">&quot;For your eyes only!\n&quot;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;Enter your secret number: &quot;</span>;<br><span class="hljs-type">float</span> secret;<br>cin &gt;&gt; secret;<br>fout &lt;&lt; <span class="hljs-string">&quot;Your secret number is &quot;</span> &lt;&lt; secret &lt;&lt; endl;<br>fout.<span class="hljs-built_in">close</span>();<br><br><span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(filename.c_str())</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;Here are the contents of &quot;</span> &lt;&lt; filename &lt;&lt; <span class="hljs-string">&quot;:\n&quot;</span>;<br><span class="hljs-type">char</span> ch;<br><span class="hljs-keyword">while</span> (fin.<span class="hljs-built_in">get</span>(ch))<br>&#123;<br>cout &lt;&lt; ch;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;Done\n&quot;</span>;<br>fin.<span class="hljs-built_in">close</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure><img src="/2024/11/27/cpp-primer-plus/17-io%E3%80%81file/1705886682513-d1edb5d2-2601-41c1-87d3-834a45ae049b.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h3 id="检查文件是否打开成功">2. 检查文件是否打开成功</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">fin.<span class="hljs-built_in">open</span>(filename);<br><span class="hljs-keyword">if</span>(fin.<span class="hljs-built_in">fail</span>())<br>&#123;&#125; <br><span class="hljs-keyword">if</span>(!fin)<br>&#123;&#125;<br><span class="hljs-keyword">if</span>(!fin.<span class="hljs-built_in">is_open</span>())<br>&#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="打开多个文件">3. 打开多个文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ifstream fin;<br>fin.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;fat.txt&quot;</span>);<br>fin.<span class="hljs-built_in">close</span>();<br>fin.<span class="hljs-built_in">clear</span>();<br>fin.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;rat.txt&quot;</span>);<br>fin.<span class="hljs-built_in">close</span>();<br></code></pre></td></tr></table></figure><h3 id="命令行处理技术">4. 命令行处理技术</h3><p>在UNIX和linux中计算文件包含的字数，命令行输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">wc</span> report1 report2 report3 //程序名 后面三个是作为命令行参数传递给程序的文件名<br><span class="hljs-comment">#include &lt;iostream&gt;</span><br><span class="hljs-comment">#include &lt;fstream&gt;</span><br><span class="hljs-comment">#include &lt;cstdlib&gt;</span><br><br>int main(int argc, char* argv[])<br>&#123;<br>using namespace std;<br><span class="hljs-keyword">if</span> (argc == 1)<br>&#123;<br>cerr &lt;&lt; <span class="hljs-string">&quot;Usage: &quot;</span> &lt;&lt; <span class="hljs-string">argv[0] &lt;&lt; &quot; filename[s]\n&quot;;</span><br><span class="hljs-string">exit(EXIT_FAILURE);</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">ifstream fin;</span><br><span class="hljs-string">long count;</span><br><span class="hljs-string">long total = 0;</span><br><span class="hljs-string">char ch;</span><br><span class="hljs-string">for (int file = 1; file &lt; argc; file++)</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">fin.open(argv</span>[file]);<br><span class="hljs-keyword">if</span> (!fin.is_open())<br>&#123;<br>cerr &lt;&lt; <span class="hljs-string">&quot;Could not open &quot;</span> &lt;&lt; <span class="hljs-string">argv[file] &lt;&lt; endl;</span><br><span class="hljs-string">fin.clear();</span><br><span class="hljs-string">continue;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">count = 0;</span><br><span class="hljs-string">while (fin.get(ch))</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">count++;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">cout &lt;&lt; count &lt;&lt; &quot; characters in &quot; &lt;&lt; argv</span>[file] &lt;&lt; <span class="hljs-string">endl;</span><br><span class="hljs-string">total += count;</span><br><span class="hljs-string">fin.clear();</span><br><span class="hljs-string">fin.close();</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">cout &lt;&lt; total &lt;&lt; &quot;characters in all files\n&quot;;</span><br><span class="hljs-string">return 0;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="文件模式">5. 文件模式</h3><figure><img src="/2024/11/27/cpp-primer-plus/17-io%E3%80%81file/1705892409171-9f7f3a78-bc26-4ffb-9c70-c65ab3356b80.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp-primer-plus/17-io%E3%80%81file/1705892442856-a6d04e8d-d29f-443c-bdab-b8491fec7b65.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h3 id="文件随机存取">6. 文件随机存取</h3><p>seekg()</p><p>seekp()</p><p>tellg()</p><p>tellp()</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++ primer plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>16. string类和标准模板库</title>
    <link href="/2024/11/27/cpp-primer-plus/16-string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/"/>
    <url>/2024/11/27/cpp-primer-plus/16-string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="string类">string类</h2><h3 id="构造字符串">1. 1.构造字符串</h3><p>size_type是一个依赖于实现的整型，是在头文件string中定义的。string类将string::npos定义为字符串的最大长度，通常为unsignedint的最大值。另外，表格中使用缩写NBTS(null-terminatedstring)来表示以空字符结束的字符串一传统的C字符串。</p><figure><img src="/2024/11/27/cpp-primer-plus/16-string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/1701702052644-b3f8713e-0ff3-4d46-977d-5899b7d5eda2.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>指定分割字符：<img src="/2024/11/27/cpp-primer-plus/16-string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/1704896035315-4f438f1f-0b44-4f43-bb77-95a0fdd35771.png" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string empty;<br>empty.<span class="hljs-built_in">capacity</span>(); <span class="hljs-comment">//字符串的容量</span><br><span class="hljs-comment">//字符串的容量比标准容量（16的倍数）小1</span><br></code></pre></td></tr></table></figure><figure><img src="/2024/11/27/cpp-primer-plus/16-string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/1704901298503-a6bed4af-18dd-4aca-b6bb-b12fc1db7a88.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>shared_ptr</p><p>unique_ptr</p><p>auto_ptr</p><p>左值与右值这两个概念是从 C中传承而来的，左值指既能够出现在等号左边，也能出现在等号右边的变量；右值则是只能出现在等号右边的变量。</p><h2 id="标准模板库">16.3 标准模板库</h2><ul><li>STL提供了一组表示容器、迭代器、函数对象和算法的模板</li><li>STL容器是同质的，即存储的值的类型相同</li></ul><h3 id="模板类vector">16.3.1 模板类vector</h3><ul><li>可以创建vector对象，将一个vector对象赋给另一个对象，使用[]运算符来访问vector元素。</li><li>要使类成为通用的，应将它设计为模板类，</li><li>STL正是这样做的一在头文件vector(以前为vector..h)中定义了一个vector模板。</li><li>要创建vector模板对象，可使用通常的<type>表示法来指出要使用的类型。另外，vector模板使用动态内存分配，因此可以用初始化参数来指出需要多少矢量：</type></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> vector</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ratings</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n; <br><span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">scores</span><span class="hljs-params">(n)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="可对矢量执行的操作">16.3.2 可对矢量执行的操作</h3><ul><li>size()返回容器中元素数目</li><li>swap()交换两个容器的内容</li><li>begin()返回一个指向容器中第一个元素的迭代器</li><li>end()返回一个表示超过容器尾的迭代器。</li></ul><p>迭代器是一个广义指针</p><ul><li>vector模板类有pushback()，是一个方便的方法，它将元素添加到矢量末尾</li><li>erase()方法删除矢量中给定区间的元素。它接受两个迭代器参数，这些参数定义了要删除的区间。第一个迭代器指向区间的起始处，第二个迭代器位于区间终止处的后一个位置。scores.erase(scores.begin(),scores.begin()+2)</li><li>insert()方法的功能与erase()相反。它接受3个迭代器参数，第一个参数指定了新元素的插入位置，第二个和第三个迭代器参数定义了被插入区间，该区间通常是另一个容器对象的一部分。old_v.insert(old_v.end(),new_v.begin()+1,new_v.end());</li></ul><h3 id="对矢量可执行的其他操作">16.3.3 对矢量可执行的其他操作</h3><ul><li><p>3个具有代表性的STL函数：for_each()random_shuffle()和sort()</p></li><li><p>for_each()</p></li><li><ul><li>它接受3个参数。前两个是定义容器中区间的迭代器，最后一个是指向函数的指针,最后一个参数是一个函数对象</li><li>foreach()函数将被指向的函数应用于容器区间中的各个元素。被指向的函数不能修改容器元素的值。可以用foreach()函数来代替for循环。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">for_each(books.<span class="hljs-built_in">begin</span>(),books.<span class="hljs-built_in">end</span>(),ShowReview);<br></code></pre></td></tr></table></figure><ul><li><p>Randomshuffle()函数接受两个指定区间的迭代器参数，并随机排列该区间中的元素。例如，下面的语句随机排列books矢量中所有元素：</p></li><li><ul><li>该函数要求容器类允许随机访问，vector类可以做到这一点</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">random_shuffle</span>(books.<span class="hljs-built_in">begin</span>(),books.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure><ul><li>sort()函数也要求容器支持随机访问。该函数有两个版本，第一个版本接受两个定义区间的迭代器参数，并使用为存储在容器中的类型元素定义的&lt;运算符，对区间中的元素进行操作。例如，下面的语句按升序对coolstuff的内容进行排序，排序时使用内置的&lt;运算符对值进行比较：<img src="/2024/11/27/cpp-primer-plus/16-string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/1705200998948-8333c2ec-53f8-447a-a508-9a72646db2a7.png" alt="img"></li><li>如果容器元素是用户定义的对象，则要使用sort(),必须定义能够处理该类型对象的operator&lt;()函数</li></ul><h3 id="基于范围的for循环">16.3.4 基于范围的for循环</h3><ul><li>不同于foreach(),基于范围的for循环可修改容器的内容，诀窍是指定一个引用参数。例如，假设有如下函数：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InflateReview</span> <span class="hljs-params">(Review &amp;r)</span></span>&#123;r.rating++;&#125;<br></code></pre></td></tr></table></figure><ul><li>可使用如下循环对books的每个元素执行该函数：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : books)<span class="hljs-built_in">InflateReview</span>(x);<br></code></pre></td></tr></table></figure><h2 id="泛型编程">16.4 泛型编程</h2><p>STL是一种泛型编程</p><h3 id="为何使用迭代器">16.4.1 为何使用迭代器</h3><ul><li>模板使得算法独立于存储的数据类型，而迭代器使算法独立于使用的容器类型。因此，它们都是STL通用方法的重要组成部分。</li><li>要实现find函数，迭代器应具备哪些特征呢？下面是一个简短的列表<img src="/2024/11/27/cpp-primer-plus/16-string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/1705201603996-cebe5660-82cb-4d80-a44d-c7d5474cb720.png" alt="img"></li><li>为区分++运算符的前缀版本和后缀版本，C++将operator+-+作为前缀版本，将operator++(int)作为后缀版本：其中的参数永远也不会被用到，所以不必指定其名称。</li><li><figure><img src="/2024/11/27/cpp-primer-plus/16-string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/1705201754756-d604f2b7-68df-4a66-a19c-b30f4e6a7902.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><figure><img src="/2024/11/27/cpp-primer-plus/16-string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/1705201763135-7528fe1d-9cc3-421c-a6ef-b6b9d5bb5797.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ul><h3 id="迭代器类型">16.4.2 迭代器类型</h3><ul><li><p>输入迭代器</p></li><li><ul><li>来自容器的信息被视为输入，输入迭代器可被程序用来读取容器中的信息。具体地说，对输入迭代器解除引用，将使程序能够读取容器中的值，但不一定能让程序修改值。因此，需要输入迭代器的算法将不会修改容器中的值。</li><li>输入迭代器必须能够访问容器中所有的值，这是通过支持++运算符（前缀格式和后缀格式）来实现的。</li><li>如果将输入迭代器设置为指向容器中的第一个元素，并不断将其递增，直到到达超尾位置，则它将依次指向容器中的每一个元素。顺便说一句，并不能保证输入迭代器第二次遍历容器时，顺序不变。</li><li>另外，输入迭代器被递增后，也不能保证其先前的值仍然可以被解除引用。基于输入迭代器的任何算法都应当是单通行(single-pass)的，不依赖于前一次遍历时的迭代器值，也不依赖于本次遍历中前面的迭代器值。</li><li>注意，输入迭代器是单向迭代器，可以递增，但不能倒退。</li></ul></li><li><p>输出迭代器</p></li><li><ul><li>STL使用术语“输出”来指用于将信息从程序传输给容器的迭代器，因此程序的输出就是容器的输入。</li><li>STL足够通用，其容器可以表示输出设备，因此容器也可能如此。另外，如果算法不用读取作容器的内容就可以修改它（如通过生成要存储的新值），则没有理由要求它使用能够读取内容的迭代器。</li></ul></li><li><p>正向迭代器</p></li><li><ul><li>与输入迭代器和输出迭代器相似，正向迭代器只使用++运算符来遍历容器，</li><li>与输入和输出迭代器不同的是，它总是按相同的顺序遍历一系列值</li><li>将正向迭代器递增后，仍然可以对前面的迭代器值解除引用（如果保存了它），并可以得到相同的值。这些特征使得多次通行算法成为可能。</li><li>正向迭代器既可以使得能够读取和修改数据，也可以使得只能读取数据：<img src="/2024/11/27/cpp-primer-plus/16-string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/1705203232030-17e2fa5f-8059-4808-a6f2-714a6b1d97eb.png" alt="img"></li></ul></li><li><p>双向迭代器</p></li><li><ul><li>假设算法需要能够双向遍历容器，情况将如何呢？例如，reverse函数可以交换第一个元素和最后一个元素、将指向第一个元素的指针加1、将指向第二个元素的指针减1，并重复这种处理过程。双向迭代器具有正向迭代器的所有特性，同时支持两种（前缀和后缀）递减运算符。</li></ul></li><li><p>随机访问迭代器</p></li><li><ul><li>有些算法（如标准排序和二分检索）要求能够直接跳到容器中的任何一个元素，这叫做随机访问，需要随机访问迭代器。随机访问迭代器具有双向迭代器的所有特性，同时添加了支持随机访问的操作（如指针增加运算)和用于对元素进行排序的关系运算符。</li><li><figure><img src="/2024/11/27/cpp-primer-plus/16-string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/1705203338574-8505aeb5-398e-4f50-a12a-5306c3527253.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ul></li></ul><h3 id="迭代器层次结构">16.4.3 迭代器层次结构</h3><figure><img src="/2024/11/27/cpp-primer-plus/16-string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/1705203338546-482a142e-eb46-49d5-98c3-99c351040642.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>注意，各种迭代器的类型并不是确定的，而只是一种概念性描述。正如前面指出的，每个容器类都定义了一个类级typedef名称-iterator,因此vector<int>类的迭代器类型为vector&lt;-int&gt;:interator。.然而，该类的文档将指出，矢量迭代器是随机访问迭代器，它允许使用基于任何迭代器类型的算法，因为随机访问迭代器具有所有迭代器的功能。同样，list<in>类的迭代器类型为list<int>:iterator。STL实现了一个双向链表，它使用双向迭代器，因此不能使用基于随机访问迭代器的算法，但可以使用基于要求较低的迭代器的算法。</int></in></int></p><h3 id="概念改进和模型">16.4.4 概念、改进和模型</h3><ul><li><p>将指针用作迭代器</p></li><li><ul><li><figure><img src="/2024/11/27/cpp-primer-plus/16-string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/1705203847529-085689e1-6598-4331-b653-53845175bc9f.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ul></li><li><ul><li><figure><img src="/2024/11/27/cpp-primer-plus/16-string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/1705203954325-39265c50-b345-4695-a444-1b4fb305a3a4.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ul></li><li><p>其他有用的迭代器</p></li><li><ul><li>反向打印</li></ul></li><li><ul><li><ul><li><figure><img src="/2024/11/27/cpp-primer-plus/16-string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/1705204191930-9bd26c4e-622f-4594-904e-4d944b54eb60.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ul></li></ul></li><li><ul><li>显式和隐式</li></ul></li><li><ul><li><ul><li><figure><img src="/2024/11/27/cpp-primer-plus/16-string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/1705204255531-e571a957-3d61-4736-83f7-7efe0f0e833f.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ul></li></ul></li><li><ul><li>插入迭代器</li></ul></li><li><ul><li><ul><li>back insert iterator将元素插入到容器尾部，</li><li>而front insert iterator将元素插入到容器的前端。</li><li>最后，insert iterator将元素插入到insertiterator构造函数的参数指定的位置前面。这三个插入迭代器都是输出容器概念的模型。</li></ul></li></ul></li><li><p>这里存在一些限制。</p></li><li><ul><li>back insertiterator只能用于允许在尾部快速插入的容器（快速插入指的是一个时间固定的算法，将在本章后面的“容器概念”一节做进一步讨论)，vector类符合这种要求。</li><li>front insertiterator只能用于允许在起始位置做时间固定插入的容器类型，vector类不能满足这种要求，但queue满足。</li><li>insertiterator没有这些限制，因此可以用它把信息插入到矢量的前端。然而，frontinsert iterator对于那些支持它的容器来说，完成任务的速度更快。</li></ul></li></ul><h3 id="容器种类">16.4.5 容器种类</h3><ul><li>序列中的元素具有确定的顺序，因此可以执行诸如将值插入到特定位置、删除特定区间等操作</li></ul><figure><img src="/2024/11/27/cpp-primer-plus/16-string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/1705208611763-e6582659-7839-4160-9fe3-72a9576a2f53.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>因为模板类deque、list、queue、priority_queue、stack和vector都是序列概念的模型，所以它们都支持16.7</p><figure><img src="/2024/11/27/cpp-primer-plus/16-string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/1705208675566-1f79eabe-9934-4745-97cb-d6db3315c028.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ul><li><p>a[n]和a.at(n)都返回一个指向容器中第n个元素（从0开始编号）的引用。它们之间的差别在于，如果n落在容器的有效区间外，则a.atn)将执行边界检查，并引发outof range异常。</p></li><li><p>vector</p></li><li><ul><li>vector是数组的一种类表示，它提供了自动内存管理功能，可以动态地改变vector对象的长度，并随着元素的添加和删除而增大和缩小。它提供了对元素的随机访问。在尾部添加和删除元素的时间是固定的，但在头部或中间插入和删除元素的复杂度为线性时间。</li><li>除序列外，vector还是可反转容器(reversiblecontainer)概念的模型。这增加了两个类方法：rbegin()和rend(),前者返回一个指向反转序列的第一个元素的迭代器，后者返回反转序列的超尾迭代器。因此，如果dice是一个vector&lt;-int&gt;容器，而Show(int)是显示一个整数的函数，则下面的代码将首先正向显示dice的内容，然后反向显示：<img src="/2024/11/27/cpp-primer-plus/16-string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/1705209315393-57c5dcf4-8c38-4ee5-84fd-bb1ae7ea4fcc.png" alt="img"></li></ul></li><li><p>deque</p></li><li><ul><li>deque模板类（在deque头文件中声明）表示双端队列(double-endedqueue),通常被简称为deque</li><li>支持随机访问</li><li>主要区别在于，从deque对象的开始位置插入和删除元素的时间是固定的，而不像vector中那样是线性时间的。所以，如果多数操作发生在序列的起始和结尾处，则应考虑使用deque数据结构。</li><li>为实现在deque两端执行插入和删除操作的时间为固定的这一目的，deque对象的设计比vector对象更为复杂。因此，尽管二者都提供对元素的随机访问和在序列中部执行线性时间的插入和删除操作，但vector容器执行这些操作时速度要快些。</li></ul></li><li><p>list</p></li><li><ul><li>list模板类（在list头文件中声明）表示双向链表。除了第一个和最后一个元素外，每个元素都与前后的元素相链接，这意味着可以双向遍历链表。</li><li>list和vector之间关键的区别在于，list在链表中任一位置进行插入和删除的时间都是固定的(vector模板提供了除结尾处外的线性时间的插入和删除，在结尾处，它提供了固定时间的插入和删除)。因此，vector强调的是通过随机访问进行快速访问，而list强调的是元素的快速插入和删除。</li><li>与vector相似，list也是可反转容器。与vector不同的是，list不支持数组表示法和随机访问。</li><li>与矢量迭代器不同，从容器中插入或删除元素之后，链表迭代器指向元素将不变。</li><li><figure><img src="/2024/11/27/cpp-primer-plus/16-string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/1705209697258-a59a4e7d-b9da-4133-913e-add48a4fe6b4.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>(6)forward list (C++11)C+11新增了容器类forwardlist,它实现了单链表。在这种链表中，每个节点都只链接到下一个节点，而没有链接到前一个节点。因此forward_list只需要正向迭代器，而不需要双向迭代器。因此，不同于vector和Iist,forwardlist是不可反转的容器。相比于list,forwardlist更简单、更紧凑，但功能也更少。</li></ul></li><li><p>queue</p></li><li><ul><li><figure><img src="/2024/11/27/cpp-primer-plus/16-string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/1705209922804-0560709f-0556-49ac-b7a7-3eb544b20e96.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ul></li><li><p>priority_queue</p></li><li><ul><li>priority_.queue模板类（在queue头文件中声明）是另一个适配器类，它支持的操作与queue相同。两者之间的主要区别在于，在priority_queue中，最大的元素被移到队首（生活不总是公平的，队列也一样）。内部区别在于，默认的底层类是vector。可以修改用于确定哪个元素放到队首的比较方式，方法是提供一个可选的构造函数参数：</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">priority_queue&lt;<span class="hljs-type">int</span>&gt;pql; <span class="hljs-comment">//default version</span><br>priority_queue&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">pq2</span>(greater&lt;<span class="hljs-type">int</span>&gt;);<span class="hljs-comment">//use greater&lt;int&gt;to order</span><br></code></pre></td></tr></table></figure><ul><li><ul><li>greater&lt;&gt;()函数是一个预定义的函数对象，本章稍后将讨论它。</li></ul></li></ul><figure><img src="/2024/11/27/cpp-primer-plus/16-string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/1705211093927-5efa264b-a429-438e-b60a-01b0e9eac93d.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp-primer-plus/16-string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/1705211113536-711dd3ef-5ef8-441a-b4b6-7a77dde36b53.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++ primer plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15. 友元、异常和其他</title>
    <link href="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/"/>
    <url>/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/</url>
    
    <content type="html"><![CDATA[<h1 id="友元">1. 友元</h1><p>友元类、友元函数、类彼此成为对方的友元</p><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701652038425-6b3580c5-01b2-40b7-8c0d-18f2ec75a74d.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>共同的友元</p><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701652156789-8bebc6c1-69f9-46a5-abef-1fa611a77617.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h1 id="嵌套类">2. 嵌套类</h1><p>在另一个类中声明的类被称为嵌套类，通过提供新的类型类作用域来避免名称混乱。</p><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701652484604-d66d488a-2702-4e61-a034-18bd29e90d88.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>模板中也可以嵌套类</p><h1 id="异常">3. 异常</h1><p>1.调用abort()</p><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701653648121-9ad2ded3-b111-40ae-a746-27b6faf9699c.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701653902872-e7d1710b-7b97-41cf-b552-6623c33cc512.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>2.返回错误码</p><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701653992967-feda3970-39ab-4e91-b246-dfdf3970d696.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701654057563-54566728-38a4-481b-9f07-e9a421fab935.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>3.异常机制</p><p>异常处理三个组成部分</p><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701654351534-86b9a302-3d50-45a7-83cc-6809c69d77eb.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701654393896-9656e0cd-e917-4a7a-a4a6-74afe61a371e.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701654551912-7a8866b2-dcc6-4704-a457-bdef636583e0.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701654586044-aaaabb99-d4ea-4ad1-95dd-1527da3edd57.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701654636747-d175b5f2-91ba-4cf1-8994-d047bc0b0382.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>4.将对象 用作异常类型</p><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701655249812-05e4412e-f3c5-4db0-959f-73f6615abdcd.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701655272475-cddb7272-2d0b-4de9-948d-0f5543fd5779.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701655312497-2005dd8b-7ea1-474d-a614-b83eca775228.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>6.栈解退</p><ul><li>C++通常是如何处理函数调用和返回的。</li><li>C++通常通过将信息放在栈（参见第9章）中来处理函数调用。具体地说，程序将调用函数的指令的地址（返回地址）放到栈中。当被调用的函数执行完毕后，程序将使用该地址来确定从哪里开始继续执行。另外，函数调用将函数参数放到栈中。在栈中，这些函数参数被视为自动变量。如果被调用的函数创建了新的自动变量，则这些变量也将被添加到栈中。如果被调用的函数调用了另一个函数，则后者的信息将被添加到栈中，依此类推。当函数结束时，程序流程将跳到该函数被调用时存储的地址处，同时栈顶的元素被释放。因此，函数通常都返回到调用它的函数，依此类推，同时每个函数都在结束时释放其自动变量。如果自动变量是类对象，则类的析构函数（如果有的话）将被调用。</li><li>现在假设函数由于出现异常（而不是由于返回）而终止，则程序也将释放栈中的内存，但不会在释放栈的第一个返回地址后停止，而是继续释放栈，直到找到一个位于try块（参见图15.3）中的返回地址。随后，控制权将转到块尾的异常处理程序，而不是函数调用后面的第一条语句。这个过程被称为栈解退。引发机制的一个非常重要的特性是，和函数返回一样，对于栈中的自动类对象，类的析构函数将被调用。然而，函数返回仅仅处理该函数放在栈中的对象，而how语句则处理ry块和how之间整个函数调用序列放在栈中的对象。如果没有栈解退这种特性，则引发异常后，对于中间函数调用放在栈中的自动类对象，其析构函数将不会被调用。</li></ul><p>7.其他异常特性</p><p>另一个不同之处是，引发异常时编译器总是创建一个临时拷贝，即使异常规范和catch块中指定的是引用。</p><p>提示：如果有一个异常类继承层次结构，应这样排列catch块：将捕获位于层次结构最下面的异常类的catch语句放在最前面，将捕获基类异常的catch语句放在最后面。</p><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701658754707-6d82379d-0630-4ae2-855a-6fe34812b77a.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701658774575-caf70920-52dd-43c3-9703-1bacdd0a95d6.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>8.exception</p><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701659121698-4e1e4810-0938-42c4-9d29-1a376d8cca41.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>2.bad_alloc异常和new</p><p>对于使用new导致的内存分配问题，C++的最新处理方式是让new引发bad_alloc异常。</p><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701660057723-c7847ca6-c0aa-469a-acb8-2487f0614134.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701660219448-cd965530-879f-4905-a8db-3f9f8f6a33a0.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>9.异常 类 和继承</p><p>异常、类和继承以三种方式相互关联。首先，可以像标准C++库所做的那样，从一个异常类派生出另一个；其次，可以在类定义中嵌套异常类声明来组合异常；第三，这种嵌套声明本身可被继承，还可用作基类。</p><p>异常被引发后，在两种情况下，会导致问题。首先，如果它是在带异常规范的函数中引发的，则必须与规范列表中的某种异常匹配（在继承层次结构中，类类型与这个类及其派生类的对象匹配），否则称为意外异常(unexpectedexception)。在默认情况下，这将导致程序异常终止（虽然C++1I摒弃了异常规范，但仍支持它，且有些现有的代码使用了它)。如果异常不是在函数中引发的（或者函数没有异常规范），则必须捕获它。如果没被捕获（在没有try块或没有匹配的catch块时，将出现这种情况），则异常被称为未捕获异常(uncaughtexception)。在默认情况下，这将导致程序异常终止。然而，可以修改程序对意外异常和未捕获异常的反应。</p><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701663810741-90587ae4-3856-4e9e-89f1-f617947927e5.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h1 id="rtti">4. RTTI</h1><p>RTTI的工作原理：</p><p>C++有3个支持RTTI的元素</p><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701664946350-976ab1e5-01fb-45f3-b60a-973e2887a4d6.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>RTTI只适用于包含虚函数的类。</p><p>1.dynamic_cast</p><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701665233289-1c1d77e2-dc2d-486b-8262-c62bec7065d8.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701665240618-0f0c4622-082f-40c4-9ed8-f6434681238a.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701665483998-cdef3edf-33dc-4b6c-bd2e-ac09e097a7fd.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>2.typeid运算符和type_info类</p><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701665586972-10c66980-f4d3-4a64-90b7-156708853b28.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>typeid运算符返回一个对type_info对象的引用，其中，type_info是在头文件typeinfo(以前为typeinfo.h)中定义的一个类。type_info类重载了==和!=运算符，以便可以使用这些运算符来对类型进行比较。</p><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701665745319-6081452b-2848-42af-9e31-945bf062701d.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701665754030-e11aa1e0-9ae2-4d82-9fda-6ab1068071a7.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701665833085-d55ac7d3-0eaa-4cf9-87fe-f27c0a4e2575.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701671377544-23659e3e-c3d5-457a-bfeb-c5b8d73ed478.jpeg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701672770940-07001a78-fec3-499c-8a37-9660b953dbfd.jpeg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701673105382-bdb2db6a-a820-4eb6-8afe-201d50b3b2e6.jpeg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701673515829-b8a2da70-159a-4e3c-82ea-b9e2f8ef4496.jpeg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701673580240-ee01cf85-99d4-4e1f-975a-7b2ebcf7d606.jpeg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp-primer-plus/15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/1701674855983-c16a8484-70ba-4b01-85ae-2cc9c2d6d54a.jpeg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++ primer plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>14. c++中的代码重用</title>
    <link href="/2024/11/27/cpp-primer-plus/14-c++%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/"/>
    <url>/2024/11/27/cpp-primer-plus/14-c++%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="包含对象成员的类">1. 包含对象成员的类</h1><h2 id="valaray类简介">1.1. valaray类简介</h2><p>使用explicit关闭隐式转换</p><p>valarray类是由头文件valarray支持的。顾名思义，这个类用于处理数值（或具有类似特性的类），它支持诸如将数组中所有元素的值相加以及在数组中找出最大和最小的值等操作。valarray被定义为一个模板类，以便能够处理不同的数据类型。</p><p>valaray类的方法：</p><figure><img src="/2024/11/27/cpp-primer-plus/14-c++%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/1701340012717-9dbd4e9a-9b4c-48fb-bbea-99f428fbbb04.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>C++包含让程序员能够限制程序结构的特性一使用xplicit防止单参数构造函数的隐式转换，使用cost限制方法修改数据，等等。这样做的根本原因是：在编译阶段出现错误优于在运行阶段出现错误。</p><h1 id="私有继承">2. 私有继承</h1><p>C++还有另一种实现has-a关系的途径一私有继承。使用私有继承，基类的公有成员和保护成员都将成为派生类的私有成员。这意味着基类方法将不会成为派生对象公有接口的一部分，但可以在派生类的成员函数中使用它们。</p><p>使用private定义类</p><figure><img src="/2024/11/27/cpp-primer-plus/14-c++%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/1701341897014-9da86e60-cc60-4ad1-9210-e0db6c5ec121.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp-primer-plus/14-c++%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/1701341912559-e93cce0a-5704-4844-990a-478688186694.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>省略了显式对象名称，并在内联构造函数中使用了类名，而不是成员名。</p><p>使用私有继承时，只能在派生类的方法中使用基类的方法。</p><p>私有继承使得能够使用类名和作用域解析运算符来调用基类的方法：</p><figure><img src="/2024/11/27/cpp-primer-plus/14-c++%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/1701355639971-391a53bb-736e-4d49-85ff-1b499d53cc5c.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>访问基类对象：</p><figure><img src="/2024/11/27/cpp-primer-plus/14-c++%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/1701355755898-f272e54f-6367-4e2f-9510-6e05ece54ba2.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>访问基类的友元函数</p><figure><img src="/2024/11/27/cpp-primer-plus/14-c++%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/1701356040815-c2f96944-27bb-4ce1-b363-4925cb46211a.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h2 id="保护继承">2.1. 保护继承</h2><figure><img src="/2024/11/27/cpp-primer-plus/14-c++%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/1701356176036-0d833515-d0a8-492b-8dda-e879e678434a.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>使用保护继承时，基类的公有成员和保护成员都将成为派生类的保护成员。</p><h1 id="多重继承">3. 多重继承</h1><p>正如本章前面讨论的，私有MI和保护MI可以表示has-a关系。</p><figure><img src="/2024/11/27/cpp-primer-plus/14-c++%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/1701393957670-045d0ca4-a14a-4a68-92ac-5eb5894ee40d.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h2 id="section">3.1.</h2><figure><img src="/2024/11/27/cpp-primer-plus/14-c++%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/1701394012510-eb5377de-dcb1-4643-87e4-597beb9c8ef0.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>通常，这种赋值将把基类指针设置为派生对象中的基类对象的地址。但ed中包含两个Worker对象，有两个地址可供选择，所以应使用类型转换来指定对象：</p><figure><img src="/2024/11/27/cpp-primer-plus/14-c++%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/1701394053655-d7d4921c-601c-4bda-9ae0-ecd10ffbf9be.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>这将使得使用基类指针来引用不同的对象（多态性）复杂化。</p><h3 id="虚基类">3.1.1. 虚基类</h3><figure><img src="/2024/11/27/cpp-primer-plus/14-c++%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/1701394131777-a0a144e5-6a30-4724-aeea-ae468df94740.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>现在，SingingWaiter对象将只包含Worker对象的一个副本。从本质上说，继承的Singer和Waiter对象共享一个Worker对象，而不是各自引入自己的Worker对象副本（请参见图l4.5)。因为SingingWaiter现在只包含了一个Worker子对象，所以可以使用多态。</p><figure><img src="/2024/11/27/cpp-primer-plus/14-c++%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/1701394582527-be2778f0-48b6-48e2-8dec-528c2d63d09c.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>C++在基类是虚的时，禁止信息通过中间类自动传递给基类。</p><figure><img src="/2024/11/27/cpp-primer-plus/14-c++%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/1701394696142-822a729b-ea25-4a84-869e-b36b5bc0bfe3.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>警告：如果类有间接虚基类，则除非只需使用该虚基类的默认构造函数，否则必须显式地调用该虚基类的某个构造函数。</p><p>警告：多重继承可能导致函数调用的二义性。</p><ul><li><figure><img src="/2024/11/27/cpp-primer-plus/14-c++%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/1701394786558-9ebf3d89-c5ce-4081-96e8-91fe16781315.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><figure><img src="/2024/11/27/cpp-primer-plus/14-c++%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/1701394810916-f8b28a4b-d933-4e0a-82c1-057d2f0f84c8.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ul><figure><img src="/2024/11/27/cpp-primer-plus/14-c++%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/1701394826074-65c06f6c-e1c7-40bd-9361-17a3874ff41b.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ul><li>对于单继承来说，让派生方法调用基类的方法是可以的。</li><li><figure><img src="/2024/11/27/cpp-primer-plus/14-c++%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/1701395274402-d2a97288-493d-4874-8b92-d94283008313.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><figure><img src="/2024/11/27/cpp-primer-plus/14-c++%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/1701395288695-1b4de580-a606-48b0-b79e-b0211a09935d.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><figure><img src="/2024/11/27/cpp-primer-plus/14-c++%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/1701395302173-0899a128-2a00-4aa8-a543-98c545406b8b.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>那么，一个成员名如何优先于另一个成员名呢？派生类中的名称优先于直接或间接祖先类中的相同名称。例如，在下面的定义中：</li><li><figure><img src="/2024/11/27/cpp-primer-plus/14-c++%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/1701395804138-d6dcc528-0f8f-4284-a23d-be596f00c3f4.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ul><h1 id="类模板">4. 类模板</h1><p>首先介绍一个允许指定数组大小的简单数组模板。一种方法是在类中使用动态数组和构造函数参数来提供元素数目。</p><p>另一种方法是使用模板参数来提供常规数组的大小，C++11新增的模板array就是这样做的。</p><figure><img src="/2024/11/27/cpp-primer-plus/14-c++%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/1701483644369-e99b152f-7ebb-48be-9364-89c382154ba9.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>表达式参数方法的主要缺点是，每种数组大小都将生成自己的模板。也就是说，下面的声明将生成两个独立的类声明：</p><figure><img src="/2024/11/27/cpp-primer-plus/14-c++%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/1701483726710-80c06006-54e7-4bee-82c2-7d5b998be797.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp-primer-plus/14-c++%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/1701486177154-09f1a231-1f07-402b-8d2a-25eafa722025.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++ primer plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>13. 类继承</title>
    <link href="/2024/11/27/cpp-primer-plus/13-%E7%B1%BB%E7%BB%A7%E6%89%BF/"/>
    <url>/2024/11/27/cpp-primer-plus/13-%E7%B1%BB%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="继承-is-a关系">13.2 继承： is-a关系</h1><p>c++三种继承方式：</p><ul><li><p>公有继承</p></li><li><ul><li>建立一种is-a关系，即派生类对象也是一个基类对象，可以对基类对象执行的任何操作，也可以对派生类对象执行</li></ul></li><li><p>保护继承</p></li><li><p>私有继承</p></li></ul><h1 id="多态公有继承">13.3 多态公有继承</h1><ul><li>在派生类中重新定义基类的方法。</li><li>使用虚方法，使用关键词virtual</li><li>基类声明了一个虚析构函数，为了确保释放派生对象时，按正确的顺序调用析构函数，</li><li>关键字virtual只用于类声明的方法原型中</li><li>派生类并不能直接访问基类的私有数据，而必须使用基类的公有方法才能访问这些数据</li><li>派生类构造函数在初始化基类私有数据时，采用的是成员初始化列表语法</li><li></li></ul><figure><img src="/2024/11/27/cpp-primer-plus/13-%E7%B1%BB%E7%BB%A7%E6%89%BF/1701183381268-2d61ed7f-133d-4eb7-95f1-ff7322d5f722.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>编译器对虚方法使用动态联编。</p><p>通常，编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为虚函数表(virtualfunctiontable,vtbl)。虚函数表中存储了为类对象进行声明的虚函数的地址。例如，基类对象包含一个指针，该指针指向基类中所有虚函数的地址表。派生类对象将包含一个指向独立地址表的指针。如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址：如果派生类没有重新定义虚函数，该b1将保存函数原始版本的地址。如果派生类定义了新的虚函数，则该函数的地址也将被添加到vb中（参见图13.5）。注意，无论类中包含的虚函数是1个还是10个，都只需要在对象中添加1个地址成员，只是表的大小不同而已。</p><p>调用虚函数时，程序将查看存储在对象中的vbl地址，然后转向相应的函数地址表。如果使用类声明中定义的第一个虚函数，则程序将使用数组中的第一个函数地址，并执行具有该地址的函数。如果使用类声明中的第三个虚函数，程序将使用地址为数组中第三个元素的函数。</p><ul><li>每个对象都将增大，增大量为存储地址的空间：</li><li>对于每个类，编译器都创建一个虚函数地址表（数组）：</li><li>对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址。</li></ul><p>通常应给基类提供一个虚析构函数，即使它并不需要析构函数。</p><p>友元不能是虚函数，因为友元不是类成员，而只有成员才能是虚函数</p><p>这引出了两条经验规则：第一，如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针（这种例外是新出现的）。这种特性被称为返回类型协变(covarianceof return type),因为允许返回类型随类类型的变化而变化：</p><h1 id="访问控制-protected">访问控制 protected</h1><p>访问类别，这种类别用关键字protected表示。关键字protected与private相似，在类外只能用公有类成员来访问protected部分中的类成员。private和protected之间的区别只有在基类派生的类中才会表现出来。派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员。因此，对于外部世界来说，保护成员的行为与私有成员相似：但对于派生类来说，保护成员的行为与公有成员相似。</p><h1 id="抽象基类">13.6 抽象基类</h1><p>c++通过使用纯虚函数提供未实现的函数。纯虚函数声明的结尾处为=0，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>：<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">Area</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当类声明中包含纯虚函数时，则不能创建该类的对象。这里的理念是，包含纯虚函数的类只用作基类。要成为真正的ABC,必须至少包含一个纯虚函数。原型中的-0使虚函数成为纯虚函数。这里的方法Area()没有定义，但C++甚至允许纯虚函数有定义。例如，也许所有的基类方法都与Move()一样，可以在基类中进行定义</p><p><img src="/2024/11/27/cpp-primer-plus/13-%E7%B1%BB%E7%BB%A7%E6%89%BF/1701269513479-c5caec0c-9b39-4caa-9373-34b44fe66298.png" alt="img"><img src="/2024/11/27/cpp-primer-plus/13-%E7%B1%BB%E7%BB%A7%E6%89%BF/1701269524547-7e620aa5-cfe1-43ed-aded-04abb98dad80.png" alt="img"></p><p>在原型中使用=0指出类是一个抽象基类，在类中可以不定义该函数。</p><h1 id="继承和动态内存分配">13.7 继承和动态内存分配</h1><p>基类使用动态内存分配，并重新定义赋值和复制构造函数，这将怎样影响派生类的实现呢？</p><h2 id="第一种情况派生类不使用new">第一种情况：派生类不使用new</h2><p>不需要定义显式析构函数、复制构造函数和赋值运算符</p><h2 id="第二种情况派生类使用new">第二种情况：派生类使用new</h2><figure><img src="/2024/11/27/cpp-primer-plus/13-%E7%B1%BB%E7%BB%A7%E6%89%BF/1701319292824-66335428-b471-46db-908c-75597df0ea6c.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>必须为派生类定义显式析构函数、复制构造函数和赋值运算符</p><figure><img src="/2024/11/27/cpp-primer-plus/13-%E7%B1%BB%E7%BB%A7%E6%89%BF/1701319430467-52ff3857-4072-4eed-a401-14783bb34ca1.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>复制构造函数</p><p><img src="/2024/11/27/cpp-primer-plus/13-%E7%B1%BB%E7%BB%A7%E6%89%BF/1701319458634-09c80093-1504-4f1a-a04a-4a91072485f1.png" alt="img"><img src="/2024/11/27/cpp-primer-plus/13-%E7%B1%BB%E7%BB%A7%E6%89%BF/1701319830214-390d0184-573f-48c7-b4e4-c7d6823e5126.png" alt="img"></p><p>hasDMA复制构造函数只能访问hasDMA的数据，因此它必须调用baseDMA复制构造函数来处理共享的baseDMA数据</p><p>对于赋值运算符，这是通过使用作用域解析运算符显式地调用基类的赋值运算符来完成的。</p><figure><img src="/2024/11/27/cpp-primer-plus/13-%E7%B1%BB%E7%BB%A7%E6%89%BF/1701320748605-98ca0f0e-c0b3-4437-ad62-64bca146cb2a.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>作为hasDMA类的友元，该函数能够访问style成员。然而，还存在一个问题：该函数如不是baseDMA类的友元，那它如何访问成员lable和rating呢？答案是使用baseDMA类的友元函数operator&lt;&lt;()。下一个问题是，因为友元不是成员函数，所以不能使用作用域解析运算符来指出要使用哪个函数。这个问题的解决方法是使用强制类型转换，以便匹配原型时能够选择正确的函数。因此，代码将参数consthasDMA&amp;转换成类型为const baseDMA&amp;的参数：</p><figure><img src="/2024/11/27/cpp-primer-plus/13-%E7%B1%BB%E7%BB%A7%E6%89%BF/1701329791687-f9f70575-9de4-4228-a82d-d067fb848961.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h1 id="类设计回顾">13.8 类设计回顾</h1><h2 id="默认构造函数">1. 默认构造函数</h2><figure><img src="/2024/11/27/cpp-primer-plus/13-%E7%B1%BB%E7%BB%A7%E6%89%BF/1701329856574-97eefade-7e81-422a-8946-f769b1679098.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h2 id="复制构造函数">2. 复制构造函数</h2><figure><img src="/2024/11/27/cpp-primer-plus/13-%E7%B1%BB%E7%BB%A7%E6%89%BF/1701329922671-5d27dc33-02ac-4df8-8a67-058678126be7.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h2 id="赋值运算符">3. 赋值运算符</h2><figure><img src="/2024/11/27/cpp-primer-plus/13-%E7%B1%BB%E7%BB%A7%E6%89%BF/1701329953768-e783af56-3a91-4a75-8298-f321e7bf9559.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp-primer-plus/13-%E7%B1%BB%E7%BB%A7%E6%89%BF/1701330123966-bc56e263-173c-4ec9-ae5d-ee64e863942d.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h2 id="构造函数不能被继承">4. 构造函数不能被继承</h2><p>构造函数是不能继承的，也就是说，创建派生类对象时，必须调用派生类的构造函数。然而，派生类构造函数通常使用成员初始化列表语法来调用基类构造函数，以创建派生对象的基类部分。如果派生类构造函数没有使用成员初始化列表语法显式调用基类构造函数，将使用基类的默认构造函数。在继承链中，每个类都可以使用成员初始化列表将信息传递给相邻的基类。C++11新增了一种让您能够继承构造函数的机制，但默认仍不继承构造函数。</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++ primer plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11. 使用类</title>
    <link href="/2024/11/27/cpp-primer-plus/11-%E4%BD%BF%E7%94%A8%E7%B1%BB/"/>
    <url>/2024/11/27/cpp-primer-plus/11-%E4%BD%BF%E7%94%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="运算符重载">运算符重载</h1><figure><img src="/2024/11/27/cpp-primer-plus/11-%E4%BD%BF%E7%94%A8%E7%B1%BB/1700962579971-a26a2ed3-3113-49ea-a636-feec3c6024ae.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++ primer plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10. 对象和类</title>
    <link href="/2024/11/27/cpp-primer-plus/10-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/"/>
    <url>/2024/11/27/cpp-primer-plus/10-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="类的构造函数和析构函数">类的构造函数和析构函数</h1><ul><li>类的数据成员名使用m_前缀或者_后缀</li></ul><h2 id="const成员函数">const成员函数</h2><p>​我们知道，在C++中，若一个变量声明为const类型，则试图修改该变量的值的操作都被视编译错误。例如，</p><p>const char blank = ‘’;</p><p>blank = ‘’; // 错误</p><p>​面向对象程序设计中，为了体现封装性，通常不允许直接修改类对象的数据成员。若要修改类对象，应调用公有成员函数来完成。为了保证const对象的常量性，编译器须区分不安全与安全的成员函数（即区分试图修改类对象与不修改类对象的函数）。例如，</p><p>const Screen blankScreen;</p><p>blankScreen.display(); // 对象的读操作</p><p>blankScreen.set(‘*’); // 错误：const类对象不允许修改</p><p>​<strong>在C++中，只有被声明为const的成员函数才能被一个const类对象调用。</strong></p><p>​要声明一个const类型的类成员函数，只需要在成员函数参数列表后加上关键字const，例如，</p><p>class Screen {</p><p>public:</p><p>char get() const;</p><p>};</p><p>​ 在类体之外定义const成员函数时，还必须加上const关键字，例如</p><p>char Screen::get() const {</p><p>return _screen[_cursor];</p><p>}</p><p>​若将成员成员函数声明为const，则该函数不允许修改类的数据成员。例如，</p><p>class Screen {</p><p>public:</p><p>​ int ok() const {return _cursor; }</p><p>​ int error(intival) const { _cursor = ival; }</p><p>};</p><p>​在上面成员函数的定义中，ok()的定义是合法的，error()的定义则非法。</p><p>​值得注意的是，把一个成员函数声明为const可以保证这个成员函数不修改数据成员，但是，如果据成员是指针，则const成员函数并不能保证不修改指针指向的对象，编译器不会把这种修改检测为错误。例如，</p><p>class Name {</p><p>public:</p><p>​ void setName(const string &amp;s) const;</p><p>private:</p><p>​ char *m_sName;</p><p>};</p><p>void setName(const string &amp;s) const {</p><p>​ m_sName = s.c_str(); // 错误！不能修改m_sName;</p><p>​ for (int i = 0; i &lt; s.size(); ++i)</p><p>​ m_sName[i] = s[i]; // 不好的风格，但不是错误的</p><p>}</p><p>​ 虽然 m_Name 不能被修改，但 m_sName 是 char * 类型，const成员函数可以修改其所指向的字符。</p><p>​ const成员函数可以被具有相同参数列表的非const成员函数重载，例如，</p><p>class Screen {</p><p>public:</p><p>​ char get(int x,int y);</p><p>​ char get(int x,int y) const;</p><p>};</p><p>​ 在这种情况下，类对象的常量性决定调用哪个函数。</p><p>const Screen cs;</p><p>Screen cc2;</p><p>char ch = cs.get(0, 0); // 调用const成员函数</p><p>ch = cs2.get(0, 0); // 调用非const成员函数</p><p>小结：</p><p>1）const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员；</p><p>2）非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；</p><p>3）作为一种良好的编程风格，在声明一个成员函数时，若该成员函数并不对数据成员进行修改操作，应尽可能将该成员函数声明为const成员函数。</p><p>6.const成员函数</p><p>请看下面的代码片段：</p><p>const Stock land Stock ("Kludgehorn Properties");</p><p>land.show ()</p><figure><img src="/2024/11/27/cpp-primer-plus/10-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/1700925148186-07194aeb-0419-4a48-9e67-68cf6ff2ef13.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h1 id="this指针">this指针</h1><h1 id="动态内存">动态内存</h1><p>静态成员初始化</p><figure><img src="/2024/11/27/cpp-primer-plus/10-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/1700983611829-0e3f9ed4-38bf-4f9a-ade7-d0239c7dd470.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>这条语句将静态成员num_strings的值初始化为零。请注意，不能在类声明中初始化静态成员变量，这是因为声明描述了如何分配内存，但并不分配内存。您可以使用这种格式来创建对象，从而分配和初始化内存。对于静态类成员，可以在类声明之外使用单独的语句来进行初始化，这是因为静态类成员是单独存储的，而不是对象的组成部分。请注意，初始化语句指出了类型，并使用了作用域运算符，但没有使用关键字static。</p><p>拷贝构造函数使用深拷贝，可以避免浅拷贝带来的两次析构函数释放同一块空间的问题</p><figure><img src="/2024/11/27/cpp-primer-plus/10-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/1700985928732-dc6ffb52-4470-4ac2-a556-91a197cf3039.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++ primer plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9. 内存模型和名称空间</title>
    <link href="/2024/11/27/cpp-primer-plus/9-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4/"/>
    <url>/2024/11/27/cpp-primer-plus/9-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h3 id="存储特续性作用域和链接性">1. 存储特续性、作用域和链接性</h3><p>cin()是面向单词的输入，即使用空白（空格、制表符和换行符）来确定结束为止，将其传递给接收的变量或数组，空白之后输入的字符仍留在输入队列中，下次读取输入时，继续读取。</p><p>cin.getLine(name,ArSize)是面向行的输入，该函数每次读取一行，它通过换行符来确定行尾，但不保存换行符。相反，在存储字符串时，它用空字符替换换行符。</p><p>cin.get(name,ArSize)也是面向行的输入，该函数不是丢弃换行符，而是将其留在输入队列中。</p><p>cin.get()读取一个字符（即使是换行符），常用来处理换行符，为读取下一行输入做好准备。</p><p>cin.get(ch)读取一个字符（即使是换行符），并赋值给char类型的ch</p><p>方法cin.get(input,.ArSize)将一直读取输入，直到到达行尾或读取了ArSize-1个字符为止。它把换行符留在输入队列中。该程序使用cin.get(next)读取行输入后的字符。如果next是换行符，则说明cin.get(input,.ArSize)读取了整行；否则说明行中还有字符没有被读取。随后，程序使用一个循环来丢弃余下的字符，不过读者可以修改代码，让下一轮输入读取行中余下的字符。该程序还利用了这样一个事实，即试图使用get(char*,int)读取空行将导致cin为false。</p><h4 id="a.-定位new运算符">a. 定位new运算符</h4><figure><img src="/2024/11/27/cpp-primer-plus/9-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4/1700793978076-e7b5b3db-2d13-4757-adc1-27eec3991231.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp-primer-plus/9-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4/1700794001601-e27287ae-a0d2-4e91-b39e-10015593765a.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h3 id="命名空间">2. 命名空间</h3><p>using声明和using编译</p><p>using 声明和 using编译指令是C++中用于简化命名空间和类型使用的关键字。虽然它们在功能上有些相似，但在使用方式和作用范围上有所不同。</p><ol type="1"><li>using 声明： using声明用于引入特定的命名空间、类型或成员到当前的作用域中，以便可以直接使用它们，而无需使用完全限定的名称。它的语法如下：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> namespace_name;<br><span class="hljs-keyword">using</span> type = type_name;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>::member;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;        <span class="hljs-comment">// 引入命名空间std中的cout</span><br><span class="hljs-keyword">using</span> std::endl;        <span class="hljs-comment">// 引入命名空间std中的endl</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Hello, world!&quot;</span> &lt;&lt; endl;  <span class="hljs-comment">// 直接使用cout和endl，而无需使用std::cout和std::endl</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中，通过使用 using std::cout 和 using std::endl声明，我们可以直接在 main 函数中使用 cout 和 endl，而无需写成 std::cout和 std::endl。</p><p>需要注意的是，使用 using声明会将特定的命名空间、类型或成员引入到当前作用域，可能会引入命名冲突的风险。因此，最好将using 声明放在函数内部或尽可能小的作用域中，以减少潜在的冲突。</p><ol type="1"><li>using 编译指令： using编译指令用于在源文件的顶部引入整个命名空间或命名空间中的特定部分，以便在整个源文件中直接使用它们。它的语法如下：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> namespace_name;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <span class="hljs-comment">// 引入整个命名空间std</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Hello, world!&quot;</span> &lt;&lt; endl;  <span class="hljs-comment">// 直接使用cout和endl，而无需使用std::cout和std::endl</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中，通过使用 using namespacestd，我们可以在整个源文件中直接使用 std 命名空间中的成员，而无需写成std::cout 和 std::endl。</p><p>使用 using编译指令可以简化代码，但可能会引入命名冲突的风险。因此，最好在源文件的顶部使用using 编译指令，并避免在头文件中使用，以减少潜在的冲突。</p><p>总结：</p><ul><li>using 声明用于在当前作用域内引入特定的命名空间、类型或成员。</li><li>using编译指令用于在整个源文件中引入整个命名空间或命名空间的特定部分。</li></ul>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++ primer plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8. 函数探幽</title>
    <link href="/2024/11/27/cpp-primer-plus/8-%E5%87%BD%E6%95%B0%E6%8E%A2%E5%B9%BD/"/>
    <url>/2024/11/27/cpp-primer-plus/8-%E5%87%BD%E6%95%B0%E6%8E%A2%E5%B9%BD/</url>
    
    <content type="html"><![CDATA[<h3 id="函数模板">函数模板</h3><p>隐式实例化、显式实例化和显式具体化统称为具体化(specialization)。它们的相同之处在于，它们表示的都是使用具体类型的函数定义，而不是通用描述。</p><p>引入显式实例化后，必须使用新的语法一在声明中使用前缀template和template&lt;&gt;，以区分显式实例化和显式具体化。通常，功能越多，语法规则也越多。下面的代码片段总结了这些概念：</p><figure><img src="/2024/11/27/cpp-primer-plus/8-%E5%87%BD%E6%95%B0%E6%8E%A2%E5%B9%BD/1700728752975-1c0b50d7-eaa5-47c3-81b4-054678d5c974.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>然而，有时候，即使两个函数都完全匹配，仍可完成重载解析。首先，指向非cost数据的指针和引用优先与非const指针和引用参数匹配。也就是说，在recycle()示例中，如果只定义了函数#3和#4是完全匹配的，则将选择#3，因为ink没有被声明为const。.然而，<strong>const和非const之间的区别只适用于指针和引用指向的数据</strong>。也就是说，如果只定义了#1和#2，则将出现二义性错误。</p><figure><img src="/2024/11/27/cpp-primer-plus/8-%E5%87%BD%E6%95%B0%E6%8E%A2%E5%B9%BD/1700728959606-664ee444-dc04-4490-b435-cf2d3398c1d9.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>简而言之，重载解析将寻找最匹配的函数。如果只存在一个这样的函数，则选择它：如果存在多个这样的函数，但其中只有一个是非模板函数，则选择该函数：如果存在多个适合的函数，且它们都为模板函数，但其中有一个函数比其他函数更具体，则选择该函数。如果有多个同样合适的非模板函数或模板函数，但没有一个函数比其他函数更具体，则函数调用将是不确定的，因此是错误的：当然，如果不存在匹配的函数，则也是错误</p><p>2.关键字decltype（C++11)</p><p>C++11新增的关键字decltype提供了解决方案。可这样使用该关键字：</p><p>int x;</p><p>decltype(x) y;//make y the same type as x</p><p>C++新增了一种声明和定义函数的语法。下面使用内置类型来说明这种语法的工作原理。对于下面的原型：</p><figure><img src="/2024/11/27/cpp-primer-plus/8-%E5%87%BD%E6%95%B0%E6%8E%A2%E5%B9%BD/1700729320278-cb9a82c9-8af3-410f-969c-1e6b746bd889.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp-primer-plus/8-%E5%87%BD%E6%95%B0%E6%8E%A2%E5%B9%BD/1700729537363-6a891f7e-395c-4520-af3f-65176552d94e.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++ primer plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15. STL-常用算法</title>
    <link href="/2024/11/27/cpp/15-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    <url>/2024/11/27/cpp/15-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<figure><img src="/2024/11/27/cpp/15-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/1694939256088-7fd06b10-4c80-47f2-8f99-2ff0768f66c0.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h1 id="常用遍历算法">5.1 常用遍历算法</h1><figure><img src="/2024/11/27/cpp/15-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/1694940009822-2094aed7-581d-417e-905a-f8eaac0a91be.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h3 id="for_each">for_each</h3><p>for_each(iterator beg, iterator end,_func)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print01</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">print02</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br><br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), print01);<br>    cout &lt;&lt; endl;<br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">print02</span>());<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="transform">transform</h3><figure><img src="/2024/11/27/cpp/15-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/1694941538977-391c217d-b02b-4834-a06c-2f0398287e8d.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>搬运要提前开辟空间，否则无法搬运</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TransForm</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> v;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt; t;<br>    t.<span class="hljs-built_in">resize</span>(v.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-built_in">transform</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), t.<span class="hljs-built_in">begin</span>(),<span class="hljs-built_in">TransForm</span>());<br>    for_each(t.<span class="hljs-built_in">begin</span>(), t.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">print02</span>());<br>&#125;<br></code></pre></td></tr></table></figure><figure><img src="/2024/11/27/cpp/15-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/1705215111397-cd778a02-609a-4d93-aaa2-8653f4fa0dcb.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h1 id="常用查找算法">5.2 常用查找算法</h1><figure><img src="/2024/11/27/cpp/15-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/1694942632647-8828ac65-1e96-4cc2-bfe7-3959e1429d08.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h2 id="find">5.2.1 find</h2><figure><img src="/2024/11/27/cpp/15-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/1694942650730-6c3860d3-acba-491b-a9bf-65bba7badbcd.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = <span class="hljs-built_in">find</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">if</span> (it == v.<span class="hljs-built_in">end</span>())<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;don&#x27;t&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; *it &lt;&lt; endl;<br>    &#125;<br><br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">print02</span>());<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(string mn, <span class="hljs-type">int</span> ma) :<span class="hljs-built_in">name</span>(mn), <span class="hljs-built_in">age</span>(ma) &#123;&#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Person&amp;p)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;name == p.name &amp;&amp; <span class="hljs-keyword">this</span>-&gt;age ==p.age)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    string name;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test04</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;Person&gt; v;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">30</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-number">40</span>)</span></span>;<br><br>    v.<span class="hljs-built_in">push_back</span>(p1);<br>    v.<span class="hljs-built_in">push_back</span>(p2);<br>    v.<span class="hljs-built_in">push_back</span>(p3);<br>    v.<span class="hljs-built_in">push_back</span>(p4);<br><br><br>    <span class="hljs-function">Person <span class="hljs-title">pp</span><span class="hljs-params">(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">20</span>)</span></span>;<br>    vector&lt;Person&gt;::iterator it = <span class="hljs-built_in">find</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), pp);<br>    <span class="hljs-keyword">if</span> (it == v.<span class="hljs-built_in">end</span>())<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;no&quot;</span> &lt;&lt; endl;<br><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; it-&gt;age &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; it-&gt;name &lt;&lt; endl;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="find_if">5.2.2 find_if</h2><figure><img src="/2024/11/27/cpp/15-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/1694945738368-284ba7b2-f63d-4f4d-a5e0-f23a05c5167e.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GreaterFive</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> val &gt; <span class="hljs-number">5</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test06</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = <span class="hljs-built_in">find_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">GreaterFive</span>());<br>    <span class="hljs-keyword">if</span> (it == v.<span class="hljs-built_in">end</span>())<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;don&#x27;t&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; *it &lt;&lt; endl;<br>    &#125;<br><br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">print02</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="adjacant_find">5.2.3 adjacant_find</h2><figure><img src="/2024/11/27/cpp/15-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/1694946132430-1ec3fb82-9699-43a7-8f81-4b7aef1b2af3.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test07</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">9</span>);<br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = <span class="hljs-built_in">adjacent_find</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">if</span> (it == v.<span class="hljs-built_in">end</span>())<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;don&#x27;t&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; *it &lt;&lt; endl;<br>    &#125;<br><br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">print02</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="binary_search">5.2.4 binary_search</h2><figure><img src="/2024/11/27/cpp/15-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/1694946447252-a8fb155e-1bd8-4206-81f8-925b80d39e32.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test08</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-built_in">binary_search</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(),<span class="hljs-number">9</span>) &lt;&lt; endl;<br><br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">print02</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="count">5.2.5 count</h2><figure><img src="/2024/11/27/cpp/15-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/1694946671737-6bf5d32d-6b5e-4115-9806-2283c95fb5af.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>要重载 ==</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person2</span>(string mn, <span class="hljs-type">int</span> ma) :<span class="hljs-built_in">name</span>(mn), <span class="hljs-built_in">age</span>(ma) &#123;&#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Person2&amp; p)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;age == p.age)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    string name;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test10</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;Person2&gt; v;<br>    <span class="hljs-function">Person2 <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;zhang&quot;</span>, <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(p);<br>    &#125;<br>    <span class="hljs-function">Person2 <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;zhang&quot;</span>, <span class="hljs-number">10</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-built_in">count</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), p2) &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h2 id="count_if">5.2.6 count_if</h2><figure><img src="/2024/11/27/cpp/15-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/1694947113573-77a029f4-4f6e-4ede-b467-504a4cc387d2.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test11</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-built_in">count_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">GreaterFive</span>()) &lt;&lt; endl;<br><br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">print02</span>());<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person3</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person3</span>(string mn, <span class="hljs-type">int</span> ma) :<span class="hljs-built_in">name</span>(mn), <span class="hljs-built_in">age</span>(ma) &#123;&#125;<br><br>    <br>    string name;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Less20</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Person3&amp; p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (p.age &lt; <span class="hljs-number">20</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test12</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;Person3&gt; v;<br>    <span class="hljs-function">Person3 <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;zhang&quot;</span>, <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(p);<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-built_in">count_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">Less20</span>()) &lt;&lt; endl;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="常用排序算法">5.3 常用排序算法</h1><figure><img src="/2024/11/27/cpp/15-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/1694947701901-76413d91-c9e8-488a-8eae-a56c34320be0.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h2 id="sort">5.3.1 sort</h2><figure><img src="/2024/11/27/cpp/15-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/1694947746132-940e811e-c946-45d3-916e-65848ec3a794.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test13</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-2</span>);<br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">print02</span>());<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">print02</span>());<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">print02</span>());<br>    cout &lt;&lt; endl;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="random_shuffle">5.3.2 random_shuffle</h2><figure><img src="/2024/11/27/cpp/15-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/1694947999166-682e455f-0805-4e77-aea5-3b154f8a8730.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test14</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-2</span>);<br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">print02</span>());<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-built_in">random_shuffle</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">print02</span>());<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="merge">5.3.3 merge</h2><figure><img src="/2024/11/27/cpp/15-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/1694948175848-2774a8f8-d9f9-4af9-a455-1bfde57ca077.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test15</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    vector&lt;<span class="hljs-type">int</span>&gt; t;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vt;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        t.<span class="hljs-built_in">push_back</span>(i<span class="hljs-number">+1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 提前分配空间</span><br>    vt.<span class="hljs-built_in">resize</span>(v.<span class="hljs-built_in">size</span>() + t.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-built_in">merge</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), t.<span class="hljs-built_in">begin</span>(), t.<span class="hljs-built_in">end</span>(), vt.<span class="hljs-built_in">begin</span>());<br>    for_each(vt.<span class="hljs-built_in">begin</span>(), vt.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">print02</span>());<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="reverse">5.3.4 reverse</h2><figure><img src="/2024/11/27/cpp/15-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/1694948443173-359ba46f-6630-4703-a542-3ea71d1a8c90.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test16</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 提前分配空间</span><br>    <span class="hljs-built_in">reverse</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">print02</span>());<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="常用拷贝和替换算法">5.4 常用拷贝和替换算法</h1><figure><img src="/2024/11/27/cpp/15-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/1694948590202-f988505f-1701-402b-baea-d55903a4fa5a.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h2 id="copy">5.4.1 copy</h2><figure><img src="/2024/11/27/cpp/15-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/1694948644179-6bea1a31-929d-444f-b59a-573274995b0b.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test17</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    vector&lt;<span class="hljs-type">int</span>&gt; t;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br><br>    <span class="hljs-comment">// 提前分配空间</span><br>    t.<span class="hljs-built_in">resize</span>(v.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-built_in">copy</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(),t.<span class="hljs-built_in">begin</span>());<br>    for_each(t.<span class="hljs-built_in">begin</span>(), t.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">print02</span>());<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="replace">5.4.2 replace</h2><figure><img src="/2024/11/27/cpp/15-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/1694953212642-94d05f03-f76a-4753-b3dd-59004c913a5e.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test18</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br><br>    <span class="hljs-built_in">replace</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">9</span>,<span class="hljs-number">10</span>);<br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">print02</span>());<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="replace_if">5.4.3 replace_if</h2><figure><img src="/2024/11/27/cpp/15-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/1694953370368-eba86a10-7599-4441-ad75-fb8e9763b50d.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test18</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br><br>    <span class="hljs-comment">// 提前分配空间</span><br><br>    <span class="hljs-built_in">replace_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">GreaterFive</span>(), <span class="hljs-number">10</span>);<br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">print02</span>());<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="swap">5.4.4 swap</h2><figure><img src="/2024/11/27/cpp/15-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/1694953540770-7c5c3738-457c-42c7-bb5a-49289deffd85.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test20</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    vector&lt;<span class="hljs-type">int</span>&gt; t;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        t.<span class="hljs-built_in">push_back</span>(i*<span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-comment">// 提前分配空间</span><br>    <span class="hljs-built_in">swap</span>(v, t);<br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">print02</span>());<br>    cout &lt;&lt; endl;<br>    for_each(t.<span class="hljs-built_in">begin</span>(), t.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">print02</span>());<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="常用算术生成算法">5.5 常用算术生成算法</h1><figure><img src="/2024/11/27/cpp/15-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/1694953750614-fdd76d87-89e1-4e96-9e23-1d3d693509c5.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h2 id="accumulate">5.5.1accumulate</h2><figure><img src="/2024/11/27/cpp/15-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/1694953814721-a3f170a6-f421-4751-a7dc-a8290ba4c7a6.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test21</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-type">int</span> total  = <span class="hljs-built_in">accumulate</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">print02</span>());<br>    cout &lt;&lt; endl;<br>    cout &lt;&lt; total &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="fill">5.5.2 fill</h2><figure><img src="/2024/11/27/cpp/15-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/1694953997039-30862e12-00b3-4c28-b14a-998926eca1a9.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test22</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-built_in">fill</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">20</span>);<br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">print02</span>());<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="常用集合算法">5.6常用集合算法</h1><figure><img src="/2024/11/27/cpp/15-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/1694954110501-3525b07c-8ed1-4db8-8d38-4d228e55ab50.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h2 id="set-intersection">5.6.1 set intersection</h2><figure><img src="/2024/11/27/cpp/15-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/1694954143467-97b162b4-23c5-45a3-a471-6695a7a5df23.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>返回值为交集最后一个元素的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test23</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    vector&lt;<span class="hljs-type">int</span>&gt; t;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vt;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        t.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">5</span>);<br>    &#125;<br>    vt.<span class="hljs-built_in">resize</span>(<span class="hljs-built_in">min</span>(v.<span class="hljs-built_in">size</span>(), t.<span class="hljs-built_in">size</span>()));<br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator it =  <span class="hljs-built_in">set_intersection</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), t.<span class="hljs-built_in">begin</span>(), t.<span class="hljs-built_in">end</span>(), vt.<span class="hljs-built_in">begin</span>());<br>    for_each(vt.<span class="hljs-built_in">begin</span>(), it, <span class="hljs-built_in">print02</span>());<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="set_union">5.6.2 set_union</h2><figure><img src="/2024/11/27/cpp/15-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/1694954768660-9efa1125-bcaa-4ffd-82cf-de6be4ef0b13.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test24</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    vector&lt;<span class="hljs-type">int</span>&gt; t;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vt;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        t.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">5</span>);<br>    &#125;<br>    vt.<span class="hljs-built_in">resize</span>((v.<span class="hljs-built_in">size</span>()+t.<span class="hljs-built_in">size</span>()));<br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = <span class="hljs-built_in">set_union</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), t.<span class="hljs-built_in">begin</span>(), t.<span class="hljs-built_in">end</span>(), vt.<span class="hljs-built_in">begin</span>());<br>    for_each(vt.<span class="hljs-built_in">begin</span>(), it, <span class="hljs-built_in">print02</span>());<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="set_diffrence">5.6.3 set_diffrence</h2><figure><img src="/2024/11/27/cpp/15-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/1694954804343-9422e286-f3c8-44cb-a2a9-578eb28bf545.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test25</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    vector&lt;<span class="hljs-type">int</span>&gt; t;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vt;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        t.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">5</span>);<br>    &#125;<br>    vt.<span class="hljs-built_in">resize</span>(<span class="hljs-built_in">max</span>(v.<span class="hljs-built_in">size</span>() , t.<span class="hljs-built_in">size</span>()));<br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = <span class="hljs-built_in">set_difference</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), t.<span class="hljs-built_in">begin</span>(), t.<span class="hljs-built_in">end</span>(), vt.<span class="hljs-built_in">begin</span>());<br>    for_each(vt.<span class="hljs-built_in">begin</span>(), it, <span class="hljs-built_in">print02</span>());<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++ 黑马</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>14. STL 函数对象</title>
    <link href="/2024/11/27/cpp/14-STL%20%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/"/>
    <url>/2024/11/27/cpp/14-STL%20%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="函数对象">4.1 函数对象</h1><p>概念：</p><p>重载函数调用操作符的类，其对象常称为函数对象</p><p>函数对象使用重载的(0时，行为类似函数调用，也叫仿函数</p><p>本质：</p><p>函数对象（仿函数）是一个类，不是一个函数</p><h2 id="函数对象使用">4.1.1 函数对象使用</h2><p>特点：</p><p>函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值</p><p>函数对象超出普通函数的概念，函数对象可以有自己的状态</p><p>函数对象可以作为参数传递</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdd</span><br>&#123;<br><span class="hljs-keyword">public</span> :<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPrint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyPrint</span>():<span class="hljs-built_in">count</span>(<span class="hljs-number">0</span>) &#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(string test)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; test &lt;&lt; endl;<br>        count++;<br>    &#125;<br>    <span class="hljs-type">int</span> count;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doPrint</span><span class="hljs-params">(MyPrint&amp; mp, string test)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">mp</span>(test);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    MyAdd myadd;<br>    cout &lt;&lt; <span class="hljs-built_in">myadd</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>) &lt;&lt; endl;<br>    MyPrint myprint;<br>    <span class="hljs-built_in">myprint</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-built_in">myprint</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-built_in">myprint</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    cout &lt;&lt; myprint.count &lt;&lt; endl;<br>    <span class="hljs-built_in">doPrint</span>(myprint, <span class="hljs-string">&quot;hello&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="谓词">4.2 谓词</h1><h2 id="谓词-1">4.2.1 谓词</h2><p>概念：</p><p>·返回boo类型的仿函数称为谓词</p><p>如果operator(）接受一个参数，那么叫做一元谓词</p><p>如果operator(）接受两个参数，那么叫做二元谓词</p><h2 id="一元谓词">4.2.2 一元谓词</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GreaterFive</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> val &gt; <span class="hljs-number">5</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector &lt;<span class="hljs-type">int</span>&gt;v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    vector &lt;<span class="hljs-type">int</span>&gt;::iterator it = <span class="hljs-built_in">find_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">GreaterFive</span>());<span class="hljs-comment">//匿名函数对象</span><br>    <span class="hljs-keyword">if</span> (it == v.<span class="hljs-built_in">end</span>())<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;未找到&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;zhaodaole&quot;</span> &lt;&lt; *it &lt;&lt; endl;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test02</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二元谓词">4.2.3 二元谓词</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCompare</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> a &gt; b;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector &lt;<span class="hljs-type">int</span>&gt;v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br><br>    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(),<span class="hljs-built_in">MyCompare</span>());<br>    <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)<br>    &#123;<br>        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="内建函数对象">4.3 内建函数对象</h1><h2 id="内建函数对象意义">4.3.1 内建函数对象意义</h2><p>概念：</p><p>STL内建了一些函数对象</p><p>分类：</p><p>·算术仿函数</p><p>关系仿函数</p><p>·罗辑仿函数</p><p>用法：</p><p>这些仿函数所产生的对象，用法和一般函数完全相同</p><p>使用内建函数对象，需要引入头文件#include<functional></functional></p><h2 id="算术仿函数">4.3.2 算术仿函数</h2><figure><img src="/2024/11/27/cpp/14-STL%20%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/1694938110670-47db6381-575d-4cd9-99f4-627d2027e682.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test04</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    negate&lt;<span class="hljs-type">int</span>&gt;n;<br>    cout &lt;&lt; <span class="hljs-built_in">n</span>(<span class="hljs-number">50</span>) &lt;&lt; endl;<span class="hljs-comment">// -50</span><br><br>    modulus&lt;<span class="hljs-type">int</span>&gt;p;<br>    cout &lt;&lt; <span class="hljs-built_in">p</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="关系仿函数">4.3.关系仿函数</h2><figure><img src="/2024/11/27/cpp/14-STL%20%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/1694938365012-934d0dc8-e781-498a-9935-efa1a1f74179.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test05</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector &lt;<span class="hljs-type">int</span>&gt;v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)<br>    &#123;<br>        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br>    <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)<br>    &#123;<br>        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="逻辑仿函数">4.3.逻辑仿函数</h2><figure><img src="/2024/11/27/cpp/14-STL%20%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/1694938665048-b2351766-f778-45dd-a400-b6c586e011f4.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test06</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">bool</span>&gt; v;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">true</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">false</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">true</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">true</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">bool</span>&gt;::const_iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)<br>    &#123;<br>        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    vector&lt;<span class="hljs-type">bool</span>&gt;v2;<br>    v<span class="hljs-number">2.</span><span class="hljs-built_in">resize</span>(v.<span class="hljs-built_in">size</span>());<br><br>    <span class="hljs-built_in">transform</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), v<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(), <span class="hljs-built_in">logical_not</span>&lt;<span class="hljs-type">bool</span>&gt;());<br>    <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">bool</span>&gt;::const_iterator it = v<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(); it != v<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>(); it++)<br>    &#123;<br>        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++ 黑马</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>13. STL常用容器</title>
    <link href="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/"/>
    <url>/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="string-容器">3.1 string 容器</h1><h2 id="string基本概念">3.1.1 string基本概念</h2><p>本质：</p><p>。string是C++风格的字符串，而string本质上是一个类</p><p>stringi和char*区别：</p><p>·char*是一个指针</p><p>·string是一个类，类内部封装了char<em>,管理这个字符串，是一个char</em>型的容器。</p><p>特点：</p><p>string类内部封装了很多成员方法I</p><p>例如：查找find,拷贝copy,删除delete替换replace,插入insert</p><p>string管理chr*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</p><h2 id="string构造函数">3.1.2 string构造函数</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694850849276-b8532a37-daff-4395-b186-d30d91d5569b.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// class189_stl_string.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string s1;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;hello world&quot;</span>;<br>    <span class="hljs-function">string <span class="hljs-title">s2</span><span class="hljs-params">(str)</span></span>;<br>    cout &lt;&lt; s2 &lt;&lt; endl;<br>    <span class="hljs-function">string <span class="hljs-title">s3</span><span class="hljs-params">(s2)</span></span>;<span class="hljs-comment">//拷贝构造</span><br>    cout &lt;&lt; s3 &lt;&lt; endl;<br>    <span class="hljs-function">string <span class="hljs-title">s4</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;a&#x27;</span>)</span></span>;<br>    cout &lt;&lt; s4 &lt;&lt; endl;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="string赋值操作">3.1.3 string赋值操作</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694851975792-3ee28d18-0526-4baf-9ef7-6a48bcb1b243.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string str1;<br>    str1 = <span class="hljs-string">&quot;hello world&quot;</span>;<br><br>    string str2;<br>    str2 = str1;<br><br>    string str3;<br>    str3 = <span class="hljs-string">&#x27;a&#x27;</span>;<br><br>    string str4;<br>    str<span class="hljs-number">4.</span><span class="hljs-built_in">assign</span>(<span class="hljs-string">&quot;hello c++&quot;</span>);<br><br>    string str5;<br>    str<span class="hljs-number">5.</span><span class="hljs-built_in">assign</span>(<span class="hljs-string">&quot;hello c++&quot;</span>, <span class="hljs-number">5</span>);<br><br>    string str6;<br>    str<span class="hljs-number">4.</span><span class="hljs-built_in">assign</span>(str5);<br><br>    string str4;<br>    str<span class="hljs-number">4.</span><span class="hljs-built_in">assign</span>(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;w&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串拼接">3.1.4 字符串拼接</h2><p>在字符串尾拼接字符串</p><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694852026997-26415dd6-ee0f-4ff5-bea6-af63827ccaf5.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string str1 = <span class="hljs-string">&quot;wo&quot;</span>;<br>    str1 += <span class="hljs-string">&quot;aiwanyouxi&quot;</span>;<br>    str1 += <span class="hljs-string">&#x27;:&#x27;</span>;<br>    <br>    string str2 = <span class="hljs-string">&quot;LOL&quot;</span>;<br>    str1 += str2;<br>    cout &lt;&lt; str1 &lt;&lt; endl;<br><br>    string str3 = <span class="hljs-string">&quot;I&quot;</span>;<br>    str<span class="hljs-number">3.</span><span class="hljs-built_in">append</span>(<span class="hljs-string">&quot; love &quot;</span>);<br>    str<span class="hljs-number">3.</span><span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;game abcde&quot;</span>, <span class="hljs-number">4</span>);<br>    str<span class="hljs-number">3.</span><span class="hljs-built_in">append</span>(str2);<br>    str<span class="hljs-number">3.</span><span class="hljs-built_in">append</span>(str2, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br>    cout &lt;&lt; str3 &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="string查找和替换">3.1.5 string查找和替换</h2><p>功能描述：</p><p>查找：查找指定字符是否存在</p><p>,替换：在指定的位置替换字符串</p><p>函数原型：</p><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694852667605-ed17a1e4-d480-4a3b-a26d-9291c9d8ecb2.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string str1 = <span class="hljs-string">&quot;abcdefgde&quot;</span>;<br>    <span class="hljs-type">int</span> pos = str<span class="hljs-number">1.f</span>ind(<span class="hljs-string">&quot;de&quot;</span>);  <span class="hljs-comment">//没有返回-1</span><br>    cout &lt;&lt; pos &lt;&lt; endl;<br><br>    pos = str<span class="hljs-number">1.</span><span class="hljs-built_in">rfind</span>(<span class="hljs-string">&quot;de&quot;</span>);     <span class="hljs-comment">//rfind从右往左查</span><br>    cout &lt;&lt; pos &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test04</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string str1 = <span class="hljs-string">&quot;abcdefg&quot;</span>;<br>    str<span class="hljs-number">1.</span><span class="hljs-built_in">replace</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&quot;111&quot;</span>);  <span class="hljs-comment">//没有返回-1</span><br>    cout &lt;&lt; str1 &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="string字符串比较">3.1.6 string字符串比较</h2><p>功能描述：</p><p>·字符串之间的比较</p><p>比较方式：</p><p>·字符串比较是按字符的ASCI码进行对比</p><p>=返回0</p><p>&gt;返回1</p><p>&lt;返回-1</p><p><strong>函数原型：</strong></p><p>int compare(const string &amp;s)const; //与字符串s比较</p><p>int compare(const char *s)const; //与字符串s比较</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test05</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string str1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>    string str2 = <span class="hljs-string">&quot;hfllo&quot;</span>;<br>    cout &lt;&lt; str<span class="hljs-number">1.</span><span class="hljs-built_in">compare</span>(str2) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符存取">3.1.7 字符存取</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694853988430-2529261b-f472-4fdb-ac5d-433f49611dce.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test06</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string str1 = <span class="hljs-string">&quot;hello&quot;</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        cout &lt;&lt; str1[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        cout &lt;&lt; str<span class="hljs-number">1.</span><span class="hljs-built_in">at</span>(i) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    str1[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;x&#x27;</span>;<br>    cout &lt;&lt; str1 &lt;&lt; endl;<br><br>    str1[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;x&#x27;</span>;<br>    cout &lt;&lt; str1 &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="string插入和删除">3.1.8 string插入和删除</h2><p>功能描述：</p><p>·对string字符串进行插入和删除字符操作</p><p>函数原型：</p><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694854285252-32c89679-d0db-4933-ac18-c7491fa14771.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test07</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string str1 = <span class="hljs-string">&quot;hello&quot;</span>;<br><br>    str<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;111&quot;</span>);<br>    cout &lt;&lt; str1 &lt;&lt; endl;<br><br>    str<span class="hljs-number">1.</span><span class="hljs-built_in">erase</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>    cout &lt;&lt; str1 &lt;&lt; endl;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="string子串">3.1.9 string子串</h2><p>功能描述：</p><p>·从字符串中获取想要的子串</p><p>函数原型：</p><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694854454735-89024c7e-b9d5-4032-b041-e0839a3119bb.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test08</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string str1 = <span class="hljs-string">&quot;hello&quot;</span>;<br><br>    string subStr = str<span class="hljs-number">1.</span><span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>    cout &lt;&lt; subStr &lt;&lt; endl;<br><br>    <span class="hljs-type">int</span> pos = str<span class="hljs-number">1.f</span>ind(<span class="hljs-string">&#x27;o&#x27;</span>);<br>    string str = str<span class="hljs-number">1.</span><span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, pos);<br>    cout &lt;&lt; str &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="vector容器">3.2 vector容器</h1><h2 id="vector基本概念">3.2.1 vector基本概念</h2><p>功能：</p><p>·vector数据结构和数组非常相似，也称为单端数组</p><p>vector.与普通数组区别：</p><p>·不同之处在于数组是静态空间，而vectori可以动态扩展</p><p>动态扩展：</p><p>·并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</p><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694855351121-d2edb5f1-d8e3-4922-bd73-bd7106b3006e.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h2 id="vector构造函数">3.2.2 vector构造函数</h2><p>功能描述：</p><p>·创建vector容器</p><p>函数原型：</p><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694855409453-e6e8076d-3aae-4c16-8e1d-057b5b5f36b6.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printVector</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>() ; it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-built_in">printVector</span>(v1);<br><br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">v2</span>(v<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(),v<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">printVector</span>(v2);<br><br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">v3</span>(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>);<br><span class="hljs-built_in">printVector</span>(v3);<br><br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">v4</span>(v3);<br><span class="hljs-built_in">printVector</span>(v4);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="vector赋值操作">3.2.3 vector赋值操作</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694855929195-b649b2df-2e98-41ba-9968-5439e831944d.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-built_in">printVector</span>(v1);<br><br>vector&lt;<span class="hljs-type">int</span>&gt;v2 = v1;<br><span class="hljs-built_in">printVector</span>(v2);<br><br>vector&lt;<span class="hljs-type">int</span>&gt;v3;<br>v<span class="hljs-number">3.</span><span class="hljs-built_in">assign</span>(v<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(),v1 .<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">printVector</span>(v3);<br><br>vector&lt;<span class="hljs-type">int</span>&gt;v4;<br>v<span class="hljs-number">4.</span><span class="hljs-built_in">assign</span>(<span class="hljs-number">10</span>,<span class="hljs-number">100</span>);<br><span class="hljs-built_in">printVector</span>(v4);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="容量和大小">3.2.4 容量和大小</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694856345333-3988ff96-10a2-43c5-8163-d2acfef4b6a1.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-built_in">printVector</span>(v1);<br><br>cout &lt;&lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">empty</span>() &lt;&lt; endl;<br>cout &lt;&lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br>cout &lt;&lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>v<span class="hljs-number">1.</span><span class="hljs-built_in">resize</span>(<span class="hljs-number">15</span>);<br><span class="hljs-built_in">printVector</span>(v1);<br>cout &lt;&lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">empty</span>() &lt;&lt; endl;<br>cout &lt;&lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br>cout &lt;&lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>v<span class="hljs-number">1.</span><span class="hljs-built_in">resize</span>(<span class="hljs-number">5</span>);<br><span class="hljs-built_in">printVector</span>(v1);<br>cout &lt;&lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">empty</span>() &lt;&lt; endl;<br>cout &lt;&lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br>cout &lt;&lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="插入和删除">3.2.5 插入和删除</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694856948025-6089edd1-c03b-45b7-bc34-936e4ff6ffc7.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test04</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-built_in">printVector</span>(v1);<br><br>v<span class="hljs-number">1.</span><span class="hljs-built_in">pop_back</span>();<br>v<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(v<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), <span class="hljs-number">100</span>);<br><span class="hljs-built_in">printVector</span>(v1);<br>v<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(v<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), <span class="hljs-number">2</span>, <span class="hljs-number">100</span>);<br><span class="hljs-built_in">printVector</span>(v1);<br>v<span class="hljs-number">1.</span><span class="hljs-built_in">erase</span>(v<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>());<br><span class="hljs-built_in">printVector</span>(v1);<br><span class="hljs-comment">//清空</span><br>v<span class="hljs-number">1.</span><span class="hljs-built_in">erase</span>(v<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(),v<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">printVector</span>(v1);<br>v<span class="hljs-number">1.</span><span class="hljs-built_in">clear</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数据存取">3.2.6 数据存取</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694857882650-5efd9536-fb75-4ac8-a40c-868d5da75b79.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test05</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-built_in">printVector</span>(v1);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>cout &lt;&lt; v1[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>cout &lt;&lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">at</span>(i) &lt;&lt;  <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>cout &lt;&lt; v<span class="hljs-number">1.f</span>ront() &lt;&lt; endl;<br>cout &lt;&lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">back</span>() &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="互换容器">3.2.7 互换容器</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694858205699-97c6699b-dc57-46e3-9691-cc98161b7969.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>巧用swap可以收缩内存空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test06</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-built_in">printVector</span>(v1);<br>vector&lt;<span class="hljs-type">int</span>&gt;v2;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">10</span>; i &gt; <span class="hljs-number">0</span>; i--)<br>&#123;<br>v<span class="hljs-number">2.</span><span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-built_in">printVector</span>(v2);<br>v<span class="hljs-number">1.</span><span class="hljs-built_in">swap</span>(v2);<br><span class="hljs-built_in">printVector</span>(v1);<br><span class="hljs-built_in">printVector</span>(v2);<br>v<span class="hljs-number">1.</span><span class="hljs-built_in">resize</span>(<span class="hljs-number">3</span>);<br><span class="hljs-comment">//巧用swap收缩内存</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(v1).<span class="hljs-built_in">swap</span>(v1);<span class="hljs-comment">//匿名对象</span><br>cout &lt;&lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="预留空间">3.2.8 预留空间</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694858790486-d4b734b4-8f33-4a0e-8759-d14be5bfcb6c.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test07</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br>v.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">100000</span>);<br><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span>* p = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++)<br>&#123;<br>v.<span class="hljs-built_in">push_back</span>(i);<br><span class="hljs-keyword">if</span> (p!=&amp;v[<span class="hljs-number">0</span>])<br>&#123;<br>p = &amp;v[<span class="hljs-number">0</span>];<br>num++;<br>&#125;<br>&#125;<br>cout &lt;&lt; num;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="deque容器">3.3 deque容器</h1><h2 id="deque容器基本概念">3.3.1 deque容器基本概念</h2><p><strong>功能：</strong></p><p>·双端数组，可以对头端进行插入删除操作</p><p><strong>deque与vector区别：</strong></p><p>·vector对于头部的插入删除效率低，数据量越大，效率越低</p><p>·deque相对而言，对头部的插入删别除速度回vector快</p><p>·vector访问元素时的速度会比deque快这和两者内部实现有关</p><p>deque内部工作原理：</p><p>dequer内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据</p><p>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p><p>deque容器的迭代器也是支持随机访问的</p><h2 id="deque构造函数">3.3.2 deque构造函数</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694862945753-64c23ef6-0d62-4c29-a2ee-f03c98afbae6.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printDeque</span><span class="hljs-params">(<span class="hljs-type">const</span> deque&lt;<span class="hljs-type">int</span>&gt; &amp;d)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (deque&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = d.<span class="hljs-built_in">begin</span>(); it != d.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>deque&lt;<span class="hljs-type">int</span>&gt; d1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>d<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-built_in">printDeque</span>(d1);<br><span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d2</span><span class="hljs-params">(d<span class="hljs-number">1.</span>begin(), d<span class="hljs-number">1.</span>end())</span></span>;<br><span class="hljs-built_in">printDeque</span>(d2);<br><br><span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d3</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>)</span></span>;<br><span class="hljs-built_in">printDeque</span>(d3);<br><br><span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d4</span><span class="hljs-params">(d3)</span></span>;<br><span class="hljs-built_in">printDeque</span>(d4);<br></code></pre></td></tr></table></figure><h2 id="赋值操作">3.3.3 赋值操作</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694864741790-269ff523-e33e-4c36-8584-066423bca265.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>deque&lt;<span class="hljs-type">int</span>&gt; d1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>d<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-built_in">printDeque</span>(d1);<br>deque&lt;<span class="hljs-type">int</span>&gt; d2;<br>d2 = d1;<br><span class="hljs-built_in">printDeque</span>(d2);<br><br>deque&lt;<span class="hljs-type">int</span>&gt; d3;<br>d<span class="hljs-number">3.</span><span class="hljs-built_in">assign</span>(d<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), d<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">printDeque</span>(d3);<br><br>deque&lt;<span class="hljs-type">int</span>&gt; d4;<br>d<span class="hljs-number">4.</span><span class="hljs-built_in">assign</span>(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>);<br><span class="hljs-built_in">printDeque</span>(d4);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="大小操作">3.3.4 大小操作</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694864993553-f4752123-2b33-4109-b61b-97065f88f9a1.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>deque&lt;<span class="hljs-type">int</span>&gt; d1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>d<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-built_in">printDeque</span>(d1);<br>cout &lt;&lt; d<span class="hljs-number">1.</span><span class="hljs-built_in">empty</span>() &lt;&lt; endl;<br>cout &lt;&lt; d<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>d<span class="hljs-number">1.</span><span class="hljs-built_in">resize</span>(<span class="hljs-number">15</span>);<br>d<span class="hljs-number">1.</span><span class="hljs-built_in">resize</span>(<span class="hljs-number">16</span>,<span class="hljs-number">1</span>);<br>d<span class="hljs-number">1.</span><span class="hljs-built_in">resize</span>(<span class="hljs-number">5</span>);<br><br><span class="hljs-built_in">printDeque</span>(d1);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="插入和删除-1">3.3.5 插入和删除</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694865346174-20b3f051-b286-43a5-90f7-73b5a723db19.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test04</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>deque&lt;<span class="hljs-type">int</span>&gt; d1;<br>d<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>d<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>d<span class="hljs-number">1.</span><span class="hljs-built_in">push_front</span>(<span class="hljs-number">100</span>);<br>d<span class="hljs-number">1.</span><span class="hljs-built_in">push_front</span>(<span class="hljs-number">200</span>);<br><br><span class="hljs-built_in">printDeque</span>(d1);<br>d<span class="hljs-number">1.</span><span class="hljs-built_in">pop_back</span>();<br><span class="hljs-built_in">printDeque</span>(d1);<br>d<span class="hljs-number">1.</span><span class="hljs-built_in">pop_front</span>();<br><span class="hljs-built_in">printDeque</span>(d1);<br><br><br>d<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(d<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), <span class="hljs-number">1000</span>);<br><span class="hljs-built_in">printDeque</span>(d1);<br>d<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(d<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), <span class="hljs-number">2</span>,<span class="hljs-number">2000</span>);<br><span class="hljs-built_in">printDeque</span>(d1);<br><br>deque&lt;<span class="hljs-type">int</span>&gt;d2;<br>d<span class="hljs-number">2.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>d<span class="hljs-number">2.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>d<span class="hljs-number">2.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br><br>d<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(d<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), d<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(), d<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">printDeque</span>(d1);<br><br>d<span class="hljs-number">1.</span><span class="hljs-built_in">erase</span>(d<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>());<br><span class="hljs-built_in">printDeque</span>(d1);<br><br>deque&lt;<span class="hljs-type">int</span>&gt;::iterator it = d<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>();<br>it++;<br>d<span class="hljs-number">1.</span><span class="hljs-built_in">erase</span>(it);<br><span class="hljs-built_in">printDeque</span>(d1);<br>d<span class="hljs-number">1.</span><span class="hljs-built_in">clear</span>();<br><span class="hljs-built_in">printDeque</span>(d1);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数据存取-1">3.3.6 数据存取</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694865953318-c3b049cd-554e-4c57-b9bc-72d4c56eed01.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test05</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>deque&lt;<span class="hljs-type">int</span>&gt; d1;<br>d<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>d<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>d<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>d<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>d<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>d<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; d<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>cout &lt;&lt; d1[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt; d<span class="hljs-number">1.</span><span class="hljs-built_in">at</span>(i) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>cout &lt;&lt; d<span class="hljs-number">1.f</span>ront() &lt;&lt; endl;<br>cout &lt;&lt; d<span class="hljs-number">1.</span><span class="hljs-built_in">back</span>() &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="排序">3.3.7 排序</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694866190159-664dab4c-cc25-4062-8ac2-69d5e4009602.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>对于支持随机访问的迭代器的容器，都可以利用sot算法直接对其进行排序</p><p>vector容器也可以利用sort进行排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test06</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>deque&lt;<span class="hljs-type">int</span>&gt; d1;<br>d<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>d<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>d<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>d<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">60</span>);<br>d<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br>d<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br><br><span class="hljs-built_in">printDeque</span>(d1);<br><span class="hljs-built_in">sort</span>(d<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), d<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>());<span class="hljs-comment">//从小到大</span><br><span class="hljs-built_in">printDeque</span>(d1);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="stack容器">3.4 stack容器</h1><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694868340616-64067469-b2a3-415d-8730-afd90a6ef14d.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p><p>栈中进入数据称为-入栈push</p><p>栈中弹出数据称为一出栈pop</p><h2 id="stack常用接口">3.4.1 stack常用接口</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694868739397-88f2f221-bab5-459f-ae93-10e657400ec4.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt;s;<br>    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">10</span>);<br>    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">20</span>);<br>    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">30</span>);<br>    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">40</span>);<br><br>    <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        cout &lt;&lt; s.<span class="hljs-built_in">top</span>() &lt;&lt; endl;<br>        s.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    cout &lt;&lt; s.<span class="hljs-built_in">size</span>() &lt;&lt; endl;;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="queue-容器">3.5 queue 容器</h1><p>概念：Queue是一种先进先出(First In FirstOut,FIFO)的数据结构，它有两个出口</p><p>队列Queue符合先进先出</p><p>只有队头和队尾能被外界访问，因此不允许有遍历行为</p><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694869245220-8840f403-6d47-4332-9e8a-d73265fa2584.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>入队-push</p><p>出队-pop</p><p>返回队头元素-front</p><p>返回队尾元素-back</p><p>判断队是否为空-empty</p><p>返回队列大小-size</p><h2 id="常用接口">3.5.1 常用接口</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(string m_name, <span class="hljs-type">int</span> m_age) :<span class="hljs-built_in">name</span>(m_name), <span class="hljs-built_in">age</span>(m_age) &#123;&#125;<br>    string name;<br>    <span class="hljs-type">int</span> age;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    queue&lt;Person&gt; q;<br><br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;tangseng&quot;</span>, <span class="hljs-number">30</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;sunwukong&quot;</span>, <span class="hljs-number">1000</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;zhubajie&quot;</span>, <span class="hljs-number">900</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;shaseng&quot;</span>, <span class="hljs-number">800</span>)</span></span>;<br><br>    q.<span class="hljs-built_in">push</span>(p1);<br>    q.<span class="hljs-built_in">push</span>(p2);<br>    q.<span class="hljs-built_in">push</span>(p3);<br>    q.<span class="hljs-built_in">push</span>(p4);<br>    cout &lt;&lt; q.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        cout &lt;&lt; q.<span class="hljs-built_in">front</span>().name &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; q.<span class="hljs-built_in">front</span>().age &lt;&lt; endl;<br>        cout &lt;&lt; q.<span class="hljs-built_in">back</span>().name &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; q.<span class="hljs-built_in">back</span>().age &lt;&lt; endl;<br>        q.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    cout &lt;&lt; q.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="list-容器">3.6 list 容器</h1><p>功能：将数据进行链式存储</p><p>链表(st)是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p><p>链表的组成：链表由一系列结点组成</p><p>结点的组成：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域</p><p>STL中的链表是一个双向循环链表</p><p>由于链表的存储方式并不是连续的内存空间，因此链表s中的迭代器只支特前移和后移，属于双向迭代器</p><p>list的优点：</p><p>·采用动态存储分配，不会造成内存浪费和溢出</p><p>·链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</p><p>list的缺点：</p><p>·链表灵活，但是空间（指针域）和时间（遍历）额外耗费较大</p><p>List有一个重要的性质，插入操作和删除操作都不会造成原有ist迭代器的失效，这在vector;是不成立的。</p><p>总结：STL中List和vector是两个最常被使用的容器，各有优缺点</p><h2 id="iist构造函数.">3.6.1 Iist构造函数.</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694909088108-2adecd16-6260-4827-80b3-f1a63c9ba661.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// class215 STL List.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintList</span><span class="hljs-params">(<span class="hljs-type">const</span> list&lt;<span class="hljs-type">int</span>&gt;&amp; L)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (list&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = L.<span class="hljs-built_in">begin</span>(); it != L.<span class="hljs-built_in">end</span>(); it++)<br>    &#123;<br>        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    list&lt;<span class="hljs-type">int</span>&gt; L1;<br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br><br>    <span class="hljs-built_in">PrintList</span>(L1);<br>    <span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">L2</span><span class="hljs-params">(L<span class="hljs-number">1.</span>begin(), L<span class="hljs-number">1.</span>end())</span></span>;<br>    <span class="hljs-built_in">PrintList</span>(L2);<br><br>    <span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">L3</span><span class="hljs-params">(L1)</span></span>;<br>    <span class="hljs-built_in">PrintList</span>(L3);<br>    <br>    <span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">L4</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">1000</span>)</span></span>;<br>    <span class="hljs-built_in">PrintList</span>(L4);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="iist赋值和交换">3.6.2 Iist赋值和交换</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694909500757-fbd234bd-d878-4fab-9e21-669e1726865b.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    list&lt;<span class="hljs-type">int</span>&gt; L1;<br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br><br>    <span class="hljs-built_in">PrintList</span>(L1);<br><br>    list&lt;<span class="hljs-type">int</span>&gt; L2;<br>    L2 = L1;<br>    <span class="hljs-built_in">PrintList</span>(L2);<br><br><br>    list&lt;<span class="hljs-type">int</span>&gt; L3;<br>    L<span class="hljs-number">3.</span><span class="hljs-built_in">assign</span>(L<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), L<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">PrintList</span>(L3);<br><br><br>    list&lt;<span class="hljs-type">int</span>&gt; L4;<br>    L<span class="hljs-number">4.</span><span class="hljs-built_in">assign</span>(<span class="hljs-number">10</span>, <span class="hljs-number">1000</span>);<br>    <span class="hljs-built_in">PrintList</span>(L4);<br><br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">swap</span>(L4);<br>    <span class="hljs-built_in">PrintList</span>(L1);<br>    <span class="hljs-built_in">PrintList</span>(L4);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="iist大小操作">3.6.3 Iist大小操作</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694909799951-e1219de5-12d6-49c4-84a9-bfa64d808138.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    list&lt;<span class="hljs-type">int</span>&gt; L1;<br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br><br>    <span class="hljs-built_in">PrintList</span>(L1);<br>    cout &lt;&lt; L<span class="hljs-number">1.</span><span class="hljs-built_in">empty</span>() &lt;&lt; endl;<br>    cout &lt;&lt; L<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">resize</span>(<span class="hljs-number">10</span>,<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">PrintList</span>(L1);<br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">resize</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">PrintList</span>(L1);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="iist插入和删除">3.6.4 Iist插入和删除</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694910008862-2fe26fcf-72f8-470d-bc3d-771ff9afe457.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test04</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    list&lt;<span class="hljs-type">int</span>&gt; L1;<br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br><br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">push_front</span>(<span class="hljs-number">100</span>);<br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">push_front</span>(<span class="hljs-number">200</span>);<br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">push_front</span>(<span class="hljs-number">300</span>);<br>    <span class="hljs-built_in">PrintList</span>(L1);<br><br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-built_in">PrintList</span>(L1);<br><br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">pop_front</span>();<br>    <span class="hljs-built_in">PrintList</span>(L1);<br><br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(L<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(),<span class="hljs-number">1000</span>);<br>    <span class="hljs-built_in">PrintList</span>(L1);<br>    list&lt;<span class="hljs-type">int</span>&gt;::iterator it = L<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>();<br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(++it,<span class="hljs-number">1000</span>);<br><br>    it = L<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>();<br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">erase</span>(it);<br>    <span class="hljs-built_in">PrintList</span>(L1);<br><br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">remove</span>(<span class="hljs-number">1000</span>);<br>    <span class="hljs-built_in">PrintList</span>(L1);<br><br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">clear</span>();<br>    <span class="hljs-built_in">PrintList</span>(L1);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="iist数据存取">3.6.5 Iist数据存取</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694911607122-5c15f9f5-f375-465b-9a64-6b2acb78f032.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>验证迭代器是不支持随机访问的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test05</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    list&lt;<span class="hljs-type">int</span>&gt; L1;<br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>    cout &lt;&lt; L<span class="hljs-number">1.f</span>ront() &lt;&lt; endl;<br>    cout &lt;&lt; L<span class="hljs-number">1.</span><span class="hljs-built_in">back</span>() &lt;&lt; endl;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="iist反转和排序">3.6.6 Iist反转和排序</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694912083514-d4db6b42-9349-4793-9da6-c4d6d8d30ad8.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>所有不支持随机访问迭代器的容器，不可以用标准算法</p><p>不支持随机访问迭代器的容器，内部会提供对应一些算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">myCompare</span><span class="hljs-params">(<span class="hljs-type">int</span> num1,<span class="hljs-type">int</span> num2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> num1 &gt; num2;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test05</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    list&lt;<span class="hljs-type">int</span>&gt; L1;<br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">60</span>);<br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">70</span>);<br>    <span class="hljs-built_in">PrintList</span>(L1);<br><br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">reverse</span>();<br>    <span class="hljs-built_in">PrintList</span>(L1);<br><br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">sort</span>();<span class="hljs-comment">//默认升序</span><br>    <span class="hljs-built_in">PrintList</span>(L1);<br>    L<span class="hljs-number">1.</span><span class="hljs-built_in">sort</span>(myCompare);<br>    <span class="hljs-built_in">PrintList</span>(L1);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="setmultiset容器">3.7 set/multiset容器</h1><h2 id="概念">3.7.1 概念</h2><p>简介：</p><p>·所有元素都会在插入时自动被排序</p><p>本质：</p><p>·set/multiset属于关联式容器，底层结构是用二叉树实现。</p><p>set和multiset区别：</p><p>。set不允许容器中有重复的元素</p><p>multiset允许容器中有重复的元素</p><h2 id="set构造和赋值">3.7.2 set构造和赋值</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694913858516-5577410f-1311-4eb3-9077-665e048818e2.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// class223_STL_SET.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printSet</span><span class="hljs-params">(set&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (set&lt;<span class="hljs-type">int</span>&gt;::iterator it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>set&lt;<span class="hljs-type">int</span>&gt;s1;<br>s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br><br><span class="hljs-built_in">printSet</span>(s1);<br><br>set&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">s2</span>(s1);<br><span class="hljs-built_in">printSet</span>(s2);<br><br>set&lt;<span class="hljs-type">int</span>&gt;s3;<br>s3 =(s1);<br><span class="hljs-built_in">printSet</span>(s3);<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="set大小和交换">3.7.3 set大小和交换</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694914241211-714709c4-ad92-42ee-9fc3-42e092cfab57.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>set&lt;<span class="hljs-type">int</span>&gt;s1;<br>s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br><span class="hljs-built_in">printSet</span>(s1);<br><br>cout &lt;&lt; s<span class="hljs-number">1.</span><span class="hljs-built_in">empty</span>() &lt;&lt; endl;<br>cout &lt;&lt; s<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>set&lt;<span class="hljs-type">int</span>&gt;s2;<br>s<span class="hljs-number">2.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">100</span>);<br>s<span class="hljs-number">2.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">200</span>);<br>s<span class="hljs-number">2.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">300</span>);<br>s<span class="hljs-number">2.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">400</span>);<br><br><span class="hljs-built_in">printSet</span>(s2);<br>s<span class="hljs-number">1.</span><span class="hljs-built_in">swap</span>(s2);<br><span class="hljs-built_in">printSet</span>(s1);<br><span class="hljs-built_in">printSet</span>(s2);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="set插入和删除">3.7.4 set插入和删除</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694914556408-69f524bc-7c13-4474-bf6b-54c6012a5651.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>set&lt;<span class="hljs-type">int</span>&gt;s1;<br>s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br><span class="hljs-built_in">printSet</span>(s1);<br><br>s<span class="hljs-number">1.</span><span class="hljs-built_in">erase</span>(s<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>());<br><span class="hljs-built_in">printSet</span>(s1);<br>s<span class="hljs-number">1.</span><span class="hljs-built_in">erase</span>(<span class="hljs-number">30</span>);<br><span class="hljs-built_in">printSet</span>(s1);<br><br>s<span class="hljs-number">1.</span><span class="hljs-built_in">clear</span>();<br><span class="hljs-built_in">printSet</span>(s1);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="set查找和统计">3.7.5 set查找和统计</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694914779496-19db99fa-76e1-4ebe-a0b9-945ca61725e9.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test04</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>set&lt;<span class="hljs-type">int</span>&gt;s1;<br>s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br><span class="hljs-built_in">printSet</span>(s1);<br><br>set&lt;<span class="hljs-type">int</span>&gt;::iterator pos = s<span class="hljs-number">1.f</span>ind(<span class="hljs-number">30</span>);<br><span class="hljs-keyword">if</span> (pos!=s<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>())<br>&#123;<br>cout &lt;&lt; *pos &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-type">int</span> num = s<span class="hljs-number">1.</span><span class="hljs-built_in">count</span>(<span class="hljs-number">30</span>);<br>cout &lt;&lt; num &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="set和multiset区别">3.7.6 set和multiset区别</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694915065551-5eb9ad8e-d8e2-4085-b373-78318fc0c530.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test05</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>set&lt;<span class="hljs-type">int</span>&gt;s1;<br>pair&lt;set&lt;<span class="hljs-type">int</span>&gt;::iterator, <span class="hljs-type">bool</span>&gt; ret = s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>ret = s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>cout &lt;&lt; ret.second &lt;&lt; endl;<br><br>multiset&lt;<span class="hljs-type">int</span>&gt;ms;<br>ms.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>ms.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">for</span> (multiset&lt;<span class="hljs-type">int</span>&gt;::iterator it = ms.<span class="hljs-built_in">begin</span>(); it != ms.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="pair对组创建">3.7.7 pair对组创建</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694915601796-227de4d5-ae2b-44b7-8121-2e7d03862357.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test06</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>pair&lt;string, <span class="hljs-type">int</span>&gt;<span class="hljs-built_in">p</span>(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">20</span>);<br>cout &lt;&lt; p.first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p.second &lt;&lt; endl;<br><br>pair&lt;string, <span class="hljs-type">int</span>&gt;p2 = <span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">20</span>);<br>cout &lt;&lt; p<span class="hljs-number">2.f</span>irst &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p<span class="hljs-number">2.</span>second &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="set容器排序">3.7.8 set容器排序</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694915808748-9727e553-e108-4e06-9775-9f14f8113bf6.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCompare</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//常量对象只能调用常量成员函数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> num1,<span class="hljs-type">int</span> num2)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> num1 &gt; num2;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test07</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>set&lt;<span class="hljs-type">int</span>&gt;s1;<br>s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br>s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">50</span>);<br>s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">60</span>);<br><br><span class="hljs-built_in">printSet</span>(s1);<br><br>set&lt;<span class="hljs-type">int</span>,MyCompare&gt;s2;<br>s<span class="hljs-number">2.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>s<span class="hljs-number">2.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>s<span class="hljs-number">2.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>s<span class="hljs-number">2.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br>s<span class="hljs-number">2.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">50</span>);<br>s<span class="hljs-number">2.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">60</span>);<br><br><span class="hljs-keyword">for</span> (set&lt;<span class="hljs-type">int</span>, MyCompare&gt;::iterator it = s<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(); it != s<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">comparePerson</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Person&amp;p1,<span class="hljs-type">const</span> Person&amp;p2)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> p<span class="hljs-number">1.</span>age &gt; p<span class="hljs-number">2.</span>age;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test08</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>set&lt;Person, comparePerson&gt;s1;<br><br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;刘备&quot;</span>, <span class="hljs-number">24</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;关羽&quot;</span>, <span class="hljs-number">30</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;张飞&quot;</span>, <span class="hljs-number">25</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;赵云&quot;</span>, <span class="hljs-number">20</span>)</span></span>;<br>s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(p1);<br>s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(p2);<br>s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(p3);<br>s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(p4);<br><br><span class="hljs-keyword">for</span> (set&lt;Person, comparePerson&gt;::iterator it = s<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(); it != s<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; it-&gt;name &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; it-&gt;age &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; endl;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="mapmultimap容器">3.8 map/multimap容器</h1><h2 id="map基本概念">3.8.1 map基本概念</h2><p>简介：</p><p>map中所有元素都是pair</p><p>·pair中第一个元素为key(键值)，起到索引作用，第二个元素为value(实值)</p><p>·所有元素都会根据元素的键值自动排序</p><p>本质：</p><p>map/multimap属于关联式容器，底层结构是用二叉树实现。</p><p>优点：</p><p>·可以根据key值快速找到value值</p><p>map和multimapl区别：</p><p>·map不允许容器中有重复key值元素</p><p>multimap:允许容器中有重复key值元素</p><h2 id="map构造和赋值">3.8.2 map构造和赋值</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694917949172-75d51cd2-f2cf-4cbc-89d3-83ce51156376.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintMap</span><span class="hljs-params">(map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp;m)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;::iterator it = m.<span class="hljs-built_in">begin</span>(); it != m.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;m;<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">20</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">40</span>));<br><span class="hljs-built_in">PrintMap</span>(m);<br><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;<span class="hljs-built_in">m2</span>(m);<br><span class="hljs-built_in">PrintMap</span>(m2);<br><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;m3 = m2;<br><span class="hljs-built_in">PrintMap</span>(m3);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="map大小和交换">3.8.3 map大小和交换</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694918574046-9d4ce2a7-8b9d-4088-9511-1fa8533ab5c3.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;m;<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">20</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">40</span>));<br><span class="hljs-built_in">PrintMap</span>(m);<br>cout &lt;&lt; m.<span class="hljs-built_in">empty</span>() &lt;&lt; endl;<br>cout &lt;&lt; m.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;m2;<br>m<span class="hljs-number">2.</span><span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">12</span>, <span class="hljs-number">120</span>));<br>m<span class="hljs-number">2.</span><span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">22</span>, <span class="hljs-number">202</span>));<br>m<span class="hljs-number">2.</span><span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">32</span>, <span class="hljs-number">320</span>));<br>m<span class="hljs-number">2.</span><span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>, <span class="hljs-number">420</span>));<br><span class="hljs-built_in">PrintMap</span>(m2);<br>m.<span class="hljs-built_in">swap</span>(m2);<br><span class="hljs-built_in">PrintMap</span>(m);<br><span class="hljs-built_in">PrintMap</span>(m2);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="map插入和删除">3.8.4 map插入和删除</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694918898016-e2ace0ce-dc0b-403a-b76a-471f327ef42c.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;m;<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">2</span>, <span class="hljs-number">20</span>));<br>m.<span class="hljs-built_in">insert</span>(map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">value_type</span>(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>));<br>m[<span class="hljs-number">4</span>] = <span class="hljs-number">40</span>;<br><span class="hljs-built_in">PrintMap</span>(m);<br><br>m.<span class="hljs-built_in">erase</span>(m.<span class="hljs-built_in">begin</span>());<br><span class="hljs-built_in">PrintMap</span>(m);<br><br>m.<span class="hljs-built_in">erase</span>(<span class="hljs-number">3</span>);<br><span class="hljs-built_in">PrintMap</span>(m);<br><br>m.<span class="hljs-built_in">erase</span>(m.<span class="hljs-built_in">begin</span>(), m.<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">PrintMap</span>(m);<br><br>m.<span class="hljs-built_in">clear</span>();<br><span class="hljs-built_in">PrintMap</span>(m);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="map查找和统计">3.8.5 map查找和统计</h2><figure><img src="/2024/11/27/cpp/13-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/1694919436963-e39b91d9-f8b8-40fc-ae71-552c634d1c6b.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test04</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;m;<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">2</span>, <span class="hljs-number">20</span>));<br>m.<span class="hljs-built_in">insert</span>(map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">value_type</span>(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>));<br>m[<span class="hljs-number">4</span>] = <span class="hljs-number">40</span>;<br><span class="hljs-built_in">PrintMap</span>(m);<br><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator pos = m.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>);<br>cout &lt;&lt; pos-&gt;first &lt;&lt;<span class="hljs-string">&quot; &quot;</span> &lt;&lt; pos-&gt;second &lt;&lt; endl;<br><span class="hljs-type">int</span> num = m.<span class="hljs-built_in">count</span>(<span class="hljs-number">3</span>);<br>cout &lt;&lt; num &lt;&lt; endl;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="map容器排序">3.8.6 map容器排序</h2><p>学习目标：</p><p>·map容器默认排序规则为按照key值进行从小到大排序，掌握如何改变排序规则</p><p>主要技术点：</p><p>·利用仿函数，可以改变排序规则</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test05</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, MyCompare&gt;m;<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">2</span>, <span class="hljs-number">20</span>));<br>m.<span class="hljs-built_in">insert</span>(map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">value_type</span>(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>));<br>m[<span class="hljs-number">4</span>] = <span class="hljs-number">40</span>;<br><span class="hljs-keyword">for</span> (map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, MyCompare&gt;::iterator it = m.<span class="hljs-built_in">begin</span>(); it != m.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; endl;  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++ 黑马</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12. STL初识</title>
    <link href="/2024/11/27/cpp/12-STL%E5%88%9D%E8%AF%86/"/>
    <url>/2024/11/27/cpp/12-STL%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>长久以来，软件界一直希望建立一种可重复利用的东西</p><p>C+的面向对象和泛型编程思想，目的就是复用性的提升</p><p>大多情况下，数据结构和算法都未能有一套标准，导致被迫从事大量重复工作</p><p>为了建立数据结构和算法的一套标准，诞生了ST礼</p><p>STL(Standard Template Library,标准模板库)</p><p>STL从广义上分为：容器(container)算法(algorithm)迭代器(iterator)</p><p>容器和算法之间通过迭代器进行无缝连接。</p><p>STL几乎所有的代码都采用了模板类或者模板函数</p><p>STL大体分为六大组件，分别是：容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</p><p>1.容器：各种数据结构，如vector、.list、deque、set、map等，用来存放数据。</p><p>2.算法：各种常用的算法，如sot、find、copy、for_each等</p><p>3.迭代器：扮演了容器与算法之间的胶合剂。</p><p>4.仿函数：行为类似函数，可作为算法的某种策略。</p><p>5.适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</p><p>6.空间配置器：负责空间的配置与管理。</p><p>容器：置物之所也</p><p>I</p><p>STL容器就是将运用最广泛的一些数据结构实现出来</p><p>常用的数据结构：数组，链表，树，栈，队列，集合，映射表等</p><p>这些容器分为序列式容器和关联式容器两种：</p><p>序列式容器强调值的排序，序列式容器中的每个元素均有固定的位置。</p><p>关联式容器：二叉树结构，各元素之间没有严格的物理上的顺序关系</p><p>算法：问题之解法也</p><p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法Algorithms)</p><p>算法分为：质变算法和非质变算法。</p><p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p><p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p><h1 id="容器算法迭代器">2.1 容器算法迭代器</h1><h2 id="vector存放内置数据类型">2.1.1 vector存放内置数据类型</h2><p>容器：</p><p>vector</p><p>算法：</p><p>for_each</p><p>迭代器：</p><p>vector<int>:iterator</int></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// class186_STL初识vector.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; val &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//尾插</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br><br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator itBegin = v.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">//起始迭代器，指向容器中第一个元素</span><br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator itEnd = v.<span class="hljs-built_in">end</span>();<span class="hljs-comment">//起始迭代器，指向容器中最后一个元素的下一个位置</span><br>    <span class="hljs-comment">//第一种遍历方式</span><br>    <span class="hljs-keyword">while</span> (itBegin != itEnd)<br>    &#123;<br>        cout &lt;&lt; *itBegin &lt;&lt; endl;<br>        itBegin++;<br>    &#125;<br>    <span class="hljs-comment">//第二种遍历方式</span><br>    <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)<br>    &#123;<br>        cout &lt;&lt; *it &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//第三种遍历方式</span><br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), myPrint);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="vector存放自定义数据类型">2.1.2 vector存放自定义数据类型</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// class186_STL初识vector.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(string m_name, <span class="hljs-type">int</span> m_age) :<span class="hljs-built_in">name</span>(m_name), <span class="hljs-built_in">age</span>(m_age) &#123;&#125;<br>    string name;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(Person&amp; p)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; p.name &lt;&lt; <span class="hljs-string">&quot;   &quot;</span>&lt;&lt; p.age &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint2</span><span class="hljs-params">(Person* p)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; p-&gt;name &lt;&lt; <span class="hljs-string">&quot;   &quot;</span> &lt;&lt; p-&gt;age &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//尾插</span><br>    vector&lt;Person*&gt; v;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-number">10</span>)</span></span>;<br><br>    v.<span class="hljs-built_in">push_back</span>(&amp;p1);<br>    v.<span class="hljs-built_in">push_back</span>(&amp;p2);<br>    v.<span class="hljs-built_in">push_back</span>(&amp;p3);<br>    v.<span class="hljs-built_in">push_back</span>(&amp;p4);<br>    v.<span class="hljs-built_in">push_back</span>(&amp;p5);<br><br><br>    <span class="hljs-comment">//第二种遍历方式</span><br>    <span class="hljs-keyword">for</span> (vector&lt;Person*&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)<br>    &#123;<br>        cout &lt;&lt; (**it).name &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; (**it).age &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//第三种遍历方式</span><br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), myPrint2);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//尾插</span><br>    vector&lt;Person&gt; v;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-number">10</span>)</span></span>;<br><br>    v.<span class="hljs-built_in">push_back</span>(p1);<br>    v.<span class="hljs-built_in">push_back</span>(p2);<br>    v.<span class="hljs-built_in">push_back</span>(p3);<br>    v.<span class="hljs-built_in">push_back</span>(p4);<br>    v.<span class="hljs-built_in">push_back</span>(p5);<br><br>    <br>    <span class="hljs-comment">//第二种遍历方式</span><br>    <span class="hljs-keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)<br>    &#123;<br>        cout &lt;&lt; (*it).name &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; (*it).age &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//第三种遍历方式</span><br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), myPrint);<br>    <span class="hljs-built_in">test</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="vector容器嵌套容器">2.5.3 Vector容器嵌套容器</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// class186_STL初识vector.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;v;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v1;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v2;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v3;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v4;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>    &#123;<br>        v<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">1</span>);<br>        v<span class="hljs-number">2.</span><span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">2</span>);<br>        v<span class="hljs-number">3.</span><span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">3</span>);<br>        v<span class="hljs-number">4.</span><span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">4</span>);<br>    &#125;<br>    v.<span class="hljs-built_in">push_back</span>(v1);<br>    v.<span class="hljs-built_in">push_back</span>(v2);<br>    v.<span class="hljs-built_in">push_back</span>(v3);<br>    v.<span class="hljs-built_in">push_back</span>(v4);<br><br>    <span class="hljs-keyword">for</span> (vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator itt = (*it).<span class="hljs-built_in">begin</span>(); itt != (*it).<span class="hljs-built_in">end</span>(); itt++)<br>        &#123;<br>            cout &lt;&lt; *itt &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    <span class="hljs-built_in">test</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++ 黑马</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11. 模板</title>
    <link href="/2024/11/27/cpp/11-%E6%A8%A1%E6%9D%BF/"/>
    <url>/2024/11/27/cpp/11-%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<p>模板就是简历通用的模具，大大提高 复用性。</p><h1 id="概念">1.1 概念</h1><p>特点：</p><ul><li>模板不可以直接使用，只是一个框架</li><li>模板的通用并不是万能的</li></ul><h1 id="函数模板">1.2 函数模板</h1><p>泛型编程，主要利用的技术 是模板</p><p>两种模板：函数模板和类模板</p><h2 id="函数模板用法">1.2.1 函数模板用法</h2><p>建立一个通用函数，返回类型和形参类型可以不具体制定，用一个虚拟的类型来代表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-comment">// class167_模板.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>T temp = a;<br>a = b;<br>b = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br><span class="hljs-type">double</span> c = <span class="hljs-number">1.1</span>, d = <span class="hljs-number">2.2</span>;<br><span class="hljs-comment">//自动类型推导</span><br><span class="hljs-built_in">mySwap</span>(a, b);<br>cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;<br><span class="hljs-comment">//显式指定类型</span><br><span class="hljs-built_in">mySwap</span>&lt;<span class="hljs-type">double</span>&gt;(c, d);<br>cout &lt;&lt; c &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; d &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用关键字template</p><p>两种方式：自动类型推导，显式指定类型</p><p>模板的目的是为了提高复用性，将类型参数化</p><h2 id="函数模板注意事项">1.2.2 函数模板注意事项</h2><p>注意事项：</p><p>·自动类型推导，必须推导出一致的数据类类型T,才可以使用</p><p>·模板必须要确定出的数据类型，才可以使用</p><h2 id="排序">1.2.3 排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// class167_模板.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>T temp = a;<br>a = b;<br>b = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySort</span><span class="hljs-params">(T arr[], <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br><span class="hljs-type">int</span> max = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; len; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (arr[max] &lt; arr[j])<br>&#123;<br>max = j;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (max!=i)<br>&#123;<br><span class="hljs-built_in">mySwap</span>(arr[max], arr[i]);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(T arr[], <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br>cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> charArr[] = <span class="hljs-string">&quot;badcfe&quot;</span>;<br><span class="hljs-type">int</span> length = <span class="hljs-built_in">sizeof</span>(charArr) / <span class="hljs-built_in">sizeof</span>(charArr[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">mySort</span>(charArr, length);<br><span class="hljs-built_in">printArray</span>(charArr, length);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="普通函数与-函数模板的区别">1.2.4 普通函数与 函数模板的区别</h2><p>普通函数与函数模板区别：</p><p>·普通函数调用时可以发生自动类型转换（隐式类型转换）</p><p>·函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</p><p>如果利用显示指定类型的方式，可以发生隐式类型转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">myAdd</span><span class="hljs-params">(T a,T b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">myAdd</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">myAdd</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">myAdd</span>&lt;<span class="hljs-type">char</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>) &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="调用规则如下">1.2.5 调用规则如下：</h2><p>1.如果函数模板和普通函数都可以实现，优先调用普通函数</p><p>2.可以通过空模板参数列表来强制调用函数模板</p><p>3.函数模板也可以发生重载</p><p>4.如果函数模板可以产生更好的匹配，优先调用函数模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// class167_模板.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;hello&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(T a, T b)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;temp&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(T a, T b,T c)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;temp ccc&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//优先普通函数</span><br><span class="hljs-built_in">myPrint</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br><br>myPrint&lt;&gt;(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br>myPrint&lt;&gt;(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>);<br><span class="hljs-comment">//重载</span><br>myPrint&lt;&gt;(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>既然提供了 函数模板，最好 就不要提供普通函数，否则 会出现二义性</p><h2 id="模板的-局限性">1.2.6 模板的 局限性</h2><p>在上述代码中，如果T的数据类型传入的是像Perso这样的自定义数据类型，也无法正常运行</p><p>因此C++为了解决这种问题，提供模板的重载，可以为这些特定的类型提供具体化的模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// class167_模板.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(string m_name, <span class="hljs-type">int</span> m_age) :<span class="hljs-built_in">name</span>(m_name), <span class="hljs-built_in">age</span>(m_age) &#123;&#125;<br>string name;<br><span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">myCompare</span><span class="hljs-params">(T &amp;a, T &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (a==b)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">myCompare</span><span class="hljs-params">(Person&amp; a, Person&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (a.age ==b.age)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br>cout &lt;&lt; <span class="hljs-built_in">myCompare</span>(a, b) &lt;&lt; endl;<br><br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;Tim&quot;</span>, <span class="hljs-number">10</span>)</span></span>;<br>cout &lt;&lt; <span class="hljs-built_in">myCompare</span>(p1, p2) &lt;&lt; endl; <br><span class="hljs-comment">//重载运算符</span><br><span class="hljs-comment">//具体化实现</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="类模板">1.3 类模板</h1><h2 id="类模板语法">1.3.1 类模板语法</h2><p>类模板作用：</p><p>·建立一个通用类，类中的成员数据类型可以不具体制定，用一个虚拟的类型来代表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>  T&gt;<br><span class="hljs-keyword">class</span><br></code></pre></td></tr></table></figure><p>解释：</p><p>template-声明创建模板</p><p>typename-表面其后面的符号是一种数据类型，可以用class代替</p><p>T通用的数据类型，</p><p>名称可以替换，通常为大写字母</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// class174_类模板.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">NameType</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgeType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(NameType n, AgeType a) :<span class="hljs-built_in">name</span>(n), <span class="hljs-built_in">age</span>(a) &#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowPerson</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; name &lt;&lt; endl;<br>cout &lt;&lt; age &lt;&lt; endl;<br>&#125;<br>NameType name;<br>AgeType age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Person&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">99</span>)</span></span>;<br>p<span class="hljs-number">1.</span><span class="hljs-built_in">ShowPerson</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类模板与函数模板区别主要有两点">1.3.2类模板与函数模板区别主要有两点：</h2><p>1.类模板没有自动类型推导的使用方式</p><p>2.类模板在模板参数列表中可以有默认参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">NameType</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgeType</span> = <span class="hljs-type">int</span>&gt;<br><span class="hljs-keyword">class</span> Person<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(NameType n, AgeType a) :<span class="hljs-built_in">name</span>(n), <span class="hljs-built_in">age</span>(a) &#123;&#125;<br><span class="hljs-type">void</span> <span class="hljs-built_in">ShowPerson</span>()<br>&#123;<br>cout &lt;&lt; name &lt;&lt; endl;<br>cout &lt;&lt; age &lt;&lt; endl;<br>&#125;<br>NameType name;<br>AgeType age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Person&lt;string&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">99</span>)</span></span>;<br>p<span class="hljs-number">1.</span><span class="hljs-built_in">ShowPerson</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类模板中成员函数创建时间">1.3.3 类模板中成员函数创建时间</h2><p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p><p>普通类中的成员函数一开始就可以创建</p><p>·类模板中的成员函数在调用时才创建</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// class174_类模板.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowPerson1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;name&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowPerson2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;age&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>T obj;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>obj.<span class="hljs-built_in">ShowPerson1</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>obj.<span class="hljs-built_in">ShowPerson2</span>();<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>MyClass&lt;Person1&gt;m;<br>m.<span class="hljs-built_in">func1</span>();<br><span class="hljs-comment">//m.func2();</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类模板对象做函数参数">1.3.4 类模板对象做函数参数</h2><p>学习目标：</p><p>·类模板实例化出的对象，向函数传参的方式</p><p>一共有三种传入方式：</p><p>1.指定传入的类型一直接显示对象的数据类型<strong>(最常用）</strong></p><p>2.参数模板化</p><p>一将对象中的参数变为模板进行传递</p><p>3.整个类模板化</p><p>一将这个对象类型模板化进行传递</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// class174_类模板.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(T1 m_name, T2 m_age) :<span class="hljs-built_in">name</span>(m_name), <span class="hljs-built_in">age</span>(m_age) &#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowPerson</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; name &lt;&lt; endl;<br>cout &lt;&lt; age &lt;&lt; endl;<br>&#125;<br>T1 name;<br>T2 age;<br>&#125;;<br><span class="hljs-comment">//指定传入类型</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPerson1</span><span class="hljs-params">(Person&lt;string, <span class="hljs-type">int</span>&gt;&amp;p)</span></span><br><span class="hljs-function"></span>&#123;<br>p.<span class="hljs-built_in">ShowPerson</span>();<br>&#125;<br><span class="hljs-comment">//2.参数模板化</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T1, <span class="hljs-keyword">class</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPerson2</span><span class="hljs-params">(Person&lt;T1, T2&gt;&amp; p)</span></span><br><span class="hljs-function"></span>&#123;<br>p.<span class="hljs-built_in">ShowPerson</span>();<br><span class="hljs-comment">//cout &lt;&lt; typeid(T1).name() &lt;&lt; endl;</span><br><span class="hljs-comment">//cout &lt;&lt; typeid(T2).name() &lt;&lt; endl;</span><br>&#125;<br><span class="hljs-comment">//3.整个类模板化</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPerson3</span><span class="hljs-params">(T&amp; p)</span></span><br><span class="hljs-function"></span>&#123;<br>p.<span class="hljs-built_in">ShowPerson</span>();<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Person&lt;string, <span class="hljs-type">int</span>&gt;<span class="hljs-built_in">p</span>(<span class="hljs-string">&quot;sun&quot;</span>, <span class="hljs-number">100</span>);<br><span class="hljs-built_in">printPerson1</span>(p);<br>Person&lt;string, <span class="hljs-type">int</span>&gt;<span class="hljs-built_in">p2</span>(<span class="hljs-string">&quot;zhu&quot;</span>, <span class="hljs-number">100</span>);<br><span class="hljs-built_in">printPerson2</span>(p2);<br>Person&lt;string, <span class="hljs-type">int</span>&gt;<span class="hljs-built_in">p3</span>(<span class="hljs-string">&quot;tang&quot;</span>, <span class="hljs-number">100</span>);<br><span class="hljs-built_in">printPerson3</span>(p3);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类模板与继承">1.3.5 类模板与继承</h2><p>当类模板碰到继承时，需要注意一下几点：</p><p>·当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</p><p>·如果不指定，编泽器无法给子类分配内存</p><p>·如果想灵活指定出父类中T的类型，子类也需变为类模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// class174_类模板.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br>T m;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> :<span class="hljs-keyword">public</span> Base&lt;<span class="hljs-type">int</span>&gt;<br>&#123;<br><br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son2</span> :<span class="hljs-keyword">public</span> Base&lt;T2&gt;<br>&#123;<br>T1 obj;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Son s1;<br><br>Son2 &lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; s2;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类模板函数类外实现">1.3.6 类模板函数类外实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// class174_类模板.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(T1 m_name, T2 m_age); <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowPerson</span><span class="hljs-params">()</span></span>;<br><br>T1 name;<br>T2 age;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br>Person&lt;T1,T2&gt;::<span class="hljs-built_in">Person</span>(T1 m_name, T2 m_age)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;name = (m_name);<br><span class="hljs-keyword">this</span>-&gt;age = (m_age);<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-type">void</span> Person&lt;T1, T2&gt;::<span class="hljs-built_in">ShowPerson</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;name &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Person&lt;string, <span class="hljs-type">int</span>&gt;<span class="hljs-built_in">p</span>(<span class="hljs-string">&quot;sun&quot;</span>, <span class="hljs-number">100</span>);<br>p.<span class="hljs-built_in">ShowPerson</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类模板份文件编写">1.3.7 类模板份文件编写</h2><p>问题：</p><p>。</p><p>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</p><p>解决：</p><p>。解决方式1：直接包含.cpp源文件</p><p>。解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp,hpp是约定的名称，并不是强制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// class174_类模板.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Person.hpp&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Person&lt;string, <span class="hljs-type">int</span>&gt;<span class="hljs-built_in">p</span>(<span class="hljs-string">&quot;sun&quot;</span>, <span class="hljs-number">100</span>);<br>p.<span class="hljs-built_in">ShowPerson</span>();<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(T1 m_name, T2 m_age);<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowPerson</span><span class="hljs-params">()</span></span>;<br><br>T1 name;<br>T2 age;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br>Person&lt;T1, T2&gt;::<span class="hljs-built_in">Person</span>(T1 m_name, T2 m_age)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;name = (m_name);<br><span class="hljs-keyword">this</span>-&gt;age = (m_age);<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-type">void</span> Person&lt;T1, T2&gt;::<span class="hljs-built_in">ShowPerson</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;name &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;age &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类模板与友元">1.3.类模板与友元</h2><p>全局函数类内实现·直接在<strong>类内声明友元</strong>即可</p><p>全局函数类外实现·需要提前让编译器知道全局函数的存在</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowPerson2</span><span class="hljs-params">(Person&lt;T1, T2&gt; p)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; p.name &lt;&lt; endl;<br>cout &lt;&lt; p.age &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowPerson</span><span class="hljs-params">(Person&lt;T1, T2&gt; p)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; p.name &lt;&lt; endl;<br>cout &lt;&lt; p.age &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> ShowPerson2 &lt;&gt;(Person&lt;T1, T2&gt; p);<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(T1 m_name, T2 m_age);<br><br><span class="hljs-keyword">private</span>:<br>T1 name;<br>T2 age;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br>Person&lt;T1, T2&gt;::<span class="hljs-built_in">Person</span>(T1 m_name, T2 m_age)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;name = (m_name);<br><span class="hljs-keyword">this</span>-&gt;age = (m_age);<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Person&lt;string, <span class="hljs-type">int</span>&gt;<span class="hljs-built_in">p</span>(<span class="hljs-string">&quot;sun&quot;</span>, <span class="hljs-number">100</span>);<br><span class="hljs-built_in">ShowPerson2</span>(p);<br><span class="hljs-built_in">ShowPerson</span>(p);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++ 黑马</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10. 文件操作</title>
    <link href="/2024/11/27/cpp/10-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <url>/2024/11/27/cpp/10-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>程序运行时产生的数据都属于时数据，程序一旦运行结束都会被释放</p><p>通过文件可以将数据持久化</p><p>C++中对文件操作需要包含头文件fstream</p><p>文件类型分为两种：</p><p>1.文本文件·文件以文本的ASCII码形式存储在计算机中</p><p>2.二进制文件-文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们</p><p>操作文件的三大类：</p><p>1,ofstream:写操作</p><p>2.ifstream:读操作</p><p>3.fstream:读写操作</p><h1 id="文本文件">5.1 文本文件</h1><h2 id="写文件">5.1.1 写文件</h2><p>写文件步如下：</p><p>1.包含头文件</p><p>#include <fstream></fstream></p><p>2.创建流对象</p><p>ofstream ofs;</p><p>3.打开文件</p><p>ofs.open"文件路径"，打开方式)</p><p>4.写数据</p><p>ofs&lt;&lt;“写入的数据"</p><p>5,关闭文件</p><p>ofs.close();</p><p>文件打开方式</p><figure><img src="/2024/11/27/cpp/10-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/1694655551848-ec76a7fa-f455-4f02-aafa-d12195ff6e97.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>注意：文件特打开方式可以配合便用，利用引操作符</p><p>例如：用二进制方式写文件ios::binary| ios::out</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// class143_文本文件.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ofstream ofs;<br>ofs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, ios::out);<br>ofs &lt;&lt; <span class="hljs-string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;<br>ofs &lt;&lt; <span class="hljs-string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;<br>ofs &lt;&lt; <span class="hljs-string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;<br><br>ofs.<span class="hljs-built_in">close</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="读文件">5.1.2 读文件</h2><p>读文件与写文件步骤相似，但是读取方式相对于比较多</p><p>读文件步如下：</p><p>1.包含头文件</p><p>#include <fstream></fstream></p><p>2.建流对象</p><p>ifstream ifs;</p><p>3.打开文件并判断文件是否打开成功</p><p>ifs.open("文件路径"打开方式)：</p><p>4.读数据</p><p>四种方式读取</p><p>5.关闭文件</p><p>ifs.close();</p><p>总结：</p><p>读文件可以利用ifstream,或者fstream类</p><p>利用is_open函数可以判断文件是否打开成功</p><p>·close关闭文件I</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// class143_文本文件.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ifstream ifs;<br>ifs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>,ios::in);<br><span class="hljs-keyword">if</span> (!ifs.<span class="hljs-built_in">is_open</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//char buf[1024] = &#123; 0 &#125;;</span><br><span class="hljs-comment">//第一种</span><br><span class="hljs-comment">//while (ifs &gt;&gt; buf)</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//第三种</span><br><span class="hljs-comment">//while (ifs.getline(buf,sizeof(buf)))</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//ifs.close();</span><br><span class="hljs-comment">/*string buf;</span><br><span class="hljs-comment">while (getline(ifs,buf))</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="hljs-comment">&#125;*/</span><br><br><span class="hljs-type">char</span> c;<br><span class="hljs-keyword">while</span> ((c = ifs.<span class="hljs-built_in">get</span>()) !=EOF)<span class="hljs-comment">//文件尾</span><br>&#123;<br>cout &lt;&lt; c;<br>&#125;<br>ifs.<span class="hljs-built_in">close</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二进制文件">5.2 二进制文件</h1><p>以二进制的方式对文件进行读写操作</p><p>打开方式要指定为ios::binary</p><h2 id="写文件-1">5.2.1 写文件</h2><p>二进制方式写文件主要利用流对象调用成员函数wite</p><p>函数原型：ostream&amp; write(const char*buffer,int len);</p><p>参数解释：字符指针ouffer指向内存中一段存储空间。len是读写的字节数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-type">char</span> name[<span class="hljs-number">64</span>];<br><span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">ofstream <span class="hljs-title">ofs</span><span class="hljs-params">(<span class="hljs-string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;<br>Person p = &#123; <span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">18</span> &#125;;<br>ofs.<span class="hljs-built_in">write</span>((<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)&amp;p, <span class="hljs-built_in">sizeof</span>(Person));<br><br>ofs.<span class="hljs-built_in">close</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="读文件-1">5.2.2 读文件</h2><p>二进制方式读文件主要利用流对象调用成员函数rad</p><p>函数原型：</p><p>istream&amp; read(char *buffer ,int len);</p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// class143_文本文件.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-type">char</span> name[<span class="hljs-number">64</span>];<br><span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">ifstream <span class="hljs-title">ifs</span><span class="hljs-params">(<span class="hljs-string">&quot;person.txt&quot;</span>, ios::in | ios::binary)</span></span>;<br><span class="hljs-keyword">if</span> (!ifs.<span class="hljs-built_in">is_open</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;打开失败&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>Person p;<br><br>ifs.<span class="hljs-built_in">read</span>((<span class="hljs-type">char</span>*)&amp;p, <span class="hljs-built_in">sizeof</span>(Person));<br>cout &lt;&lt; p.age &lt;&lt; endl;<br>cout &lt;&lt; p.name &lt;&lt; endl;<br>ifs.<span class="hljs-built_in">close</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++ 黑马</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9. 类和对象</title>
    <link href="/2024/11/27/cpp/9-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <url>/2024/11/27/cpp/9-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>c++面向对象三大特性：封装、继承、多态</p><h3 id="封装">4.1 封装</h3><p>将属性和行为作为一个整体</p><p>加以权限限制</p><ul><li><p>访问权限</p></li><li><ul><li>公共权限 public 类内可访问，类外可以访问</li><li>保护权限 protected 类内可访问，类外不可访问 儿子可以访问父亲保护内容</li><li>私有权限 private 类内可访问，类外不可访问儿子不可以访问父亲私有内容</li></ul></li></ul><h4 id="pstruct-和-class-区别">4.1.1 pstruct 和 class 区别</h4><p>struct默认权限为public</p><p>class默认权限为private</p><h4 id="成员属性设置为私有">4.1.2 成员属性设置为私有</h4><p>优点：</p><p>将所有成员属性设置为私有，可以自己控制读写权限</p><p>对于写权限，可以检测数据的有效性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs plain">#include &lt;iostream&gt;<br> using  namespace std;<br> class Person<br> &#123;<br> <br> public:<br>     void setName(string name1)<br>     &#123;<br>         name = name1;<br>     &#125;<br>     string getName()<br>     &#123;<br>         return name;<br>     &#125;<br>     int getAge()<br>     &#123;<br>         return age;<br>     &#125;<br>     void setLover(string lover1)<br>     &#123;<br>         lover = lover1;<br>     &#125;<br> private:<br>     string name;<br>     int age;<br>     string lover;<br> &#125;;<br> int main()<br> &#123;<br>     Person p;<br>     p.setName(&quot;zhangsan&quot;);<br>     cout &lt;&lt;  p.getName() &lt;&lt; endl;<br>     cout &lt;&lt; &quot;Hello World!\n&quot;;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="对象的初始化和清理">4.2 对象的初始化和清理</h3><h4 id="构造函数和析构函数">4.2.1 构造函数和析构函数</h4><p>构造函数：创建对象时为对象的成员属性赋值，无须手动调用</p><ul><li>类名（）{}</li><li>无返回值，不写void</li><li>可以有重载</li><li>程序在调用对象时会自动调用构造函数，</li></ul><p>析构函数：对象销毁前系统自动调用，执行清理工作</p><ul><li>~类名（）{}</li><li>不可以有参数，不可以重载</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plain">#include &lt;iostream&gt;<br> using namespace std;<br> <br> class Person<br> &#123;<br> public:<br>     Person()<br>     &#123;<br>         cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl;<br>     &#125;<br> <br>     ~Person() &#123;<br>         cout &lt;&lt; &quot;析构&quot; &lt;&lt; endl;<br>     &#125;<br> &#125;;<br> <br> int main()<br> &#123;<br>     Person p1;//局部变量 栈上的数据，执行完毕后，释放这个对象<br> &#125;<br></code></pre></td></tr></table></figure><h4 id="构造函数的分类和使用">4.2.2 构造函数的分类和使用</h4><p>有参构造和无参构造（默认构造）</p><p>普通构造和拷贝构造</p><p>调用方式：括号法、显示法、隐式转换法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>()<br>    &#123;<br>        age = <span class="hljs-number">10</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;默认构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a)<br>    &#123;<br>        age = a;<br>        cout &lt;&lt; <span class="hljs-string">&quot;有参构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person &amp;p) <span class="hljs-comment">// const 不能修改p，同时要用引用</span><br>    &#123;<br>        <span class="hljs-comment">//将传入的人身上的所有属性，拷贝到我身上</span><br>        age = p.age;<br>        cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Person</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;析构函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//1.括号法</span><br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;<br>    <span class="hljs-comment">//注意：</span><br>    <span class="hljs-comment">//调用默认构造函数不要加括号</span><br>    <span class="hljs-comment">//编译器会认为是函数的声明；</span><br>    <span class="hljs-comment">// Person p();       像 void func();</span><br>    <span class="hljs-comment">// </span><br>    <span class="hljs-comment">//2.显示法</span><br>    Person p3;<br>    Person p4 = <span class="hljs-built_in">Person</span>(<span class="hljs-number">10</span>);<br>    Person p5 = <span class="hljs-built_in">Person</span>(p3);<br>    <span class="hljs-comment">//Person(10) 匿名对象 特点：当前行执行结束后，系统会立即回收掉匿名对象</span><br>    <span class="hljs-comment">//不要利用拷贝构造函数，初始化匿名对象</span><br>    <span class="hljs-comment">//Person（p3);   编译器会认为是 Person p3</span><br>    <br>    <span class="hljs-comment">//3.隐式法</span><br>    Person p6 = <span class="hljs-number">10</span>; <br>    Person p7 = p6;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="拷贝构造函数调用时机">4.2.3 拷贝构造函数调用时机</h4><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传值</li><li>以值方式返回局部对象</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;默认构造&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age)<br>    &#123;<br>        p_age = age;<br>        cout &lt;&lt; <span class="hljs-string">&quot;有参构造&quot;</span> &lt;&lt; endl;<br><br>    &#125;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person&amp; p)<br>    &#123;<br>        p_age = p.p_age;<br>        cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造&quot;</span> &lt;&lt; endl;<br><br>    &#125;<br><br>    ~<span class="hljs-built_in">Person</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;析构&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> p_age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//1.使用一个已经创建完毕的对象来初始化一个新对象</span><br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;<br>&#125;<br><br><span class="hljs-comment">//2.值传递的方式给函数参数传值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">(Person p1)</span></span><br><span class="hljs-function"></span>&#123;<br>   <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person p;<br>    <span class="hljs-built_in">doWork</span>(p);<br>&#125;<br><span class="hljs-comment">//3.以值方式返回局部对象</span><br><span class="hljs-function">Person <span class="hljs-title">doWork2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person p1;<br>    cout &lt;&lt; (<span class="hljs-type">int</span>*)&amp;p1 &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> p1;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person p = <span class="hljs-built_in">doWork2</span>();<br>    cout &lt;&lt; (<span class="hljs-type">int</span>*)&amp;p &lt;&lt; endl;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test3</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="构造函数调用规则">4.2.4 构造函数调用规则</h4><p>默认情况下，一个类添加3个函数</p><p>默认构造、析构、拷贝构造函数</p><ul><li>如果用户定义有参构造函数，c++不再提供默认无参构造，但是有默认有参构造</li><li>如果用户定义有参构造函数，c++不再提供默认无参构造，但是有默认有参构造</li></ul><h4 id="深拷贝和浅拷贝">4.2.5 深拷贝和浅拷贝</h4><p>浅拷贝：简单的赋值拷贝操作，编译器的默认拷贝构造</p><p>问题：堆区内存重复释放</p><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p><p>如果属性有在堆区开辟的，一定要自己提供拷贝函数，防止浅拷贝带来的问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;默认构造&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age, <span class="hljs-type">int</span> heitht)<br>    &#123;<br>        p_age = age;<br>        p_height = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(heitht);<br>        cout &lt;&lt; <span class="hljs-string">&quot;有参构造&quot;</span> &lt;&lt; endl;<br><br>    &#125;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person&amp; p) <span class="hljs-comment">//深拷贝</span><br>    &#123;<br>        p_age = p.p_age;<br>        cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造&quot;</span> &lt;&lt; endl;<br>        p_height = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*p.p_height);<br>    &#125;<br><br>    ~<span class="hljs-built_in">Person</span>()<br>    &#123;<br>        <span class="hljs-comment">//将堆区开辟的数据释放</span><br>        <span class="hljs-keyword">if</span> (p_height != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">delete</span> p_height;<br>            p_height = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;析构&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-type">int</span> p_age;<br>    <span class="hljs-type">int</span>* p_height;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>,<span class="hljs-number">180</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="初始化列表">4.2.6 初始化列表</h4><p>初始化属性</p><p>构造函数(): 属性1（值1），...{}</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c):<span class="hljs-built_in">a</span>(a),<span class="hljs-built_in">b</span>(b),<span class="hljs-built_in">c</span>(c)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;默认构造&quot;</span> &lt;&lt; endl;<br>    &#125;<br>   <br>    ~<span class="hljs-built_in">Person</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;析构&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-type">int</span> c;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">30</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>)</span></span>;<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="类对象作为类成员">4.2.7 类对象作为类成员</h4><p>对象成员</p><p>当其他类对象作为本类成员，构造时先构造类对象，再构造自身，析构反着来</p><h4 id="静态成员">4.2.8 静态成员</h4><p>成员前加static</p><p>静态成员变量：</p><ul><li>所有对象共享同一份数据</li><li>再编译阶段分配内存</li><li>类内声明，类外初始化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;默认构造&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Person</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;析构&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-type">int</span> Person::age = <span class="hljs-number">100</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//1.使用一个已经创建完毕的对象来初始化一个新对象</span><br>    Person p1;<br>    Person p2;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person p;<br>    <span class="hljs-comment">//通过对象访问</span><br>    cout &lt;&lt; p.age &lt;&lt; endl;<br>    <span class="hljs-comment">//通过类名访问 类外不能访问私有的静态成员变量</span><br>    cout &lt;&lt; Person::age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//test();</span><br>    <span class="hljs-built_in">test2</span>();<br><br>&#125;<br></code></pre></td></tr></table></figure><p>静态成员函数</p><p>所有对象共享同一个函数</p><p>静态成员你函数只能访问静态成员变量</p><p>也有访问权限，类外调用不到</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        age = <span class="hljs-number">50</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;static&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-type">int</span> Person::age = <span class="hljs-number">100</span>;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person p;<br>    p.<span class="hljs-built_in">func</span>();<br>    Person::<span class="hljs-built_in">func</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test3</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="c对象模型和this指针">4.3 c++对象模型和this指针</h3><h4 id="成员变量和成员函数分开存储">4.3.1成员变量和成员函数分开存储</h4><p>在c++中，类内的成员变量和成员函数分开存储</p><p>只有非静态成员变量才属于类的对象上</p><p>空对象占用内存空间为1</p><p>c++编译器会给每个空对象也分配一个字节空间，是为了区分对象占内存的位置，每个空对象也应该有一个独一无二的内存地址</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp">lass Person<br>&#123;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person p;<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(p) &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test</span>();<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br>    <span class="hljs-type">int</span> m_a; <span class="hljs-comment">//非静态成员变量，属于类的对象上</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span>  b; <span class="hljs-comment">//静态成员变量，不属于类对象上 </span><br>&#125;;<br><span class="hljs-type">int</span> Person::b = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person p;<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(p) &lt;&lt; endl;<span class="hljs-comment">//sizeof(p) = 4</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test1</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="this指针概念">4.3.2 this指针概念</h4><p>this指针指向被调用的成员函数所属的对象</p><p>this指针是隐含每一个非静态成员函数内的一种指针</p><p>this指针不需要定义，直接使用即可</p><p>this指针的用途：</p><ul><li>当形参和成员变量同名时，可用this指针来区分</li><li>在类的非静态成员函数中返回对象本身，可使用return *this</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;age = age;<br>    &#125;<br>    <span class="hljs-function">Person&amp; <span class="hljs-title">PersonAddAge</span><span class="hljs-params">(Person &amp;p)</span>  <span class="hljs-comment">//引用返回p2本身</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;age += p.age;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    cout &lt;&lt; p<span class="hljs-number">1.</span>age &lt;&lt; endl;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-comment">//链式编程思想</span><br>    p<span class="hljs-number">2.</span><span class="hljs-built_in">PersonAddAge</span>(p1).<span class="hljs-built_in">PersonAddAge</span>(p1).<span class="hljs-built_in">PersonAddAge</span>(p1);<br>    cout &lt;&lt; p<span class="hljs-number">2.</span>age &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="空指针访问成员函数">4.3.3 空指针访问成员函数</h4><p>c++中空指针也是可以调用成员函数的，但是要注意有咩有用到this指针</p><p>如果用到this指针，需要加以判断保证代码的鲁棒性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowClassName</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Person&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showAge</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//传入的指针是NULL</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        cout &lt;&lt; age &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person* p = <span class="hljs-literal">NULL</span>;<br>    p-&gt;<span class="hljs-built_in">ShowClassName</span>();<br>    p-&gt;<span class="hljs-built_in">showAge</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="const修饰成员函数">4.3.4 const修饰成员函数</h4><p>常函数：</p><ul><li>不可以修改成员属性</li><li>成员属性声明时加关键字mutable后，在常函数、常对象中依然可以修改</li></ul><p>常对象：</p><ul><li>声明对象 前加const</li><li>常对象只能调用常函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//this指针的本质时指针常量，指向不可以修改</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowPerson</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-comment">//const Person* const this; const修饰this指针，让指针指向的 值也不可以修改</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//age = 100; 报错</span><br>        b = <span class="hljs-number">100</span>;<br>    &#125;<br>   <br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> b;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person p;<br>    p.<span class="hljs-built_in">ShowPerson</span>();<br>    <span class="hljs-type">const</span> Person p1;<br>    p<span class="hljs-number">1.</span><span class="hljs-built_in">ShowPerson</span>();<br>    <span class="hljs-comment">//p1.age = 100;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="友元">4.4 友元</h3><p>在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p><p>友元的目的就是让—个函数或者类访问另—个类中私有成员</p><p>友元的关键字为friend</p><p>友元的三种实现</p><ul><li>全局函数做友元·</li><li>类做友元</li><li>成员函数做友元</li></ul><h4 id="全局函数做友元">4.4.1 全局函数做友元</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">GoodGuy</span><span class="hljs-params">(Building* building)</span></span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Building</span>()<br>    &#123;<br>        livingRoom = <span class="hljs-string">&quot;客厅&quot;</span>;<br>        bedroom = <span class="hljs-string">&quot;卧室&quot;</span>;<br>    &#125;<br>    string livingRoom;<br><br><span class="hljs-keyword">private</span>:<br>    string bedroom;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GoodGuy</span><span class="hljs-params">(Building* building)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;好基友全局函数: &quot;</span> &lt;&lt; building-&gt;livingRoom &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;好基友全局函数: &quot;</span> &lt;&lt; building-&gt;bedroom &lt;&lt; endl;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Building building;<br>    <span class="hljs-built_in">GoodGuy</span>(&amp;building);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="类做友元">4.4.2 类做友元</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GoodGuy</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">GoodGuy</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Visit</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//参观函数访问building中的属性</span><br>    Building* building;<br><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span><br>&#123;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GoodGuy</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Building</span>();<br>    string sittingRoom;<br><br><span class="hljs-keyword">private</span>:<br>    string bedroom;<br><br>&#125;;<br><br>Building::<span class="hljs-built_in">Building</span>()<br>&#123;<br>    sittingRoom = <span class="hljs-string">&quot;客厅&quot;</span>;<br>    bedroom = <span class="hljs-string">&quot;卧室&quot;</span>;<br>&#125;<br><br>GoodGuy::<span class="hljs-built_in">GoodGuy</span>()<br>&#123;<br>    building = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Building</span>();<span class="hljs-comment">//堆区</span><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GoodGuy::Visit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;访问：&quot;</span> &lt;&lt; building-&gt;sittingRoom &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;访问：&quot;</span> &lt;&lt; building-&gt;bedroom &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    GoodGuy gg;<br>    gg.<span class="hljs-built_in">Visit</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="成员函数做友元">4.4.3 成员函数做友元</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GoodGuy</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">GoodGuy</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Visit</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//参观函数访问building中的属性</span><br>    Building* building;<br><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">GoodGuy::Visit</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Building</span>();<br>    string sittingRoom;<br><br><span class="hljs-keyword">private</span>:<br>    string bedroom;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="运算符重载">4.5 运算符重载</h3><h4 id="加号运算符重载">4.5.1 加号运算符重载</h4><p>实现两个自定义数据类型相加的运算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> c = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> d = <span class="hljs-number">0</span>) :<span class="hljs-built_in">a</span>(c), <span class="hljs-built_in">b</span>(d) &#123;&#125;<br><br>    <span class="hljs-comment">// 成员函数重载</span><br>    <span class="hljs-comment">//Person operator+(Person&amp; p)</span><br>    <span class="hljs-comment">//&#123;</span><br>    <span class="hljs-comment">//    Person temp;</span><br>    <span class="hljs-comment">//    temp.a = this-&gt;a + p.a;</span><br>    <span class="hljs-comment">//    temp.b = this-&gt;b + p.b;</span><br>    <span class="hljs-comment">//    return temp;</span><br>    <span class="hljs-comment">//&#125;</span><br><br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> b;<br><br>&#125;;<br><span class="hljs-comment">// 全局函数</span><br>Person <span class="hljs-keyword">operator</span>+(Person&amp; p1, Person&amp; p2)<br>&#123;<br>    Person temp;<br>    temp.a = p<span class="hljs-number">1.</span>a + p<span class="hljs-number">2.</span>a;<br>    temp.b = p<span class="hljs-number">1.</span>b + p<span class="hljs-number">2.</span>b;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>)</span></span>;<br>    Person p3 = p1 + p2;<br>    cout &lt;&lt; p<span class="hljs-number">3.</span>a &lt;&lt; endl;<br>    cout &lt;&lt; p<span class="hljs-number">3.</span>b &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="左移运算符重载">4.5.2 左移运算符重载</h4><p>只能用全局函数重载左移，</p><p>配合友元使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; cout, Person&amp; p);<br>        <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> c = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> d = <span class="hljs-number">0</span>) :<span class="hljs-built_in">a</span>(c), <span class="hljs-built_in">b</span>(d) &#123;&#125;<br><br>    <span class="hljs-comment">// 成员函数重载无法实现</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> b;<br><br>&#125;;<br><span class="hljs-comment">// 全局函数</span><br>ostream&amp;  <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;cout, Person&amp; p)<br>&#123;<br>    cout &lt;&lt; p.a &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> cout;<span class="hljs-comment">//</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>)</span></span>;<br>    cout &lt;&lt; p1 &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="递增运算符重载">4.5.3 递增运算符重载</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> c = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> d = <span class="hljs-number">0</span>) :<span class="hljs-built_in">a</span>(c), <span class="hljs-built_in">b</span>(d) &#123;&#125;<br><br>    <span class="hljs-comment">// 成员函数</span><br>    <span class="hljs-comment">//前置递增返回引用</span><br>    Person&amp; <span class="hljs-keyword">operator</span>++()<br>    &#123;<br>        a++;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-comment">//后置递增 返回值</span><br>    Person <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>)<br>    &#123;<br>        Person p = *<span class="hljs-keyword">this</span>;<br>        a++;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> b;<br><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-type">int</span> a = (++p1).a;<br>    cout &lt;&lt; a &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="赋值运算符重载">4.5.4 赋值运算符重载</h4><p>C++编泽器至少给一个类添加4个函数</p><p>1.默认构造（函数无参，函数体为空)</p><p>2.默认析构（函数无参，函数体为空）</p><p>3.默认拷贝构造函数，对属性进行值拷贝</p><p>4.赋值运算符operator=,对属性进行值拷贝</p><p>如果类中有属性指向堆区，做嘱值操作时也会出现深浅烤贝问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> l_age)<br>    &#123;<br>        age = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(l_age);<br>    &#125;<br>    ~<span class="hljs-built_in">Person</span>()<br>    &#123;<br>        <span class="hljs-keyword">if</span> (age != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">delete</span> age;<br>            age = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br>    Person&amp; <span class="hljs-keyword">operator</span>=(Person &amp;p)<br>    &#123;<br>        <span class="hljs-comment">//考虑重复释放堆区问题</span><br>        <span class="hljs-keyword">if</span> (age != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">delete</span> age;<br>            age = <span class="hljs-literal">NULL</span> ;<br>        &#125;<br>        age = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*p.age);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-type">int</span>* age;<br><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-number">30</span>)</span></span>;<br>    p1 = p2 = p3;   <br>   <br>    cout &lt;&lt; *p<span class="hljs-number">1.</span>age &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="关系运算符重载">4.5.5 关系运算符重载</h4><p>作用：重载关系运算符，可以让两个自定义类型对象进行对比操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(string l_name, <span class="hljs-type">int</span> l_age)<br>    &#123;<br>        age = (l_age);<br>        name = l_name;<br>    &#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(Person&amp; p)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (name == p.name &amp;&amp; age == p.age)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(Person&amp; p)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (name == p.name &amp;&amp; age == p.age)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    string name;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">18</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">19</span>)</span></span>;<br>    <span class="hljs-keyword">if</span> (p1 == p2)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;相等&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;不相等&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="函数调用运算符重载-仿函数">4.5.6 函数调用运算符重载 仿函数</h4><p>函数调用运算符（）也可以重载</p><p>由于重载后使用的方式非常像函数的调用，因此称为仿函数</p><p>仿函数没有固定写法，非常灵活</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(string l_name, <span class="hljs-type">int</span> l_age)<br>    &#123;<br>        age = (l_age);<br>        name = l_name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(string test)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; test &lt;&lt; endl;<br>    &#125;<br>    string name;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-comment">//仿函数灵活，无固定写法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myAdd</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> num1 + num2;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">18</span>)</span></span>;<br>    <span class="hljs-built_in">p1</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    myAdd myadd;<br>    cout &lt;&lt; <span class="hljs-built_in">myadd</span>(<span class="hljs-number">18</span>, <span class="hljs-number">16</span>) &lt;&lt; endl;<br><br>    <span class="hljs-comment">//匿名函数对象 类名()(参数)，当前行执行完，立即释放</span><br>    cout &lt;&lt; <span class="hljs-built_in">myAdd</span>()(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="继承">4.6 继承</h3><h4 id="继承的基本语法">4.6.1 继承的基本语法</h4><p>继承的好处：减少重复代码</p><p>语法：class 子类：继承方式 父类</p><p>子类也称为派生类</p><p>父类也称为基类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;class127_继承.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasePage</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">header</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;toubu&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">footer</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;底部&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">left</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;左侧&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Java</span> :<span class="hljs-keyword">public</span> BasePage<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;java&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Java ja;<br>    ja.<span class="hljs-built_in">header</span>();<br>    ja.<span class="hljs-built_in">footer</span>();<br>    ja.<span class="hljs-built_in">left</span>();<br>    ja.<span class="hljs-built_in">content</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="继承方式">4.6.2 继承方式</h4><p>继承方式一共有三种：</p><p>·公共继承</p><p>保护继承</p><p>·私有继承</p><figure><img src="/2024/11/27/cpp/9-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/1694573990164-7f69ded3-39b6-4547-8b6e-3ba4201334cc.jpeg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h4 id="继承中的对象模型">4.6.3 继承中的对象模型</h4><p>父类中所以非静态成员属性都会被子类继承下去</p><figure><img src="/2024/11/27/cpp/9-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/1694576410777-305ad4ba-f6a2-4db6-86cf-24d1dbccb52d.jpeg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h4 id="继承中的构造和析构顺序">4.6.4 继承中的构造和析构顺序</h4><p>构造 先父类后子类</p><p>析构 先子类后父类</p><h4 id="继承同名成员处理方式">4.6.5 继承同名成员处理方式</h4><figure><img src="/2024/11/27/cpp/9-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/1694576897148-586e9b25-bb6e-4989-9dfe-0f9a2af406a6.jpeg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp/9-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/1694577075484-2c54e994-ab3d-4953-9d3c-75a218000e53.jpeg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>父类需要加Base::</p><h4 id="同名静态成员处理">4.6.6 同名静态成员处理</h4><p>静态成员和耳非静态成员出现同名，处理方式一致</p><p>·访问子类同名成员直接访问即可</p><p>·访问父类同名成员需要加作用域</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> a;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;base func&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-type">int</span> Base::a = <span class="hljs-number">100</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> a;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Son func&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-type">int</span> Son::a = <span class="hljs-number">200</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//通过对象访问</span><br>Son s;<br>cout &lt;&lt; s.a &lt;&lt; endl;<br>cout &lt;&lt; s.Base::a &lt;&lt; endl;<br><span class="hljs-comment">//通过类名访问</span><br>cout &lt;&lt; Son::a &lt;&lt; endl;<br>cout &lt;&lt; Son::Base::a &lt;&lt; endl;<br><br>s.<span class="hljs-built_in">func</span>();<br>s.Base::<span class="hljs-built_in">func</span>();<br><br>Son::<span class="hljs-built_in">func</span>();<br>Son::Base::<span class="hljs-built_in">func</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多继承语法">4.6.7 多继承语法</h4><p>C++允许一个类继承多个类</p><p>语法：class 子类 ： 继承方式 父类1，继承方式 父类2，</p><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p><p>C++实际开发中不建议用多继承</p><h4 id="菱形继承">4.6.8 菱形继承</h4><figure><img src="/2024/11/27/cpp/9-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/1694603177519-44280a65-6a84-477d-b551-93fd9aafdcf9.jpeg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp/9-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/1694603178705-cefdd96c-725e-48bb-97b4-159d20c760d9.jpeg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp/9-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/1694603179516-e0568c90-09ff-47aa-9c48-2435deca7b6c.jpeg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp/9-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/1694603180518-e98d372d-1981-4da1-87da-c44d28cda714.jpeg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp/9-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/1694603181421-46dcd21e-23d5-424b-be9e-74a1d67e455e.jpeg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/cpp/9-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/1694603181953-98bd175c-6479-4b6e-9ff9-e719b7fdd7ba.jpeg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h3 id="多态">4.7 多态</h3><h4 id="多态基本概念">4.7.1 多态基本概念</h4><p>多态是c++面向对象三大特性之</p><p>多态分为两类</p><p>静态多态：函救重载和运算符重载属于静态多态，复用函数名</p><p>动态多态：派生类和虚函数实现运行时多态</p><p>静态多态和动态多态区别：</p><p>静态多态的感数地址早绑定，编泽阶段确定团数地址</p><p>动态多态的函数地址晚绑定-运行阶段确定函教地址</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span><br>&#123;<br><span class="hljs-keyword">public</span> :<br>    <span class="hljs-comment">//虚函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;animal speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Animal<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//重写函数返回值类型    函数名参数列表完全相同</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;cat speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">////执行说话的函数</span><br><span class="hljs-comment">//地址早绑定在编译阶段确定函数地址</span><br><span class="hljs-comment">// 如果想执行让猫说话，那么这个函数地址就不能提前绑定，需要在运行阶段进行绑定，地址晚绑</span><br><span class="hljs-comment">///动态多态满足条件</span><br><span class="hljs-comment">//1、有继承关系</span><br><span class="hljs-comment">//2、子类重写父类的虚函数</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSpeak</span><span class="hljs-params">(Animal &amp;animal)</span></span><br><span class="hljs-function"></span>&#123;<br>    animal.<span class="hljs-built_in">speak</span>();<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Cat cat;<br>    <span class="hljs-built_in">doSpeak</span>(cat);<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><p>多态满足条件</p><p>·有继承关系</p><p>·子类重写父类中的虚函数</p><p>多态使用条件</p><p>·父类指针或引用指向子类对象</p><p>重写：函数返回值类型函数名参数列表完全一致称为重写</p><h4 id="多态案例一计算机类">4.7.2 多态案例一、计算机类</h4><p>案例描述：</p><p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p><p>多态的优点：</p><p>· 代码组织结构清晰</p><p>` 可读性强</p><p>· 利于前期和后期的扩展以及维护</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Abstract</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> num1;<br><span class="hljs-type">int</span> num2;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddCalculator</span> : <span class="hljs-keyword">public</span> Abstract<br>&#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//如果想扩展新的功能，需求修改源码</span><br><span class="hljs-comment">// 在真是开发中提倡开闭原则</span><br><span class="hljs-comment">//开闭原则：对扩展进行开发，对修改进行关闭</span><br><span class="hljs-keyword">return</span> num1 + num2;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubCalculator</span> : <span class="hljs-keyword">public</span> Abstract<br>&#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//如果想扩展新的功能，需求修改源码</span><br><span class="hljs-comment">// 在真是开发中提倡开闭原则</span><br><span class="hljs-comment">//开闭原则：对扩展进行开发，对修改进行关闭</span><br><span class="hljs-keyword">return</span> num1 - num2;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Abstract* abs = <span class="hljs-keyword">new</span> AddCalculator;<br>abs-&gt;num1 = <span class="hljs-number">20</span>;<br>abs-&gt;num2 = <span class="hljs-number">20</span>;<br>cout &lt;&lt; abs-&gt;<span class="hljs-built_in">getResult</span>() &lt;&lt; endl;<br><span class="hljs-keyword">delete</span> abs;<br>abs = <span class="hljs-keyword">new</span> SubCalculator;<br>abs-&gt;num1 = <span class="hljs-number">20</span>;<br>abs-&gt;num2 = <span class="hljs-number">20</span>;<br>cout &lt;&lt; abs-&gt;<span class="hljs-built_in">getResult</span>() &lt;&lt; endl;<br><span class="hljs-keyword">delete</span> abs;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="纯虚函数和抽象类">4.7.3 纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容，因此可以将虚函数改为纯虚函数</p><p>纯虚函数语法：virtual 返回值类型 函数名（参数列表）=0;</p><p>当类中有了纯虚函数，这个类也称为抽象类</p><p>抽象类特点：</p><p>·无法实例化对象</p><p>·子类必须重写抽象类中的纯虚函数，否则也属于抽象类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 纯虚函数</span><br><span class="hljs-comment">//只要有一个纯虚函数，这个类称为抽象类</span><br><span class="hljs-comment">//抽象类特点：</span><br><span class="hljs-comment">// 1、无法实例化对象</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Base* base = <span class="hljs-keyword">new</span> Son;<br>base-&gt;<span class="hljs-built_in">func</span>();<br><span class="hljs-keyword">delete</span> base;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多态案例二制作饮品">4.7.4 多态案例二：制作饮品</h4><p>案例描述：</p><p>制作饮品的大致流程为：煮水·冲泡·倒入杯中·加入辅料</p><p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Drinking</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Boil</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Brew</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PourInCup</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PutSomething</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MakeDrink</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">Boil</span>();<br><span class="hljs-built_in">Brew</span>();<br><span class="hljs-built_in">PourInCup</span>();<br><span class="hljs-built_in">PutSomething</span>();<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coffee</span> : <span class="hljs-keyword">public</span> Drinking<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Boil</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;煮农夫山泉&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Brew</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;冲泡咖啡&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PourInCup</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;倒入杯中&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PutSomething</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;加入糖和牛奶&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tea</span> : <span class="hljs-keyword">public</span> Drinking<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Boil</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;煮矿泉水&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Brew</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;冲泡茶叶&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PourInCup</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;倒入杯中&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PutSomething</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;加入柠檬&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">(Drinking* d)</span></span><br><span class="hljs-function"></span>&#123;<br>d-&gt;<span class="hljs-built_in">MakeDrink</span>();<br><span class="hljs-keyword">delete</span> d;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">doWork</span>(<span class="hljs-keyword">new</span> Coffee);<br><span class="hljs-built_in">doWork</span>(<span class="hljs-keyword">new</span> Tea);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="虚析构和纯虚析构">4.7.5 虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辩到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p>解决方式：将父类中的析构函数双为析所构或老纯虚析构</p><p>虚析构和纯虚析构共性：</p><p>·可以解决类指针释放子类对象</p><p>·都需要有具体的函数实现</p><p>虚析构和纯虚析构区别：</p><p>·如果是纯虚析构，该类属于抽象类，无法实例化对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Speak</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-comment">//可以解决类指针释放子类对象</span><br><span class="hljs-comment">//virtual ~Animal() &#123;&#125;  //虚析构</span><br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Animal</span>() = <span class="hljs-number">0</span>;<span class="hljs-comment">//纯虚析构</span><br>&#125;;<br>Animal::~<span class="hljs-built_in">Animal</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;chunxigou&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Animal<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Cat</span>(string m_name)<br>&#123;<br>name = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(m_name);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;miaomiao&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">Cat</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (name != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> name;<br>name = <span class="hljs-literal">NULL</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;xigou&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;<br>string *name;<br>&#125;;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Animal* ani = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Cat</span>(<span class="hljs-string">&quot;Tom&quot;</span>);<br>ani-&gt;<span class="hljs-built_in">Speak</span>();<br><span class="hljs-keyword">delete</span> ani;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><p>1.虚析构或纯空析构就是用来解决通过父类指针释放子类对象</p><p>2.如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p><p>3,用有纯虚析构函数的类也属于抽象类</p><h4 id="多态案例三-电脑组装">4.7.6 多态案例三 电脑组装</h4><p>电脑主要组成部件为CPU(用于计算)，显卡〔用于显示)，内存条（用于存储）</p><p>将每个零件封装出抽象基类，并目提供不同的厂商生产不同的零件，例如Intel)厂商和Lenovo厂商</p><p>创建电脑类提供让电脑工作的函数井且调用每个零件工作的接口</p><p>测试时组装三台不同的电脑进行工作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cpu</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Calculate</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">VideoCard</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Display</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Memory</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Storage</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Computer</span>(Cpu* m_cpu, VideoCard* m_vc, Memory* m_mem)<br>&#123;<br>cpu = m_cpu;<br>vc = m_vc;<br>mem = m_mem;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cpu-&gt;<span class="hljs-built_in">Calculate</span>();<br>vc-&gt;<span class="hljs-built_in">Display</span>();<br>mem-&gt;<span class="hljs-built_in">Storage</span>();<br>&#125;<br>~<span class="hljs-built_in">Computer</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (cpu != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> cpu;<br>cpu = <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (vc != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> vc;<br>vc = <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (mem != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> mem;<br>mem = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">private</span>:<br>Cpu* cpu;<br>VideoCard* vc;<br>Memory* mem;<br><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelCpu</span> : <span class="hljs-keyword">public</span> Cpu<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Calculate</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;intel cpu cal&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Intelvc</span> : <span class="hljs-keyword">public</span> VideoCard<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Display</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;intel cpu display&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelMemory</span> : <span class="hljs-keyword">public</span> Memory<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Storage</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;intel cpu cal&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LenovoCpu</span> : <span class="hljs-keyword">public</span> Cpu<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Calculate</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Lenovo cpu cal&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lenovovc</span> : <span class="hljs-keyword">public</span> VideoCard<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Display</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Lenovo  display&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LenovoMemory</span> : <span class="hljs-keyword">public</span> Memory<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Storage</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Lenovo storage&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Cpu* intelCpu = <span class="hljs-keyword">new</span> IntelCpu;<br>VideoCard* intelvc = <span class="hljs-keyword">new</span> Intelvc;<br>Memory* intelMemory = <span class="hljs-keyword">new</span> IntelMemory;<br><br>Computer* computer1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Computer</span>(intelCpu, intelvc, intelMemory);<br>computer1-&gt;<span class="hljs-built_in">work</span>();<br><span class="hljs-keyword">delete</span> computer1;<br><br>Computer* computer2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Computer</span>(<span class="hljs-keyword">new</span> LenovoCpu, <span class="hljs-keyword">new</span> Lenovovc, <span class="hljs-keyword">new</span> LenovoMemory);<br>computer2-&gt;<span class="hljs-built_in">work</span>();<br><span class="hljs-keyword">delete</span> computer2;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++ 黑马</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8. 函数提高</title>
    <link href="/2024/11/27/cpp/8-%E5%87%BD%E6%95%B0%E6%8F%90%E9%AB%98/"/>
    <url>/2024/11/27/cpp/8-%E5%87%BD%E6%95%B0%E6%8F%90%E9%AB%98/</url>
    
    <content type="html"><![CDATA[<h3 id="函数默认参数">3.1 函数默认参数</h3><p>函数的形参列表中的形参是可以有默认值的</p><p>语法： 返回值类型 函数名 （参数=默认值）{}</p><h3 id="函数占位参数">3.2 函数占位参数</h3><p>占位参数可以有默认参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span>)</span></span><br><span class="hljs-function"> </span>&#123;<br>     cout &lt;&lt; <span class="hljs-string">&quot;Hello World!\n&quot;</span>;<br> &#125;<br> <br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> = <span class="hljs-number">10</span>)</span></span><br><span class="hljs-function"> </span>&#123;<br>     cout &lt;&lt; <span class="hljs-string">&quot;Hello World!\n&quot;</span>;<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>, <span class="hljs-number">3</span>);<br>     <span class="hljs-built_in">func2</span>(<span class="hljs-number">10</span>);<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="函数重载">3.3 函数重载</h3><p>作用名可以相同，提高复用性</p><h4 id="函数重载条件">3.3.1 函数重载条件</h4><ul><li>同一个作用域下</li><li>函数名称相同</li><li>函数参数类型不同或者个数不同或者顺序不同</li></ul><p>函数的返回值不可以作为函数重载的条件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>     cout &lt;&lt; <span class="hljs-string">&quot;函数调用&quot;</span> &lt;&lt; endl;<br> &#125;<br> <br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"> </span>&#123;<br>     cout &lt;&lt; <span class="hljs-string">&quot;函数调用2&quot;</span> &lt;&lt; endl;<br> &#125;<br> <br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">double</span> c)</span></span><br><span class="hljs-function"> </span>&#123;<br>     cout &lt;&lt;<span class="hljs-string">&quot;函数3&quot;</span>&lt;&lt; endl;<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">double</span> c, <span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"> </span>&#123;<br>     cout &lt;&lt; <span class="hljs-string">&quot;函数5&quot;</span> &lt;&lt; endl;<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">double</span> c)</span></span><br><span class="hljs-function"> </span>&#123;<br>     cout &lt;&lt; <span class="hljs-string">&quot;函数6&quot;</span> &lt;&lt; endl;<br> &#125;<br> <br> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-built_in">func</span>();<br>     <span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>);<br>     cout &lt;&lt; <span class="hljs-string">&quot;Hello World!\n&quot;</span>;<br> &#125;<br></code></pre></td></tr></table></figure><h4 id="函数重载注意事项">3.3.2 函数重载注意事项</h4><ul><li>引用作为重载条件</li><li>函数重载碰到函数默认参数，可能会出现二义性</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a)</span>   <span class="hljs-comment">//int &amp;a = 10; 不合法</span></span><br><span class="hljs-function"> </span>&#123;<br>     cout &lt;&lt; <span class="hljs-string">&quot;func1&quot;</span> &lt;&lt; endl;<br> &#125;<br> <br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; a)</span><span class="hljs-comment">//const int &amp;a = 10; 合法</span></span><br><span class="hljs-function"> </span>&#123;<br>     cout &lt;&lt; <span class="hljs-string">&quot;func2&quot;</span> &lt;&lt; endl;<br> &#125;<br> <br> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>     <span class="hljs-built_in">func</span>(a);<br>     <span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<br> &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>)</span>   </span><br><span class="hljs-function"> </span>&#123;<br>     cout &lt;&lt; <span class="hljs-string">&quot;func3&quot;</span> &lt;&lt; endl;<br> &#125;<br> <br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>   </span><br><span class="hljs-function"> </span>&#123;<br>     cout &lt;&lt; <span class="hljs-string">&quot;func4&quot;</span> &lt;&lt; endl;<br> &#125;<br> <br> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-built_in">func2</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">//当函数重载碰到默认参数，出现二义性，报错，尽量避免这种情况</span><br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++ 黑马</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7. 引用</title>
    <link href="/2024/11/27/cpp/7-%E5%BC%95%E7%94%A8/"/>
    <url>/2024/11/27/cpp/7-%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>给变量起一个别名</p><p>引用必须初始化，初始化后不可以改变</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br> <span class="hljs-type">int</span> &amp;b = a;<br></code></pre></td></tr></table></figure><h3 id="引用做函数参数">2.1 引用做函数参数</h3><p>函数传参时，可以利用引用让形参修饰实参，可以简化指针修改实参</p><h3 id="引用做函数返回值">2.2 引用做函数返回值</h3><p>不要返回局部变量引用</p><p>用法：函数调用作为左值</p><h3 id="引用的本质">2.3 引用的本质</h3><p>在c++内部实现是一个指针常量</p><p>int &amp;ref = a</p><p>int* const ref = &amp;a</p><p>c++推荐使用引用技术，语法方便，引用本质是指针常量</p><h3 id="常量引用">2.4 常量引用</h3><p>用来修饰形参，防止误操作</p><p>在函数形参列表中，用const修饰形参，防止形参改变实参</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++ 黑马</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6. 内存分区模型</title>
    <link href="/2024/11/27/cpp/6-%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/11/27/cpp/6-%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>内存分为四个区域：代码区、全局区、栈区、堆区</p><h3 id="程序运行前">1.1 程序运行前</h3><p>代码区是共享的、只读的，存放CPU的机器指令</p><p>全局区存放全局变量和静态变量以及常量（字符串常量、全局常量），该区域的数据在程序结束后由操作系统释放</p><h3 id="程序运行后">1.2 程序运行后</h3><p>栈区：由编译器自动分配释放，存放函数的参数值（形参），局部变量等</p><p>不要返回局部变量的地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <br> <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-type">int</span> a = <span class="hljs-number">20</span>;<br>     <span class="hljs-keyword">return</span> &amp;a;<br> &#125;<br> <br> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-type">int</span>* p = <span class="hljs-built_in">func</span>();<br>     cout &lt;&lt; *p &lt;&lt; endl; <span class="hljs-comment">//第一次可以打印正确的数字，是因为编译器做了保留</span><br>     cout &lt;&lt; *p &lt;&lt; endl; <span class="hljs-comment">//第二次这个数据就不再保留了</span><br> <br> &#125;<br></code></pre></td></tr></table></figure><p>堆区：由程序员分配释放，若程序员不是放，程序结束时由操作系统回收</p><p>在cpp中主要利用new在堆区开辟内存</p><h3 id="new关键字">1.3 new关键字</h3><p>堆区开辟的数据，由程序员手动删除，利用操作符delete</p><p>利用new创建的数据，会返回数据对应的类型的指针</p><p>利用new在堆区创建数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br> <span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<br>     <span class="hljs-keyword">return</span> p;<br> &#125;<br> <br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-type">int</span>* p = <span class="hljs-built_in">func</span>();<br>     cout &lt;&lt; *p &lt;&lt; endl;<br>     cout &lt;&lt; *p &lt;&lt; endl;<br>     cout &lt;&lt; *p &lt;&lt; endl;<br>     <span class="hljs-keyword">delete</span> p;<br> &#125;<br> <br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-type">int</span> * arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>     &#123;<br>         arr[i] = i + <span class="hljs-number">100</span>;<br>     &#125;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>     &#123;<br>         cout &lt;&lt; arr[i] &lt;&lt; endl;<br>     &#125;<br>     <span class="hljs-keyword">delete</span>[] arr;<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-built_in">test01</span>();<br>     <span class="hljs-built_in">test02</span>();<br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++ 黑马</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5. 结构体</title>
    <link href="/2024/11/27/cpp/5-%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <url>/2024/11/27/cpp/5-%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<h3 id="定义">5.1 定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span><br> &#123;<br>     string name;<br>     <span class="hljs-type">int</span> age;<br>     <span class="hljs-type">int</span> score;<br> &#125;s3;<br> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>     student s1;<br>     student s2 = &#123;<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">19</span>, <span class="hljs-number">80</span>&#125;;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="结构体数组">5.2 结构体数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> 结构体名 数组名[元素个数] = &#123;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&#125;;<br></code></pre></td></tr></table></figure><h3 id="结构体指针">5.3 结构体指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">student s = &#123; <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">19</span>, <span class="hljs-number">80</span> &#125;;<br>student* p = &amp;s;<br>cout &lt;&lt; p-&gt;age &lt;&lt; endl;<br>cout &lt;&lt; p-&gt;name &lt;&lt; endl;<br>cout &lt;&lt; p-&gt;score &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h3 id="结构体嵌套结构体">5.4 结构体嵌套结构体</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">teacher</span><br> &#123;<br>     <span class="hljs-type">int</span> id;<br>     string name;<br>     <span class="hljs-type">int</span> age;<br>     <span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> stu;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="结构体做函数参数">5.5 结构体做函数参数</h3><h3 id="const">5.6 const</h3><p>const防止误操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printStu</span><span class="hljs-params">(<span class="hljs-type">const</span> student *s)</span></span><br><span class="hljs-function"> </span>&#123;<br>     cout&lt;&lt;s-&gt;name&lt;&lt;endl;<br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++ 黑马</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4. 指针</title>
    <link href="/2024/11/27/cpp/4-%E6%8C%87%E9%92%88/"/>
    <url>/2024/11/27/cpp/4-%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h3 id="空指针">4.1 空指针</h3><p>初始化 int *p = NULL; 空指针不可访问</p><h3 id="野指针">4.2 野指针</h3><p>指向非法的内存空间</p><h3 id="const修饰指针">4.3 const修饰指针</h3><p>常量指针：指针的指向可以更改，但是指针指向的值不能更改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* p = &amp;a<br></code></pre></td></tr></table></figure><p>指针常量：指针指向的值可以更改，但是指针的指向不能更改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = &amp;a<br></code></pre></td></tr></table></figure><p>指针的指向和指向的值都不能修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = &amp;a;<br></code></pre></td></tr></table></figure><h3 id="指针和数组">4.4 指针和数组</h3><p>利用指针访问数组中的元素</p><h3 id="指针和函数">4.5 指针和函数</h3><p>利用指针做函数参数，可以修改实参的值</p><h3 id="指针数组函数">4.6 指针、数组、函数</h3>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++ 黑马</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3. 数组</title>
    <link href="/2024/11/27/cpp/3-%E6%95%B0%E7%BB%84/"/>
    <url>/2024/11/27/cpp/3-%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="一维数组">3.1 一维数组</h3><ul><li>int score[10];</li><li>int score[10] = {10,11};</li><li>int score[] = {10, 11};</li><li>根据数组名可以获取数组的长度和首地址</li></ul>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++ 黑马</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2. 运算符</title>
    <link href="/2024/11/27/cpp/2-%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2024/11/27/cpp/2-%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="逻辑运算符">2.1 逻辑运算符</h3><p>！非 &amp;&amp; 与 || 或</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++ 黑马</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. 数据类型</title>
    <link href="/2024/11/27/cpp/1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2024/11/27/cpp/1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="sizeof关键字">1.1 sizeof关键字</h3><p>sizeof（数据类型/变量）</p><h3 id="实型浮点型">1.2 实型（浮点型）</h3><p>单精度 float 4字节 7位有效数字双精度 double 8字节15-16位有效数字float a = 3.14f;double b = 3.14;科学计数法float f1 =3e2;</p><h3 id="字符型">1.3 字符型</h3><p>char ch = 'a';</p><h3 id="字符串型">1.4 字符串型</h3><p>C风格字符串 char str1[] = "hello world";string str2 = "helloworld";要包含头文件 #include &lt; string &gt;</p><h3 id="数据的输入">1.5 数据的输入</h3><p>cin&gt;&gt;a;</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>c++ 黑马</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>29. 数据库维护</title>
    <link href="/2024/11/27/mysql_bzbh/29-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%B4%E6%8A%A4/"/>
    <url>/2024/11/27/mysql_bzbh/29-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%B4%E6%8A%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="备份数据">1. 备份数据</h1><ol type="1"><li>像所有数据一样，MySQL的数据也必须经常备份。</li><li>首先刷新未写数据为了保证所有数据被写到磁盘（包括索引数据），可能需要在进行备份前使用FLUSHTABLES语句。</li></ol><h1 id="进行数据库维护">2. 进行数据库维护</h1><ol type="1"><li><p>ANALYZE TABLE，用来检查表键是否正确</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/29-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%B4%E6%8A%A4/1709369395637-7d7f6b0b-3590-479f-bafb-fb4ae7b7b61d.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>CHECK TABLE用来针对许多问题对表进行检查。</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/29-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%B4%E6%8A%A4/1709369419643-b63f9819-5a40-4802-b982-41cb51fb536b.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>CHECK TABLE支持一系列的用于MyISAM表的方式</p></li><li><ol type="1"><li>CHANGED检查自最后一次检查以来改动过的表。EXTENDED执行最彻底的检查，FAST只检查未正常关闭的表，MEDIUM检查所有被删除的链接并进行键检验，QUICK只进行快速扫描</li><li>CHECK TABLE发现和修复问题</li><li><figure><img src="/2024/11/27/mysql_bzbh/29-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%B4%E6%8A%A4/1709369494285-5f41c577-6e61-4b3a-a961-ad4b3d928308.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>如果MyISAM表访问产生不正确和不一致的结果，可能需要用REPAIRTABLE来修复相应的表。</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL必知必会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL必知必会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>28. 安全管理</title>
    <link href="/2024/11/27/mysql_bzbh/28-%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/"/>
    <url>/2024/11/27/mysql_bzbh/28-%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="访问控制">1. 访问控制</h1><ol type="1"><li>MySQL服务器的安全基础是：用户应该对他们需要的数据具有适当的访问权，既不能多也不能少</li></ol><h1 id="管理用户">2. 管理用户</h1><ol type="1"><li><p>MySQL用户账号和信息存储在名为mysql的MySQL数据库中</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/28-%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/1709368759539-0363e959-df8c-431d-b2e1-3f18f38e2ccc.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><figure><img src="/2024/11/27/mysql_bzbh/28-%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/1709368763735-807d0bbe-f577-48bf-9362-6ef9226da145.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>mysql数据库有一个名为user的表，它包含所有用户账号。user表有一个名为user的列，它存储用户登录名。新安装的服务器可能只有一个用户（如这里所示），过去建立的服务器可能具有很多用户。</li></ol></li></ol><h2 id="创建用户账号">2.1. 创建用户账号</h2><ol type="1"><li><p>为了创建一个新用户账号，使用CREATE USER语句，</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/28-%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/1709368819875-55c5b38b-b330-4912-b818-01995d623777.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>指定散列口令IDENTIFIEDBY指定的口令为纯文本，MySQL将在保存到user表之前对其进行加密。为了作为散列值指定口令，使用IDENTIFIEDBY PASSWORD。</p></li><li><p>为重新命名一个用户账号，使用RENAME USER语句，</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/28-%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/1709368886010-ccadc490-465e-45db-884a-f9df84356c55.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol><h2 id="删除用户账号">2.2. 删除用户账号</h2><ol type="1"><li><p>为了删除一个用户账号（以及相关的权限），使用DROPUSER语句，</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/28-%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/1709368911130-add4e70d-86c9-4267-8c93-5fe422fe70ca.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol><h2 id="设置访问权限">2.3. 设置访问权限</h2><ol type="1"><li><p>为看到赋予用户账号的权限，使用SHOW GRANTS FOR，</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/28-%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/1709368951673-6d6bd6a1-7f75-41ea-b1f9-40d9a60e6f4f.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>输出结果显示用户bforta有一个权限USAGE ON<em>.</em>。USAGE表示根本没有权限</li></ol></li><li><p>GRANT的用法</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/28-%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/1709369071029-a85f4403-e3be-4716-b6ba-ae2d26a6d597.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>此GRANT允许用户在crashcourse.*（crashcourse数据库的所有表）上使用SELECT</li><li>具有只读访问权限</li></ol></li><li><p>SHOW GRANTS反映这个更改</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/28-%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/1709369107145-014cfc71-939c-4e37-bb78-dcf17dce4052.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>GRANT的反操作为REVOKE，用它来撤销特定的权限</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/28-%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/1709369163060-2bcd5edd-662d-4b56-81fd-fd84a49c2240.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>GRANT和REVOKE可在几个层次上控制访问权限：</p></li><li><ol type="1"><li>整个服务器，使用GRANT ALL和REVOKE ALL</li><li>整个数据库，使用ON database.*；</li><li>特定的表，使用ON database.table</li><li>特定的列</li><li>特定的存储过程。</li></ol></li><li><p>可以授予或撤销的每个权限</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/28-%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/1709369223957-b455e10e-73d0-4893-b696-a03b8c4cf273.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><figure><img src="/2024/11/27/mysql_bzbh/28-%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/1709369232675-b7b84b95-396e-4dd0-99d2-ed7df9448db6.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>简化多次授权可通过列出各权限并用逗号分隔，将多条GRANT语句串在一起，如下所示：</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/28-%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/1709369253009-3d5df0af-32f8-48b7-9a96-3048ada58329.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol><h2 id="更改口令">2.4. 更改口令</h2><ol type="1"><li><p>为了更改用户口令，可使用SET PASSWORD语句。</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/28-%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/1709369277395-b4212fe4-09f0-41d7-8b5f-a515d55fbfa9.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>SET PASSWORD还可以用来设置你自己的口令：</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/28-%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/1709369291166-334ecc1e-b905-42d5-8c2c-4d5d4f220248.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL必知必会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL必知必会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>27. 全球化和本地化</title>
    <link href="/2024/11/27/mysql_bzbh/27-%E5%85%A8%E7%90%83%E5%8C%96%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%8C%96/"/>
    <url>/2024/11/27/mysql_bzbh/27-%E5%85%A8%E7%90%83%E5%8C%96%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="全球化和本地化">1. 全球化和本地化</h1><h1 id="使用字符集和校对顺序">2. 使用字符集和校对顺序</h1><ol type="1"><li><p>MySQL支持众多的字符集。为查看所支持的字符集完整列表</p></li><li><ol type="1"><li>show character set;</li><li>这条语句显示所有可用的字符集以及每个字符集的描述和默认校对。</li></ol></li><li><p>为了查看所支持校对的完整列表，使用以下语句</p></li><li><ol type="1"><li>show collation;</li></ol></li><li><p>通常系统管理在安装时定义一个默认的字符集和校对</p></li><li><p>在创建数据库时，指定默认的字符集和校对</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/27-%E5%85%A8%E7%90%83%E5%8C%96%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%8C%96/1709368479298-12661caf-6dcc-4546-b98d-d3398f7b15cd.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>为了给表指定字符集和校对，可使用带子句的CREATE TABLE</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/27-%E5%85%A8%E7%90%83%E5%8C%96%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%8C%96/1709368510667-d84d6bc4-d4e1-4371-9acd-d5783171119e.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>此语句创建一个包含两列的表，并且指定一个字符集和一个校对顺序。</li></ol></li><li><p>除了能指定字符集和校对的表范围外，MySQL还允许对每个列设置它们</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/27-%E5%85%A8%E7%90%83%E5%8C%96%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%8C%96/1709368560371-92392e73-6c7c-4c1f-a10d-b7314cbb1b22.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>校对在对用ORDER BY子句检索出来的数据排序时起重要的作用。</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/27-%E5%85%A8%E7%90%83%E5%8C%96%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%8C%96/1709368620266-43e905ca-7a3e-48ce-87de-53a7398708a1.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL必知必会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL必知必会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>26. 管理事务处理</title>
    <link href="/2024/11/27/mysql_bzbh/26-%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    <url>/2024/11/27/mysql_bzbh/26-%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="事务处理">1. 事务处理</h1><ol type="1"><li>事务处理（transactionprocessing）可以用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行。</li></ol><h1 id="控制事务处理">2. 控制事务处理</h1><ol type="1"><li><p>MySQL使用下面的语句来标识事务的开始：</p></li><li><ol type="1"><li>start transaction</li></ol></li></ol><h2 id="使用rollback">2.1. 使用ROLLBACK</h2><ol type="1"><li><p>MySQL的ROLLBACK命令用来回退（撤销）MySQL语句，请看下面的语句</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/26-%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/1709368083622-e8184b8d-f721-443f-af51-0c884a3ca96b.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><figure><img src="/2024/11/27/mysql_bzbh/26-%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/1709368088882-75d0850e-ef03-44ad-b8ad-7c9f46ca8a90.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>这时用一条ROLLBACK语句回退START TRANSACTION之后的所有语句</li></ol></li><li><p>ROLLBACK只能在一个事务处理内使用（在执行一条STARTTRANSACTION命令之后）</p></li></ol><h2 id="使用commit">2.2. 使用COMMIT</h2><ol type="1"><li><p>在事务处理块中，提交不会隐含地进行。为进行明确的提交，使用COMMIT语句</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/26-%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/1709368156641-2652530b-0619-41d2-b8c3-ac6152016037.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>在这个例子中，从系统中完全删除订单20010。因为涉及更新两个数据库表orders和orderItems，所以使用事务处理块来保证订单不被部分删除。最后的COMMIT语句仅在不出错时写出更改。如果第一条DELETE起作用，但第二条失败，则DELETE不会提交（实际上，它是被自动撤销的</li></ol></li><li><p>隐含事务关闭当COMMIT或ROLLBACK语句执行后，事务会自动关闭（将来的更改会隐含提交）。</p></li></ol><h2 id="使用保留点">2.3. 使用保留点</h2><ol type="1"><li><p>为了支持回退部分事务处理，必须能在事务处理块中合适的位置放置占位符。这样，如果需要回退，可以回退到某个占位符。</p></li><li><p>这些占位符称为保留点。为了创建占位符，可如下使用SAVEPOINT</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/26-%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/1709368244176-1ee7cd77-dfa7-47ba-99cb-c909f8acc83f.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>每个保留点都取标识它的唯一名字，以便在回退时，MySQL知道要回退到何处。为了回退到本例给出的保留点，可如下进行：</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/26-%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/1709368270185-7ee690a7-d209-492d-818d-02706c899253.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>保留点越多越好可以在MySQL代码中设置任意多的保留点，越多越好。为什么呢？因为保留点越多，你就越能按自己的意愿灵活地进行回退</p></li><li><p>释放保留点保留点在事务处理完成（执行一条ROLLBACK或COMMIT）后自动释放。</p></li></ol><h2 id="更改默认的提交行为">2.4. 更改默认的提交行为</h2><ol type="1"><li><p>为指示MySQL不自动提交更改，需要使用以下语句</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/26-%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/1709368323693-7980dbd9-1894-4f8d-a65d-31b3fe30fdfb.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL必知必会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL必知必会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>25. 使用触发器</title>
    <link href="/2024/11/27/mysql_bzbh/25-%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <url>/2024/11/27/mysql_bzbh/25-%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="触发器">1. 触发器</h1><ol type="1"><li><p>触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句</p></li><li><ol type="1"><li>delete;</li><li>insert;</li><li>upate</li></ol></li></ol><h1 id="创建触发器">2. 创建触发器</h1><ol type="1"><li><p>在创建触发器时，需要给出4条信息：</p></li><li><ol type="1"><li>唯一的触发器名</li><li>触发器关联的表</li><li>触发器应该响应的活动（DELETE、INSERT或UPDATE）；</li><li>触发器何时执行（处理之前或之后）</li></ol></li><li><p>保持每个数据库的触发器名唯一</p></li><li><p>触发器用CREATE TRIGGER语句创建</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/25-%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8/1709365540108-a2738124-afcc-40d2-b17e-ad5bb339d7e4.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>CREATETRIGGER用来创建名为newproduct的新触发器。触发器可在一个操作发生之前或之后执行，这里给出了AFTERINSERT，所以此触发器将在INSERT语句成功执行后执行。这个触发器还指定FOREACH ROW，因此代码对每个插入行执行。在这个例子中，文本Productadded将对每个插入的行显示一次。</li><li>为了测试这个触发器，使用INSERT语句添加一行或多行到products中，你将看到对每个成功的插入，显示Productadded消息。</li><li>仅支持表只有表才支持触发器，视图不支持（临时表也不支持）</li></ol></li><li><p>触发器按每个表每个事件每次地定义，每个表每个事件每次只允许一个触发器。因此，每个表最多支持6个触发器（每条INSERT、UPDATE和DELETE的之前和之后）。</p></li><li><p>单一触发器不能与多个事件或多个表关联，所以，如果你需要一个对INSERT和UPDATE操作执行的触发器，则应该定义两个触发器</p></li></ol><h1 id="删除触发器">3. 删除触发器</h1><p>为了删除一个触发器，可使用DROP TRIGGER语句，</p><figure><img src="/2024/11/27/mysql_bzbh/25-%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8/1709365945269-62092e1b-58dd-4ca6-b17d-28d8bc7a81f6.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>触发器不能更新或覆盖。为了修改一个触发器，必须先删除它，然后再重新创建。</p><h1 id="使用触发器">4. 使用触发器</h1><h2 id="insert触发器">4.1. INSERT触发器</h2><ol type="1"><li><p>INSERT触发器在INSERT语句执行之前或之后执行</p></li><li><ol type="1"><li>在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行</li><li>在BEFOREINSERT触发器中，NEW中的值也可以被更新（允许更改被插入的值）</li><li>对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自动生成值</li></ol></li><li><figure><img src="/2024/11/27/mysql_bzbh/25-%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8/1709366184579-13a3cc00-8ceb-4d63-8749-87687fd2b4e0.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/25-%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8/1709366192563-915e992b-27d1-47aa-a9b8-c9b8205b56da.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>BEFORE或AFTER？通常，将BEFORE用于数据验证和净化（目的是保证插入表中的数据确实是需要的数据）。本提示也适用于UPDATE触发器</p></li></ol><h2 id="delete触发器">4.2. DELETE触发器</h2><ol type="1"><li>在DELETE触发器代码内，你可以引用一个名为OLD的虚拟表，访问被删除的行；</li><li>OLD中的值全都是只读的，不能更新。</li><li>下面的例子演示使用OLD保存将要被删除的行到一个存档表中：</li><li><figure><img src="/2024/11/27/mysql_bzbh/25-%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8/1709366375640-c2600220-cf05-4ad6-83fa-7747660d8507.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol><h2 id="update触发器">4.3. UPDATE触发器</h2><ol type="1"><li>UPDATE触发器在UPDATE语句执行之前或之后执行。需要知道以下几点：</li><li>在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问以前（UPDATE语句前）的值，引用一个名为NEW的虚拟表访问新更新的值；</li><li>在BEFOREUPDATE触发器中，NEW中的值可能也被更新（允许更改将要用于UPDATE语句中的值）；</li><li>OLD中的值全都是只读的，不能更新</li><li><figure><img src="/2024/11/27/mysql_bzbh/25-%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8/1709366489365-4b0e7e36-1679-4357-844d-cb8a8f34ab67.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL必知必会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL必知必会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>24. 使用游标</title>
    <link href="/2024/11/27/mysql_bzbh/24-%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87/"/>
    <url>/2024/11/27/mysql_bzbh/24-%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<h1 id="游标">1. 游标</h1><ol type="1"><li>游标（cursor）是一个存储在MySQL服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。</li><li>游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。</li><li>只能用于存储过程不像多数DBMS，MySQL游标只能用于存储过程（和函数）</li></ol><h1 id="使用游标">2. 使用游标</h1><h2 id="创建游标">2.1. 创建游标</h2><ol type="1"><li><p>游标用DECLARE语句创建</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/24-%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87/1709363965695-9f327b28-bc0c-40e0-82d8-c153d42037eb.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol><h2 id="打开和关闭游标">2.2. 打开和关闭游标</h2><ol type="1"><li><p>游标用OPEN CURSOR语句来打开</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/24-%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87/1709364749993-a0f28878-4f37-4a61-b61f-b2d58fdcd892.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>游标处理完成后，应当使用如下语句关闭游标：</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/24-%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87/1709364756973-3af4bfd3-213a-48b6-b030-371c2251c0f0.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol><h2 id="使用游标数据">2.3. 使用游标数据</h2><ol type="1"><li>在一个游标被打开后，可以使用FETCH语句分别访问它的每一行。</li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL必知必会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL必知必会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>23. 使用存储过程</title>
    <link href="/2024/11/27/mysql_bzbh/23-%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    <url>/2024/11/27/mysql_bzbh/23-%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="存储过程">1. 存储过程</h1><ol type="1"><li>存储过程简单来说，就是为以后的使用而保存的一条或多条MySQL语句的集合。可将其视为批文件，虽然它们的作用不仅限于批处理</li></ol><h1 id="为什么要使用存储过程">2. 为什么要使用存储过程</h1><ol type="1"><li>使用存储过程有3个主要的好处，即简单、安全、高性能。显然，它们都很重要</li></ol><h1 id="使用存储过程">3. 使用存储过程</h1><h2 id="执行存储过程">3.1. 执行存储过程</h2><ol type="1"><li>MySQL称存储过程的执行为调用，因此MySQL执行存储过程的语句为CALL。</li><li><figure><img src="/2024/11/27/mysql_bzbh/23-%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/1709349782956-21a018fb-65a7-4a49-bdc3-40dc674d8e94.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>存储过程可以显示结果，也可以不显示结果，</li></ol><h2 id="创建存储过程">3.2. 创建存储过程</h2><figure><img src="/2024/11/27/mysql_bzbh/23-%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/1709349850794-87bbfde2-d9cb-4d80-b585-d73c1a4f98b7.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li><p>临时更改命令行实用程序的语句分隔符</p></li><li><figure><img src="/2024/11/27/mysql_bzbh/23-%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/1709349924277-8ed7ef27-f164-4884-bfb8-ef9eccb9c6ea.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><p>使用该存储过程</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/23-%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/1709349959735-44679d84-b2b2-4ab0-8f3d-ae70161b4c6d.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol><h2 id="删除存储过程">3.3. 删除存储过程</h2><figure><img src="/2024/11/27/mysql_bzbh/23-%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/1709349981687-f49554c4-31c8-499c-8c57-508bff3187ce.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>仅当存在时删除如果指定的过程不存在，则DROPPROCEDURE将产生一个错误。当过程存在想删除它时（如果过程不存在也不产生错误）可使用DROPPROCEDURE IF EXISTS。</li></ol><h2 id="使用参数">3.4. 使用参数</h2><ol type="1"><li><p>变量（variable）内存中一个特定的位置，用来临时存储数据。</p></li><li><figure><img src="/2024/11/27/mysql_bzbh/23-%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/1709350088837-7e6ab289-fdb5-49cd-9c70-4241acabe615.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><p>此存储过程接受3个参数：pl存储产品最低价格，ph存储产品最高价格，pa存储产品平均价格。每个参数必须具有指定的类型，这里使用十进制值。关键字OUT指出相应的参数用来从存储过程传出一个值（返回给调用者）。MySQL支持IN（传递给存储过程）、OUT（从存储过程传出，如这里所用）和INOUT（对存储过程传入和传出）类型的参数。存储过程的代码位于BEGIN和END语句内，如前所见，它们是一系列SELECT语句，用来检索值，然后保存到相应的变量（通过指定INTO关键字）</p></li><li><p>存储过程的参数允许的数据类型与表中使用的数据类型相同。</p></li><li><p>为了显示检索出的产品平均价格，可如下进行：</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/23-%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/1709350173102-45c15486-110d-4589-9228-2db3f7efff96.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>这次使用IN和OUT参数。ordertotal接受订单号并返回该订单的合计：</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/23-%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/1709362780626-5ab50b26-7427-4bf0-8ad4-1283df3d322c.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><figure><img src="/2024/11/27/mysql_bzbh/23-%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/1709362795520-ab7d8a53-8744-40bd-b869-f127aa07057b.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><figure><img src="/2024/11/27/mysql_bzbh/23-%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/1709362824015-5b8386d3-0cc9-46f7-a5d8-589fa3b4c9d7.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol><h2 id="建立智能存储过程">3.5. 建立智能存储过程</h2><figure><img src="/2024/11/27/mysql_bzbh/23-%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/1709362891184-611230aa-b959-4fec-a2b9-f562bc6191ba.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/mysql_bzbh/23-%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/1709363103764-7be60972-4a34-4ad9-bb6e-b9fdc15d91ae.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h2 id="检查存储过程">3.6. 检查存储过程</h2><p>为显示用来创建一个存储过程的CREATE语句，使用SHOW CREATEPROCEDURE语句：</p><figure><img src="/2024/11/27/mysql_bzbh/23-%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/1709363213457-d48c555f-89b4-473a-8130-a70364079976.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>限制过程状态结果 SHOW PROCEDURESTATUS列出所有存储过程。为限制其输出，可使用LIKE指定一个过滤模式，</p><figure><img src="/2024/11/27/mysql_bzbh/23-%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/1709363251901-efda8689-8522-4fb3-9bc0-3d40d7c191cc.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL必知必会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL必知必会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22. 使用视图</title>
    <link href="/2024/11/27/mysql_bzbh/22-%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE/"/>
    <url>/2024/11/27/mysql_bzbh/22-%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="视图">1. 视图</h1><ol type="1"><li>视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。</li><li>为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予</li><li>ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDERBY，那么该视图中的ORDER BY将被覆盖。</li></ol><h1 id="使用视图">2. 使用视图</h1><ol type="1"><li>视图用CREATE VIEW语句来创建。</li><li>使用SHOW CREATE VIEW viewname；来查看创建视图的语句</li><li>用DROP删除视图，其语法为DROP VIEW viewname;。</li><li>更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE OR REPLACEVIEW。</li></ol><h2 id="利用视图简化复杂的联结">2.1. 利用视图简化复杂的联结</h2><ol type="1"><li>视图的最常见的应用之一是隐藏复杂的SQL，这通常都会涉及联结</li><li><figure><img src="/2024/11/27/mysql_bzbh/22-%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE/1709348412835-3bd81496-f8b2-46be-b601-aec70f975ff2.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>这条语句创建一个名为productcustomers的视图，它联结三个表，以返回已订购了任意产品的所有客户的列表。如果执行SELECT* FROM productcustomers，将列出订购了任意产品的客户。</li><li><figure><img src="/2024/11/27/mysql_bzbh/22-%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE/1709348617620-da9cdf80-578f-492e-9c33-a29af0ab9bf8.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol><h2 id="用视图重新格式化检索出的数据">2.2.用视图重新格式化检索出的数据</h2><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/22-%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE/1709348691601-3b065612-be8c-4fee-bc2f-ee6b94b24bb5.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><figure><img src="/2024/11/27/mysql_bzbh/22-%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE/1709348774972-2ac04481-7138-458b-8e11-9aaf83542306.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol><h2 id="用视图过滤不想要的数据">2.3. 用视图过滤不想要的数据</h2><figure><img src="/2024/11/27/mysql_bzbh/22-%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE/1709348868508-585f507f-c1c8-45f2-a409-9412ca65ef06.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h2 id="使用视图与计算字段">2.4. 使用视图与计算字段</h2><figure><img src="/2024/11/27/mysql_bzbh/22-%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE/1709349157660-f9db0002-6958-4c00-8630-8a1da0639e72.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h2 id="更新视图">2.5. 更新视图</h2>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL必知必会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL必知必会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21. 创建和操纵表</title>
    <link href="/2024/11/27/mysql_bzbh/21-%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E7%BA%B5%E8%A1%A8/"/>
    <url>/2024/11/27/mysql_bzbh/21-%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E7%BA%B5%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="创建表">1. 创建表</h1><h2 id="表创建基础">1.1. 表创建基础</h2><ol type="1"><li><p>利用CREATE TABLE创建表，必须给出下列信息</p></li><li><ol type="1"><li>新表的名字，在关键字CREATE TABLE之后给出</li><li>表列的名字和定义，用逗号分隔</li><li><figure><img src="/2024/11/27/mysql_bzbh/21-%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E7%BA%B5%E8%A1%A8/1709343350324-a54143ba-e6b1-48b3-9090-0261b84c865a.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>表的主键可以在创建表时用PRIMARY KEY关键字指定。</li><li>在创建新表时，指定的表名必须不存在，否则将出错。</li><li>在创建新表时，指定的表名必须不存在，否则将出错。</li></ol></li></ol><h2 id="使用null值">1.2. 使用NULL值</h2><ol type="1"><li><p>在插入或更新行时，该列必须有值</p></li><li><p>每个表列或者是NULL列，或者是NOTNULL列，这种状态在创建时由表的定义规定。</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/21-%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E7%BA%B5%E8%A1%A8/1709344476562-711e3d02-63da-4adc-ba09-ff08d6146f9e.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><figure><img src="/2024/11/27/mysql_bzbh/21-%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E7%BA%B5%E8%A1%A8/1709344591335-2d3b7a65-e508-4098-b489-a0560a60f63e.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol><h2 id="主键再介绍">1.3. 主键再介绍</h2><ol type="1"><li>主键值必须唯一。</li><li>创建由多个列组成的主键，应该以逗号分隔的列表给出各列名，</li><li><figure><img src="/2024/11/27/mysql_bzbh/21-%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E7%BA%B5%E8%A1%A8/1709345054334-d98f6f1c-2c80-4041-907b-38d5ec491dcc.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol><h2 id="使用auto_increment">1.4. 使用AUTO_INCREMENT</h2><ol type="1"><li><p>AUTO_INCREMENT告诉MySQL，本列每当增加一行时自动增量。</p></li><li><p>每个表只允许一个AUTO_INCREMENT列，而且它必须被索引（如，通过使它成为主键）。</p></li><li><p>如何在使用AUTO_INCREMENT列时获得这个值呢？可使用last_insert_id()函数获得这个值</p></li><li><ol type="1"><li>select last_insert_id()</li><li>此语句返回最后一个AUTO_INCREMENT值，然后可以将它用于后续的MySQL语句</li></ol></li></ol><h2 id="指定默认值">1.5. 指定默认值</h2><ol type="1"><li><p>default关键字</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/21-%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E7%BA%B5%E8%A1%A8/1709346727159-0c523d39-5eee-4921-8d58-47add6aba276.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><figure><img src="/2024/11/27/mysql_bzbh/21-%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E7%BA%B5%E8%A1%A8/1709346736341-29ebea9d-d172-47fa-ae25-f82aab8e56c6.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol><h2 id="引擎类型">1.6. 引擎类型</h2><ol type="1"><li><p>CREATE TABLE语句以ENGINE=InnoDB语句结束</p></li><li><p>常见引擎</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/21-%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E7%BA%B5%E8%A1%A8/1709346825093-a964c04e-9d4d-4c9b-8ed1-8623721c2402.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol><h1 id="更新表">2. 更新表</h1><ol type="1"><li><p>更新表定义，可使用ALTER TABLE语句</p></li><li><p>为了使用ALTER TABLE更改表结构，必须给出下面的信息：</p></li><li><ol type="1"><li>在ALTER TABLE之后给出要更改的表名（该表必须存在，否则将出错）；</li><li>所做更改的列表</li></ol></li><li><figure><img src="/2024/11/27/mysql_bzbh/21-%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E7%BA%B5%E8%A1%A8/1709347341535-3ff4aa79-2394-441a-9587-a47d779670cf.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><p>ALTERTABLE的一种常见用途是定义外键。下面是用来定义本书中的表所用的外键的代码</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/21-%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E7%BA%B5%E8%A1%A8/1709347482368-dea4bcd0-5bab-41a2-8cf9-f9548a0dd522.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>复杂的表结构更改一般需要手动删除过程，它涉及以下步骤：</p></li><li><ol type="1"><li>用新的列布局创建一个新表；</li><li>使用INSERTSELECT语句（关于这条语句的详细介绍，请参阅第19章）从旧表复制数据到新表。如果有必要，可使用转换函数和计算字段；</li><li>检验包含所需数据的新表；</li><li>重命名旧表（如果确定，可以删除它）；</li><li>用旧表原来的名字重命名新表；</li><li>根据需要，重新创建触发器、存储过程、索引和外键。</li></ol></li></ol><h1 id="删除表">3. 删除表</h1><ol type="1"><li><p>删除表（删除整个表而不是其内容）非常简单，使用DROPTABLE语句即可</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/21-%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E7%BA%B5%E8%A1%A8/1709347712334-8dfe33b3-28dd-4864-bdc7-ffeb3b0b163c.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol><h1 id="重命名表">4. 重命名表</h1><ol type="1"><li>使用RENAME TABLE语句可以重命名一个表：</li><li><figure><img src="/2024/11/27/mysql_bzbh/21-%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E7%BA%B5%E8%A1%A8/1709347760868-0dd647db-136d-45f5-a0a1-76990b510a43.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL必知必会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL必知必会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20. 更新和删除数据</title>
    <link href="/2024/11/27/mysql_bzbh/20-%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE/"/>
    <url>/2024/11/27/mysql_bzbh/20-%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="更新数据">1. 更新数据</h1><ol type="1"><li><p>为了更新（修改）表中的数据，可使用UPDATE语句。</p></li><li><p>不要省略WHERE子句在使用UPDATE时一定要注意细心。因为稍不注意，就会更新表中所有行</p></li><li><p>UPDATE语句由3部分组成，分别是：</p></li><li><ol type="1"><li>要更新的表；</li><li>列名和它们的新值；</li><li>确定要更新行的过滤条件</li></ol></li><li><figure><img src="/2024/11/27/mysql_bzbh/20-%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE/1709307449058-328ae940-df9f-4fb7-b925-05281cd0a743.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><p>UPDATE语句总是以要更新的表的名字开始。在此例子中，要更新的表的名字为customers。SET命令用来将新值赋给被更新的列。</p></li><li><p>更新多个列的语法稍有不同</p></li><li><figure><img src="/2024/11/27/mysql_bzbh/20-%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE/1709307486500-37e50860-6f5b-451f-b54d-138d5c9ef520.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><p>在更新多个列时，只需要使用单个SET命令，每个“列=值”对之间用逗号分隔（最后一列之后不用逗号）。</p></li><li><p>IGNORE关键字如果用UPDATE语句更新多行，并且在更新这些行中的一行或多行时出一个现错误，则整个UPDATE操作被取消（错误发生前更新的所有行被恢复到它们原来的值）。为即使是发生错误，也继续进行更新，可使用IGNORE关键字，如下所示：UPDATEIGNORE customers…</p></li><li><p>为了删除某个列的值，可设置它为NULL（假如表定义允许NULL值）</p></li><li><figure><img src="/2024/11/27/mysql_bzbh/20-%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE/1709307729597-d6a75445-6db0-423f-8683-d55657efbd44.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol><h1 id="删除数据">2. 删除数据</h1><ol type="1"><li>delete</li><li><figure><img src="/2024/11/27/mysql_bzbh/20-%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE/1709307867847-ad4f8cd3-5ca3-4366-adf7-008719022f9e.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>更快的删除如果想从表中删除所有行，不要使用DELETE。可使用TRUNCATETABLE语句，它完成相同的工作，但速度更快（TRUNCATE实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据）。</li></ol><h1 id="更新和删除的指导原则">3. 更新和删除的指导原则</h1><ol type="1"><li>前一节中使用的UPDATE和DELETE语句全都具有WHERE子句，这样做的理由很充分。如果省略了WHERE子句，则UPDATE或DELETE将被应用到表中所有的行。</li></ol>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL必知必会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL必知必会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>19. 插入数据</title>
    <link href="/2024/11/27/mysql_bzbh/19-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/"/>
    <url>/2024/11/27/mysql_bzbh/19-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="数据插入">1. 数据插入</h1><p>INSERT是用来插入（或添加）行到数据库表的。</p><h1 id="插入完整的行">2. 插入完整的行</h1><figure><img src="/2024/11/27/mysql_bzbh/19-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/1709306001472-3d93ab09-89a4-4d8c-92e5-8bf23be93c09.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>编写INSERT语句的更安全（不过更烦琐）的方法如下</p><figure><img src="/2024/11/27/mysql_bzbh/19-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/1709306090275-397c27bb-9136-49de-8648-2143c5778cac.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/mysql_bzbh/19-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/1709306106768-3c0164b4-428b-4fa1-a21b-5c65c7c16fd3.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>因为提供了列名，VALUES必须以其指定的次序匹配指定的列名，不一定按各个列出现在实际表中的次序。其优点是，即使表的结构改变，此INSERT语句仍然能正确工作。你会发现cust_id的NULL值是不必要的，cust_id列并没有出现在列表中，所以不需要任何值。</p><h1 id="插入多个行">3. 插入多个行</h1><figure><img src="/2024/11/27/mysql_bzbh/19-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/1709306381373-de757c84-0d4b-4734-9bc4-e03318af6ab5.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/mysql_bzbh/19-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/1709306389720-fa5594ad-38c4-4b77-a21d-5f65ffab8b43.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h1 id="插入检索出的数据">4. 插入检索出的数据</h1><figure><img src="/2024/11/27/mysql_bzbh/19-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/1709306479471-5e1f8a7c-6b90-43d2-bfe0-3c38477dd5dc.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/mysql_bzbh/19-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/1709306485491-bd0a4f32-a090-4136-ad91-6c9cc8d916c1.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>MySQL甚至不关心SELECT返回的列名。它使用的是列的位置，因此SELECT中的第一列（不管其列名）将用来填充表列中指定的第一个列</p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL必知必会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL必知必会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>18. 全文本搜索</title>
    <link href="/2024/11/27/mysql_bzbh/18-%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/"/>
    <url>/2024/11/27/mysql_bzbh/18-%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="理解全文本搜索">1. 理解全文本搜索</h1><h1 id="使用全文本搜索">2. 使用全文本搜索</h1><ol type="1"><li>为了进行全文本搜索，必须索引被搜索的列，而且要随着数据的改变不断地重新索引。在对表列进行适当设计后，MySQL会自动进行所有的索引和重新索引。</li></ol><h2 id="启用全文本搜索支持">2.1. 启用全文本搜索支持</h2><ol type="1"><li>一般在创建表时启用全文本搜索。</li><li>CREATETABLE语句（第21章中介绍）接受FULLTEXT子句，它给出被索引列的一个逗号分隔的列表</li><li><figure><img src="/2024/11/27/mysql_bzbh/18-%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/1709304355062-cec3ee61-e73b-43a0-89b5-aa0ffb2cba1d.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>MySQL根据子句FULLTEXT(note_text)的指示对它进行索引。</li><li>不要在导入数据时使用FULLTEXT</li></ol><h2 id="进行全文本搜索">2.2. 进行全文本搜索</h2><ol type="1"><li>在索引之后，使用两个函数Match()和Against()执行全文本搜索，其中Match()指定被搜索的列，Against()指定要使用的搜索表达式。</li><li><figure><img src="/2024/11/27/mysql_bzbh/18-%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/1709304520467-950c8e92-d6b8-4350-bb4c-e04b75f6599b.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><figure><img src="/2024/11/27/mysql_bzbh/18-%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/1709304528708-20e21570-f1d1-468a-8e4f-6a0dc888500e.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>传递给Match()的值必须与FULLTEXT()定义中的相同。如果指定多个列，则必须列出它们（而且次序正确）。</li><li>具有较高等级的行先返回（因为这些行很可能是你真正想要的行）</li></ol><h2 id="使用查询扩展">2.3. 使用查询扩展</h2><figure><img src="/2024/11/27/mysql_bzbh/18-%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/1709304941015-15a980b0-7de4-491c-a9d6-4b399ef46088.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h2 id="布尔文本搜索">2.4. 布尔文本搜索</h2><ol type="1"><li><p>MySQL支持全文本搜索的另外一种形式，称为布尔方式（booleanmode）。</p></li><li><ol type="1"><li>要匹配的词；</li><li>要排斥的词（如果某行包含这个词，则不返回该行，即使它包含其他指定的词也是如此）；</li><li>排列提示（指定某些词比其他词更重要，更重要的词等级更高）；</li><li>表达式分组；</li><li>另外一些内容。</li></ol></li><li><p>即使没有FULLTEXT索引也可以使用布尔方式不同于迄今为止使用的全文本搜索语法的地方在于，即使没有定义FULLTEXT索引，也可以使用它。但这是一种非常缓慢的操作</p></li><li><figure><img src="/2024/11/27/mysql_bzbh/18-%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/1709305221959-1996db5d-c8ef-452d-9155-c72648b4eb56.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><figure><img src="/2024/11/27/mysql_bzbh/18-%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/1709305338384-e46a7f3b-99da-4424-8b84-b03db2558e6a.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><figure><img src="/2024/11/27/mysql_bzbh/18-%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/1709305449388-e6582f26-41c9-4fba-96de-c3c775ef4b1f.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><figure><img src="/2024/11/27/mysql_bzbh/18-%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/1709305567066-ffe602ad-68bb-45e9-bad5-2f401c5e13d5.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><figure><img src="/2024/11/27/mysql_bzbh/18-%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/1709305579041-ed33aa07-f621-40b6-a328-5452ddf48fd6.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><figure><img src="/2024/11/27/mysql_bzbh/18-%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/1709305652042-bfc0e763-9292-4042-9d3f-82c8bd86f9a6.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol><h2 id="全文本搜索的使用说明">2.5. 全文本搜索的使用说明</h2>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL必知必会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL必知必会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>17. 组合查询</title>
    <link href="/2024/11/27/mysql_bzbh/17-%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2/"/>
    <url>/2024/11/27/mysql_bzbh/17-%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="组合查询">1. 组合查询</h1><ol type="1"><li>多数SQL查询都只包含从一个或多个表中返回数据的单条SELECT语句。MySQL也允许执行多个查询（多条SELECT语句），并将结果作为单个查询结果集返回。这些组合查询通常称为并（union）或复合查询（compoundquery）。</li></ol><h1 id="创建组合查询">2. 创建组合查询</h1><p>利用union</p><h2 id="使用union">2.1. 使用union</h2><ol type="1"><li>给出每条SELECT语句，在各条语句之间放上关键字UNION。</li><li><figure><img src="/2024/11/27/mysql_bzbh/17-%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2/1709303418767-66f2f993-694d-4729-8544-4338535d6825.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>这条语句由前面的两条SELECT语句组成，语句中用UNION关键字分隔。UNION指示MySQL执行两条SELECT语句，并把输出组合成单个查询结果集</li></ol><h2 id="union规则">2.2. union规则</h2><ol type="1"><li>UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔</li><li>UNION中的每个查询必须包含相同的列、表达式或聚集函数（不过各个列不需要以相同的次序列出）。</li><li>列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型</li></ol><h2 id="包含或取消重复的行">2.3. 包含或取消重复的行</h2><ol type="1"><li>UNION从查询结果集中自动去除了重复的行</li><li>返回所有匹配行，可使用UNION ALL而不是UNION</li><li>使用UNION ALL，MySQL不取消重复的行。</li></ol><h2 id="对组合查询结果排序">2.4. 对组合查询结果排序</h2><ol type="1"><li>SELECT语句的输出用ORDERBY子句排序。在用UNION组合查询时，只能使用一条ORDERBY子句，它必须出现在最后一条SELECT语句之后。</li><li><figure><img src="/2024/11/27/mysql_bzbh/17-%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2/1709303645160-a65d34d2-b4d1-490e-9f12-4454c31cbb77.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL必知必会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL必知必会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>16. 创建高级联结</title>
    <link href="/2024/11/27/mysql_bzbh/16-%E5%88%9B%E5%BB%BA%E9%AB%98%E7%BA%A7%E8%81%94%E7%BB%93/"/>
    <url>/2024/11/27/mysql_bzbh/16-%E5%88%9B%E5%BB%BA%E9%AB%98%E7%BA%A7%E8%81%94%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="使用表别名">1. 使用表别名</h1><ol type="1"><li><p>SQL还允许给表名起别名。</p></li><li><ol type="1"><li>缩短SQL语句；</li><li>允许在单条SELECT语句中多次使用相同的表。</li></ol></li><li><figure><img src="/2024/11/27/mysql_bzbh/16-%E5%88%9B%E5%BB%BA%E9%AB%98%E7%BA%A7%E8%81%94%E7%BB%93/1709298522973-2b93cc41-368c-45be-a2df-0d23b0f2997c.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><p>表别名只在查询执行中使用。与列别名不一样，表别名不返回到客户机。</p></li></ol><h1 id="使用不同类型的联结">2. 使用不同类型的联结</h1><h2 id="自联结">2.1. 自联结</h2><figure><img src="/2024/11/27/mysql_bzbh/16-%E5%88%9B%E5%BB%BA%E9%AB%98%E7%BA%A7%E8%81%94%E7%BB%93/1709298610673-b9ea5290-f806-41f5-b70f-64dac9b2afe3.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h2 id="自然联结">2.2. 自然联结</h2><ol type="1"><li>自然联结排除多次出现，使每个列只返回一次。</li><li>然联结是这样一种联结，其中你只能选择那些唯一的列。这一般是通过对表使用通配符（SELECT*），对所有其他表的列使用明确的子集来完成的</li><li><figure><img src="/2024/11/27/mysql_bzbh/16-%E5%88%9B%E5%BB%BA%E9%AB%98%E7%BA%A7%E8%81%94%E7%BB%93/1709299273520-6cef0e6d-9fdc-4931-8bab-f9fc85042785.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol><h2 id="外部联结">2.3. 外部联结</h2><figure><img src="/2024/11/27/mysql_bzbh/16-%E5%88%9B%E5%BB%BA%E9%AB%98%E7%BA%A7%E8%81%94%E7%BB%93/1709299396493-fbe82e91-7a88-4572-ad68-d40325b06a43.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>联结包含了那些在相关表中没有关联行的行。这种类型的联结称为外部联结。</li><li>外部联结语法类似。为了检索所有客户，包括那些没有订单的客户，可如下进行：</li><li><figure><img src="/2024/11/27/mysql_bzbh/16-%E5%88%9B%E5%BB%BA%E9%AB%98%E7%BA%A7%E8%81%94%E7%BB%93/1709299419135-4fe66dfd-31f7-40ad-a06f-d2b4d4d880ab.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>这条SELECT语句使用了关键字OUTERJOIN来指定联结的类型（而不是在WHERE子句中指定）。但是，与内部联结关联两个表中的行不同的是，外部联结还包括没有关联行的行。在使用OUTERJOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表（RIGHT指出的是OUTERJOIN右边的表，而LEFT指出的是OUTER JOIN左边的表）。</li><li>为了从右边的表中选择所有行，应该使用RIGHT OUTER JOIN，</li><li><figure><img src="/2024/11/27/mysql_bzbh/16-%E5%88%9B%E5%BB%BA%E9%AB%98%E7%BA%A7%E8%81%94%E7%BB%93/1709299578056-6893dd66-3c10-4b03-8902-7e18377967a7.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol><h1 id="使用带聚集函数的联结">3. 使用带聚集函数的联结</h1><figure><img src="/2024/11/27/mysql_bzbh/16-%E5%88%9B%E5%BB%BA%E9%AB%98%E7%BA%A7%E8%81%94%E7%BB%93/1709302853227-5c478efe-9a64-4c5e-83cd-21f3a5c30c73.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/mysql_bzbh/16-%E5%88%9B%E5%BB%BA%E9%AB%98%E7%BA%A7%E8%81%94%E7%BB%93/1709302863943-b87aea8f-138a-4767-934b-d9f2ef7658ef.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL必知必会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL必知必会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15. 联结表</title>
    <link href="/2024/11/27/mysql_bzbh/15-%E8%81%94%E7%BB%93%E8%A1%A8/"/>
    <url>/2024/11/27/mysql_bzbh/15-%E8%81%94%E7%BB%93%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="联结">1. 联结</h1><h2 id="关系表">1.1. 关系表</h2><ol type="1"><li>外键（foreignkey）外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。</li><li>可伸缩性（scale）能够适应不断增加的工作量而不失败。设计良好的数据库或应用程序称之为可伸缩性好（scalewell）。</li><li>如果数据存储在多个表中，怎样用单条SELECT语句检索出数据？答案是使用联结。</li><li>联结是一种机制，用来在一条SELECT语句中关联表，因此称之为联结。</li></ol><h1 id="创建联结">2. 创建联结</h1><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/15-%E8%81%94%E7%BB%93%E8%A1%A8/1709297779666-4d9890ce-7df7-45e9-bca8-de59e57dd488.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>与以前的SELECT语句不一样，这条语句的FROM子句列出了两个表，分别是vendors和products。它们就是这条SELECT语句联结的两个表的名字。这两个表用WHERE子句正确联结，WHERE子句指示MySQL匹配vendors表中的vend_id和products表中的vend_id。</li></ol><h2 id="where子句的重要性">2.1. WHERE子句的重要性</h2><ol type="1"><li><p>笛卡儿积（cartesianproduct）由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/15-%E8%81%94%E7%BB%93%E8%A1%A8/1709298000653-5299ad2a-eb7c-4da9-81ec-82e4d15c27c6.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol><h2 id="内部联结">2.2. 内部联结</h2><ol type="1"><li>目前为止所用的联结称为等值联结（equijoin），它基于两个表之间的相等测试。这种联结也称为内部联结。</li><li><figure><img src="/2024/11/27/mysql_bzbh/15-%E8%81%94%E7%BB%93%E8%A1%A8/1709298116390-eb17ebbb-177f-4b4c-a45f-e6b036594ee3.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>此语句中的SELECT与前面的SELECT语句相同，但FROM子句不同。这里，两个表之间的关系是FROM子句的组成部分，以INNERJOIN指定。在使用这种语法时，联结条件用特定的ON子句而不是WHERE子句给出。传递给ON的实际条件与传递给WHERE的相同。</li></ol><h2 id="联结多个表">2.3. 联结多个表</h2><ol type="1"><li>SQL对一条SELECT语句中可以联结的表的数目没有限制。</li><li>MySQL在运行时关联指定的每个表以处理联结。这种处理可能是非常耗费资源的，因此应该仔细，不要联结不必要的表。联结的表越多，性能下降越厉害。</li><li><figure><img src="/2024/11/27/mysql_bzbh/15-%E8%81%94%E7%BB%93%E8%A1%A8/1709298306319-1ffe32aa-822e-4c96-ba7a-1fd0c0328a88.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>子查询并不总是执行复杂SELECT操作的最有效的方法，下面是使用联结的相同查询：</li><li><figure><img src="/2024/11/27/mysql_bzbh/15-%E8%81%94%E7%BB%93%E8%A1%A8/1709298365209-bd13a811-e615-44f5-8fc7-d4bc12a0c241.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL必知必会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL必知必会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>14. 使用子查询</title>
    <link href="/2024/11/27/mysql_bzbh/14-%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2/"/>
    <url>/2024/11/27/mysql_bzbh/14-%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="子查询">1. 子查询</h1><ol type="1"><li>查询（query）任何SQL语句都是查询。但此术语一般指SELECT语句。</li></ol><h1 id="利用子查询进行过滤">2. 利用子查询进行过滤</h1><ol type="1"><li></li></ol><figure><img src="/2024/11/27/mysql_bzbh/14-%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2/1709296764469-91b78a45-90b3-4d8c-a2a8-3c359b7db66f.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li><p>在SELECT语句中，子查询总是从内向外处理。在处理上面的SELECT语句时，MySQL实际上执行了两个操作</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/14-%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2/1709296823200-8b0179c9-a8d2-470c-b055-8f8563aaa2a5.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><figure><img src="/2024/11/27/mysql_bzbh/14-%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2/1709296830454-2085e010-651f-42e0-a4c2-128cd5f654a5.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>在WHERE子句中使用子查询能够编写出功能很强并且很灵活的SQL语句。对于能嵌套的子查询的数目没有限制，不过在实际使用时由于性能的限制，不能嵌套太多的子查询。</p></li><li><p>虽然子查询一般与IN操作符结合使用，但也可以用于测试等于（=）、不等于（&lt;&gt;）等。</p></li></ol><h1 id="作为计算字段使用子查询">3. 作为计算字段使用子查询</h1><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/14-%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2/1709297335999-7c879e14-6a32-4a34-9d2f-42e2f5cdcf23.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><p>相关子查询（correlated subquery）涉及外部查询的子查询。</p></li><li><p>任何时候只要列名可能有多义性，就必须使用这种语法（表名和列名由一个句点分隔）。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL必知必会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL必知必会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>13. 分组数据</title>
    <link href="/2024/11/27/mysql_bzbh/13-%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE/"/>
    <url>/2024/11/27/mysql_bzbh/13-%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="数据分组">1. 数据分组</h1><h1 id="创建分组">2. 创建分组</h1><ol type="1"><li><p>group by</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/13-%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE/1709295017286-d3149aee-dceb-4a0b-9c62-c179bf4fc541.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。</li><li>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前</li></ol></li><li><p>使用ROLLUP使用WITHROLLUP关键字，可以得到每个分组以及每个分组汇总级别（针对每个分组）的值</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/13-%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE/1709295683630-d1b3822d-5c84-4649-8b1e-64946cf7dc90.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><figure><img src="/2024/11/27/mysql_bzbh/13-%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE/1709295748704-a4dbe3ef-4734-4c2c-a10c-e9005cee7c7f.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol><h1 id="过滤分组">3. 过滤分组</h1><ol type="1"><li><p>而HAVING过滤分组</p></li><li><p>HAVING支持所有WHERE操作符</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/13-%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE/1709295836933-582f6a3d-1843-4e1e-8a94-55cd6330e606.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>这条SELECT语句的前3行类似于上面的语句。最后一行增加了HAVING子句，它过滤COUNT(*)&gt;=2（两个以上的订单）的那些分组。</li></ol></li><li><p>它列出具有2个（含）以上、价格为10（含）以上的产品的供应商：</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/13-%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE/1709296196268-47df8f6f-0f7e-46f1-b895-1e2c62ceb5df.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol><h1 id="分组和排序">4. 分组和排序</h1><figure><img src="/2024/11/27/mysql_bzbh/13-%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE/1709296250260-ba274c64-9041-4894-9f5b-2a36471b83c7.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/mysql_bzbh/13-%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE/1709296318371-f5ab8914-28a6-45ba-9fce-b77569ca8fab.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h1 id="select子句顺序">5. select子句顺序</h1><figure><img src="/2024/11/27/mysql_bzbh/13-%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE/1709296371345-2267b720-2be7-48dd-8090-ff3a87d01a4f.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/mysql_bzbh/13-%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE/1709296381960-5a29ed7e-e7f1-4398-8fad-64a08483e544.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL必知必会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL必知必会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12. 汇总数据</title>
    <link href="/2024/11/27/mysql_bzbh/12-%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE/"/>
    <url>/2024/11/27/mysql_bzbh/12-%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="聚集函数">1. 聚集函数</h1><ol type="1"><li>聚集函数（aggregatefunction）运行在行组上，计算和返回单个值的函数</li><li><figure><img src="/2024/11/27/mysql_bzbh/12-%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE/1709292321228-ef9a78e1-a70c-49bc-9638-0fa021a78ac7.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol><h2 id="avg函数">1.1. avg()函数</h2><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/12-%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE/1709292350761-1d52b9ba-8765-42ff-849a-6638c2de32a5.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><p>AVG()也可以用来确定特定列或行的平均值。下面的例子返回特定供应商所提供产品的平均价格</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/12-%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE/1709292391061-7a928902-acbc-4c4b-bbba-4428835c275f.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>NULL值AVG()函数忽略列值为NULL的行。</p></li><li><p><strong>只用于单个列</strong>AVG()只能用来确定特定数值列的平均值，而且列名必须作为函数参数给出。为了获得多个列的平均值，必须使用多个AVG()函数。</p></li></ol><h2 id="count函数">1.2. count()函数</h2><ol type="1"><li><p>用COUNT()确定表中行的数目或符合特定条件的行的数目。</p></li><li><p>COUNT()函数有两种使用方式。</p></li><li><ol type="1"><li>使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值。</li><li>使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值。</li><li><figure><img src="/2024/11/27/mysql_bzbh/12-%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE/1709292603421-897e91c1-540c-404f-88f9-a02afd028214.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><figure><img src="/2024/11/27/mysql_bzbh/12-%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE/1709292625982-bfac2924-0f40-46f4-91de-18896b8e0dd6.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol><h2 id="max函数">1.3. max()函数</h2><ol type="1"><li><p>MAX()返回指定列中的最大值。MAX()要求指定列名</p></li><li><ol type="1"><li><figure><img src="https://cdn.nlark.com/yuque/0/2024/png/35229143/1709292673362-08298e58-4788-463d-9d38-7c2490f4fff3.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>对非数值数据使用MAX()虽然MAX()一般用来找出最大的数值或日期值，但MySQL允许将它用来返回任意列中的最大值，包括返回文本列中的最大值。在用于文本数据时，如果数据按相应的列排序，则MAX()返回最后一行。</p></li><li><p>MAX()函数忽略列值为NULL的行。</p></li></ol><h2 id="min函数">1.4. min()函数</h2><ol type="1"><li>MIN()的功能正好与MAX()功能相反，它返回指定列的最小值。</li></ol><figure><img src="/2024/11/27/mysql_bzbh/12-%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE/1709292750357-0e94a7e9-4e85-437f-93a6-fa28bef3ae9e.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>对非数值数据使用MIN()MIN()函数与MAX()函数类似，MySQL允许将它用来返回任意列中的最小值，包括返回文本列中的最小值。在用于文本数据时，如果数据按相应的列排序，则MIN()返回最前面的行。</li></ol><h2 id="sum函数">1.5. sum()函数</h2><ol type="1"><li><p>SUM()用来返回指定列值的和（总计）。</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/12-%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE/1709292973683-1f12793f-38f5-463f-bed4-c56ea27ba8aa.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>SUM()也可以用来合计计算值</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/12-%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE/1709293002183-43df0b6d-cc97-4a56-b5fa-af3566725771.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>SUM()函数忽略列值为NULL的行。</li></ol></li></ol><h1 id="聚集不同值">2. 聚集不同值</h1><ol type="1"><li><p>聚集函数的DISTINCT的使用</p></li><li><ol type="1"><li><figure><img src="https://cdn.nlark.com/yuque/0/2024/png/35229143/1709294624187-45f1d39c-76f9-4913-954a-608d1c564258.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>以上5个聚集函数都可以如下使用：</p></li><li><ol type="1"><li>对所有的行执行计算，指定ALL参数或不给参数（因为ALL是默认行为）；</li><li>只包含不同的值，指定DISTINCT参数。</li><li>ALL为默认ALL参数不需要指定，因为它是默认行为。如果不指定DISTINCT，则假定为ALL。</li></ol></li><li><p>如果指定列名，则DISTINCT只能用于COUNT()。DISTINCT不能用于COUNT(*)，因此不允许使用COUNT（DISTINCT），否则会产生错误。类似地，DISTINCT必须使用列名，不能用于计算或表达式。</p></li></ol><h1 id="组合聚集函数">3. 组合聚集函数</h1><ol type="1"><li>实际上SELECT语句可根据需要包含多个聚集函数。</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2024/png/35229143/1709294752463-abd2e5c9-0c4e-476c-8acc-cbbc7b1f5330.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="https://cdn.nlark.com/yuque/0/2024/png/35229143/1709294759665-305b2b19-7838-423e-8f16-4a092980d344.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL必知必会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL必知必会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11. 使用数据处理函数</title>
    <link href="/2024/11/27/mysql_bzbh/11-%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/"/>
    <url>/2024/11/27/mysql_bzbh/11-%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="函数">1. 函数</h1><h1 id="使用函数">2. 使用函数</h1><h2 id="文本处理函数">2.1. 文本处理函数</h2><figure><img src="/2024/11/27/mysql_bzbh/11-%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/1709290733408-606d6fc3-bcff-491a-a1ae-cc8463d8c90a.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li><p>Upper（）</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/11-%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/1709290753539-62c29f43-f6c4-4b42-9f22-5597f15e18f9.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><figure><img src="/2024/11/27/mysql_bzbh/11-%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/1709290909490-513a0f94-317e-4711-9e3d-80c3109053c5.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法。SOUNDEX考虑了类似的发音字符和音节，使得能对串进行发音比较而不是字母比较</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/11-%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/1709291557152-4263219e-e23b-4d99-9a15-da4a32fe60f4.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol><h2 id="日期和时间处理函数">2.2. 日期和时间处理函数</h2><figure><img src="/2024/11/27/mysql_bzbh/11-%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/1709291614367-de1c6d01-c12e-4b1c-86a1-9ffc4a769ab3.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li><p>Date（）</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/11-%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/1709291722780-14d87b67-24dc-40f5-bbbb-7b434fb50dd9.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>如果要的是日期，请使用Date()如果你想要的仅是日期，则使用Date()是一个良好的习惯，即使你知道相应的列只包含日期也是如此。这样，如果由于某种原因表中以后有日期和时间值，你的SQL代码也不用改变。当然，也存在一个Time()函数，在你只想要时间时应该使用它。</p></li><li><p>想检索出2005年9月下的所有订单</p></li><li><ol type="1"><li>between</li></ol></li><li><ol type="1"><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/11-%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/1709292094788-5dc1b527-6c1f-4b2b-9d49-ce68fb595e0a.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol></li><li><ol type="1"><li>year and month</li></ol></li></ol><h2 id="数值处理函数">2.3. 数值处理函数</h2><figure><img src="/2024/11/27/mysql_bzbh/11-%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/1709292164259-6194f36a-992e-423c-90b9-149363127e80.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL必知必会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL必知必会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10. 创建计算字段</title>
    <link href="/2024/11/27/mysql_bzbh/10-%E5%88%9B%E5%BB%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5/"/>
    <url>/2024/11/27/mysql_bzbh/10-%E5%88%9B%E5%BB%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="计算字段">1. 计算字段</h1><h1 id="拼接字段">2. 拼接字段</h1><ol type="1"><li><p>拼接（concatenate）将值联结到一起构成单个值。</p></li><li><p>在MySQL的SELECT语句中，可使用Concat()函数来拼接两个列</p></li><li><p>select concat(列1，'('，列2，')'）from 表 order by 列；</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/10-%E5%88%9B%E5%BB%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5/1709269185000-57620421-1242-4d66-a85e-5cf592549dbe.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>删除数据右侧多余的空格Rtrim（）函数</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/10-%E5%88%9B%E5%BB%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5/1709269223840-4c199eb3-d6d6-489c-93c4-ff5822dfd871.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>Trim函数MySQL除了支持RTrim()（正如刚才所见，它去掉串右边的空格），还支持LTrim()（去掉串左边的空格）以及Trim()（去掉串左右两边的空格）。</p></li><li><p>SQL支持列别名。别名（alias）是一个字段或值的替换名。AS</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/10-%E5%88%9B%E5%BB%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5/1709269304147-44393f90-d5a9-405b-9162-6a3c4dbafdc0.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol><h1 id="执行算数计算">3. 执行算数计算</h1><figure><img src="/2024/11/27/mysql_bzbh/10-%E5%88%9B%E5%BB%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5/1709269528335-6038d03e-6d8a-47c4-ab82-2b7fc5bb38cd.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li><p>支持算数操作符</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/10-%E5%88%9B%E5%BB%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5/1709269571958-80e77549-4eb1-4998-89a0-1b07347eea04.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL必知必会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL必知必会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9. 用正则表达式进行搜索</title>
    <link href="/2024/11/27/mysql_bzbh/9-%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%90%9C%E7%B4%A2/"/>
    <url>/2024/11/27/mysql_bzbh/9-%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="正则表达式介绍">1. 正则表达式介绍</h1><ol type="1"><li>正则表达式是用来匹配文本的特殊的串（字符集合）。</li></ol><h1 id="使用mysql正则表达式">2. 使用MySQL正则表达式</h1><h2 id="基本字符匹配">2.1. 基本字符匹配</h2><ol type="1"><li><p>REGEXP</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/9-%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%90%9C%E7%B4%A2/1709255000314-30aa6088-177b-4e6e-9947-1971f57d9e02.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>REGEXP后所跟的东西作为正则表达式（与文字正文1000匹配的一个正则表达式）处理</li></ol></li><li><p>.</p></li><li><ol type="1"><li><figure><img src="https://cdn.nlark.com/yuque/0/2024/png/35229143/1709255053054-547a93ba-96b5-473a-8187-04ddb7160dc5.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>是正则表达式语言中一个特殊的字符。它表示匹配任意一个字符</li><li>LIKE匹配整个列。如果被匹配的文本在列值中出现，LIKE将不会找到它，相应的行也不被返回（除非使用通配符）。而REGEXP在列值内进行匹配，如果被匹配的文本在列值中出现，REGEXP将会找到它，相应的行将被返回。</li></ol></li></ol><h2 id="进行or匹配">2.2. 进行OR匹配</h2><ol type="1"><li><div class="line-block"></div></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/9-%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%90%9C%E7%B4%A2/1709256076136-4cb06a73-d492-43f2-8de2-580f0712517f.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol><h2 id="匹配几个字符之一">2.3. 匹配几个字符之一</h2><ol type="1"><li><p>[]</p></li><li><ol type="1"><li>匹配任何单一字符</li><li><figure><img src="/2024/11/27/mysql_bzbh/9-%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%90%9C%E7%B4%A2/1709256158003-3143cc9d-e156-4f51-a6ce-700c9856216d.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>^</p></li><li><ol type="1"><li>字符集合也可以被否定，即，它们将匹配除指定字符外的任何东西。为否定一个字符集，在集合的开始处放置一个^即可。因此，尽管[123]匹配字符1、2或3，但[^123]却匹配除这些字符外的任何东西。</li></ol></li></ol><h2 id="匹配范围">2.4. 匹配范围</h2><ol type="1"><li><p>范围不限于完整的集合，[1-3]和[6-9]也是合法的范围。此外，范围不一定只是数值的，[a-z]匹配任意字母字符。</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/9-%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%90%9C%E7%B4%A2/1709256291260-e3a93c82-a569-4e61-a192-75f5939ef40e.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol><h2 id="匹配特殊字符">2.5. 匹配特殊字符</h2><ol type="1"><li><p>为了匹配特殊字符，必须用\为前导。\-表示查找-，\.表示查找.。</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/9-%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%90%9C%E7%B4%A2/1709267866061-5c6c47f1-426d-45e2-a0cf-e8bf876c801a.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>\也用来引用元字符（具有特殊含义的字符）</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/9-%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%90%9C%E7%B4%A2/1709267885479-0f4fd154-8211-49c7-90de-dbec080044ab.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol><h2 id="匹配字符类">2.6. 匹配字符类</h2><figure><img src="https://cdn.nlark.com/yuque/0/2024/png/35229143/1709267971110-5bf20e50-ae10-4b95-8df2-88b453ac7183.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h2 id="匹配多个实例">2.7. 匹配多个实例</h2><figure><img src="/2024/11/27/mysql_bzbh/9-%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%90%9C%E7%B4%A2/1709268032805-b50c73cf-cec9-4349-843f-bd351d78c6a7.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li><p>？匹配匹配它前面的任何字符的0次或1次出现</p></li><li><ol type="1"><li><figure><img src="https://cdn.nlark.com/yuque/0/2024/png/35229143/1709268141659-43bea8bd-26f1-4a1f-b014-2448c30afd16.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>{n}</p></li><li><ol type="1"><li><figure><img src="https://cdn.nlark.com/yuque/0/2024/png/35229143/1709268209646-3ff26f1c-b2b0-4179-a7c0-718ba626506f.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol><h2 id="定位符">2.8. 定位符</h2><figure><img src="https://cdn.nlark.com/yuque/0/2024/png/35229143/1709268528336-2f816bbd-a7a7-4243-bed9-f7836af99263.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>^</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2024/png/35229143/1709268561611-f3126a99-1fb0-4dca-9446-6a00ecd989f7.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li><sup>的双重用途</sup>有两种用法。在集合中（用[和]定义），用它来否定该集合，否则，用来指串的开始处</li><li>使REGEXP起类似LIKE的作用本章前面说过，LIKE和REGEXP的不同在于，LIKE匹配整个串而REGEXP匹配子串。利用定位符，通过用^开始每个表达式，用$结束每个表达式，可以使REGEXP的作用与LIKE一样</li><li><figure><img src="/2024/11/27/mysql_bzbh/9-%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%90%9C%E7%B4%A2/1709268721247-fd0fa368-1b3b-4f53-8718-a0c37528f620.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL必知必会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL必知必会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8. 用通配符进行过滤</title>
    <link href="/2024/11/27/mysql_bzbh/8-%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4/"/>
    <url>/2024/11/27/mysql_bzbh/8-%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="like操作符">1. Like操作符</h1><ol type="1"><li>通配符（wildcard）用来匹配值的一部分的特殊字符</li></ol><h2 id="百分号通配符">1.1. 百分号（%）通配符</h2><ol type="1"><li><p>在搜索串中，%表示任何字符出现任意次数。</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/8-%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4/1709254266244-2a926d88-2755-4211-8478-26b2e8b58770.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>此例子使用了搜索模式'jet%'。在执行这条子句时，将检索任意以jet起头的词。%告诉MySQL接受jet之后的任意字符，不管它有多少字符。</li><li>区分大小写根据MySQL的配置方式，搜索可以是区分大小写的。如果区分大小写，'jet%'与JetPack1000将不匹配</li></ol></li><li><p>通配符可在搜索模式中任意位置使用，并且可以使用多个通配符。下面的例子使用两个通配符，它们位于模式的两端</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/8-%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4/1709254331977-f88f561e-0a08-4488-a18e-7ac8be6536aa.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><figure><img src="/2024/11/27/mysql_bzbh/8-%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4/1709254338929-ba0046b9-cd14-4e6d-b77c-8c1abafce15a.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>通配符也可以出现在搜索模式的中间，虽然这样做不太有用。下面的例子找出以s起头以e结尾的所有产品：</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/8-%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4/1709254359653-30fe22a0-f867-437e-9c94-545fea6b4d06.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>%代表搜索模式中给定位置的0个、1个或多个字符。</li></ol></li><li><p>注意尾空格尾空格可能会干扰通配符匹配。例如，在保存词anvil时，如果它后面有一个或多个空格，则子句WHEREprod_name LIKE'%anvil'将不会匹配它们，因为在最后的l后有多余的字符。解决这个问题的一个简单的办法是在搜索模式最后附加一个%。一个更好的办法是使用函数（第11章将会介绍）去掉首尾空格。</p></li><li><p>注意NULL虽然似乎%通配符可以匹配任何东西，但有一个例外，即NULL。即使是WHEREprod_name LIKE '%'也不能匹配用值NULL作为产品名的行</p></li></ol><h2 id="下划线_通配符">1.2. 下划线（_)通配符</h2><ol type="1"><li><p>下划线的用途与%一样，但下划线只匹配单个字符而不是多个字符。</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/8-%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4/1709254464941-7339b07e-0fdb-481f-be7b-ae548dc52d7f.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>与%能匹配0个字符不一样，_总是匹配一个字符，不能多也不能少。</p></li></ol><h1 id="使用通配符的技巧">2. 使用通配符的技巧</h1><ol type="1"><li>通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长</li></ol>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL必知必会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL必知必会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7. 数据过滤</title>
    <link href="/2024/11/27/mysql_bzbh/7-%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4/"/>
    <url>/2024/11/27/mysql_bzbh/7-%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="组合where子句">1. 组合where子句</h1><h2 id="and操作符">1.1. AND操作符</h2><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/7-%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4/1709221345123-071bb109-d0c2-4867-b2ad-6bd3399a7dbd.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol><h2 id="or操作符">1.2. OR操作符</h2><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/7-%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4/1709221377423-5d05ed54-e66d-4c91-84b8-1dcf70f61523.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol><h2 id="计算次序">1.3. 计算次序</h2><ol type="1"><li><p>先处理AND，再处理OR</p></li><li><p>加括号可以改变次序</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/7-%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4/1709221455075-18ddfb92-ac4a-4e3e-8df7-13af547de775.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol><h1 id="in操作符">2. IN操作符</h1><ol type="1"><li><p>IN操作符用来指定条件范围，范围中的每个条件都可以进行匹配。IN取合法值的由逗号分隔的清单，全都括在圆括号中。</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/7-%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4/1709221562174-507714b4-00c4-4d95-bdaf-d758bea1c34b.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>在使用长的合法选项清单时，IN操作符的语法更清楚且更直观。</p></li><li><p>在使用IN时，计算的次序更容易管理（因为使用的操作符更少）。</p></li><li><p>IN操作符一般比OR操作符清单执行更快。</p></li><li><p>IN的最大优点是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句。第14章将对此进行详细介绍。</p></li></ol><h1 id="not操作符">3. NOT操作符</h1><ol type="1"><li><p>WHERE子句中的NOT操作符有且只有一个功能，那就是否定它之后所跟的任何条件。</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/7-%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4/1709221771191-1bd390ac-96b4-407f-b598-d8568a969e84.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL必知必会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL必知必会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6. 过滤数据</title>
    <link href="/2024/11/27/mysql_bzbh/6-%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE/"/>
    <url>/2024/11/27/mysql_bzbh/6-%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="使用where子句">1. 使用where子句</h1><ol type="1"><li>select 列 from 表 where 条件；</li></ol><figure><img src="/2024/11/27/mysql_bzbh/6-%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE/1709216953756-97816c10-4753-4f16-a165-b34fda1ff731.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h1 id="where子句操作符">2. where子句操作符</h1><figure><img src="/2024/11/27/mysql_bzbh/6-%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE/1709219937066-9e782018-2947-44a8-80e8-eb247dd2760f.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h2 id="检查单个值">2.1. 检查单个值</h2><ol type="1"><li><p>=</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/6-%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE/1709219973870-38a2a4ea-ad27-42c7-9a32-e33861364d42.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>&lt;</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/6-%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE/1709220024815-a1c994f7-3120-4fbb-9f0f-d51f323b431c.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>&lt;=</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/6-%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE/1709220055685-f2743894-1f31-4867-b2ae-62374c2f7c02.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol><h2 id="不匹配检查">2.2. 不匹配检查</h2><ol type="1"><li><p>&lt;&gt;</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/6-%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE/1709220120654-3b7a71c7-dde7-4e81-aedb-23875d8ef8e9.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>!=</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/6-%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE/1709220158501-3cd25bcd-23e5-4a42-bd95-a3155aa58538.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>单引号用来限定字符串</li></ol></li></ol><h2 id="范围值检查">2.3. 范围值检查</h2><ol type="1"><li><p>between</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/6-%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE/1709220375657-4e8f3d51-139c-4533-abb7-0de9857f5ccb.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol><h2 id="空值检查">2.4. 空值检查</h2><ol type="1"><li><p>is null</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/6-%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE/1709220730542-12f4593a-7cb5-4ecc-9757-88ceb54dc8bc.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><figure><img src="/2024/11/27/mysql_bzbh/6-%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE/1709220890820-d69fe7ed-c6a8-4d36-97f5-6920dfaef092.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL必知必会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL必知必会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5. 排序检索数据</title>
    <link href="/2024/11/27/mysql_bzbh/5-%E6%8E%92%E5%BA%8F%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE/"/>
    <url>/2024/11/27/mysql_bzbh/5-%E6%8E%92%E5%BA%8F%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="排序数据">1. 排序数据</h1><ol type="1"><li>select 列 from 表 order by 列；</li></ol><figure><img src="/2024/11/27/mysql_bzbh/5-%E6%8E%92%E5%BA%8F%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE/1709216268455-4ba35ac7-1d2a-4e2e-9328-69282df4fdb1.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h1 id="按多个列排序">2. 按多个列排序</h1><ol type="1"><li>select 列1，列2，列3 from 表 order by 要排序的列1 要排序的列2；</li><li>下面的代码检索3个列，并按其中两个列对结果进行排序——首先按价格，然后再按名称排序。</li></ol><figure><img src="/2024/11/27/mysql_bzbh/5-%E6%8E%92%E5%BA%8F%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE/1709216409961-d61dccea-ebd9-41fb-9781-0bfce7efb33d.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h1 id="指定排序方向">3. 指定排序方向</h1><ol type="1"><li>降序排序 指定DESC关键字。</li><li>select 列1，列2，列3 from 表 order by 列 desc；</li></ol><figure><img src="/2024/11/27/mysql_bzbh/5-%E6%8E%92%E5%BA%8F%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE/1709216558118-e73c3f73-5235-4716-bd2e-dd31b5e5f868.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>select 列1，列2，列3 from 表 order by 列1 desc，列2；</li><li>DESC关键字只应用到直接位于其前面的列名。在上例中，只对prod_price列指定DESC，对prod_name列不指定。因此，prod_price列以降序排序，而prod_name列（在每个价格内）仍然按标准的升序排序。</li><li>在多个列上降序排序如果想在多个列上进行降序排序，必须对每个列指定DESC关键字。</li><li>与DESC相反的关键字是ASC（ASCENDING），在升序排序时可以指定它。但实际上，ASC没有多大用处，因为升序是默认的（如果既不指定ASC也不指定DESC，则假定为ASC）</li><li>在字典（dictionary）排序顺序中，A被视为与a相同，这是MySQL（和大多数数据库管理系统）的默认行为。</li><li>使用ORDER BY和LIMIT的组合，能够找出一个列中最高或最低的值。</li></ol><figure><img src="/2024/11/27/mysql_bzbh/5-%E6%8E%92%E5%BA%8F%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE/1709216705190-7dda1f6a-a24c-44fc-a8e6-7b9207c2d743.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL必知必会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL必知必会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4. 检索数据</title>
    <link href="/2024/11/27/mysql_bzbh/4-%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE/"/>
    <url>/2024/11/27/mysql_bzbh/4-%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="select-语句">1. SELECT 语句</h1><h1 id="检索单个列">2. 检索单个列</h1><ol type="1"><li><p>select列名 from table名；</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/4-%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE/1709212065109-18c24bee-3ca6-4db8-866c-6b4e171b4ddf.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>SQL语句不区分大小写</li></ol></li></ol><h1 id="检索多个列">3. 检索多个列</h1><ol type="1"><li><p>select列1，列2，列3 from表；</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/4-%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE/1709212146169-c4e94313-593b-4605-b77b-dd86a4a76a48.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol><h1 id="检索所有列">4. 检索所有列</h1><ol type="1"><li><p>select * from 表；</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/4-%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE/1709212202738-ef0c407b-d621-4ace-be62-ce824a5ceab6.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>检索未知列使用通配符有一个大优点。由于不明确指定列名（因为星号检索每个列），所以能检索出名字未知的列。</li></ol></li></ol><h1 id="检索不同的行">5. 检索不同的行</h1><ol type="1"><li><p>select distinct 列 from 表；</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/4-%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE/1709212528678-ae43cbf8-d513-4594-acca-a43fb542f779.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li><figure><img src="/2024/11/27/mysql_bzbh/4-%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE/1709212580288-50cb8345-c694-4aaa-8b14-21353c29536f.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol><h1 id="限制结果">6. 限制结果</h1><ol type="1"><li><p>select 列 from 表 limit 行数；</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/4-%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE/1709212620542-9412422e-dcf8-4f6c-83bd-aa8d33d0aea2.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li><li><p>select 列 from 表 limit 开始行，行数；</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/4-%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE/1709212655599-371645c9-12c2-4285-82bc-78844a4d6023.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li><li>行数从0开始</li></ol></li></ol><h1 id="使用完全限定的表名">7. 使用完全限定的表名</h1><ol type="1"><li><p>select 表.列 from 数据库.表</p></li><li><ol type="1"><li><figure><img src="/2024/11/27/mysql_bzbh/4-%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE/1709212763069-3bec05ad-60c9-4e57-a754-5d5a84bbfe38.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL必知必会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL必知必会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3. 使用MySQL</title>
    <link href="/2024/11/27/mysql_bzbh/3-%E4%BD%BF%E7%94%A8MySQL/"/>
    <url>/2024/11/27/mysql_bzbh/3-%E4%BD%BF%E7%94%A8MySQL/</url>
    
    <content type="html"><![CDATA[<h1 id="了解数据库和表">1. 了解数据库和表</h1><p>为了连接到MySQL，需要以下信息：</p><ul><li>主机名（计算机名）——如果连接到本地MySQL服务器，为localhost；</li><li>端口（如果使用默认端口3306之外的端口）</li><li>一个合法的用户名；</li><li>用户口令（如果需要）。</li></ul><p>mysql -h localhost -u root -p</p><h1 id="选择数据库">2. 选择数据库</h1><p>use 数据库名称</p><figure><img src="/2024/11/27/mysql_bzbh/3-%E4%BD%BF%E7%94%A8MySQL/1709086189109-db4181a4-a8f9-4f0e-8ed9-49e86c9fc171.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h1 id="了解数据库和表-1">3. 了解数据库和表</h1><ol type="1"><li>MySQL的SHOW命令来显示这些信息</li></ol><figure><img src="/2024/11/27/mysql_bzbh/3-%E4%BD%BF%E7%94%A8MySQL/1709085355781-f5fb64ef-6049-4e55-862f-df83d923c659.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/mysql_bzbh/3-%E4%BD%BF%E7%94%A8MySQL/1709085387550-613a105a-0e51-4c3c-881a-cc1614f404f7.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/11/27/mysql_bzbh/3-%E4%BD%BF%E7%94%A8MySQL/1709085455021-e9e48aea-d6fa-4769-93ec-e440f77ed2ff.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>SHOW COLUMNS要求给出一个表名（这个例子中的FROMcustomers），它对每个字段返回一行，行中包含字段名、数据类型、是否允许NULL、键信息、默认值以及其他信息（如字段cust_id的auto_increment）。</p><ol type="1"><li><p>所支持的其他SHOW语句还有：</p></li><li><ol type="1"><li>SHOW STATUS，用于显示广泛的服务器状态信息；</li><li>SHOW CREATE DATABASE和SHOW CREATETABLE，分别用来显示创建特定数据库或表的MySQL语句；</li><li>SHOW GRANTS，用来显示授予用户（所有用户或特定用户）的安全权限；</li><li>SHOW ERRORS和SHOW WARNINGS，用来显示服务器错误或警告消息。</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL必知必会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL必知必会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. 了解SQL</title>
    <link href="/2024/11/27/mysql_bzbh/1-%E4%BA%86%E8%A7%A3SQL/"/>
    <url>/2024/11/27/mysql_bzbh/1-%E4%BA%86%E8%A7%A3SQL/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库基础">1. 数据库基础</h1><h2 id="什么是数据库">1.1. 什么是数据库</h2><ul><li>数据库（database）保存有组织的数据的容器（通常是一个文件或一组文件）。</li></ul><h2 id="表">1.2. 表</h2><ul><li><p>表（table）某种特定类型数据的结构化清单</p></li><li><p>模式（schema）关于数据库和表的布局及特性的信息。</p></li></ul><h2 id="列和数据类型">1.3. 列和数据类型</h2><ol type="1"><li>表由列组成。列中存储着表中某部分的信息。</li><li>列（column）表中的一个字段。所有表都是由一个或多个列组成的。</li><li>数据库中每个列都有相应的数据类型。数据类型定义列可以存储的数据种类。</li><li>数据类型（datatype）所容许的数据的类型。每个表列都有相应的数据类型，它限制（或容许）该列中存储的数据。</li><li>数据类型限制可存储在列中的数据种类（例如，防止在数值字段中录入字符值）。数据类型还帮助正确地排序数据，并在优化磁盘使用方面起重要的作用。</li></ol><h2 id="行">1.4. 行</h2><p>行（row）表中的一个记录。</p><p>表中的数据是按行存储的，所保存的每个记录存储在自己的行内。如果将表想象为网格，网格中垂直的列为表列，水平行为表行。</p><h2 id="主键">1.5. 主键</h2><ol type="1"><li><p>表中每一行都应该有可以唯一标识自己的一列（或一组列）。</p></li><li><p>主键（primarykey）一列（或一组列），其值能够唯一区分表中每个行。</p></li><li><p>唯一标识表中每行的这个列（或这组列）称为主键。主键用来表示一个特定的行。没有主键，更新或删除表中特定行很困难，因为没有安全的方法保证只涉及相关的行。</p></li><li><p>应该总是定义主键虽然并不总是都需要主键，但大多数数据库设计人员都应保证他们创建的每个表具有一个主键，以便于以后的数据操纵和管理。</p></li><li><p>表中的任何列都可以作为主键，只要它满足以下条件：</p></li><li><ol type="1"><li>任意两行都不具有相同的主键值；</li><li>每个行都必须具有一个主键值（主键列不允许NULL值）。</li></ol></li></ol><h1 id="什么是sql">2. 什么是SQL</h1><p>SQL（发音为字母S-Q-L或sequel）是结构化查询语言（Structured QueryLanguage）的缩写。SQL是一种专门用来与数据库通信的语言。</p><ul><li>命令输入在mysql&gt;之后；</li><li>命令用;或，换句话说，仅按Enter不执行命令；</li><li>输入help或，也可以输入更多的文本获得特定命令的帮助（如，输入helpselect获得使用SELECT语句的帮助）；</li><li>输入quit或exit退出命令行实用程序。</li></ul>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL必知必会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL必知必会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. 数组</title>
    <link href="/2024/11/27/leetcode/1-%E6%95%B0%E7%BB%84/"/>
    <url>/2024/11/27/leetcode/1-%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>13. MySQL管理</title>
    <link href="/2024/11/27/MySQL/13-MySQL%E7%AE%A1%E7%90%86/"/>
    <url>/2024/11/27/MySQL/13-MySQL%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="mysql管理">MySQL管理</h1><h2 id="系统数据库">系统数据库</h2><p>MySQL数据库安装完成后，自带了以下四个数据库，具体作用如下：</p><table><thead><tr><th>数据库</th><th>含义</th></tr></thead><tbody><tr><td>mysql</td><td>存储 MySQL服务器正常运行所需要的各种信息（时区、主从、用户、权限等）</td></tr><tr><td>information_schema</td><td>提供了访问数据库元数据的各种表和视图，包含数据库、表、字段类型及访问权限等</td></tr><tr><td>performance_schema</td><td>为 MySQL服务器运行时状态提供了一个底层监控功能，主要用于收集数据库服务器性能和参数</td></tr><tr><td>sys</td><td>包含了一系列方便 DBA 和开发人员利用 performance_schema性能数据库进行性能调优和诊断的视图</td></tr></tbody></table><h2 id="常用工具">常用工具</h2><ul><li><strong>MySQL</strong></li></ul><p>该MySQL不是指MySQL服务，而是指MySQL的客户端工具。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">语法：<br>      mysql [options][database]<br>选项：<br>      -u, --user=name             #指定用户名<br>      -p, --password[=name]       #指定密码<br>      -h, --host=name             #指定服务器IP或域名<br>      -P, --port=port             #指定连接端口<br>      -e, --execute=name          #执行SQL语句并退出<br></code></pre></td></tr></table></figure><p>-e选项可以在MySQL客户端执行SQL语句，而不用连接到MySQL数据库再执行，对于一些批处理脚本，这种方式尤其方便。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">示例：<br>  mysql -h192.168.200.202 -P3306 -uroot -p1234 itcast -e &quot;select * from stu&quot;<br></code></pre></td></tr></table></figure><ul><li><strong>mysqladmin</strong></li></ul><p>mysqladmin是一个执行管理操作的客户端程序。可以用它来检查服务器的配置和当前状态、创建并删除数据库等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">通过帮助文档查看选项：<br>  mysqladmin --help<br>示例：<br>  mysqladmin -uroot -p123456 drop &#x27;test01&#x27;;<br>  musqladmin -uroot -p123456 version;<br></code></pre></td></tr></table></figure><ul><li><strong>mysqlbinlog</strong></li></ul><p>由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文本的文本格式，就会使用到mysqlbinlog日志管理工具。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">语法：<br>  mysqlbinlog [options] log-files1 log-files2 ...<br>选项：<br>  -d, --database=name        #指定数据库名称，只列出指定的数据库相关操作<br>  -o, --offset=#             #忽略掉日志中的前n行命令<br>  -r, --result-file=name    #将输出的文本格式日志输出到指定文件<br>  -s, --short-form          #显示简单个格式，省略掉一些信息<br>  --start-datatime=date1 --stop-datetime=date2    #指定日期间隔内的所有日志<br>  --start-postion=pos1 --stop-postion=pos2        #指定位置间隔内的所有日志<br></code></pre></td></tr></table></figure><ul><li><strong>mysqlshow</strong></li></ul><p>mysqlshow客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">语法：<br>  mysqlshow [options][db_name[table_name[col_name]]]<br>选项：<br>  --count        #显示数据库及表的统计信息（数据库，表均可以不指定）<br>  -i            #显示指定数据库或者指定表的状态信息<br>示例：<br>  #查询每个数据库的表的数量及表中记录的数量<br>  mysqlshow -uroot -p2143 --count<br><br>  #查询test库中每个表中的字段数，及行数<br>  mysqlshow -uroot -p2143 --count<br><br>  #查询test库中book表的详细情况<br>  mysqlshow -uroot -p2143 test book --count<br></code></pre></td></tr></table></figure><ul><li><strong>mysqldump</strong></li></ul><p>mysqldump客户端工具用来备份数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，及插入表的SQL语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">语法：<br>  mysqldump [options] db_name [tables]<br>  mysqldump [options] --database/-B db1 [db2 db3 ...]<br>  mysqldump [options] -all-databases/-A<br>连接选项：<br>  -u, --user=name        #指定用户名<br>  -p, -password[=name]  #指定密码<br>  -h, --host=name        #指定服务器ip或域名<br>  -P, --port=#          #指定连接端口<br>输出选项：<br>  --add-drop-database      #在每个数据库创建语句前加上drop database语句<br>  --add-drop-table         #在每个表创建语句前加上drop table语句，默认开启；不开启(--skip-add-drop-table)<br>  -n, --no-create-db       #不包含数据库的创建语句<br>  -t, --no-create-info     #不包含数据库的创建语句<br>  -d, --no-data           #不包含数据<br>  -T, --tab=name           #自动生成两个文件：一个.sql文件，创建表结构的语句；一个.txt文件，数据文件<br></code></pre></td></tr></table></figure><ul><li><strong>mysqlimport/souce</strong></li></ul><p>mysqlimport是客户端数据导入工具，用来导入mysqldump加-T参数后导出的文本文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">语法：<br>  mysqlimport [options] db_name testfile1 [textfile2...]<br>示例：<br>  mysqlimport -uroot -p2143 test tmp/city.txt<br></code></pre></td></tr></table></figure><p>如果需要导入sql文件，可以使用mysql中的source指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">语法：<br>  source /root/xxxxx.sql<br></code></pre></td></tr></table></figure><h1 id="权限一览表">权限一览表</h1><blockquote><p>具体权限的作用详见<a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html" title="官方文档">官方文档</a></p></blockquote><p>GRANT 和 REVOKE 允许的静态权限</p><table><thead><tr><th style="text-align: left;">Privilege</th><th style="text-align: left;">Grant Table Column</th><th style="text-align: left;">Context</th></tr></thead><tbody><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_all"><code>ALL [PRIVILEGES]</code></a></td><td style="text-align: left;">Synonym for “all privileges”</td><td style="text-align: left;">Server administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_alter"><code>ALTER</code></a></td><td style="text-align: left;"><code>Alter_priv</code></td><td style="text-align: left;">Tables</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_alter-routine"><code>ALTER ROUTINE</code></a></td><td style="text-align: left;"><code>Alter_routine_priv</code></td><td style="text-align: left;">Stored routines</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create"><code>CREATE</code></a></td><td style="text-align: left;"><code>Create_priv</code></td><td style="text-align: left;">Databases, tables, or indexes</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-role"><code>CREATE ROLE</code></a></td><td style="text-align: left;"><code>Create_role_priv</code></td><td style="text-align: left;">Server administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-routine"><code>CREATE ROUTINE</code></a></td><td style="text-align: left;"><code>Create_routine_priv</code></td><td style="text-align: left;">Stored routines</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-tablespace"><code>CREATE TABLESPACE</code></a></td><td style="text-align: left;"><code>Create_tablespace_priv</code></td><td style="text-align: left;">Server administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-temporary-tables"><code>CREATE TEMPORARY TABLES</code></a></td><td style="text-align: left;"><code>Create_tmp_table_priv</code></td><td style="text-align: left;">Tables</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-user"><code>CREATE USER</code></a></td><td style="text-align: left;"><code>Create_user_priv</code></td><td style="text-align: left;">Server administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-view"><code>CREATE VIEW</code></a></td><td style="text-align: left;"><code>Create_view_priv</code></td><td style="text-align: left;">Views</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_delete"><code>DELETE</code></a></td><td style="text-align: left;"><code>Delete_priv</code></td><td style="text-align: left;">Tables</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_drop"><code>DROP</code></a></td><td style="text-align: left;"><code>Drop_priv</code></td><td style="text-align: left;">Databases, tables, or views</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_drop-role"><code>DROP ROLE</code></a></td><td style="text-align: left;"><code>Drop_role_priv</code></td><td style="text-align: left;">Server administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_event"><code>EVENT</code></a></td><td style="text-align: left;"><code>Event_priv</code></td><td style="text-align: left;">Databases</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_execute"><code>EXECUTE</code></a></td><td style="text-align: left;"><code>Execute_priv</code></td><td style="text-align: left;">Stored routines</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_file"><code>FILE</code></a></td><td style="text-align: left;"><code>File_priv</code></td><td style="text-align: left;">File access on server host</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_grant-option"><code>GRANT OPTION</code></a></td><td style="text-align: left;"><code>Grant_priv</code></td><td style="text-align: left;">Databases, tables, or stored routines</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_index"><code>INDEX</code></a></td><td style="text-align: left;"><code>Index_priv</code></td><td style="text-align: left;">Tables</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_insert"><code>INSERT</code></a></td><td style="text-align: left;"><code>Insert_priv</code></td><td style="text-align: left;">Tables or columns</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_lock-tables"><code>LOCK TABLES</code></a></td><td style="text-align: left;"><code>Lock_tables_priv</code></td><td style="text-align: left;">Databases</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_process"><code>PROCESS</code></a></td><td style="text-align: left;"><code>Process_priv</code></td><td style="text-align: left;">Server administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_proxy"><code>PROXY</code></a></td><td style="text-align: left;">See <code>proxies_priv</code> table</td><td style="text-align: left;">Server administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_references"><code>REFERENCES</code></a></td><td style="text-align: left;"><code>References_priv</code></td><td style="text-align: left;">Databases or tables</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_reload"><code>RELOAD</code></a></td><td style="text-align: left;"><code>Reload_priv</code></td><td style="text-align: left;">Server administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-client"><code>REPLICATION CLIENT</code></a></td><td style="text-align: left;"><code>Repl_client_priv</code></td><td style="text-align: left;">Server administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-slave"><code>REPLICATION SLAVE</code></a></td><td style="text-align: left;"><code>Repl_slave_priv</code></td><td style="text-align: left;">Server administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_select"><code>SELECT</code></a></td><td style="text-align: left;"><code>Select_priv</code></td><td style="text-align: left;">Tables or columns</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-databases"><code>SHOW DATABASES</code></a></td><td style="text-align: left;"><code>Show_db_priv</code></td><td style="text-align: left;">Server administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-view"><code>SHOW VIEW</code></a></td><td style="text-align: left;"><code>Show_view_priv</code></td><td style="text-align: left;">Views</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_shutdown"><code>SHUTDOWN</code></a></td><td style="text-align: left;"><code>Shutdown_priv</code></td><td style="text-align: left;">Server administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_super"><code>SUPER</code></a></td><td style="text-align: left;"><code>Super_priv</code></td><td style="text-align: left;">Server administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_trigger"><code>TRIGGER</code></a></td><td style="text-align: left;"><code>Trigger_priv</code></td><td style="text-align: left;">Tables</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_update"><code>UPDATE</code></a></td><td style="text-align: left;"><code>Update_priv</code></td><td style="text-align: left;">Tables or columns</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_usage"><code>USAGE</code></a></td><td style="text-align: left;">Synonym for “no privileges”</td><td style="text-align: left;">Server administration</td></tr></tbody></table><p>GRANT 和 REVOKE 允许的动态权限</p><table><thead><tr><th style="text-align: left;">Privilege</th><th style="text-align: left;">Context</th></tr></thead><tbody><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_application-password-admin"><code>APPLICATION_PASSWORD_ADMIN</code></a></td><td style="text-align: left;">Dual password administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_audit-abort-exempt"><code>AUDIT_ABORT_EXEMPT</code></a></td><td style="text-align: left;">Allow queries blocked by audit logfilter</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_audit-admin"><code>AUDIT_ADMIN</code></a></td><td style="text-align: left;">Audit log administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_authentication-policy-admin"><code>AUTHENTICATION_POLICY_ADMIN</code></a></td><td style="text-align: left;">Authentication administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_backup-admin"><code>BACKUP_ADMIN</code></a></td><td style="text-align: left;">Backup administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_binlog-admin"><code>BINLOG_ADMIN</code></a></td><td style="text-align: left;">Backup and Replication administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_binlog-encryption-admin"><code>BINLOG_ENCRYPTION_ADMIN</code></a></td><td style="text-align: left;">Backup and Replication administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_clone-admin"><code>CLONE_ADMIN</code></a></td><td style="text-align: left;">Clone administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_connection-admin"><code>CONNECTION_ADMIN</code></a></td><td style="text-align: left;">Server administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_encryption-key-admin"><code>ENCRYPTION_KEY_ADMIN</code></a></td><td style="text-align: left;">Server administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-admin"><code>FIREWALL_ADMIN</code></a></td><td style="text-align: left;">Firewall administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-exempt"><code>FIREWALL_EXEMPT</code></a></td><td style="text-align: left;">Firewall administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-user"><code>FIREWALL_USER</code></a></td><td style="text-align: left;">Firewall administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-optimizer-costs"><code>FLUSH_OPTIMIZER_COSTS</code></a></td><td style="text-align: left;">Server administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-status"><code>FLUSH_STATUS</code></a></td><td style="text-align: left;">Server administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-tables"><code>FLUSH_TABLES</code></a></td><td style="text-align: left;">Server administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-user-resources"><code>FLUSH_USER_RESOURCES</code></a></td><td style="text-align: left;">Server administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_group-replication-admin"><code>GROUP_REPLICATION_ADMIN</code></a></td><td style="text-align: left;">Replication administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_group-replication-stream"><code>GROUP_REPLICATION_STREAM</code></a></td><td style="text-align: left;">Replication administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_innodb-redo-log-archive"><code>INNODB_REDO_LOG_ARCHIVE</code></a></td><td style="text-align: left;">Redo log archiving administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_ndb-stored-user"><code>NDB_STORED_USER</code></a></td><td style="text-align: left;">NDB Cluster</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_passwordless-user-admin"><code>PASSWORDLESS_USER_ADMIN</code></a></td><td style="text-align: left;">Authentication administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_persist-ro-variables-admin"><code>PERSIST_RO_VARIABLES_ADMIN</code></a></td><td style="text-align: left;">Server administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-applier"><code>REPLICATION_APPLIER</code></a></td><td style="text-align: left;"><code>PRIVILEGE_CHECKS_USER</code> for areplication channel</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-slave-admin"><code>REPLICATION_SLAVE_ADMIN</code></a></td><td style="text-align: left;">Replication administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_resource-group-admin"><code>RESOURCE_GROUP_ADMIN</code></a></td><td style="text-align: left;">Resource group administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_resource-group-user"><code>RESOURCE_GROUP_USER</code></a></td><td style="text-align: left;">Resource group administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_role-admin"><code>ROLE_ADMIN</code></a></td><td style="text-align: left;">Server administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_session-variables-admin"><code>SESSION_VARIABLES_ADMIN</code></a></td><td style="text-align: left;">Server administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_set-user-id"><code>SET_USER_ID</code></a></td><td style="text-align: left;">Server administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-routine"><code>SHOW_ROUTINE</code></a></td><td style="text-align: left;">Server administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_system-user"><code>SYSTEM_USER</code></a></td><td style="text-align: left;">Server administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_system-variables-admin"><code>SYSTEM_VARIABLES_ADMIN</code></a></td><td style="text-align: left;">Server administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_table-encryption-admin"><code>TABLE_ENCRYPTION_ADMIN</code></a></td><td style="text-align: left;">Server administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_version-token-admin"><code>VERSION_TOKEN_ADMIN</code></a></td><td style="text-align: left;">Server administration</td></tr><tr><td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_xa-recover-admin"><code>XA_RECOVER_ADMIN</code></a></td><td style="text-align: left;">Server administration</td></tr></tbody></table><h1 id="图形化界面工具">图形化界面工具</h1><ul><li>Workbench(免费): http://dev.mysql.com/downloads/workbench/</li><li>navicat(收费，试用版30天):https://www.navicat.com/en/download/navicat-for-mysql</li><li>Sequel Pro(开源免费，仅支持Mac OS): http://www.sequelpro.com/</li><li>HeidiSQL(免费): http://www.heidisql.com/</li><li>phpMyAdmin(免费): https://www.phpmyadmin.net/</li><li>SQLyog: https://sqlyog.en.softonic.com/</li></ul><h1 id="小技巧">小技巧</h1><ol type="1"><li>在SQL语句之后加上<code>\G</code>会将结果的表格形式转换成行文本形式</li><li>查看Mysql数据库占用空间：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT table_schema &quot;Database Name&quot;<br>     , SUM(data_length + index_length) / (1024 * 1024) &quot;Database Size in MB&quot;<br>FROM information_schema.TABLES<br>GROUP BY table_schema;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12. InnoDB引擎</title>
    <link href="/2024/11/27/MySQL/12-InnoDB%E5%BC%95%E6%93%8E/"/>
    <url>/2024/11/27/MySQL/12-InnoDB%E5%BC%95%E6%93%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="innodb引擎">InnoDB引擎</h1><h2 id="逻辑存储结构">逻辑存储结构</h2><ul><li>表空间（ibd文件）：一个MySQL实例可以对应多个表空间，用于存储记录、索引等数据。</li><li>段：分为数据段（Leaf node segment）、索引段（Non-leaf nodesegment）、回滚段（Rollbacksegment），InnoDB是索引组织表，数据段就是B+树的叶子结点，索引段就是B+树的非叶子结点。段用来当管理多个Extent（区）。</li><li>区：表空间的单元结构，每个区的大小为1M。默认情况下，InnoDB存储引擎页大小为16K，即一个区中一共有64个连续的页。</li><li>页：是InnoDB存储引擎磁盘管理的最小单元，每个页的大小默认为16KB。为了保证页的连续性，InnoDB存储引擎每次从磁盘申请4-5个区。</li><li>行：InnoDB存储引擎数据就是按行进行存放的。</li></ul><p><img src="/2024/11/27/MySQL/12-InnoDB%E5%BC%95%E6%93%8E/a4be8ac711730c4b9cbfd7851d05a841.png"></p><h2 id="架构">架构</h2><p>MySQL5.5版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。</p><p><img src="/2024/11/27/MySQL/12-InnoDB%E5%BC%95%E6%93%8E/154be1df094926cf7a6e96848a49c2f2.png"></p><p><strong>内存结构</strong></p><p><img src="/2024/11/27/MySQL/12-InnoDB%E5%BC%95%E6%93%8E/e194374d0695833b5ef9fbbc779146eb.png"></p><p>ChangeBuffer:更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据Page没有在BufferPool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区ChangeBuffer中，在未来数据被读取时，再将数据合并恢复到BufferPoolr中，再将合并后的数据刷新到磁盘中。</p><p>Change Bufferl的意义是什么？与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘O。有了ChangeBuf仟er之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。</p><p><img src="/2024/11/27/MySQL/12-InnoDB%E5%BC%95%E6%93%8E/56d1ef907694171dd3fba8742f95c6e8.png"></p><p><img src="/2024/11/27/MySQL/12-InnoDB%E5%BC%95%E6%93%8E/6a215517c813ad6407777eb757ac43da.png"></p><p><img src="/2024/11/27/MySQL/12-InnoDB%E5%BC%95%E6%93%8E/c111753c5af95905e94829bdc7b98178.png"></p><p><strong>磁盘结构</strong></p><p><img src="/2024/11/27/MySQL/12-InnoDB%E5%BC%95%E6%93%8E/5e58c5ac575edf08776d5b439e863855.png"></p><p><img src="/2024/11/27/MySQL/12-InnoDB%E5%BC%95%E6%93%8E/504a5c804f7924bebb3ec0114072f45e.png"></p><p><img src="/2024/11/27/MySQL/12-InnoDB%E5%BC%95%E6%93%8E/dae5c143e5710c2a298cb14a81aa8bd0.png"></p><p><strong>后台线程</strong></p><p><img src="/2024/11/27/MySQL/12-InnoDB%E5%BC%95%E6%93%8E/436f8bcfcb6656368431f1193d136070.png"></p><h2 id="事务原理">事务原理</h2><p><strong>事务</strong></p><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p><strong>特性</strong></p><ul><li>原子性：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性：事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性：数据库提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下与运行。</li><li>持久性：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><p><img src="/2024/11/27/MySQL/12-InnoDB%E5%BC%95%E6%93%8E/2743a68525ec8dfd89c0cb1c9687d526.png"></p><p><strong>redo log（持久性）</strong></p><p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的永久性。</p><p>该日志文件由两部分组成：重做日志缓冲（redo logbuffer）以及重做日志文件（redo logfile），前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。</p><p><img src="/2024/11/27/MySQL/12-InnoDB%E5%BC%95%E6%93%8E/47311bddaa9c578fecbdca4f9de271b9.png"></p><p><strong>undo log（原子性）</strong></p><p>回滚日志，用于记录数据被修改前的信息，作用包含两个：提供回滚和MVCC（多版本并发控制）。</p><p>Undo log和redolog记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undolog中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undolog中的逻辑记录读取到相应的内容并进行回滚。</p><p>Undo log销毁：Undolog在事务执行时产生，事务提交时，并不会立即删除undolog，因为这些日志可能还用与MVCC。</p><p>Undo log存储：Undolog采用段的方式进行管理和记录，存放在前面介绍的rollbacksegment回滚段中，内部包含1024个undo log segment。</p><h2 id="mvcc"><strong>MVCC</strong></h2><p><strong>基本概念</strong></p><ul><li>当前读</li></ul><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：select... lock in share mode（共享锁），select ... forupdate、update、insert、delete（排他锁）都是一种当前读。</p><ul><li>快照读</li></ul><p>简单的select（不加锁）就是快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</p><ul><li>Read Committed：每次select，都生成一个快照读。</li><li>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</li><li>Serializable：快照读会退化成当前读。</li><li>MVCC</li></ul><p>全称Multi-Version ConcurrencyControl，多版本并发控制。指维护一个数据的多版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undolog日志和readView。</p><p><strong>实现原理</strong></p><ul><li>记录中的隐藏字段</li></ul><table><thead><tr><th>隐藏字段</th><th>含义</th></tr></thead><tbody><tr><td>DB_TRX_ID</td><td>最近修改事务 ID ，记录插入这条记录或最后一次修改该记录的事务 ID</td></tr><tr><td>DB_ROLL_PTR</td><td>回滚指针，指向这条记录的上一个版本，用于配合 undolog，指向上一个版本</td></tr><tr><td>DB_ROW_ID</td><td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段</td></tr></tbody></table><p><img src="/2024/11/27/MySQL/12-InnoDB%E5%BC%95%E6%93%8E/09c3c6c452d9229f44380fcb330f1e04.png"></p><ul><li>undo log</li></ul><p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。</p><p>当insert的时候，产生的undolog日志只在回滚时需要，在事务提交后，可被立即删除。</p><p>而update、delete的时候，产生的undolog日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。</p><p><img src="/2024/11/27/MySQL/12-InnoDB%E5%BC%95%E6%93%8E/5524cc0377798b96956bded8002e068f.png"></p><p><img src="/2024/11/27/MySQL/12-InnoDB%E5%BC%95%E6%93%8E/0f1655bfbdb52e26d7bf6863df8f2661.png"></p><ul><li>undo log版本链</li></ul><p>不同事物或相同事物对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p><ul><li>readview</li></ul><p>ReadView（读视图）是快照读SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。</p><p>ReadView中包含了四个核心字段：</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>m_ids</td><td>当前活跃的事务 ID 集合</td></tr><tr><td>min_trx_id</td><td>最小活跃事务 ID</td></tr><tr><td>max_trx_id</td><td>预分配事务 ID ，当前最大事务 ID+1（因为事务 ID 是自增的）</td></tr><tr><td>creator_trx_id</td><td>ReadView 创建者的事务 ID</td></tr></tbody></table><p>trx_id：代表是当前事务ID。</p><p><img src="/2024/11/27/MySQL/12-InnoDB%E5%BC%95%E6%93%8E/5c172e97eeb3b8673d409dff1ba16e55.png"></p><p>不同隔离级别，生成ReadView的时机不同：</p><ul><li>READ COMMITTED：在事务中每一次执行快照读时生成的ReadView。</li><li>REPEATABLEREAD：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</li></ul><p>RC隔离级别下，在事务中每一次执行快照读生成ReadView。</p><p><img src="/2024/11/27/MySQL/12-InnoDB%E5%BC%95%E6%93%8E/c316d3409280d2606c10d28531d9a677.png"></p><p>RR隔离级别下，仅在事务中第一次执行快照读生成ReadView，后续复用该ReadView。</p><p><img src="/2024/11/27/MySQL/12-InnoDB%E5%BC%95%E6%93%8E/655a74bc2ae1836ebacdea25e0913039.png"></p><p><img src="/2024/11/27/MySQL/12-InnoDB%E5%BC%95%E6%93%8E/d168be0e5ded71955fdfd219d3e0edb0.png"></p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11. 锁</title>
    <link href="/2024/11/27/MySQL/11-%E9%94%81/"/>
    <url>/2024/11/27/MySQL/11-%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="五锁">五、锁</h1><h2 id="概述">1. 概述</h2><h3 id="介绍">介绍</h3><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><h3 id="分类">分类</h3><p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p><ol type="1"><li>全局锁：锁定数据库中的所有表。</li><li>表级锁：每次操作锁住整张表。</li><li>行级锁：每次操作锁住对应的行数据。</li></ol><h2 id="全局锁">2. 全局锁</h2><h3 id="介绍-1">介绍</h3><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p><p><strong>没加锁之前（数据不一致）：</strong></p><figure><img src="https://i-blog.csdnimg.cn/blog_migrate/ac0be623e6511bc68757f9f7d525e0bf.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p><strong>加锁过程：</strong></p><figure><img src="https://i-blog.csdnimg.cn/blog_migrate/53e26972d0031836b3a77413785e6a4f.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p><strong>加锁</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">flush tables <span class="hljs-keyword">with</span> read lock;<br></code></pre></td></tr></table></figure><p><strong>备份数据</strong></p><p>注意下面这个命令需要在windows下的命令行执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqldump -uroot -p1234 itcast &gt; itcast.sql<br></code></pre></td></tr></table></figure><p><strong>解锁</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">unlock tables;<br></code></pre></td></tr></table></figure><figure><img src="/2024/11/27/MySQL/11-%E9%94%81/343fbc420b14e3a22126743b6edcf5c9.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h3 id="特点">特点</h3><p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p><ol type="1"><li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</li><li>如果在从库上更新，那么在备份期间不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</li></ol><p>在InnoDB引擎中，我们可以在备份时加上参数--single-transaction参数来完成不加锁的一致性数据备份。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">mysqldump --single-transaction -uroot -p123456 itcast &gt; itcast.sql<br></code></pre></td></tr></table></figure><figure><img src="/2024/11/27/MySQL/11-%E9%94%81/6604110b87f1394b0a811906acb5951b.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h2 id="表级锁">3. 表级锁</h2><h3 id="介绍-2">介绍</h3><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。</p><p>对于表级锁，主要分为以下三类：</p><ol type="1"><li>表锁</li><li>元数据锁（meta data lock，MDL）</li><li>意向锁</li></ol><h3 id="表锁">表锁</h3><p>对于表锁，分为两类：</p><p>读锁不会阻塞其他客户端的读，但会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。</p><ol type="1"><li>表共享读锁（read lock）</li></ol><figure><img src="/2024/11/27/MySQL/11-%E9%94%81/f3ba3dd728eba068b8f176091f26cd6e.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol start="2" type="1"><li>表独占写锁（write lock）</li></ol><figure><img src="/2024/11/27/MySQL/11-%E9%94%81/fa56c4e64689bf1aad3139e620074bee.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><blockquote><p>注意：上面两图左边代表本客户端的操作，右边代表其他客户端的操作，并且绿色代表可操作，红色代表不可操作。</p></blockquote><p>语法：</p><ol type="1"><li>加锁：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">lock tables 表名... read/write<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>释放锁</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">unlock tables / 客户端断开连接<br></code></pre></td></tr></table></figure><h3 id="元数据锁">元数据锁</h3><p>MDL加锁过程是系统自动控制，无需显示使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突，保证读写的正确性。</p><p>在MYSQL5.5中引入MDL，当对一张表进行增删改查的时候，加MDL读锁（共享）；当对表结构进行变更操作的时候，加MDL写锁（排他）。</p><table><thead><tr><th>对应SQL</th><th>锁类型</th><th>说明</th></tr></thead><tbody><tr><td>lock tables xxx read/write</td><td>SHARED_READ_ONLY/SHARED_NO_READ_WRITE</td><td></td></tr><tr><td>select 、select … lock in share mode</td><td>SHARED_READ</td><td>与 SHARED_READ 、SHARED_WRITE 兼容，与 EXCLUSIVE 互斥</td></tr><tr><td>insert 、update 、delete 、select … for update</td><td>SHARED_WRITE</td><td>与 SHARED_READ 、SHARED_WRITE 兼容，与 EXCLUSIVE 互斥</td></tr><tr><td>alter table …</td><td>EXCLUSIVE</td><td>与其它的 MDL 都互斥</td></tr></tbody></table><p>查看元数据锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> object_type,object_schema,object_name,lock_type,lock_duration <span class="hljs-keyword">from</span> performance_schema.metadata_locks;<br></code></pre></td></tr></table></figure><h3 id="意向锁">意向锁</h3><p>为了避免DML在执行中，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</p><ol type="1"><li>意向共享锁（IS）：由语句select ... lock in sharemode添加。与表锁共享锁（read）兼容，与表锁排他锁（write）互斥。</li><li>意向排他锁（IX）：由insert 、update 、delete 、select ... forupdate添加。与表锁共享锁（read）及与排他锁（write）都互斥。意向锁之间不会互斥。</li></ol><p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">select object_schema,object_name,index_name,lock_type,lock_mod,lock_data from performance_schema.data_locks;<br></code></pre></td></tr></table></figure><h2 id="行级锁">4. 行级锁</h2><h3 id="介绍-3">介绍</h3><p>行级锁，每次操作锁住对应的行数据。行定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。</p><p>InnoDB的数据是基于索引组织，行锁是通过对索引上的索引项加锁来实现的，并不是对记录加的锁。对于行级锁，主要分为以下三类：</p><ol type="1"><li>行锁（RecordLock）：锁定单个行记录的锁，防止其他事物对此进行update和delete。在RC、RR隔离级别下都支持。</li><li>间隙锁（GapLock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事物在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。</li><li>临键锁（Next-KeyLock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。</li></ol><h3 id="行锁">行锁</h3><p>InnoDB实现了以下两种类型的行锁：</p><ol type="1"><li>共享锁（S）：允许一个事物去读一行，阻止其他事物获得相同数据集的排他锁。</li><li>排他锁（X）：允许获取排他锁的事物更新数据，阻止其他事物获得相同数据集的共享锁和排他锁。</li></ol><table><thead><tr><th>当前锁类型</th><th>S（共享锁）</th><th>X（排他锁）</th></tr></thead><tbody><tr><td>S（共享锁）</td><td>兼容</td><td>冲突</td></tr><tr><td>X（排他锁）</td><td>冲突</td><td>冲突</td></tr></tbody></table><table><thead><tr><th>SQL</th><th>行锁类型</th><th>说明</th></tr></thead><tbody><tr><td>INSERT …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>UPDATE …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>DELETE …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>SELECT（正常）</td><td>不加任何锁</td><td></td></tr><tr><td>SELECT … LOCK IN SHARE MODE</td><td>共享锁</td><td>需要手动在 SELECT 之后加 LOCK IN SHARE MODE</td></tr><tr><td>SELECT … FOR UPDATE</td><td>排他锁</td><td>需要手动在 SELECT 之后 FOR UPDATE</td></tr></tbody></table><p>默认情况下，InnoDB在REPEATABLEREAD事物隔离级别运行，InnoDB使用next_key锁进行搜索和索引扫描，以防止幻读。</p><ol type="1"><li>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</li><li>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时升级为表锁。</li></ol><p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">select object_schema,object_name,index_name,lock_type,lock_mod,lock_data from performance_schema.data_locks;<br></code></pre></td></tr></table></figure><h3 id="间隙锁临键锁">间隙锁/临键锁</h3><p>默认情况下，InnoDB在REPEATABLEREAD事务隔离级别运行，InnoDB使用next_key锁进行搜索和索引扫描，以防止幻读。</p><ol type="1"><li>索引上的等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁。</li><li>索引上的等值查询（普通索引），向右遍历时最后一个值不满足查询需求时，next-keylock退化为间隙锁。</li><li>索引上的范围查询（唯一索引）–会访问到不满足条件的第一个值为止。</li></ol><blockquote><p>注意：间隙锁唯一目的是防止其他事物插入间隙。间隙锁可以共存，一个事物采用的间隙锁不会阻止另一个事务在同一间隙锁上采用间隙锁。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10. 视图/存储过程/触发器</title>
    <link href="/2024/11/27/MySQL/10-%E8%A7%86%E5%9B%BE-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <url>/2024/11/27/MySQL/10-%E8%A7%86%E5%9B%BE-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="视图">1. 视图</h1><ol type="1"><li>视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。<br></li><li>通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</li></ol><h2 id="创建视图">1.1 创建视图</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [ <span class="hljs-keyword">OR</span> REPLACE ] <span class="hljs-keyword">VIEW</span> 视图名称[（列名列表）] <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> 语句 [ <span class="hljs-keyword">WITH</span> [ <span class="hljs-keyword">CASCADED</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">LOCAL</span> ] <span class="hljs-keyword">CHECK</span> OPTION ]<br><br><span class="hljs-comment">-- 例子： </span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">or</span> replace <span class="hljs-keyword">view</span> stu_v1 <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> id,name <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> id<span class="hljs-operator">&lt;=</span><span class="hljs-number">10</span>; <br></code></pre></td></tr></table></figure><h2 id="查询视图">1.2 查询视图</h2><ol type="1"><li>查看创建视图语句： <code>SHOW CREATE VIEW</code>视图名称；<ol type="1"><li><code>show create view stu_v_1;</code></li></ol></li><li>查看视图数据：<code>SELECT*FROM</code> 视图名称；</li></ol><h2 id="修改视图">1.3 修改视图</h2><ol type="1"><li><p>方式一：<code>CREATE[OR REPLACE] VIEW 视图名称[（列名列表)）] AS SELECT 语句[ WITH[ CASCADED | LOCAL ] CHECK OPTION ]</code></p></li><li><p>方式二：<code>ALTER VIEW 视图名称 [（列名列表)] AS SELECT语句 [WITH [CASCADED | LOCAL] CHECK OPTION]</code></p></li></ol><h2 id="删除视图">1.4 删除视图</h2><ol type="1"><li><code>DROP VIEW [IF EXISTS] 视图名称 [视图名称]</code></li></ol><h2 id="视图检查选项">1.5 视图检查选项</h2><ol type="1"><li>当使用WITH CHECK QPTION子句创建视图时，<ol type="1"><li>MySQL会通过视图检查正在更改的每个行，例如插入，更新，删除，以使其符合视图的定义。</li><li>MySQL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。</li><li>为了确定检查的范围，mysql提供了两个选项：CASCADED 和 LOCAL，默认值为 CASCADED。</li></ol></li><li>NOTE：如果没有开检查选项就不会进行检查。不同版本是不同含义的，要看版本。</li></ol><h3 id="cascaded">1.5.1 CASCADED</h3><p>级联，一旦选择了这个选项，除了会检查创建视图时候的条件，还会检查所依赖视图的条件。</p><blockquote><p>比如下面的例子：创建stu_V_l 视图，id是小于等于 20的。<br><code>create or replace view stu_V_l as select id,name from student where id &lt;=20;</code>再创建 stu_v_2 视图，20 &gt;= id &gt;=10。<br><code>create or replace view stu_v_2 as select id,name from stu_v_1 where id &gt;=10 with cascaded check option;</code>再创建 stu_v_3 视图。<br><code>create or replace view stu_v_3 as select id,name from stu_v_2 where id&lt;=15;</code><br>这条数据能够成功，stu_v_3 没有开检查选项所以不会 去判断 id是否小于等于15, 直接检查 是否满足 stu_v_2。<br><code>insert into stu_v_3 values(17,'Tom');</code></p></blockquote><h3 id="local">1.5.2 LOCAL</h3><p>本地的条件也会检查，还会向上检查。在向上找的时候，就要看是否上面开了检查选项，如果没开就不检查。和CASCADED 的区别就是 CASCADED 不管上面开没开检查选项都会进行检查。</p><h2 id="更新及作用">1.6 更新及作用</h2><ol type="1"><li>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则该视图不可更新</li></ol><ul><li>聚合函数或窗口函数 ( SUM()、MIN()、MAX()、COUNT() 等 )</li><li>DISTINCT</li><li>GROUP BY</li><li>HAVING</li><li>UNION 或者UNION ALL</li></ul><blockquote><p>例子： 使用了聚合函数，插入会失败。<code>create view stu_v_count as select count(*) from student;</code><br><code>insert into stu_v_count values(10);</code></p></blockquote><ol start="2" type="1"><li>作用</li></ol><ul><li><p>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。</p></li><li><p>安全</p><ul><li>数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据<br></li></ul></li><li><p>数据独立</p><ul><li>视图可帮助用户屏蔽真实表结构变化带来的影响。</li></ul></li></ul><ol start="3" type="1"><li>总而言之类似于给表加上了一个外壳，通过这个外壳访问表的时候，只能按照所设计的方式进行访问与更新。</li></ol><h2 id="案例">1.7 案例</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 为了保证数据库表的安全性，开发人员在操作tbsr表时，只能看到的用户的基本字段，屏薇手机号和邮箱两个字段。</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> tb_user_view <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> id, name, profession, age, gender, status, createtime <span class="hljs-keyword">from</span> tb_user;<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user_view;<br><br><span class="hljs-comment">-- 查询每个学生所选修的课程（三张表联查），这个功能在很多的业务中都有使用到，为了简化操作，定义一个视图。</span><br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> tb_stu_course_view <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> s.name student_name, s.no student_no, c.name course_name <span class="hljs-keyword">from</span> student s, student_course sc, course c <span class="hljs-keyword">where</span> s.id <span class="hljs-operator">=</span> sc.studentid <span class="hljs-keyword">and</span> sc.courseid <span class="hljs-operator">=</span> c.id;<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_stu_course_view;<br></code></pre></td></tr></table></figure><h1 id="存储过程">2. 存储过程</h1><ul><li><p>存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。</p></li><li><p>存储过程思想上很简单，就是数据库SQL语言层面的代码封装与重用。</p></li><li><p>特点</p></li></ul><ol type="1"><li>封装</li><li>复用</li><li>可以接收参数，也可以返回数据减少网络交互，效率提升</li></ol><h2 id="创建">2.1 创建</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> 存储过程名称( [参数列表] ) <br><br><span class="hljs-keyword">BEGIN</span><br> <span class="hljs-keyword">SQL</span> 语句 <br><span class="hljs-keyword">END</span>;<br><span class="hljs-comment">-- eg;</span><br>delimiter $$<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> p1()<br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> users;<br><span class="hljs-keyword">end</span>$$<br>delimiter ; <span class="hljs-comment">-- 还原</span><br></code></pre></td></tr></table></figure><p>NOTE: 在命令行中，执行创建存储过程的SQL时，需要通过关键字delimiter指定SQL语句的结束符。默认是 分号作为结束符。</p><p>delimiter ，则符作为结束符。</p><h2 id="调用">2.2 调用</h2><p>CALL 名称 ( <a href="#参数">参数</a>)</p><h2 id="查看">2.3 查看</h2><p>查询指定数据库的存储过程及状态信息</p><p><code>SELECT* FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = 'xxx'</code></p><p>存储过程名称；--查询某个存储过程的定义</p><p><code>SHOW CREATE PROCEDURE 存储过程名称</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> information_schema.routines <span class="hljs-keyword">where</span> routine_schema <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;itheima&#x27;</span>;<br><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> p1;<br></code></pre></td></tr></table></figure><h2 id="删除">2.4 删除</h2><p><code>DROP PROCEDURE [ IFEXISTS ] 存储过程名称</code></p><h2 id="变量">2.5 变量</h2><h3 id="系统变量">2.5.1 系统变量</h3><p><strong>系统变量</strong> 是 <code>MySQL</code>服务器提供，不是用户定义的，属于服务器层面。分为全局变量（<code>GLOBAL</code>）、会话变量（ <code>SESSION</code>）。</p><p><strong>查看系统变量</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> [SESSION<span class="hljs-operator">|</span><span class="hljs-keyword">GLOBAL</span>] VARIABLES;<span class="hljs-comment">-- 查看所有系统变量</span><br><span class="hljs-keyword">SHOW</span> [SESSION<span class="hljs-operator">|</span><span class="hljs-keyword">GLOBAL</span>] VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;...&#x27;</span>;<span class="hljs-comment">-- 可以通过LIKE模糊匹配方式查找变量</span><br><span class="hljs-keyword">SELECT</span> @@[SESSION<span class="hljs-operator">|</span><span class="hljs-keyword">GLOBAL</span>] 系统变量名;<span class="hljs-comment">-- 查看指定变量的值</span><br></code></pre></td></tr></table></figure><p><strong>设置系统变量</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> [SESSION<span class="hljs-operator">|</span><span class="hljs-keyword">GLOBAL</span>] 查看变量名<span class="hljs-operator">=</span>值;<br><span class="hljs-keyword">SET</span> @@[SESSION<span class="hljs-operator">|</span><span class="hljs-keyword">GLOBAL</span>] 系统变量名<span class="hljs-operator">=</span>值;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p>如果没有指定 <code>SESSION/GLOBAL</code> ，默认是<code>SESSION</code> ，会话变量。</p><p><code>MySQL</code>服务重新启动后，所设置的全局变量参数会失效，要想不失效，可以在`/etc/my.cnf/ 中配置。</p></blockquote><h3 id="用户定义变量">2.5.2 用户定义变量</h3><p><strong>用户定义变量</strong>是用户根据需要自己定义的变量，用户变量不同提前声明，在用的时候直接用"<span class="citation" data-cites="变量名">@变量名</span>"使用就可以。其作用域为当前连接。</p><p><strong>赋值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> <span class="hljs-variable">@var_name</span> <span class="hljs-operator">=</span> expr [,<span class="hljs-variable">@var_name</span> <span class="hljs-operator">=</span> expr]...;<br><span class="hljs-keyword">SET</span> <span class="hljs-variable">@var_name</span> :<span class="hljs-operator">=</span> expr [,<span class="hljs-variable">@var_name</span> :<span class="hljs-operator">=</span> expr]...;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@var_name</span> :<span class="hljs-operator">=</span> expr [,<span class="hljs-variable">@var_name</span> :<span class="hljs-operator">=</span> expr]...;<br><span class="hljs-keyword">SELECT</span> 字段名 <span class="hljs-keyword">INTO</span> <span class="hljs-variable">@var_name</span> <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure><p><strong>使用</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@var_name</span>;<br></code></pre></td></tr></table></figure><p><strong>案例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 赋值</span><br><span class="hljs-keyword">set</span> <span class="hljs-variable">@myname</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;itcast&#x27;</span>;<br><span class="hljs-keyword">set</span> <span class="hljs-variable">@mysqg</span> :<span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">set</span> <span class="hljs-variable">@mygender</span> :<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-variable">@myhobby</span> :<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;java&#x27;</span>;<br><br><span class="hljs-keyword">select</span> <span class="hljs-variable">@mycolor</span> :<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;red&#x27;</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">into</span> <span class="hljs-variable">@mycount</span> <span class="hljs-keyword">from</span> tb_user;<br><br><span class="hljs-comment">-- 使用</span><br><span class="hljs-keyword">select</span> <span class="hljs-variable">@myname</span>,<span class="hljs-variable">@myage</span>,<span class="hljs-variable">@mygender</span>,<span class="hljs-variable">@myhobby</span>;<br><br><span class="hljs-keyword">select</span> <span class="hljs-variable">@mycolor</span>,<span class="hljs-variable">@mycount</span>;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>用户定义的变量无需对其进行声明或初始化，只不过获取到的值为<code>NULL</code> 。</p></blockquote><h3 id="局部变量">2.5.3 局部变量</h3><p><strong>局部变量</strong>是根据需要定义的在局部生效的变量，访问之前，需要 <code>DECLARE</code>声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的<code>BEGIN ... END</code> 块。</p><p><strong>声明</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DECLARE</span> 变量名 变量类型 [<span class="hljs-keyword">DEFAULT</span> ...];<br></code></pre></td></tr></table></figure><p>变量类型就是数据库字段类型： <code>INT</code> 、 <code>BIGINT</code>、 <code>CHAR</code> 、 <code>VARCHAR</code> 、 <code>DATE</code> 、<code>TIME</code> 等</p><p><strong>赋值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> 变量名 <span class="hljs-operator">=</span> 值;<br><span class="hljs-keyword">SET</span> 变量名 :<span class="hljs-operator">=</span> 值;<br><span class="hljs-keyword">SELECT</span> 字段名 <span class="hljs-keyword">INTO</span> 变量名 <span class="hljs-keyword">FROM</span> 表名 ...;<br></code></pre></td></tr></table></figure><p><strong>案例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> p()<br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">declare</span> stu_count <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">into</span> stu_count <span class="hljs-keyword">from</span> student;<br><span class="hljs-keyword">select</span> stu_count;<br><span class="hljs-keyword">end</span>;<br><br><span class="hljs-keyword">call</span> p();<br></code></pre></td></tr></table></figure><h2 id="if">2.6 if</h2><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">IF 条件<span class="hljs-number">1</span> <span class="hljs-keyword">THEN</span><br>...<br>ELSEIF 条件<span class="hljs-number">2</span> <span class="hljs-keyword">THEN</span> <span class="hljs-comment">-- 可选</span><br>...<br><span class="hljs-keyword">ELSE</span> <span class="hljs-comment">-- 可选</span><br>...<br><span class="hljs-keyword">END</span> IF;<br></code></pre></td></tr></table></figure><p><strong>案例</strong></p><p>根据定义的分数 <code>score</code>变量，判定当前分数对应的分数等级。</p><ol type="1"><li>score &gt;= 85 分，等级为优秀</li><li>score &gt;= 60 分且 score &lt; 85 分，等级为及格。</li><li>score &lt; 60 分，等级为不及格。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> p()<br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">declare</span> score <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">58</span>;<br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">result</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>);<br><br>if score <span class="hljs-operator">&gt;=</span> <span class="hljs-number">85</span> <span class="hljs-keyword">then</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> :<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;优秀&#x27;</span>;<br>elseif score <span class="hljs-operator">&gt;=</span> <span class="hljs-number">60</span> <span class="hljs-keyword">then</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> :<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;及格&#x27;</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> :<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;不及格&#x27;</span>;<br><span class="hljs-keyword">end</span> if;<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">result</span>;<br><span class="hljs-keyword">end</span>;<br><br><span class="hljs-keyword">call</span> p();<br></code></pre></td></tr></table></figure><h3 id="参数">参数</h3><table><thead><tr><th style="text-align: left;">类型</th><th style="text-align: left;">含义</th><th style="text-align: left;">备注</th></tr></thead><tbody><tr><td style="text-align: left;">IN</td><td style="text-align: left;">该类参数作为输入，也就是需要调用时传入值</td><td style="text-align: left;">默认</td></tr><tr><td style="text-align: left;">OUT</td><td style="text-align: left;">该类参数作为输出，也就是该参数可以作为返回值</td><td style="text-align: left;"></td></tr><tr><td style="text-align: left;">INOUT</td><td style="text-align: left;">既可以作为输入参数，也可以作为输出参数</td><td style="text-align: left;"></td></tr></tbody></table><p><strong>用法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> 存储过程名称 ([<span class="hljs-keyword">IN</span><span class="hljs-operator">/</span><span class="hljs-keyword">OUT</span><span class="hljs-operator">/</span><span class="hljs-keyword">INOUT</span> 参数名 参数类型])<br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-comment">-- SQL语句</span><br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure><p><strong>案例</strong></p><p>（1）根据传入参数 <code>score</code>，判定当前分数对应的分数等级，并返回。</p><ol type="1"><li>score &gt;= 85 分，等级为优秀</li><li>score &gt;= 60 分且 score &lt; 85 分，等级为及格。</li><li>score &lt; 60 分，等级为不及格。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> p(<span class="hljs-keyword">in</span> score <span class="hljs-type">int</span>, <span class="hljs-keyword">out</span> <span class="hljs-keyword">result</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>))<br><span class="hljs-keyword">begin</span><br>if score <span class="hljs-operator">&gt;=</span> <span class="hljs-number">85</span> <span class="hljs-keyword">then</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> :<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;优秀&#x27;</span>;<br>elseif score <span class="hljs-operator">&gt;=</span> <span class="hljs-number">60</span> <span class="hljs-keyword">then</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> :<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;及格&#x27;</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> :<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;不及格&#x27;</span>;<br><span class="hljs-keyword">end</span> if;<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">result</span>;<br><span class="hljs-keyword">end</span>;<br><br><span class="hljs-keyword">call</span> p(<span class="hljs-number">68</span>, <span class="hljs-variable">@result</span>);<br><span class="hljs-keyword">select</span> <span class="hljs-variable">@result</span>;<br></code></pre></td></tr></table></figure><p>（2）将传入的 200 分制的分数，进行换算，换算成百分制，然后返回。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> p(<span class="hljs-keyword">inout</span> score <span class="hljs-keyword">double</span>)<br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">set</span> score :<span class="hljs-operator">=</span> score <span class="hljs-operator">*</span> <span class="hljs-number">0.5</span>;<br><span class="hljs-keyword">end</span>;<br><br><span class="hljs-keyword">set</span> <span class="hljs-variable">@score</span> <span class="hljs-operator">=</span> <span class="hljs-number">78</span>;<br><span class="hljs-keyword">call</span> p(<span class="hljs-variable">@score</span>);<br><span class="hljs-keyword">select</span> <span class="hljs-variable">@score</span>;<br></code></pre></td></tr></table></figure><h2 id="case">2.7 case</h2><p><strong>语法一</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CASE</span> case_value<br><span class="hljs-keyword">WHEN</span> when_value1 <span class="hljs-keyword">THEN</span> statement_list1<br>[<span class="hljs-keyword">WHEN</span> when_value2 <span class="hljs-keyword">THEN</span> statement_list2]...<br>[<span class="hljs-keyword">ELSE</span> statement_list]<br><span class="hljs-keyword">END</span> <span class="hljs-keyword">CASE</span>;<br></code></pre></td></tr></table></figure><p><strong>语法二</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CASE</span><br><span class="hljs-keyword">WHEN</span> search_condition1 <span class="hljs-keyword">THEN</span> statement_list1<br>[<span class="hljs-keyword">WHEN</span> search_condition2 <span class="hljs-keyword">THEN</span> statement_list2]...<br>[<span class="hljs-keyword">ELSE</span> statement_list]<br><span class="hljs-keyword">END</span> <span class="hljs-keyword">CASE</span>;<br></code></pre></td></tr></table></figure><p><strong>案例</strong></p><p>根据传入的月份，判定月份所属的季节（需求采用 <code>case</code>结构）。</p><ol type="1"><li>1-3 月份，为第一季度</li><li>4-6 月份，为第二季度</li><li>7-9 月份，为第三季度</li><li>10-12 月份，为第四季度</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> p(<span class="hljs-keyword">in</span> <span class="hljs-keyword">month</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">result</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-keyword">case</span><br><span class="hljs-keyword">when</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">&gt;=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">&lt;=</span> <span class="hljs-number">3</span> <span class="hljs-keyword">then</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> :<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;第一季度&#x27;</span>;<br><span class="hljs-keyword">when</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">&gt;=</span> <span class="hljs-number">4</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">&lt;=</span> <span class="hljs-number">6</span> <span class="hljs-keyword">then</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> :<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;第二季度&#x27;</span>;<br><span class="hljs-keyword">when</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">&gt;=</span> <span class="hljs-number">7</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">&lt;=</span> <span class="hljs-number">9</span> <span class="hljs-keyword">then</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> :<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;第三季度&#x27;</span>;<br><span class="hljs-keyword">when</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">&gt;=</span> <span class="hljs-number">10</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">&lt;=</span> <span class="hljs-number">12</span> <span class="hljs-keyword">then</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> :<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;第四季度&#x27;</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> :<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;非法参数&#x27;</span>;<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">case</span>;<br><br><span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;您输入的月份为：&#x27;</span>,<span class="hljs-keyword">month</span>,<span class="hljs-string">&#x27;，所属的季度为：&#x27;</span>,<span class="hljs-keyword">result</span>);<br><span class="hljs-keyword">end</span>;<br><br><span class="hljs-keyword">call</span> p(<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><h2 id="while">2.8 while</h2><p><code>while</code>循环是有条件的循环控制语句。满足条件后，再执行循环体中的<code>SQL</code> 语句。具体语法为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 先判定条件，如果条件为true，则执行逻辑；否则，不执行逻辑</span><br>WHILE 条件 DO<br><span class="hljs-keyword">SQL</span>逻辑...<br><span class="hljs-keyword">END</span> WHILE;<br></code></pre></td></tr></table></figure><p><strong>案例</strong></p><p>计算从 <code>1</code> 累加到 <code>n</code> 的值， <code>n</code>为传入的参数值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> p(<span class="hljs-keyword">in</span> n <span class="hljs-type">int</span>)<br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">declare</span> total <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>while n<span class="hljs-operator">&gt;</span><span class="hljs-number">0</span> do<br><span class="hljs-keyword">set</span> total :<span class="hljs-operator">=</span> total <span class="hljs-operator">+</span> n;<br><span class="hljs-keyword">set</span> n :<span class="hljs-operator">=</span> n <span class="hljs-operator">-</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">end</span> while;<br><br><span class="hljs-keyword">select</span> total;<br><span class="hljs-keyword">end</span>;<br><br><span class="hljs-keyword">call</span> p(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><h2 id="repeat">2.9 repeat</h2><p><code>repeat</code>是有条件的循环控制语句，当满足条件的时候退出循环。具体语法为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 限制性一次逻辑，然后判定逻辑是否满足，如果满足，则推出。如果不满足，则继续下一次循环</span><br>REPEAT<br><span class="hljs-keyword">SQL</span>逻辑...<br>UNTIL 条件<br><span class="hljs-keyword">END</span> REPEAT;<br></code></pre></td></tr></table></figure><p><strong>案例</strong></p><p>计算从 <code>1</code> 累加到 <code>n</code> 的值， <code>n</code>为传入的参数值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> p(<span class="hljs-keyword">in</span> n <span class="hljs-type">int</span>)<br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">declare</span> total <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br><br>repeat<br><span class="hljs-keyword">set</span> total :<span class="hljs-operator">=</span> total <span class="hljs-operator">+</span> n;<br><span class="hljs-keyword">set</span> n :<span class="hljs-operator">=</span> n<span class="hljs-number">-1</span>;<br>until n<span class="hljs-operator">&lt;=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">end</span> repeat;<br><br><span class="hljs-keyword">select</span> total;<br><span class="hljs-keyword">end</span>;<br><br><span class="hljs-keyword">call</span> p(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><h2 id="loop">2.10 loop</h2><p><code>LOOP</code> 实现简单的循环，如果不在 <code>SQL</code>逻辑中增加退出循环的条件，可以用来其来实现简单的死循环。<code>LOOP</code> 可以配合一下两个语句使用：</p><ul><li><code>LEAVE</code> ：配合循环使用，退出循环。</li><li><code>ITERATE</code>：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">[begin_label:] LOOP<br><span class="hljs-keyword">SQL</span>逻辑...<br><span class="hljs-keyword">END</span> LOOP [end_label];<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">LEAVE label;<span class="hljs-comment">-- 退出指定标记的循环体</span><br>ITERATE label;<span class="hljs-comment">-- 直接进入下一次循环</span><br></code></pre></td></tr></table></figure><p><strong>案例</strong></p><ol type="1"><li>计算从 <code>1</code> 累加到 <code>n</code> 的值， <code>n</code>为传入的参数值。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> p(<span class="hljs-keyword">in</span> n <span class="hljs-type">int</span>)<br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">declare</span> total <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br><br>sum:loop<br>if n <span class="hljs-operator">&lt;=</span> <span class="hljs-number">0</span> <span class="hljs-keyword">then</span><br>leave sum;<br><span class="hljs-keyword">end</span> if;<br><br><span class="hljs-keyword">set</span> total :<span class="hljs-operator">=</span> total <span class="hljs-operator">+</span> n;<br><span class="hljs-keyword">set</span> n :<span class="hljs-operator">=</span> n <span class="hljs-operator">-</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">end</span> loop sum;<br><br><span class="hljs-keyword">select</span> total;<br><span class="hljs-keyword">end</span>;<br><br><span class="hljs-keyword">call</span> p(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><ol type="1"><li>计算从 <code>1</code> 到 <code>n</code> 之间的偶数累加的值，<code>n</code> 为传入的参数值。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> p(<span class="hljs-keyword">in</span> n <span class="hljs-type">int</span>)<br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">declare</span> total <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br><br>sum:loop<br>if n <span class="hljs-operator">&lt;=</span> <span class="hljs-number">0</span> <span class="hljs-keyword">then</span><br>leave sum;<br><span class="hljs-keyword">end</span> if;<br><br>if n <span class="hljs-operator">%</span> <span class="hljs-number">2</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">then</span><br><span class="hljs-keyword">set</span> n :<span class="hljs-operator">=</span> n <span class="hljs-operator">-</span> <span class="hljs-number">1</span>;<br>iterate sum;<br><span class="hljs-keyword">end</span> if;<br><br><span class="hljs-keyword">set</span> total :<span class="hljs-operator">=</span> total <span class="hljs-operator">+</span> n;<br><span class="hljs-keyword">set</span> n :<span class="hljs-operator">=</span> n <span class="hljs-operator">-</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">end</span> loop sum;<br><br><span class="hljs-keyword">select</span> total;<br><span class="hljs-keyword">end</span>;<br><br><span class="hljs-keyword">call</span> p(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><h2 id="游标">2.11 游标</h2><p><strong>游标（ <code>CURSOR</code>）</strong>是用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、<code>OPEN</code> 、 <code>FETCH</code> 和 <code>CLOSE</code>，其语法分别如下。</p><p><strong>声明游标</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DECLARE</span> 游标名称 <span class="hljs-keyword">CURSOR</span> <span class="hljs-keyword">FOR</span> 查询语句;<br></code></pre></td></tr></table></figure><p><strong>打开游标</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">OPEN</span> 游标名称;<br></code></pre></td></tr></table></figure></p><p><strong>获取游标记录</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">FETCH</span> 游标名称 <span class="hljs-keyword">INTO</span> 变量[,变量];<br></code></pre></td></tr></table></figure></p><p><strong>关闭游标</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CLOSE</span> 游标名称;<br></code></pre></td></tr></table></figure></p><p><strong>案例</strong></p><p>使用游标创建一个存储过程，统计 <code>STUDENT</code> 表年龄大于<code>19</code> 的记录的数量，如下为 <code>STUDENT</code>表的创建代码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER $<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> PROC_STAT()<br><span class="hljs-keyword">BEGIN</span><br>    # 创建 用于接收游标值的变量<br>    <span class="hljs-keyword">DECLARE</span> ID,AGE,TOTAL <span class="hljs-type">INT</span>;<br>    <span class="hljs-keyword">DECLARE</span> NAME,SEX <span class="hljs-type">CHAR</span>(<span class="hljs-number">10</span>);<br>    # 游标结束的标志<br>    <span class="hljs-keyword">DECLARE</span> DONE <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;<br>    # 声明游标<br>    <span class="hljs-keyword">DECLARE</span> CUR <span class="hljs-keyword">CURSOR</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">SELECT</span> STUID,STUNAME,STUSEX,STUAGE <span class="hljs-keyword">FROM</span> STUDENT <span class="hljs-keyword">WHERE</span> STUAGE <span class="hljs-operator">&gt;</span> <span class="hljs-number">19</span>;<br>    # 指定游标循环结束时的返回值<br>    <span class="hljs-keyword">DECLARE</span> CONTINUE HANDLER <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">NOT</span> FOUND <span class="hljs-keyword">SET</span> DONE <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    # 打开游标<br>    <span class="hljs-keyword">OPEN</span> CUR;<br>    # 初始化变量<br>    <span class="hljs-keyword">SET</span> TOTAL <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    # WHILE 循环<br>    WHILE DONE <span class="hljs-operator">!=</span> <span class="hljs-number">1</span> DO<br>        <span class="hljs-keyword">FETCH</span> CUR <span class="hljs-keyword">INTO</span> ID,NAME,SEX,AGE;<br>          IF DONE <span class="hljs-operator">!=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">THEN</span><br>             <span class="hljs-keyword">SET</span> TOTAL <span class="hljs-operator">=</span> TOTAL <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">END</span> IF;<br>    <span class="hljs-keyword">END</span> WHILE;<br>    # 关闭游标<br>    <span class="hljs-keyword">CLOSE</span> CUR;<br>    # 输出累计的结果<br>    <span class="hljs-keyword">SELECT</span> TOTAL;<br><span class="hljs-keyword">END</span>$<br>DELIMITER ;<br># 调用存储过程<br><span class="hljs-keyword">CALL</span> PROC_STAT();<br></code></pre></td></tr></table></figure><h2 id="条件处理程序">2.12 条件处理程序</h2><p><strong>条件处理程序（Handler）</strong>可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。具体语法为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DECLARE</span> handler_action HANDLER <span class="hljs-keyword">FOR</span> condition_value [,condition_value]... statement;<br><br>handler_action<br>CONTINUE:继续执行当前程序<br>EXIT:中止执行当前程序<br>condition_value<br><span class="hljs-keyword">SQLSTATE</span> sqlstate_value:状态码，如<span class="hljs-number">02000</span>，表示抓取的时候没数据<br><span class="hljs-keyword">SQLWARNING</span>:所有以<span class="hljs-number">01</span>开头的<span class="hljs-keyword">SQLSTATE</span>代码的简写<br><span class="hljs-keyword">NOT</span> FOUND:所有以<span class="hljs-number">02</span>开头的<span class="hljs-keyword">SQLSTATE</span>代码的简写<br><span class="hljs-keyword">SQLEXCEPTION</span>:所有没有被SQLWARNNING或<span class="hljs-keyword">NOT</span> FOUND捕获的<span class="hljs-keyword">SQLSTATE</span>代码的简写<br></code></pre></td></tr></table></figure><p><strong>案例</strong></p><p>根据传入的参数 <code>uage</code> ，来查询用户表 <code>tb_user</code>中，所有的用户年龄小于等于 <code>uage</code> 的用户姓名（<code>name</code>）和专业（<code>profession</code>），并将用户的姓名和专业插入到所创建的一张新表（<code>id,name,profession</code>） 中。</p><p>逻辑：</p><ol type="1"><li>声明游标，存储查询结果集</li><li>准备：创建表结构</li><li>开启游标</li><li>获取游标中的记录</li><li>插入数据到新表中</li><li>关闭游标</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> p(<span class="hljs-keyword">in</span> uage <span class="hljs-type">int</span>)<br><span class="hljs-keyword">begin</span><br><span class="hljs-comment">-- 需要先声明普通变量，再声明游标，不然会报错</span><br><span class="hljs-keyword">declare</span> uname <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>);<br><span class="hljs-keyword">declare</span> upro <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>);<br><span class="hljs-keyword">declare</span> u_cursor <span class="hljs-keyword">cursor</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">select</span> name,profession <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> age <span class="hljs-operator">&lt;=</span> uage;<br><span class="hljs-keyword">declare</span> exit handler <span class="hljs-keyword">for</span> <span class="hljs-keyword">SQLSTATE</span> <span class="hljs-string">&#x27;02000&#x27;</span> <span class="hljs-keyword">close</span> u_cursor;<br><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> tb_user_pro;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> tb_user_pro(<br>    id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>        name <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>),<br>        profession <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>)<br>    );<br><br>    <span class="hljs-keyword">open</span> u_cursor;<br>    while <span class="hljs-literal">true</span> do<br>    <span class="hljs-keyword">fetch</span> u_cursor <span class="hljs-keyword">into</span> uname,upro;<br>    <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_user_pro <span class="hljs-keyword">values</span> (<span class="hljs-keyword">null</span>, uname, upro);<br>    <span class="hljs-keyword">end</span> while;<br>    <span class="hljs-keyword">close</span> u_cursor;<br><br><span class="hljs-keyword">end</span>;<br><br><span class="hljs-keyword">call</span> p(<span class="hljs-number">40</span>);<br></code></pre></td></tr></table></figure><h1 id="存储函数">3. 存储函数</h1><p>存储函数是有返回值的存储过程，存储函数的参数只能是 <code>IN</code>类型的。具体语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> 存储函数名称([参数列表])<br><span class="hljs-keyword">RETURNS</span> type [characteristic...]<br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-comment">-- SQL语句</span><br><span class="hljs-keyword">RETURN</span> ...;<br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure><p><code>characteristic</code> 说明：</p><ul><li><code>DETERMINISTIC</code> ：相同的输入参数总是产生相同的结果。</li><li><code>NO SQL</code> ：不包含 <code>SQL</code> 语句。</li><li><code>READS SQL DATA</code>：包含读取数据的语句，但不包含写入数据的语句。</li><li><strong>DETERMINISTIC</strong>：<ul><li>表示函数的返回值在给定相同的输入参数时总是相同的。也就是说，对于一组特定的输入参数，函数将始终产生相同的输出。</li><li>这个特性对于数据库优化很重要，因为如果一个函数是确定性的，那么在查询计划中，数据库可以缓存这个函数的结果，以提高查询效率。</li><li>如果函数内部涉及到随机数生成或者依赖于外部变化的数据（如当前时间、用户会话变量等），则不应该声明为DETERMINISTIC。</li></ul></li><li><strong>NO SQL</strong>：<ul><li>表示函数中不包含任何SQL语句，即函数体中没有对数据库进行任何读写操作。</li><li>声明为NOSQL的函数可以安全地在如事务处理等需要确保ACID属性（原子性、一致性、隔离性、持久性）的上下文中使用，因为它们不会影响数据库的数据。</li></ul></li><li><strong>READS SQL DATA</strong>：<ul><li>表示函数中包含读取数据的SQL语句，但不包含写入数据的语句。</li><li>这种类型的函数可能会从数据库中读取数据，但不进行任何修改。因此，它们不会影响数据的一致性和完整性。</li><li>声明为READS SQLDATA的函数可以在大多数上下文中安全使用，但数据库系统会确保这些函数不会在不允许读取数据的上下文中被调用。</li></ul></li></ul><p><strong>案例</strong></p><p>计算从 <code>1</code> 累加到 <code>n</code> 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">function</span> fun1(n <span class="hljs-type">int</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-type">int</span> <span class="hljs-keyword">deterministic</span><br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">declare</span> total <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br><br>while n<span class="hljs-operator">&gt;</span><span class="hljs-number">0</span> do<br><span class="hljs-keyword">set</span> total :<span class="hljs-operator">=</span> total <span class="hljs-operator">+</span> n;<br><span class="hljs-keyword">set</span> n :<span class="hljs-operator">=</span> n <span class="hljs-operator">-</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">end</span> while;<br><br><span class="hljs-keyword">return</span> total;<br><span class="hljs-keyword">end</span>;<br><br><span class="hljs-keyword">select</span> fun1(<span class="hljs-number">50</span>);<br></code></pre></td></tr></table></figure><h1 id="触发器">4. 触发器</h1><h2 id="介绍">4.1 介绍</h2><p>触发器是与表有关的数据库对象，指在 <code>insert/update/delete</code>之前或之后，触发并执行触发器中定义的 <code>SQL</code>语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。</p><p>使用别名 <code>OLD</code> 和 <code>NEW</code>来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p><table><thead><tr><th>触发器类型</th><th>NEW 和 OLD</th></tr></thead><tbody><tr><td>INSERT 型触发器</td><td>NEW 表示将要或者已经新增的数据</td></tr><tr><td>UPDATE 型触发器</td><td>OLD 表示修改之前的数据，NEW 表示将要或已经修改后的数据</td></tr><tr><td>DELETE 型触发器</td><td>OLD 表示将要或者已经删除的数据</td></tr></tbody></table><h2 id="语法">4.2 语法</h2><p><strong>创建</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> trigger_name<br>BEFORE<span class="hljs-operator">/</span>AFTER <span class="hljs-keyword">INSERT</span><span class="hljs-operator">/</span><span class="hljs-keyword">UPDATE</span><span class="hljs-operator">/</span><span class="hljs-keyword">DELETE</span><br><span class="hljs-keyword">ON</span> tbl_name <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span>  <span class="hljs-comment">-- 行级触发器</span><br><span class="hljs-keyword">BEGIN</span><br>trigger_stmt;<br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure></p><p><strong>查看</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> TRIGGERS;<br></code></pre></td></tr></table></figure><p><strong>删除</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TRIGGER</span> [schema_name.]trigger_name;<span class="hljs-comment">--如果没有指定schema_name，默认为当前数据库</span><br></code></pre></td></tr></table></figure></p><h2 id="案例-1">4.3 <strong>案例</strong></h2><p>通过触发器记录 <code>tu_user</code>表的数据变更日志，将变更日志插入到日志表 <code>user_logs</code>中，包含增加、修改和删除。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建表结构</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> user_logs(<br>  id <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> auto_increment,<br>  operation <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;操作类型, insert/update/delete&#x27;</span>,<br>  operate_time datetime <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;操作时间&#x27;</span>,<br>  operate_id <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;操作的ID&#x27;</span>,<br>  operate_params <span class="hljs-type">varchar</span>(<span class="hljs-number">500</span>) comment <span class="hljs-string">&#x27;操作参数&#x27;</span>,<br>  <span class="hljs-keyword">primary</span> key(`id`)<br>)engine<span class="hljs-operator">=</span>innodb <span class="hljs-keyword">default</span> charset<span class="hljs-operator">=</span>utf8;<br></code></pre></td></tr></table></figure></p><h3 id="insert-类型触发器"><strong><code>INSERT</code>类型触发器：</strong></h3><p><strong>案例1</strong></p><p>编写一个名为 <code>INSERT_S</code> 的触发器，在 <code>S</code> 表执行<code>INSERT</code> 语句后被激发，此触发器将新供应商的<code>SNO</code>、 <code>SNAME</code>、 <code>STATUS</code>、<code>CITY</code> 及执行此操作的用户（ <code>USER</code>）插入<code>N_S</code> 表， <code>N_S</code> 表比 <code>S</code>表增添操作用户一列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter $<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> INSERT_S after <span class="hljs-keyword">insert</span> <span class="hljs-keyword">on</span> S <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-type">row</span><br><span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> N_S(SNO,SNAME,STATUS,CITY,<span class="hljs-keyword">USER</span>) <span class="hljs-keyword">VALUES</span>(new.SNO,new.SNAME,new.STATUS,new.CITY,<span class="hljs-keyword">USER</span>());<br><span class="hljs-keyword">end</span>$<br>delimiter ;<br></code></pre></td></tr></table></figure><p><strong>案例2</strong></p><p>编写一个名为 <code>INSERT_SPJ</code> 的触发器，当 <code>SPJ</code>表中有插入某条记录时，自动更新表 <code>SPJ_SUMQTY</code> 表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter $<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> INSERT_SPJ after <span class="hljs-keyword">insert</span> <span class="hljs-keyword">on</span> SPJ <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-type">row</span><br><span class="hljs-keyword">begin</span><br>    if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> SPJ_SUMQTY <span class="hljs-keyword">as</span> s <span class="hljs-keyword">where</span> s.PNO <span class="hljs-operator">=</span> new.PNO <span class="hljs-keyword">and</span> s.JNO <span class="hljs-operator">=</span> new.JNO) <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">update</span> SPJ_SUMQTY <span class="hljs-keyword">as</span> s1 <span class="hljs-keyword">set</span> s1.SUMQTY <span class="hljs-operator">=</span> s1.SUMQTY <span class="hljs-operator">+</span> new.QTY <span class="hljs-keyword">where</span> s1.JNO <span class="hljs-operator">=</span> new.JNO <span class="hljs-keyword">and</span> s1.PNO <span class="hljs-operator">=</span> new.PNO;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SPJ_SUMQTY <span class="hljs-keyword">VALUES</span>(new.JNO, new.PNO, new.QTY);<br>    <span class="hljs-keyword">end</span> if;<br><span class="hljs-keyword">end</span>$<br>delimiter ;<br></code></pre></td></tr></table></figure><p><strong>案例3</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 插入数据触发器</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> tb_user_insert_trigger<br>after <span class="hljs-keyword">insert</span> <span class="hljs-keyword">on</span> tb_user <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-type">row</span><br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> user_logs(id, operation, operate_time, operate_id, operate_params) <span class="hljs-keyword">VALUES</span><br>(<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;insert&#x27;</span>, now(), new.id, concat(<span class="hljs-string">&#x27;插入的数据内容为：id=&#x27;</span>,new.id,<span class="hljs-string">&#x27;,name=&#x27;</span>,new.name,<span class="hljs-string">&#x27;,phone=&#x27;</span>,new.phone,<span class="hljs-string">&#x27;,email=&#x27;</span>,new.email,<span class="hljs-string">&#x27;,profession=&#x27;</span>,new.profession));<br><span class="hljs-keyword">end</span>;<br><br><span class="hljs-comment">-- 查看</span><br><span class="hljs-keyword">show</span> triggers;<br><br><span class="hljs-comment">-- 插入数据</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_user(id, name, phone, email, profession, age, gender, status, createtime)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">25</span>,<span class="hljs-string">&#x27;二皇子&#x27;</span>,<span class="hljs-string">&#x27;18809091212&#x27;</span>,<span class="hljs-string">&#x27;erhuangzi@163.com&#x27;</span>,<span class="hljs-string">&#x27;软件工程&#x27;</span>,<span class="hljs-number">23</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,now());<br><br><span class="hljs-comment">-- 删除</span><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">trigger</span> tb_user_insert_trigger;<br></code></pre></td></tr></table></figure><h3 id="update-类型触发器"><strong><code>UPDATE</code>类型触发器：</strong></h3><p><strong>案例1</strong></p><p>编写一个名为 <code>UPDATE_S</code> 的触发器，检查 <code>S</code> 表的<code>STATUS</code> ，只允许 <code>0-100</code> 之间，超过<code>100</code> 后，改为 <code>100</code> 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter $<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> UPDATE_S before <span class="hljs-keyword">update</span> <span class="hljs-keyword">on</span> S <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-type">row</span><br><span class="hljs-keyword">begin</span><br>    if new.STATUS <span class="hljs-operator">&gt;</span> <span class="hljs-number">100</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">set</span> new.STATUS <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">end</span> if;<br><span class="hljs-keyword">end</span>$<br>delimiter ;<br></code></pre></td></tr></table></figure><p><strong>案例2</strong></p><p>编写一个名为 <code>UPDATE_SPJ</code> 的触发器，当 <code>SPJ</code>表中有更新某条记录时，自动更新表 <code>SPJ_SUMQTY</code> 表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter $<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> UPDATE_SPJ before <span class="hljs-keyword">update</span> <span class="hljs-keyword">on</span> SPJ <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-type">row</span><br><span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">update</span> SPJ_SUMQTY <span class="hljs-keyword">as</span> s1 <span class="hljs-keyword">set</span> s1.SUMQTY <span class="hljs-operator">=</span> s1.SUMQTY <span class="hljs-operator">+</span> new.QTY <span class="hljs-operator">-</span> old.QTY <span class="hljs-keyword">where</span> s1.JNO <span class="hljs-operator">=</span> new.JNO <span class="hljs-keyword">and</span> s1.PNO <span class="hljs-operator">=</span> new.PNO;<br><span class="hljs-keyword">end</span>$<br>delimiter ;<br></code></pre></td></tr></table></figure><p><strong>案例3</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 修改数据触发器</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> tb_user_update_trigger<br>after <span class="hljs-keyword">update</span> <span class="hljs-keyword">on</span> tb_user <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-type">row</span><br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> user_logs(id, operation, operate_time, operate_id, operate_params) <span class="hljs-keyword">VALUES</span><br>(<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;update&#x27;</span>, now(), new.id, concat(<span class="hljs-string">&#x27;更新之前的数据：id=&#x27;</span>,new.id,<span class="hljs-string">&#x27;,name=&#x27;</span>,old.name,<span class="hljs-string">&#x27;,phone=&#x27;</span>,old.phone,<span class="hljs-string">&#x27;,email=&#x27;</span>,old.email,<span class="hljs-string">&#x27;,profession=&#x27;</span>,old.profession,<br><span class="hljs-string">&#x27; | 更新之后的数据：id=&#x27;</span>,new.id,<span class="hljs-string">&#x27;,name=&#x27;</span>,new.name,<span class="hljs-string">&#x27;,phone=&#x27;</span>,new.phone,<span class="hljs-string">&#x27;,email=&#x27;</span>,new.email,<span class="hljs-string">&#x27;,profession=&#x27;</span>,new.profession));<br><span class="hljs-keyword">end</span>;<br><br><span class="hljs-comment">-- 查看</span><br><span class="hljs-keyword">show</span> triggers;<br><br><span class="hljs-comment">-- 更新数据</span><br><span class="hljs-keyword">update</span> tb_user <span class="hljs-keyword">set</span> age <span class="hljs-operator">=</span> <span class="hljs-number">32</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">23</span>;<br></code></pre></td></tr></table></figure><h3 id="delete-类型触发器"><strong><code>DELETE</code>类型触发器：</strong></h3><p><strong>案例1</strong></p><p>编写一个名为 <code>DELETE_SPJ</code> 的触发器，当 <code>SPJ</code>表中有删除某条记录时，自动更新表 <code>SPJ_SUMQTY</code> 表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter $<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> DELETE_SPJ after <span class="hljs-keyword">delete</span> <span class="hljs-keyword">on</span> SPJ <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-type">row</span><br><span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">update</span> SPJ_SUMQTY <span class="hljs-keyword">as</span> s1 <span class="hljs-keyword">set</span> s1.SUMQTY <span class="hljs-operator">=</span> s1.SUMQTY <span class="hljs-operator">-</span> old.QTY <span class="hljs-keyword">where</span> s1.JNO <span class="hljs-operator">=</span> old.JNO <span class="hljs-keyword">and</span> s1.PNO <span class="hljs-operator">=</span> old.PNO;<br>    <span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> SPJ_SUMQTY <span class="hljs-keyword">as</span> s1 <span class="hljs-keyword">where</span> s1.SUMQTY <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">end</span>$<br>delimiter ;<br></code></pre></td></tr></table></figure><p><strong>案例2</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 删除数据触发器</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> tb_user_delete_trigger<br>after <span class="hljs-keyword">delete</span> <span class="hljs-keyword">on</span> tb_user <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-type">row</span><br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> user_logs(id, operation, operate_time, operate_id, operate_params) <span class="hljs-keyword">VALUES</span><br>(<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;delete&#x27;</span>, now(), old.id, concat(<span class="hljs-string">&#x27;删除之前的数据：id=&#x27;</span>,old.id,<span class="hljs-string">&#x27;,name=&#x27;</span>,old.name,<span class="hljs-string">&#x27;,phone=&#x27;</span>,old.phone,<span class="hljs-string">&#x27;,email=&#x27;</span>,old.email,<span class="hljs-string">&#x27;,profession=&#x27;</span>,old.profession));<br><span class="hljs-keyword">end</span>;<br><br><span class="hljs-comment">-- 查看</span><br><span class="hljs-keyword">show</span> triggers;<br><br><span class="hljs-comment">-- 更新数据</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">25</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9. SQL优化</title>
    <link href="/2024/11/27/MySQL/9-SQL%E4%BC%98%E5%8C%96/"/>
    <url>/2024/11/27/MySQL/9-SQL%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="插入数据">1. 插入数据</h1><p>普通插入：</p><ol type="1"><li>采用批量插入（一次插入的数据不建议超过1000条，500 - 1000 为宜）</li><li>手动提交事务<ol type="1"><li>多条插入语句统一提交</li></ol></li><li>主键顺序插入（主键顺序插入的效率大于乱序插入）</li></ol><p>大批量插入：</p><ol type="1"><li>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 客户端连接服务端时，加上参数 <span class="hljs-comment">--local-infile（这一行在bash/cmd界面输入）</span><br>mysql <span class="hljs-comment">--local-infile -u root -p</span><br># 设置全局参数local_infile为<span class="hljs-number">1</span>，开启从本地加载文件导入数据的开关<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> local_infile <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">select</span> @<span class="hljs-variable">@local_infile</span>;<br># 执行load指令将准备好的数据，加载到表结构中，先要把表建立起来。<br>load data <span class="hljs-keyword">local</span> infile <span class="hljs-string">&#x27;/root/sql1.log&#x27;</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> <span class="hljs-string">&#x27;tb_user&#x27;</span> fields terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;,&#x27;</span> lines terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure><h1 id="主键优化">2. 主键优化</h1><ol type="1"><li><p>数据组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Indexorganized table, IOT）</p></li><li><p>主键的顺序的插入过程如下：</p></li></ol><p><img src="/2024/11/27/MySQL/9-SQL%E4%BC%98%E5%8C%96/image-20241130212808387.png"></p><ul><li>但是如果主键是乱序插入的话，就会导致需要插入的位置为中间的位置，会有页分裂的过程。</li></ul><ol start="3" type="1"><li><p>页分裂：页可以为空，也可以填充一般，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。</p></li><li><p>页合并：</p><ol type="1"><li>当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。</li><li>当页中删除的记录到达MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。</li></ol></li></ol><ul><li>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定</li></ul><blockquote><p>文字说明不够清晰明了，具体可以看视频里的PPT演示过程：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90</p></blockquote><ol start="5" type="1"><li>主键设计原则：</li></ol><ul><li>满足业务需求的情况下，尽量降低主键的长度，二级索引的叶子节点保存的就是主键，所以主键小占用的空间也就会少。</li><li>插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键</li><li>尽量不要使用 UUID做主键或者是其他的自然主键，如身份证号，占用的空间大。</li><li>业务操作时，避免对主键的修改</li></ul><h1 id="order-by优化">3. order by优化</h1><ol type="1"><li><p>Usingfilesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫FileSort 排序</p></li><li><p>Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为using index，不需要额外排序，操作效率高</p></li><li><p>如果order by字段全部使用升序排序或者降序排序，则都会走索引，</p><ol type="1"><li>但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是<code>Using index, Using filesort</code>，</li><li>如果要优化掉Usingfilesort，则需要另外再创建一个索引，如：<code>create index idx_user_age_phone_ad on tb_user(age asc, phone desc);</code>，此时使用<code>select id, age, phone from tb_user order by age asc, phone desc;</code>会全部走索引</li></ol></li></ol><p>总结：</p><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</li><li>尽量使用覆盖索引</li><li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）</li><li>如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size（默认256k）</li></ul><h1 id="group-by优化">4. group by优化</h1><ul><li>在分组操作时，可以通过索引来提高效率</li><li>分组操作时，索引的使用也是满足最左前缀法则的</li></ul><p>如索引为<code>idx_user_pro_age_stat</code>，则句式可以是<code>select ... where profession order by age</code>，这样也符合最左前缀法则</p><h1 id="limit优化">5. limit优化</h1><ol type="1"><li>常见的问题如<code>limit 2000000, 10</code>，此时需要 MySQL排序前2000000条记录，但仅仅返回2000000 -2000010的记录，其他记录丢弃，查询排序的代价非常大。</li><li>优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化</li></ol><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 此语句耗时很长</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_sku limit <span class="hljs-number">9000000</span>, <span class="hljs-number">10</span>;<br><span class="hljs-comment">-- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询</span><br><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> tb_sku <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">9000000</span>, <span class="hljs-number">10</span>;<br><span class="hljs-comment">-- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit</span><br><span class="hljs-comment">-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);</span><br><span class="hljs-comment">-- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度</span><br><span class="hljs-keyword">select</span> s.<span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_sku <span class="hljs-keyword">as</span> s, (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> tb_sku <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">9000000</span>, <span class="hljs-number">10</span>) <span class="hljs-keyword">as</span> a <span class="hljs-keyword">where</span> s.id <span class="hljs-operator">=</span> a.id;<br></code></pre></td></tr></table></figure><h1 id="count优化">6. count优化</h1><ol type="1"><li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*)的时候会直接返回这个数，效率很高（前提是不适用where）；<br></li><li>InnoDB 在执行 count(*)时，需要把数据一行一行地从引擎里面读出来，然后累计计数。<ol type="1"><li>优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者是用redis</li></ol></li><li>count的几种用法：</li></ol><ul><li>如果count函数的参数（count里面写的那个字段）不是NULL（字段值不为NULL），累计值就加一，最后返回累计值</li><li>用法：count(*)、count(主键)、count(字段)、count(1)</li><li>count(主键)跟count(*)一样，因为主键不能为空；count(字段)只计算字段值不为NULL的行；count(1)引擎会为每行添加一个1，然后就count这个1，返回结果也跟count(*)一样；count(null)返回0</li></ul><ol start="4" type="1"><li>各种用法的性能：</li></ol><ul><li>count(主键)：InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空）</li><li>count(字段)：没有notnull约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加；有notnull约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加</li><li>count(1)：InnoDB引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1进去，直接按行进行累加</li><li>count(*)：InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加</li></ul><ol start="6" type="1"><li>按效率排序：count(字段) &lt; count(主键) &lt; count(1) &lt;count(*)，所以尽量使用 count(*)</li></ol><h1 id="update优化避免行锁升级为表锁">7.update优化（避免行锁升级为表锁）</h1><ol type="1"><li><p>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</p></li><li><p>如以下两条语句：</p><ul><li><code>update student set no = '123' where id = 1;</code>，这句由于id有主键索引，所以只会锁这一行；<br></li><li><code>update student set no = '123' where name = 'test';</code>，这句由于name没有索引，所以会把整张表都锁住进行数据更新，</li><li>解决方法是给name字段添加索引，就可以由表锁变成行锁。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8. 索引</title>
    <link href="/2024/11/27/MySQL/8-%E7%B4%A2%E5%BC%95/"/>
    <url>/2024/11/27/MySQL/8-%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h1 id="索引概述">1. 索引概述</h1><ol type="1"><li><p>索引是帮助 MySQL<strong>高效获取数据</strong>的<strong>数据结构（有序）</strong>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。</p></li><li><p>优点：</p></li></ol><ul><li>提高数据检索效率，降低数据库的IO成本<br></li><li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</li></ul><ol start="3" type="1"><li>缺点：</li></ol><ul><li>索引列也是要占用空间的</li><li>索引大大提高了查询效率，但降低了更新的速度，比如INSERT、UPDATE、DELETE</li></ul><h1 id="索引结构">2. 索引结构</h1><p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的结构。</p><table><thead><tr><th>索引结构</th><th>描述</th></tr></thead><tbody><tr><td><strong>B+Tree</strong></td><td>最常见的索引类型，大部分引擎都支持B+树索引</td></tr><tr><td>Hash</td><td>底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询</td></tr><tr><td>R-Tree(空间索引)</td><td>空间索引是 MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td></tr><tr><td>Full-Text(全文索引)</td><td>是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr,ES</td></tr></tbody></table><table><thead><tr><th>索引</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>B+Tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-Tree索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6版本后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><h2 id="b-tree">2.1 B-Tree</h2><figure><img src="/2024/11/27/MySQL/8-%E7%B4%A2%E5%BC%95/image-20241130102624399.png" alt="二叉树"><figcaption aria-hidden="true">二叉树</figcaption></figure><ol type="1"><li><p>二叉树缺点：顺序插入时，会形成一个链表，查询性能大大降低。大数据量情况下，层级较深，检索速度慢。</p></li><li><p>二叉树形成链表的缺点可以用红黑树来解决：</p></li></ol><figure><img src="/2024/11/27/MySQL/8-%E7%B4%A2%E5%BC%95/image-20241130102753156.png" alt="红黑树"><figcaption aria-hidden="true">红黑树</figcaption></figure><ol start="3" type="1"><li><p>红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。</p></li><li><p>为了解决上述问题，可以使用 B-Tree 结构。</p></li><li><p>B-Tree (多路平衡查找树)</p><ol type="1"><li>以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的b-tree 为例（每个节点最多存储4个key，5个指针）</li></ol></li></ol><figure><img src="/2024/11/27/MySQL/8-%E7%B4%A2%E5%BC%95/image-20241130102932069.png" alt="B-Tree结构"><figcaption aria-hidden="true">B-Tree结构</figcaption></figure><blockquote><p>B-Tree的数据插入过程动画参照：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68演示地址：https://www.cs.usfca.edu/~galles/visualization/BTree.html</p></blockquote><h2 id="btree">2.2 B+Tree</h2><p>结构图：</p><figure><img src="/2024/11/27/MySQL/8-%E7%B4%A2%E5%BC%95/image-20241130103611528.png" alt="B+Tree结构图"><figcaption aria-hidden="true">B+Tree结构图</figcaption></figure><blockquote><p>演示地址：https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</p></blockquote><p>与 B-Tree 的区别：</p><ul><li>所有的数据都会出现在叶子节点</li><li>叶子节点形成一个单向链表</li></ul><p>MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。</p><figure><img src="/2024/11/27/MySQL/8-%E7%B4%A2%E5%BC%95/image-20241130103944880.png" alt="MySQL B+Tree 结构图"><figcaption aria-hidden="true">MySQL B+Tree 结构图</figcaption></figure><h2 id="hash">2.3 Hash</h2><ol type="1"><li>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。</li><li>如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</li></ol><figure><img src="/2024/11/27/MySQL/8-%E7%B4%A2%E5%BC%95/image-20241130104351376.png" alt="Hash索引原理图"><figcaption aria-hidden="true">Hash索引原理图</figcaption></figure><ol start="3" type="1"><li>特点：</li></ol><ul><li>Hash索引只能用于对等比较（=、in），不支持范围查询（betwwn、&gt;、&lt;、...）</li><li>无法利用索引完成排序操作</li><li>查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree索引</li></ul><ol start="4" type="1"><li>存储引擎支持：</li></ol><ul><li>Memory</li><li>InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree索引在指定条件下自动构建的</li></ul><h2 id="面试题">2.4 面试题</h2><ol type="1"><li>为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？</li></ol><ul><li>相对于二叉树，层级更少，搜索效率高</li><li>对于B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低</li><li>相对于 Hash 索引，B+Tree 支持范围匹配及排序操作</li></ul><h1 id="索引分类">3. 索引分类</h1><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键索引</td><td>针对于表中主键创建的索引</td><td>默认自动创建，只能有一个</td><td>PRIMARY</td></tr><tr><td>唯一索引</td><td>避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td>UNIQUE</td></tr><tr><td>常规索引</td><td>快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td>全文索引</td><td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td><td>可以有多个</td><td>FULLTEXT</td></tr></tbody></table><p>在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引(Clustered Index)</td><td>将数据存储与索引放一块，索引结构的叶子节点保存了行数据</td><td>必须有，而且只有一个</td></tr><tr><td>二级索引(Secondary Index)</td><td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p>演示图：</p><figure><img src="/2024/11/27/MySQL/8-%E7%B4%A2%E5%BC%95/image-20241130105354921.png" alt="大致原理"><figcaption aria-hidden="true">大致原理</figcaption></figure><figure><img src="/2024/11/27/MySQL/8-%E7%B4%A2%E5%BC%95/image-20241130105527942.png" alt="演示图"><figcaption aria-hidden="true">演示图</figcaption></figure><p>聚集索引选取规则：</p><ul><li>如果存在主键，主键索引就是聚集索引</li><li>如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引</li><li>如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid作为隐藏的聚集索引</li></ul><h2 id="思考题">3.1 思考题</h2><p>1. 以下 SQL 语句，哪个执行效率高？为什么？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Arm&#x27;</span>;<br><span class="hljs-comment">-- 备注：id为主键，name字段创建的有索引</span><br></code></pre></td></tr></table></figure><p>答：第一条语句，因为第二条需要回表查询，相当于两个步骤。</p><p>2. InnoDB 主键索引的 B+Tree 高度为多少？</p><p>答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.<br>可得公式：<code>n * 8 + (n + 1) * 6 = 16 * 1024</code>，其中 8 表示bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1)表示指针数量（比key多一个）。算出n约为1170。</p><p>如果树的高度为2，那么他能存储的数据量大概为：<code>1171 * 16 = 18736</code>；<br>如果树的高度为3，那么他能存储的数据量大概为：<code>1171 * 1171 * 16 = 21939856</code>。</p><p>另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。</p><h1 id="索引语法">4. 索引语法</h1><ol type="1"><li>创建索引：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [ <span class="hljs-keyword">UNIQUE</span> <span class="hljs-operator">|</span> FULLTEXT ] INDEX index_name <span class="hljs-keyword">ON</span> table_name (index_col_name, ...);<br></code></pre></td></tr></table></figure><ul><li>如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引</li></ul><ol start="2" type="1"><li><p>查看索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> INDEX <span class="hljs-keyword">FROM</span> table_name;<br></code></pre></td></tr></table></figure></li><li><p>删除索引：</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> INDEX index_name <span class="hljs-keyword">ON</span> table_name;<br></code></pre></td></tr></table></figure><p>案例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引</span><br><span class="hljs-keyword">create</span> index idx_user_name <span class="hljs-keyword">on</span> users(name);<br><span class="hljs-comment">-- phone手机号字段的值非空，且唯一，为该字段创建唯一索引</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index idx_user_phone <span class="hljs-keyword">on</span> users (phone);<br><span class="hljs-comment">-- 为profession, age, status创建联合索引</span><br><span class="hljs-keyword">create</span> index idx_user_pro_age_stat <span class="hljs-keyword">on</span> users(profession, age, status);<br><span class="hljs-comment">-- 为email建立合适的索引来提升查询效率</span><br><span class="hljs-keyword">create</span> index idx_user_email <span class="hljs-keyword">on</span> users(email);<br><br><span class="hljs-comment">-- 删除索引  </span><br><span class="hljs-keyword">drop</span> index idx_user_email <span class="hljs-keyword">on</span> users;  <br></code></pre></td></tr></table></figure><h1 id="性能分析">5. 性能分析</h1><h2 id="查看执行频次">5.1 查看执行频次</h2><p>查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">GLOBAL</span> STATUS <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;Com_______&#x27;</span>;<br><span class="hljs-comment">-- or</span><br><span class="hljs-keyword">SHOW</span> SESSION STATUS <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;Com_______&#x27;</span>;<br><span class="hljs-comment">-- 例：</span><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;Com_______&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="慢查询日志">5.2 慢查询日志</h2><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。</p><p>MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（/etc/my.cnf，ubuntu在/etc/mysql/mysql.cnf）中配置如下信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 开启慢查询日志开关  </span><br>slow_query_log=1  <br><span class="hljs-comment"># 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志  </span><br>long_query_time=2  <br></code></pre></td></tr></table></figure><p>更改后记得重启MySQL服务，日志文件位置：/var/lib/mysql/localhost-slow.log</p><p>如果不在这个文件夹下，可以在mysql数据库里面输入命令 show variableslike 'slow_query_log_file'; 来查找慢查询日志存放地址</p><p>查看慢查询日志开关状态：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;slow_query_log&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="profile">5.3 profile</h2><ol type="1"><li><p>show profile 能在做SQL优化时帮我们了解时间都耗费在哪里。通过have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@have_profiling</span>;<br></code></pre></td></tr></table></figure></li><li><p>profiling 默认关闭，可以通过set语句在session/global级别开启profiling：</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> @<span class="hljs-variable">@profilling</span>; <span class="hljs-comment">-- 查看是否开启</span><br><span class="hljs-keyword">SET</span> profiling <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">-- 手动开启</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>查看所有语句的耗时：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> profiles;<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>查看指定query_id的SQL语句各个阶段的耗时：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> profile <span class="hljs-keyword">for</span> query query_id;<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>查看指定query_id的SQL语句CPU的使用情况</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> profile cpu <span class="hljs-keyword">for</span> query query_id;<br></code></pre></td></tr></table></figure><h2 id="explain">5.4 explain</h2><ol type="1"><li>explain执行计划</li></ol><ul><li>EXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在SELECT 语句执行过程中表如何连接和连接的顺序。<br></li><li>语法： 直接在select语句之前加上关键字 explain / desc</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表名 HWERE 条件;  <br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>EXPLAIN 各字段含义：</li></ol><ul><li>id：select 查询的序列号，表示查询中执行 select子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行）<br></li><li>select_type：表示 SELECT 的类型，常见取值有SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等<br></li><li><strong>type</strong>：表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、index、all</li><li><strong>possible_key</strong>：可能应用在这张表上的索引，一个或多个</li><li><strong>Key</strong>：实际使用的索引，如果为NULL，则没有使用索引</li><li><strong>Key_len</strong>：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好</li><li>rows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的</li><li>filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好</li></ul><h1 id="使用规则">6. 使用规则</h1><h2 id="最左前缀法则">6.1 最左前缀法则</h2><ol type="1"><li><p>如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。<br></p></li><li><p>如果跳跃某一列，索引将部分失效（后面的字段索引失效）。跳过的话，后面的排序就无从说起了。最左前缀法则在用select的时候，和放的位置是没有关系的，只要存在就行。</p></li><li><p>联合索引中，出现范围查询（&lt;,&gt;），范围查询右侧的列索引失效。可以用&gt;=或者&lt;=来规避索引失效问题。</p></li></ol><h2 id="索引失效情况">6.2 索引失效情况</h2><ol type="1"><li>在索引列上进行运算操作，索引将失效。<ol type="1"><li>如：<code>explain select * from tb_user where substring(phone, 10, 2) = '15';</code></li><li>换成<code>explain select * from tb_user where phone = '17799990015';</code>这是可以的。<br></li></ol></li><li>字符串类型字段使用时，不加引号，索引将失效。<ol type="1"><li>如：<code>explain select * from tb_user where phone = 17799990015;</code>，此处phone的值没有加引号<br></li></ol></li><li>模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。<ol type="1"><li>如：<code>explain select * from tb_user where profession like '%工程';</code>，</li><li>前后都有 % 也会失效。</li><li><code>explain select * from tb_user where profession like '软件%';</code>这个是不会失效的，只有前面加了%才会失效。<br></li></ol></li><li>用 or 分割开的条件，如果 or其中一个条件的列没有索引，那么涉及的索引都不会被用到。</li><li>如果 MySQL 评估使用索引比全表更慢，则不使用索引。<ol type="1"><li>因为只要有一个没有索引，另外一个用不用索引都没有意义，都要进行全表扫描。所以就无需用索引。</li></ol></li></ol><h2 id="sql-提示">6.3 SQL 提示</h2><ol type="1"><li>是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</li></ol><ul><li>例如，使用索引：<code>explain select * from tb_user use index(idx_user_pro) where profession="软件工程";</code></li><li>不使用哪个索引：<code>explain select * from tb_user ignore index(idx_user_pro) where profession="软件工程";</code></li><li>必须使用哪个索引：<code>explain select * from tb_user force index(idx_user_pro) where profession="软件工程";</code></li></ul><ol start="2" type="1"><li>use 是建议，实际使用哪个索引 MySQL还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。</li></ol><h2 id="覆盖索引回表查询">6.4 覆盖索引&amp;回表查询</h2><ol type="1"><li><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少select *。</p></li><li><p>explain 中 extra 字段含义：</p><ol type="1"><li><code>using index condition</code>：查找使用了索引，但是需要回表查询数据</li><li><code>using where; using index;</code>：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询</li></ol></li><li><p>覆盖索引：</p><ol type="1"><li>如果在生成的二级索引（辅助索引）中可以一次性获得select所需要的字段，不需要回表查询。</li><li>如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select*；<br></li><li>如果在辅助索引（二级索引）中找聚集索引，如<code>select id, name from xxx where name='xxx';</code>，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；</li><li>如果是通过辅助索引查找其他字段，则需要回表查询，如<code>select id, name, gender from xxx where name='xxx';</code></li></ol></li><li><p>所以尽量不要用<code>select *</code>，容易出现回表查询，降低效率，除非有联合索引包含了所有字段</p></li><li><p>面试题：一张表，有四个字段（id, username, password,status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：<code>select id, username, password from tb_user where username='itcast';</code></p></li></ol><ul><li>解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引。username和password字段建立联合索引的叶子节点挂的就是 id所以不需要三者同时建索引。</li></ul><h2 id="前缀索引">6.5 前缀索引</h2><ol type="1"><li><p>当字段类型为字符串（varchar,text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p></li><li><p>语法：<code>create index idx_xxxx on table_name(columnn(n));</code><br></p></li><li><p>前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p></li><li><p>求选择性公式：</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> email) <span class="hljs-operator">/</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_user;<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-built_in">substring</span>(email, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>)) <span class="hljs-operator">/</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_user;<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>前缀索引中是有可能碰到相同的索引的情况的（因为选择性可能不为1），所以使用前缀索引进行查询的时候，mysql会有一个回表查询的过程，确定是否为所需数据。如图中的查询到lvbu6之后还要进行回表，回表完再查xiaoy，看到xiaoy是不需要的数据，则停止查下一个。</li></ol><p><img src="/2024/11/27/MySQL/8-%E7%B4%A2%E5%BC%95/image-20241130194745470.png"></p><ol start="6" type="1"><li>show index 里面的sub_part可以看到接取的长度</li></ol><h2 id="单列索引联合索引">6.6 单列索引&amp;联合索引</h2><ol type="1"><li><p>单列索引：即一个索引只包含单个列</p></li><li><p>联合索引：即一个索引包含了多个列</p></li><li><p>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p></li><li><p>单列索引情况：</p></li></ol><p><code>explain select id, phone, name from tb_user where phone = '17799990010' and name = '韩信';</code></p><ul><li>phone 和 name 都建立了索引情况下，这句只会用到phone索引字段。</li></ul><ol start="5" type="1"><li>联合索引的数据组织图：</li></ol><p><img src="/2024/11/27/MySQL/8-%E7%B4%A2%E5%BC%95/image-20241130195612323.png"></p><p><strong>注意事项</strong></p><ul><li>多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询。</li></ul><h1 id="设计原则">7. 设计原则</h1><ol type="1"><li>针对于数据量较大，且查询比较频繁的表建立索引</li><li>针对于常作为查询条件（where）、排序（order by）、分组（groupby）操作的字段建立索引</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li><li>如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率</li><li>如果索引列不能存储NULL值，请在创建表时使用NOTNULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询</li></ol><ul><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进阶篇 - 7. 存储引擎</title>
    <link href="/2024/11/27/MySQL/7-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <url>/2024/11/27/MySQL/7-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="存储引擎">存储引擎</h1><h2 id="mysql体系结构">1. MySQL体系结构：</h2><p><img src="/2024/11/27/MySQL/7-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/image-20241129205655052.png"></p><ul><li>连接层<ul><li>最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证、及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</li></ul></li><li>服务层<ul><li>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。</li></ul></li><li>引擎层<ul><li>存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过AP和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。</li></ul></li><li>存储层<ul><li>主要是将数据存储在文件系统之上，并完成与存储引擎的交互。</li></ul></li></ul><h2 id="简介">2. 简介</h2><p>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。</p><p>默认存储引擎是InnoDB。</p><p>相关操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询建表语句</span><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> account;  <br><span class="hljs-comment">-- 建表时指定存储引擎</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>...<br>) ENGINE<span class="hljs-operator">=</span>INNODB;<br><span class="hljs-comment">-- 查看当前数据库支持的存储引擎</span><br><span class="hljs-keyword">show</span> engines;<br><br><span class="hljs-comment">-- eg:</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_myisam(<br>id <span class="hljs-type">int</span>,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)<br>) engine <span class="hljs-operator">=</span> MyISAM;<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_memory(<br>id <span class="hljs-type">int</span>,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)<br>) engine <span class="hljs-operator">=</span> Memory;<br></code></pre></td></tr></table></figure><p><img src="/2024/11/27/MySQL/7-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/image-20241129213402904.png"></p><h2 id="innodb">3. InnoDB</h2><ol type="1"><li><p>InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5之后，InnoDB 是默认的 MySQL 引擎。</p></li><li><p>特点：</p></li></ol><ul><li>DML 操作遵循 ACID 模型，支持<strong>事务</strong></li><li><strong>行级锁</strong>，提高并发访问性能</li><li>支持<strong>外键</strong>约束，保证数据的完整性和正确性</li></ul><ol start="3" type="1"><li>文件：</li></ol><ul><li>xxx.ibd: xxx代表表名，InnoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。</li></ul><ol start="4" type="1"><li><p>参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间，默认打开，即每张表对应一个表空间</p></li><li><p>知识点：</p></li></ol><ul><li>查看 Mysql 变量：<code>show variables like 'innodb_file_per_table';</code></li></ul><ol start="6" type="1"><li>从idb文件提取表结构数据：</li></ol><ul><li>（在cmd运行）<ul><li><code>ibd2sdi xxx.ibd</code></li></ul></li></ul><ol start="7" type="1"><li>InnoDB 逻辑存储结构：</li></ol><figure><img src="/2024/11/27/MySQL/7-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/image-20241129215159412.png" alt="InnoDB 逻辑存储结构"><figcaption aria-hidden="true">InnoDB 逻辑存储结构</figcaption></figure><h2 id="myisam">4. MyISAM</h2><ol type="1"><li><p>MyISAM 是 MySQL 早期的默认存储引擎。</p></li><li><p>特点：</p></li></ol><ul><li>不支持事务，不支持外键</li><li>支持表锁，不支持行锁</li><li>访问速度快</li></ul><ol start="3" type="1"><li>文件：</li></ol><ul><li>xxx.sdi: 存储表结构信息 文本文件，json文件</li><li>xxx.MYD: 存储数据</li><li>xxx.MYI: 存储索引</li></ul><h2 id="memory">5. Memory</h2><ol type="1"><li><p>Memory引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。</p></li><li><p>特点：</p></li></ol><ul><li>存放在内存中，速度快</li><li>hash索引（默认）</li></ul><ol start="3" type="1"><li>文件：</li></ol><ul><li>xxx.sdi: 存储表结构信息</li></ul><h2 id="存储引擎特点">6. 存储引擎特点</h2><table><thead><tr><th>特点</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>存储限制</td><td>64TB</td><td>有</td><td>有</td></tr><tr><td>事务安全</td><td>支持</td><td>-</td><td>-</td></tr><tr><td>锁机制</td><td>行锁</td><td>表锁</td><td>表锁</td></tr><tr><td>B+tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>-</td><td>-</td><td>支持</td></tr><tr><td>全文索引</td><td>支持（5.6版本之后）</td><td>支持</td><td>-</td></tr><tr><td>空间使用</td><td>高</td><td>低</td><td>N/A</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>中等</td></tr><tr><td>批量插入速度</td><td>低</td><td>高</td><td>高</td></tr><tr><td>支持外键</td><td>支持</td><td>-</td><td>-</td></tr></tbody></table><h2 id="存储引擎的选择">7. 存储引擎的选择</h2><ol type="1"><li>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</li></ol><ul><li>InnoDB:如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则InnoDB 是比较合适的选择</li><li>MyISAM:如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。（mongodb）</li><li>Memory:将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性（redis）</li></ul><ol start="2" type="1"><li>电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory引擎。</li></ol>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6. 数据类型</title>
    <link href="/2024/11/26/MySQL/6-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2024/11/26/MySQL/6-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="数据类型">6. 数据类型</h1><h2 id="整型">1. 整型</h2><table><thead><tr><th>类型名称</th><th>取值范围</th><th>大小</th></tr></thead><tbody><tr><td>TINYINT</td><td>-128〜127</td><td>1个字节</td></tr><tr><td>SMALLINT</td><td>-32768〜32767</td><td>2个宇节</td></tr><tr><td>MEDIUMINT</td><td>-8388608〜8388607</td><td>3个字节</td></tr><tr><td>INT (INTEGHR)</td><td>-2147483648〜2147483647</td><td>4个字节</td></tr><tr><td>BIGINT</td><td>-9223372036854775808〜9223372036854775807</td><td>8个字节</td></tr></tbody></table><p>无符号在数据类型后加 unsigned 关键字。</p><h2 id="浮点型">2. 浮点型</h2><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td>FLOAT</td><td>单精度浮点数</td><td>4 个字节</td></tr><tr><td>DOUBLE</td><td>双精度浮点数</td><td>8 个字节</td></tr><tr><td>DECIMAL (M, D)，DEC</td><td>压缩的“严格”定点数</td><td>M+2 个字节</td></tr></tbody></table><h2 id="日期和时间">3. 日期和时间</h2><table><thead><tr><th>类型名称</th><th>日期格式</th><th>日期范围</th><th>存储需求</th></tr></thead><tbody><tr><td>YEAR</td><td>YYYY</td><td>1901 ~ 2155</td><td>1 个字节</td></tr><tr><td>TIME</td><td>HH:MM:SS</td><td>-838:59:59 ~ 838:59:59</td><td>3 个字节</td></tr><tr><td>DATE</td><td>YYYY-MM-DD</td><td>1000-01-01 ~ 9999-12-3</td><td>3 个字节</td></tr><tr><td>DATETIME</td><td>YYYY-MM-DD HH:MM:SS</td><td>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td><td>8 个字节</td></tr><tr><td>TIMESTAMP</td><td>YYYY-MM-DD HH:MM:SS</td><td>1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC</td><td>4 个字节</td></tr></tbody></table><h2 id="字符串">4. 字符串</h2><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td>CHAR(M)</td><td>固定长度非二进制字符串</td><td>M 字节，1&lt;=M&lt;=255</td></tr><tr><td>VARCHAR(M)</td><td>变长非二进制字符串</td><td>L+1字节，在此，L&lt; = M和 1&lt;=M&lt;=255</td></tr><tr><td>TINYTEXT</td><td>非常小的非二进制字符串</td><td>L+1字节，在此，L&lt;2^8</td></tr><tr><td>TEXT</td><td>小的非二进制字符串</td><td>L+2字节，在此，L&lt;2^16</td></tr><tr><td>MEDIUMTEXT</td><td>中等大小的非二进制字符串</td><td>L+3字节，在此，L&lt;2^24</td></tr><tr><td>LONGTEXT</td><td>大的非二进制字符串</td><td>L+4字节，在此，L&lt;2^32</td></tr><tr><td>ENUM</td><td>枚举类型，只能有一个枚举字符串值</td><td>1或2个字节，取决于枚举值的数目 (最大值为65535)</td></tr><tr><td>SET</td><td>一个设置，字符串对象可以有零个或 多个SET成员</td><td>1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员）</td></tr></tbody></table><h2 id="二进制类型">5. 二进制类型</h2><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td>BIT(M)</td><td>位字段类型</td><td>大约 (M+7)/8 字节</td></tr><tr><td>BINARY(M)</td><td>固定长度二进制字符串</td><td>M 字节</td></tr><tr><td>VARBINARY (M)</td><td>可变长度二进制字符串</td><td>M+1 字节</td></tr><tr><td>TINYBLOB (M)</td><td>非常小的BLOB</td><td>L+1 字节，在此，L&lt;2^8</td></tr><tr><td>BLOB (M)</td><td>小 BLOB</td><td>L+2 字节，在此，L&lt;2^16</td></tr><tr><td>MEDIUMBLOB (M)</td><td>中等大小的BLOB</td><td>L+3 字节，在此，L&lt;2^24</td></tr><tr><td>LONGBLOB (M)</td><td>非常大的BLOB</td><td>L+4 字节，在此，L&lt;2^32</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5. 事务</title>
    <link href="/2024/11/26/MySQL/5-%E4%BA%8B%E5%8A%A1/"/>
    <url>/2024/11/26/MySQL/5-%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="事务">5. 事务</h1><ul><li>事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</li></ul><h2 id="基本操作">5.1 基本操作：</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> account(<br>id <span class="hljs-type">int</span> auto_increment <span class="hljs-keyword">primary</span> key comment <span class="hljs-string">&#x27;主键ID&#x27;</span>,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>    money <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;余额&#x27;</span><br>) comment <span class="hljs-string">&#x27;账户表&#x27;</span>;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> account(id, name, money) <span class="hljs-keyword">values</span> (<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">2000</span>),(<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-number">2000</span>);<br><span class="hljs-keyword">update</span> account <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> <span class="hljs-number">2000</span>;<br><br><span class="hljs-comment">-- 1. 查询张三账户余额</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> account <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张三&#x27;</span>;<br><span class="hljs-comment">-- 2. 将张三账户余额-1000</span><br><span class="hljs-keyword">update</span> account <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">-</span> <span class="hljs-number">1000</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张三&#x27;</span>;<br><span class="hljs-comment">-- 此语句出错后张三钱减少但是李四钱没有增加</span><br>模拟<span class="hljs-keyword">sql</span>语句错误<br><span class="hljs-comment">-- 3. 将李四账户余额+1000</span><br><span class="hljs-keyword">update</span> account <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">+</span> <span class="hljs-number">1000</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;李四&#x27;</span>;<br><br><br><span class="hljs-comment">-- 查看事务提交方式</span><br><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@AUTOCOMMIT</span>;<br><span class="hljs-comment">-- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效</span><br><span class="hljs-keyword">SET</span> @<span class="hljs-variable">@AUTOCOMMIT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">-- 提交事务</span><br><span class="hljs-keyword">COMMIT</span>;<br><span class="hljs-comment">-- 回滚事务</span><br><span class="hljs-keyword">ROLLBACK</span>;<br><br><span class="hljs-comment">-- 设置手动提交后上面代码改为：</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> account <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张三&#x27;</span>;<br><span class="hljs-keyword">update</span> account <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">-</span> <span class="hljs-number">1000</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张三&#x27;</span>;<br><span class="hljs-keyword">update</span> account <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">+</span> <span class="hljs-number">1000</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;李四&#x27;</span>;<br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure><p>操作方式二：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 开启事务：</span><br><span class="hljs-keyword">START</span> TRANSACTION 或 <span class="hljs-keyword">BEGIN</span> TRANSACTION;<br><span class="hljs-comment">-- 提交事务：</span><br><span class="hljs-keyword">COMMIT</span>;<br><span class="hljs-comment">-- 回滚事务：</span><br><span class="hljs-keyword">ROLLBACK</span>;<br><br>操作实例：<br><span class="hljs-keyword">start</span> transaction;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> account <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张三&#x27;</span>;<br><span class="hljs-keyword">update</span> account <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">-</span> <span class="hljs-number">1000</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张三&#x27;</span>;<br><span class="hljs-keyword">update</span> account <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">+</span> <span class="hljs-number">1000</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;李四&#x27;</span>;<br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure><h2 id="四大特性acid">5.2 四大特性ACID</h2><ul><li>原子性(Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败</li><li>一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态</li><li>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li></ul><h2 id="并发事务">5.3 并发事务</h2><table><thead><tr><th>问题</th><th>描述</th></tr></thead><tbody><tr><td>脏读</td><td>一个事务读到另一个事务还没提交的数据</td></tr><tr><td>不可重复读</td><td>一个事务先后读取同一条记录，但两次读取的数据不同</td></tr><tr><td>幻读</td><td>一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在</td></tr></tbody></table><h2 id="并发事务隔离级别">5.4 并发事务隔离级别：</h2><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable Read(默认)</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><ul><li>√表示在当前隔离级别下该问题会出现</li><li>Serializable 性能最低；Read uncommitted性能最高，数据安全性最差</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查看事务隔离级别：</span><br><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@TRANSACTION_ISOLATION</span>;<br><span class="hljs-comment">-- 设置事务隔离级别：</span><br><span class="hljs-keyword">SET</span> [ SESSION <span class="hljs-operator">|</span> <span class="hljs-keyword">GLOBAL</span> ] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED <span class="hljs-operator">|</span> READ COMMITTED <span class="hljs-operator">|</span> REPEATABLE READ <span class="hljs-operator">|</span> SERIALIZABLE &#125;;<br><br><span class="hljs-keyword">set</span> session transaction isolation level REPEATABLE READ;<br></code></pre></td></tr></table></figure><p>SESSION 是会话级别，表示只针对当前会话有效，GLOBAL表示对所有会话有效</p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4. 多表查询</title>
    <link href="/2024/11/26/MySQL/4-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/"/>
    <url>/2024/11/26/MySQL/4-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="多表查询">4. 多表查询</h1><h2 id="多表关系">1. 多表关系</h2><ul><li>项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：<ul><li>一对多（多对一）</li><li>多对多</li><li>一对一</li></ul></li></ul><h3 id="一对多">1.1 一对多</h3><ul><li>案例：部门与员工</li><li>关系：一个部门对应多个员工，一个员工对应一个部门</li><li>实现：在多的一方建立外键，指向一的一方的主键</li></ul><p><img src="/2024/11/26/MySQL/4-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/image-20241126210159754.png"></p><h3 id="多对多">1.2 多对多</h3><ul><li>案例：学生与课程</li><li>关系：一个学生可以选多门课程，一门课程也可以供多个学生选修</li><li>实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</li></ul><p><img src="/2024/11/26/MySQL/4-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/image-20241126210309968.png"></p><ul><li>创建三个表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">constraint</span> fk_courseid <span class="hljs-keyword">foreign</span> key (courseid) <span class="hljs-keyword">references</span> course (id);<br><span class="hljs-keyword">constraint</span> fk_studentid <span class="hljs-keyword">foreign</span> key (studentid) <span class="hljs-keyword">references</span> student (id);<br></code></pre></td></tr></table></figure><h3 id="一对一">1.3 一对一</h3><ul><li>案例：用户与用户详情</li><li>关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率</li><li>实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）</li></ul><p><img src="/2024/11/26/MySQL/4-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/image-20241126233655365.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">constraint</span> fk_userid <span class="hljs-keyword">foreign</span> key (userid) <span class="hljs-keyword">references</span> tb_user(id);<br></code></pre></td></tr></table></figure><h2 id="查询">2. 查询</h2><h3 id="多表查询-1">2.1 多表查询</h3><ul><li><p>从多张表中国查询数据</p></li><li><p>合并查询（笛卡尔积，会展示所有组合结果）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee, dept;<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积）</p></blockquote><p>消除无效笛卡尔积，加上条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee, dept <span class="hljs-keyword">where</span> employee.dept <span class="hljs-operator">=</span> dept.id;<br></code></pre></td></tr></table></figure><h3 id="分类">2.2 分类</h3><ul><li>连接查询<ul><li>内连接：相当于查询A、B的交集</li><li>外连接：<ul><li>左外连接：查询左表所有数据，以及两张表交集部分数据</li><li>右外连接：查询右表所有数据，以及两张表交集部分数据</li></ul></li><li>自连接：<ul><li>当前表与自身的连接查询，自连接必须使用表别名</li></ul></li></ul></li><li>子查询</li></ul><h2 id="内连接查询">3. 内连接查询</h2><ul><li>内连接查询的是两张表交集的部分<ul><li>隐式内连接：</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span>, 表<span class="hljs-number">2</span> <span class="hljs-keyword">WHERE</span> 条件 ...;<br></code></pre></td></tr></table></figure><ul><li>显式内连接：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> [ <span class="hljs-keyword">INNER</span> ] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 连接条件 ...;<br></code></pre></td></tr></table></figure><ul><li>显式性能比隐式高</li></ul><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建dept表，并插入数据</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> dept(<br>id <span class="hljs-type">int</span> auto_increment comment <span class="hljs-string">&#x27;ID&#x27;</span> <span class="hljs-keyword">primary</span> key,<br>name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;部门名称&#x27;</span><br>)comment <span class="hljs-string">&#x27;部门表&#x27;</span>;<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> dept (id, name)<br> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;研发部&#x27;</span>), (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;市场部&#x27;</span>),(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;财务部&#x27;</span>), (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;销售部&#x27;</span>), (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;总经办&#x27;</span>), (<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;人事部&#x27;</span>);<br> <br> <span class="hljs-comment">-- 创建emp表，并插入数据</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> emp(<br>    id <span class="hljs-type">int</span> auto_increment comment <span class="hljs-string">&#x27;ID&#x27;</span> <span class="hljs-keyword">primary</span> key,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>    age <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>    job <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) comment <span class="hljs-string">&#x27;职位&#x27;</span>,<br>    salary <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;薪资&#x27;</span>,<br>    entrydate <span class="hljs-type">date</span> comment <span class="hljs-string">&#x27;入职时间&#x27;</span>,<br>    managerid <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;直属领导ID&#x27;</span>,<br>    dept_id <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;部门ID&#x27;</span><br>)comment <span class="hljs-string">&#x27;员工表&#x27;</span>;<span class="hljs-comment">-- 添加外键</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> emp <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> fk_emp_dept_id <span class="hljs-keyword">foreign</span> key (dept_id) <span class="hljs-keyword">references</span> <br>dept(id);<br><br> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, name, age, job,salary, entrydate, managerid, dept_id)<br> <span class="hljs-keyword">VALUES</span><br> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;金庸&#x27;</span>, <span class="hljs-number">66</span>, <span class="hljs-string">&#x27;总裁&#x27;</span>,<span class="hljs-number">20000</span>, <span class="hljs-string">&#x27;2000-01-01&#x27;</span>, <span class="hljs-keyword">null</span>,<span class="hljs-number">5</span>),<br> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;张无忌&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;项目经理&#x27;</span>,<span class="hljs-number">12500</span>, <span class="hljs-string">&#x27;2005-12-05&#x27;</span>, <span class="hljs-number">1</span>,<span class="hljs-number">1</span>),<br> (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;杨逍&#x27;</span>, <span class="hljs-number">33</span>, <span class="hljs-string">&#x27;开发&#x27;</span>, <span class="hljs-number">8400</span>,<span class="hljs-string">&#x27;2000-11-03&#x27;</span>, <span class="hljs-number">2</span>,<span class="hljs-number">1</span>),<br> (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;韦一笑&#x27;</span>, <span class="hljs-number">48</span>, <span class="hljs-string">&#x27;开发&#x27;</span>,<span class="hljs-number">11000</span>, <span class="hljs-string">&#x27;2002-02-05&#x27;</span>, <span class="hljs-number">2</span>,<span class="hljs-number">1</span>),<br> (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;常遇春&#x27;</span>, <span class="hljs-number">43</span>, <span class="hljs-string">&#x27;开发&#x27;</span>,<span class="hljs-number">10500</span>, <span class="hljs-string">&#x27;2004-09-07&#x27;</span>, <span class="hljs-number">3</span>,<span class="hljs-number">1</span>),<br> (<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;小昭&#x27;</span>, <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;程序员鼓励师&#x27;</span>,<span class="hljs-number">6600</span>, <span class="hljs-string">&#x27;2004-10-12&#x27;</span>, <span class="hljs-number">2</span>,<span class="hljs-number">1</span>),<br> (<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;灭绝&#x27;</span>, <span class="hljs-number">60</span>, <span class="hljs-string">&#x27;财务总监&#x27;</span>,<span class="hljs-number">8500</span>, <span class="hljs-string">&#x27;2002-09-12&#x27;</span>, <span class="hljs-number">1</span>,<span class="hljs-number">3</span>),<br> (<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;周芷若&#x27;</span>, <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;会计&#x27;</span>,<span class="hljs-number">48000</span>, <span class="hljs-string">&#x27;2006-06-02&#x27;</span>, <span class="hljs-number">7</span>,<span class="hljs-number">3</span>),<br> (<span class="hljs-number">9</span>, <span class="hljs-string">&#x27;丁敏君&#x27;</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&#x27;出纳&#x27;</span>,<span class="hljs-number">5250</span>, <span class="hljs-string">&#x27;2009-05-13&#x27;</span>, <span class="hljs-number">7</span>,<span class="hljs-number">3</span>),<br> (<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;赵敏&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;市场部总监&#x27;</span>,<span class="hljs-number">12500</span>, <span class="hljs-string">&#x27;2004-10-12&#x27;</span>, <span class="hljs-number">1</span>,<span class="hljs-number">2</span>),<br> (<span class="hljs-number">11</span>, <span class="hljs-string">&#x27;鹿杖客&#x27;</span>, <span class="hljs-number">56</span>, <span class="hljs-string">&#x27;职员&#x27;</span>,<span class="hljs-number">3750</span>, <span class="hljs-string">&#x27;2006-10-03&#x27;</span>, <span class="hljs-number">10</span>,<span class="hljs-number">2</span>),<br> (<span class="hljs-number">12</span>, <span class="hljs-string">&#x27;鹤笔翁&#x27;</span>, <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;职员&#x27;</span>,<span class="hljs-number">3750</span>, <span class="hljs-string">&#x27;2007-05-09&#x27;</span>, <span class="hljs-number">10</span>,<span class="hljs-number">2</span>),<br> (<span class="hljs-number">13</span>, <span class="hljs-string">&#x27;方东白&#x27;</span>, <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;职员&#x27;</span>,<span class="hljs-number">5500</span>, <span class="hljs-string">&#x27;2009-02-12&#x27;</span>, <span class="hljs-number">10</span>,<span class="hljs-number">2</span>),<br> (<span class="hljs-number">14</span>, <span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-number">88</span>, <span class="hljs-string">&#x27;销售总监&#x27;</span>,<span class="hljs-number">14000</span>, <span class="hljs-string">&#x27;2004-10-12&#x27;</span>, <span class="hljs-number">1</span>,<span class="hljs-number">4</span>),<br> (<span class="hljs-number">15</span>, <span class="hljs-string">&#x27;俞莲舟&#x27;</span>, <span class="hljs-number">38</span>, <span class="hljs-string">&#x27;销售&#x27;</span>,<span class="hljs-number">4600</span>, <span class="hljs-string">&#x27;2004-10-12&#x27;</span>, <span class="hljs-number">14</span>,<span class="hljs-number">4</span>),<br> (<span class="hljs-number">16</span>, <span class="hljs-string">&#x27;宋远桥&#x27;</span>, <span class="hljs-number">40</span>, <span class="hljs-string">&#x27;销售&#x27;</span>,<span class="hljs-number">4600</span>, <span class="hljs-string">&#x27;2004-10-12&#x27;</span>, <span class="hljs-number">14</span>,<span class="hljs-number">4</span>),<br> (<span class="hljs-number">17</span>, <span class="hljs-string">&#x27;陈友谅&#x27;</span>, <span class="hljs-number">42</span>, <span class="hljs-keyword">null</span>,<span class="hljs-number">2000</span>, <span class="hljs-string">&#x27;2011-10-12&#x27;</span>, <span class="hljs-number">1</span>,<span class="hljs-keyword">null</span>);<br><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询员工姓名，及关联的部门的名称</span><br><span class="hljs-comment">-- 隐式</span><br><span class="hljs-keyword">select</span> e.name, d.name <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">as</span> e, dept <span class="hljs-keyword">as</span> d <span class="hljs-keyword">where</span> e.dept_id <span class="hljs-operator">=</span> d.id;<br><span class="hljs-comment">-- 显式</span><br><span class="hljs-keyword">select</span> e.name, d.name <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">as</span> e <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> dept <span class="hljs-keyword">as</span> d <span class="hljs-keyword">on</span> e.dept_id <span class="hljs-operator">=</span> d.id;<br></code></pre></td></tr></table></figure><h2 id="外连接查询">4. 外连接查询</h2><ul><li>左外连接：<ul><li>查询左表所有数据，以及两张表交集部分数据</li><li>相当于查询表1的所有数据，包含表1和表2交集部分数据</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">LEFT</span> [ <span class="hljs-keyword">OUTER</span> ] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 条件 ...;<br></code></pre></td></tr></table></figure><ul><li>右外连接：<ul><li>查询右表所有数据，以及两张表交集部分数据</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">RIGHT</span> [ <span class="hljs-keyword">OUTER</span> ] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 条件 ...;<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询emp表的所有数据，和对应的部门信息（左外连接）</span><br><span class="hljs-comment">-- 左</span><br><span class="hljs-keyword">select</span> e.<span class="hljs-operator">*</span>, d.name <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">as</span> e <span class="hljs-keyword">left</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> dept <span class="hljs-keyword">as</span> d <span class="hljs-keyword">on</span> e.dept_id <span class="hljs-operator">=</span> d.id;<br><span class="hljs-comment">-- 2.查询dept表的所有数据，和对应的员工信息（右外连接）</span><br><span class="hljs-keyword">select</span> d.name, e.<span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> dept d <span class="hljs-keyword">left</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> emp e <span class="hljs-keyword">on</span> e.dept_id <span class="hljs-operator">=</span> d.id;  <br><span class="hljs-comment">-- 这条语句与下面的语句效果一样</span><br><span class="hljs-comment">-- 右</span><br><span class="hljs-keyword">select</span> d.name, e.<span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">as</span> e <span class="hljs-keyword">right</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> dept <span class="hljs-keyword">as</span> d <span class="hljs-keyword">on</span> e.dept_id <span class="hljs-operator">=</span> d.id;<br></code></pre></td></tr></table></figure><p>左连接可以查询到没有dept的emp，右连接可以查询到没有emp的dept</p><h2 id="自连接查询">5. 自连接查询</h2><ul><li>当前表与自身的连接查询，自连接必须使用表别名</li></ul><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表A 别名A <span class="hljs-keyword">JOIN</span> 表A 别名B <span class="hljs-keyword">ON</span> 条件 ...;<br></code></pre></td></tr></table></figure><ul><li>自连接查询，可以是内连接查询，也可以是外连接查询</li></ul><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询员工及其所属领导的名字</span><br><span class="hljs-keyword">select</span> a.name, b.name <span class="hljs-keyword">from</span> emp a, emp b <span class="hljs-keyword">where</span> a.managerid <span class="hljs-operator">=</span> b.id;<br><span class="hljs-comment">-- 没有领导的也查询出来</span><br><span class="hljs-keyword">select</span> a.name, b.name <span class="hljs-keyword">from</span> emp a <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> emp b <span class="hljs-keyword">on</span> a.managerid <span class="hljs-operator">=</span> b.id;<br></code></pre></td></tr></table></figure><h2 id="联合查询-union-union-all">6. 联合查询 union, union all</h2><ul><li><p>把多次查询的结果合并，形成一个新的查询集</p></li><li><p>语法：</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表A ...<br><span class="hljs-keyword">UNION</span> [<span class="hljs-keyword">ALL</span>]<br><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表B ...;<br><br><span class="hljs-comment">-- eg:</span><br><span class="hljs-comment">-- 将薪资低于5000的员工，和年龄大于50岁的员工全部查询出来</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> salary <span class="hljs-operator">&lt;</span> <span class="hljs-number">5000</span><br><span class="hljs-keyword">union</span> <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">50</span>;<br></code></pre></td></tr></table></figure><h3 id="注意事项">注意事项</h3><ul><li>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。</li><li>UNION ALL 会有重复结果，UNION 不会</li><li>联合查询比使用or效率高，不会使索引失效</li></ul><h2 id="子查询">7. 子查询</h2><p>SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">WHERE</span> column1 <span class="hljs-operator">=</span> ( <span class="hljs-keyword">SELECT</span> column1 <span class="hljs-keyword">FROM</span> t2);<br></code></pre></td></tr></table></figure><p><strong>子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT的任何一个</strong></p><p>根据子查询结果可以分为：</p><ul><li>标量子查询（子查询结果为单个值）</li><li>列子查询（子查询结果为一列）</li><li>行子查询（子查询结果为一行）</li><li>表子查询（子查询结果为多行多列）</li></ul><p>根据子查询位置可分为：</p><ul><li>WHERE 之后</li><li>FROM 之后</li><li>SELECT 之后</li></ul><h3 id="标量子查询">7.1 标量子查询</h3><ul><li>子查询返回的结果是单个值（数字、字符串、日期等）。<ul><li>常用操作符：= &lt; &gt; &gt; &gt;= &lt; &lt;=</li></ul></li><li>例子：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询销售部所有员工<br>select id from dept where name = &#x27;销售部&#x27;;<br>-- 根据销售部部门ID，查询员工信息<br>select * from emp where dept_id = 4;<br>-- 合并（子查询）<br>select * from emp where dept_id = (select id from dept where name = &#x27;销售部&#x27;);<br><br>-- 查询xxx入职之后的员工信息<br>select * from emp where entrydate &gt; (select entrydate from emp where name = &#x27;方东白&#x27;);<br></code></pre></td></tr></table></figure><h3 id="列子查询">7.2 列子查询</h3><ul><li><p>返回的结果是一列（可以是多行）。</p></li><li><p>常用操作符：</p></li></ul><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>IN</td><td>在指定的集合范围内，多选一</td></tr><tr><td>NOT IN</td><td>不在指定的集合范围内</td></tr><tr><td>ANY</td><td>子查询返回列表中，有任意一个满足即可</td></tr><tr><td>SOME</td><td>与ANY等同，使用SOME的地方都可以使用ANY</td></tr><tr><td>ALL</td><td>子查询返回列表的所有值都必须满足</td></tr></tbody></table><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询销售部和市场部的所有员工信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> dept_id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;销售部&#x27;</span> <span class="hljs-keyword">or</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;市场部&#x27;</span>);<br><span class="hljs-comment">-- 查询比财务部所有人工资都高的员工信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> salary <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">all</span>(<span class="hljs-keyword">select</span> salary <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> dept_id <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;财务部&#x27;</span>));<br><span class="hljs-comment">-- 查询比研发部任意一人工资高的员工信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> salary <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">any</span> (<span class="hljs-keyword">select</span> salary <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> dept_id <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;研发部&#x27;</span>));<br></code></pre></td></tr></table></figure><h3 id="行子查询">7.3 行子查询</h3><ul><li>返回的结果是一行（可以是多列）。<ul><li>常用操作符：=, &lt;, &gt;, IN, NOT IN</li></ul></li><li>例子：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询与xxx的薪资及直属领导相同的员工信息<br>select * from emp where (salary, managerid) = (12500, 1);<br>select * from emp where (salary, managerid) = (select salary, managerid from emp where name = &#x27;张无忌&#x27;);<br></code></pre></td></tr></table></figure><h3 id="表子查询">7.4 表子查询</h3><ul><li>返回的结果是多行多列<ul><li>常用操作符：IN</li></ul></li><li>例子：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询与xxx1，xxx2的职位和薪资相同的员工</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> (job, salary) <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> job, salary <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;鹿杖客&#x27;</span> <span class="hljs-keyword">or</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;宋远桥&#x27;</span>);<br><span class="hljs-comment">-- 查询入职日期是2006-01-01之后的员工，及其部门信息</span><br><span class="hljs-keyword">select</span> e.<span class="hljs-operator">*</span>, d.<span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> entrydate <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;2006-01-01&#x27;</span>) <span class="hljs-keyword">as</span> e <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> dept <span class="hljs-keyword">as</span> d <span class="hljs-keyword">on</span> e.dept_id <span class="hljs-operator">=</span> d.id;<br></code></pre></td></tr></table></figure><h2 id="查询案例">8. 查询案例</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs sql"> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> salgrade(<br>     grade <span class="hljs-type">int</span>,<br>     losal <span class="hljs-type">int</span>,<br>     hisal <span class="hljs-type">int</span><br> ) comment <span class="hljs-string">&#x27;薪资等级表&#x27;</span>;<br> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3000</span>);<br> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade <span class="hljs-keyword">values</span> (<span class="hljs-number">2</span>,<span class="hljs-number">3001</span>,<span class="hljs-number">5000</span>);<br> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade <span class="hljs-keyword">values</span> (<span class="hljs-number">3</span>,<span class="hljs-number">5001</span>,<span class="hljs-number">8000</span>);<br> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade <span class="hljs-keyword">values</span> (<span class="hljs-number">4</span>,<span class="hljs-number">8001</span>,<span class="hljs-number">10000</span>);<br> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade <span class="hljs-keyword">values</span> (<span class="hljs-number">5</span>,<span class="hljs-number">10001</span>,<span class="hljs-number">15000</span>);<br> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade <span class="hljs-keyword">values</span> (<span class="hljs-number">6</span>,<span class="hljs-number">15001</span>,<span class="hljs-number">20000</span>);<br> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade <span class="hljs-keyword">values</span> (<span class="hljs-number">7</span>,<span class="hljs-number">20001</span>,<span class="hljs-number">25000</span>);<br> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade <span class="hljs-keyword">values</span> (<span class="hljs-number">8</span>,<span class="hljs-number">25001</span>,<span class="hljs-number">30000</span>);<br> <br><span class="hljs-comment">-- 查询员工的姓名、年龄、职位、部门信息。</span><br><span class="hljs-keyword">select</span> e.name, e.age, e.job, d.name <span class="hljs-keyword">from</span> emp e, dept d <span class="hljs-keyword">where</span> e.dept_id <span class="hljs-operator">=</span> d.id;<br><span class="hljs-comment">-- 查询年龄小于30岁的员工姓名、年龄、职位、部门信息。</span><br><span class="hljs-keyword">select</span> e.name, e.age, e.job, d.name <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> e.dept_id <span class="hljs-operator">=</span> d.id <span class="hljs-keyword">where</span> e.age <span class="hljs-operator">&lt;</span> <span class="hljs-number">30</span>;<br><span class="hljs-comment">-- 查询拥有员工的部门ID、部门名称。</span><br><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> d.id, d.name <span class="hljs-keyword">from</span> emp e, dept d <span class="hljs-keyword">where</span> e.dept_id <span class="hljs-operator">=</span> d.id;<br><span class="hljs-comment">-- 查询所有年龄大于40岁的员工，及其归属的部门名称；如果员工没有分配部门，也需要展示出来。</span><br><span class="hljs-keyword">select</span> e.<span class="hljs-operator">*</span>, d.name <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> e.dept_id <span class="hljs-operator">=</span> d.id <span class="hljs-keyword">where</span> e.age <span class="hljs-operator">&gt;</span> <span class="hljs-number">40</span>;<br><span class="hljs-comment">-- 查询所有员工的工资等级。</span><br><span class="hljs-keyword">select</span> e.<span class="hljs-operator">*</span>, s.grade <span class="hljs-keyword">from</span> emp e, salgrade s <span class="hljs-keyword">where</span> e.salary <span class="hljs-keyword">between</span> s.losal <span class="hljs-keyword">and</span> s.hisal; <br><span class="hljs-comment">-- 查询&quot;研发部”所有员工的信息及工资等级。</span><br><span class="hljs-keyword">select</span> e.<span class="hljs-operator">*</span>, s.grade <br><span class="hljs-keyword">from</span> emp e, <br> dept d, <br> salgrade s <br><span class="hljs-keyword">where</span> e.dept_id <span class="hljs-operator">=</span> d.id <br><span class="hljs-keyword">and</span> e.salary <span class="hljs-keyword">between</span> s.losal <span class="hljs-keyword">and</span> s.hisal <br><span class="hljs-keyword">and</span> d.name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;研发部&#x27;</span>;<br><span class="hljs-comment">-- 查询&quot;研发部”员工的平均工资。</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(e.salary)<br><span class="hljs-keyword">from</span> emp e,<br> dept d<br><span class="hljs-keyword">where</span> e.dept_id <span class="hljs-operator">=</span> d.id<br><span class="hljs-keyword">and</span> d.name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;研发部&#x27;</span>;<br><span class="hljs-comment">-- 查询工资比&quot;灭绝&quot;高的员工信息。</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> emp<br><span class="hljs-keyword">where</span> salary <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">select</span> salary<br>                <span class="hljs-keyword">from</span> emp<br>                <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;灭绝&#x27;</span>);<br>                <br><span class="hljs-comment">-- 查询比平均薪资高的员工信息。</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">from</span> emp<br><span class="hljs-keyword">where</span> salary <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(salary)<br><span class="hljs-keyword">from</span> emp);<br><br><span class="hljs-comment">-- 查询低于本部门平均工资的员工信息。</span><br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">from</span> emp e2<br><span class="hljs-keyword">where</span> salary <span class="hljs-operator">&lt;</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(e1.salary)<br>                <span class="hljs-keyword">from</span> emp e1<br>                <span class="hljs-keyword">where</span> e1.dept_id <span class="hljs-operator">=</span> e2.dept_id);<br><span class="hljs-comment">-- 查询所有的部门信息，并统计部门的员工人数。</span><br><span class="hljs-keyword">select</span> d.id, d.name, (<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<br>  <span class="hljs-keyword">from</span> emp e<br>  <span class="hljs-keyword">where</span> e.dept_id <span class="hljs-operator">=</span> d.id) <span class="hljs-string">&#x27;人数&#x27;</span><br><span class="hljs-keyword">from</span> dept d;<br><br><br><span class="hljs-comment">-- 查询所有学生的选课情况，展示出学生名称，学号，课程名称</span><br><span class="hljs-comment">-- 表：student,course,student_course</span><br><span class="hljs-keyword">select</span> s.name, s.no, c.name<br><span class="hljs-keyword">from</span> student s,<br> student_course sc,<br> course c<br><span class="hljs-keyword">where</span> s.id <span class="hljs-operator">=</span> sc.studentid<br><span class="hljs-keyword">and</span> sc.courseid <span class="hljs-operator">=</span> c.id;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3. 约束</title>
    <link href="/2024/11/26/MySQL/3-%E7%BA%A6%E6%9D%9F/"/>
    <url>/2024/11/26/MySQL/3-%E7%BA%A6%E6%9D%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="约束">3. 约束</h1><ul><li>概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。</li><li>目的：保证数据库中数据的正确、有效性和完整性。</li><li>分类：</li></ul><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段的数据不能为null</td><td>NOT NULL</td></tr><tr><td>唯一约束</td><td>保证该字段的所有数据都是唯一、不重复的</td><td>UNIQUE</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>PRIMARY KEY</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段的值，则采用默认值</td><td>DEFAULT</td></tr><tr><td>检查约束（8.0.1版本后）</td><td>保证字段值满足某一个条件</td><td>CHECK</td></tr><tr><td>外键约束</td><td>用来让两张图的数据之间建立连接，保证数据的一致性和完整性</td><td>FOREIGN KEY</td></tr></tbody></table><p>约束是作用于表中字段上的，可以再创建表/修改表的时候添加约束。</p><h2 id="常用约束">1. 常用约束</h2><table><thead><tr><th>约束条件</th><th>关键字</th></tr></thead><tbody><tr><td>主键</td><td>PRIMARY KEY</td></tr><tr><td>自动增长</td><td>AUTO_INCREMENT</td></tr><tr><td>不为空</td><td>NOT NULL</td></tr><tr><td>唯一</td><td>UNIQUE</td></tr><tr><td>逻辑条件</td><td>CHECK</td></tr><tr><td>默认值</td><td>DEFAULT</td></tr></tbody></table><p>例子：</p><p><img src="/2024/11/26/MySQL/3-%E7%BA%A6%E6%9D%9F/image-20241126202101551.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span>(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment comment <span class="hljs-string">&#x27;主键&#x27;</span>,<br>name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">unique</span> comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>age <span class="hljs-type">int</span> <span class="hljs-keyword">check</span>(age <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">&lt;</span> <span class="hljs-number">120</span>) comment <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>status <span class="hljs-type">char</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;1&#x27;</span> comment <span class="hljs-string">&#x27;状态&#x27;</span>,<br>gender <span class="hljs-type">char</span>(<span class="hljs-number">1</span>) comment <span class="hljs-string">&#x27;性别&#x27;</span><br>)comment <span class="hljs-string">&#x27;用户表&#x27;</span>;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span>(name, age, status, gender) <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;Tom1&#x27;</span>, <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>),(<span class="hljs-string">&#x27;Tom2&#x27;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>),(<span class="hljs-string">&#x27;Tom3&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>);<br><br><br></code></pre></td></tr></table></figure><h2 id="外键约束">2. 外键约束</h2><ul><li><p>外键用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性。</p></li><li><p>添加外键：</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>字段名 字段类型,<br>...<br>[<span class="hljs-keyword">CONSTRAINT</span>] [外键名称] <span class="hljs-keyword">FOREIGN</span> KEY(外键字段名) <span class="hljs-keyword">REFERENCES</span> 主表(主表列名)<br>);<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> 外键名称 <span class="hljs-keyword">FOREIGN</span> KEY (外键字段名) <span class="hljs-keyword">REFERENCES</span> 主表(主表列名);<br><br><span class="hljs-comment">-- 例子</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> emp2 <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> fk_emp2_dept_id <span class="hljs-keyword">foreign</span> key(dept_id) <span class="hljs-keyword">references</span> dept(id);<br></code></pre></td></tr></table></figure><ul><li>删除外键：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">FOREIGN</span> KEY 外键名;<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> emp2 <span class="hljs-keyword">drop</span> <span class="hljs-keyword">foreign</span> key fk_emp2_dept_id;<br></code></pre></td></tr></table></figure><p><img src="/2024/11/26/MySQL/3-%E7%BA%A6%E6%9D%9F/image-20241126203209128.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sql"><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> dept(<br>    id <span class="hljs-type">int</span> auto_increment comment <span class="hljs-string">&#x27;ID&#x27;</span> <span class="hljs-keyword">primary</span> key ,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;部门名称&#x27;</span><br>)comment <span class="hljs-string">&#x27;部门表&#x27;</span>;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> dept (id, name) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;研发部&#x27;</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;市场部&#x27;</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;财务部&#x27;</span>),(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;销售部&#x27;</span>),(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;总经办&#x27;</span>);<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> emp2(<br>    id <span class="hljs-type">int</span> auto_increment comment <span class="hljs-string">&#x27;id&#x27;</span> <span class="hljs-keyword">primary</span> key ,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>    age <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>    job <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) comment <span class="hljs-string">&#x27;职位&#x27;</span>,<br>    salary <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;薪资&#x27;</span>,<br>    enterdate <span class="hljs-type">date</span> comment <span class="hljs-string">&#x27;入职时间&#x27;</span>,<br>    managerid <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;直属领导id&#x27;</span>,<br>    dept_id <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;部门id&#x27;</span><br>)comment <span class="hljs-string">&#x27;员工表&#x27;</span>;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp2(id, name, age, job, salary, enterdate, managerid, dept_id)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;金庸&#x27;</span>,<span class="hljs-number">66</span>,<span class="hljs-string">&#x27;总裁&#x27;</span>,<span class="hljs-number">20000</span>,<span class="hljs-string">&#x27;2000-01-01&#x27;</span>,<span class="hljs-keyword">null</span>,<span class="hljs-number">5</span>),<br>       (<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;张无忌&#x27;</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&#x27;项目经理&#x27;</span>,<span class="hljs-number">12500</span>,<span class="hljs-string">&#x27;2005-12-05&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>),<br>       (<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;杨逍&#x27;</span>,<span class="hljs-number">33</span>,<span class="hljs-string">&#x27;开发&#x27;</span>,<span class="hljs-number">8400</span>,<span class="hljs-string">&#x27;2000-11-03&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>),<br>       (<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;韦一笑&#x27;</span>,<span class="hljs-number">48</span>,<span class="hljs-string">&#x27;开发&#x27;</span>,<span class="hljs-number">11000</span>,<span class="hljs-string">&#x27;2002-02-05&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>),<br>       (<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;常遇春&#x27;</span>,<span class="hljs-number">43</span>,<span class="hljs-string">&#x27;开发&#x27;</span>,<span class="hljs-number">10500</span>,<span class="hljs-string">&#x27;2004-09-07&#x27;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>),<br>       (<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;小昭&#x27;</span>,<span class="hljs-number">19</span>,<span class="hljs-string">&#x27;程序员鼓励师&#x27;</span>,<span class="hljs-number">6600</span>,<span class="hljs-string">&#x27;2004-10-12&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h3 id="删除更新行为">删除/更新行为</h3><table><thead><tr><th>行为</th><th>说明</th></tr></thead><tbody><tr><td>NO ACTION</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与RESTRICT一致）</td></tr><tr><td>RESTRICT</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与NOACTION一致）</td></tr><tr><td>CASCADE</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键在子表中的记录</td></tr><tr><td>SET NULL</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null）</td></tr><tr><td>SET DEFAULT</td><td>父表有变更时，子表将外键设为一个默认值（Innodb不支持）</td></tr></tbody></table><p>更改删除/更新行为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> 外键名称 <span class="hljs-keyword">FOREIGN</span> KEY (外键字段) <span class="hljs-keyword">REFERENCES</span> 主表名(主表字段名) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> 行为 <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> 行为;<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> emp2 <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> fk_emp2_dept_id <span class="hljs-keyword">foreign</span> key (dept_id ) <span class="hljs-keyword">references</span> dept(id) <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> cascade <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> cascade;<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> emp2 <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> fk_emp2_dept_id <span class="hljs-keyword">foreign</span> key (dept_id ) <span class="hljs-keyword">references</span> dept(id) <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2. 函数</title>
    <link href="/2024/11/26/MySQL/2-%E5%87%BD%E6%95%B0/"/>
    <url>/2024/11/26/MySQL/2-%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="函数">2. 函数</h1><ul><li>字符串函数</li><li>数值函数</li><li>日期函数</li><li>流程函数</li></ul><h2 id="字符串函数">1. 字符串函数</h2><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CONCAT(s1, s2, …, sn)</td><td>字符串拼接，将s1, s2, …, sn拼接成一个字符串</td></tr><tr><td>LOWER(str)</td><td>将字符串全部转为小写</td></tr><tr><td>UPPER(str)</td><td>将字符串全部转为大写</td></tr><tr><td>LPAD(str, n, pad)</td><td>左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td></tr><tr><td>RPAD(str, n, pad)</td><td>右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td></tr><tr><td>TRIM(str)</td><td>去掉字符串头部和尾部的空格</td></tr><tr><td>SUBSTRING(str, start, len)</td><td>返回从字符串str从start位置起的len个长度的字符串</td></tr><tr><td>REPLACE(column, source, replace)</td><td>替换字符串</td></tr></tbody></table><p>使用示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 拼接</span><br><span class="hljs-keyword">SELECT</span> CONCAT(<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;World&#x27;</span>);<br><span class="hljs-comment">-- 小写</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">LOWER</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>);<br><span class="hljs-comment">-- 大写</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">UPPER</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>);<br><span class="hljs-comment">-- 左填充</span><br><span class="hljs-keyword">SELECT</span> LPAD(<span class="hljs-string">&#x27;01&#x27;</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;-&#x27;</span>);<br><span class="hljs-comment">-- 右填充</span><br><span class="hljs-keyword">SELECT</span> RPAD(<span class="hljs-string">&#x27;01&#x27;</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;-&#x27;</span>);<br><span class="hljs-comment">-- 去除空格</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">TRIM</span>(<span class="hljs-string">&#x27; Hello World &#x27;</span>);<br><span class="hljs-comment">-- 切片（起始索引为1）</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUBSTRING</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 由于业务需求变更，企业员工的工号，统一为<span class="hljs-number">5</span>位数，目前不足<span class="hljs-number">5</span>位数的全部在前面补<span class="hljs-number">0</span>。比如：<span class="hljs-number">1</span>号员工的工号应该为<span class="hljs-number">00001</span>。<br><span class="hljs-keyword">update</span> emp <span class="hljs-keyword">set</span> workno <span class="hljs-operator">=</span> lpad(workno, <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;0&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="数值函数">2. 数值函数</h2><p>常见函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CEIL(x)</td><td>向上取整</td></tr><tr><td>FLOOR(x)</td><td>向下取整</td></tr><tr><td>MOD(x, y)</td><td>返回x/y的模</td></tr><tr><td>RAND()</td><td>返回0~1内的随机数</td></tr><tr><td>ROUND(x, y)</td><td>求参数x的四舍五入值，保留y位小数</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">ceil</span>(<span class="hljs-number">1.1</span>);<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">floor</span>(<span class="hljs-number">1.9</span>);<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">mod</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>);<br><span class="hljs-keyword">select</span> rand();<br><span class="hljs-keyword">select</span> round(<span class="hljs-number">2.346</span>, <span class="hljs-number">2</span>);<br><br># 通过数据库的函数，生成一个六位数的随机验证码。<br><span class="hljs-keyword">select</span> lpad(round(rand()<span class="hljs-operator">*</span><span class="hljs-number">100000</span>, <span class="hljs-number">0</span>), <span class="hljs-number">6</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h2 id="日期函数">3. 日期函数</h2><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CURDATE()</td><td>返回当前日期</td></tr><tr><td>CURTIME()</td><td>返回当前时间</td></tr><tr><td>NOW()</td><td>返回当前日期和时间</td></tr><tr><td>YEAR(date)</td><td>获取指定date的年份</td></tr><tr><td>MONTH(date)</td><td>获取指定date的月份</td></tr><tr><td>DAY(date)</td><td>获取指定date的日期</td></tr><tr><td>DATE_ADD(date, INTERVAL expr type)</td><td>返回一个日期/时间值加上一个时间间隔expr后的时间值</td></tr><tr><td>DATEDIFF(date1, date2)</td><td>返回起始时间date1和结束时间date2之间的天数</td></tr></tbody></table><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> curdate();<br><span class="hljs-keyword">select</span> curtime();<br><span class="hljs-keyword">select</span> now();<br><br><span class="hljs-keyword">select</span> <span class="hljs-keyword">year</span>(now());<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">month</span>(now());<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">day</span>(now());<br><br><span class="hljs-comment">-- DATE_ADD</span><br><span class="hljs-keyword">SELECT</span> DATE_ADD(NOW(), <span class="hljs-type">INTERVAL</span> <span class="hljs-number">70</span> <span class="hljs-keyword">DAY</span>);<br><span class="hljs-keyword">select</span> datediff(<span class="hljs-string">&#x27;2021-12-01&#x27;</span>,<span class="hljs-string">&#x27;2022-12-02&#x27;</span>);<br><br><span class="hljs-comment">-- 案例：查询所有员工的入职天数，并根据入职天数倒序排序。</span><br><span class="hljs-keyword">select</span> name, datediff(curdate(), entrydate) <span class="hljs-string">&#x27;entrydays&#x27;</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> entrydays <span class="hljs-keyword">desc</span>;<br></code></pre></td></tr></table></figure><h2 id="流程函数">4. 流程函数</h2><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>IF(value, t, f)</td><td>如果value为true，则返回t，否则返回f</td></tr><tr><td>IFNULL(value1, value2)</td><td>如果value1不为空，返回value1，否则返回value2</td></tr><tr><td>CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td><td>如果val1为true，返回res1，… 否则返回default默认值</td></tr><tr><td>CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ]END</td><td>如果expr的值等于val1，返回res1，… 否则返回default默认值</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> if(<span class="hljs-literal">true</span>, <span class="hljs-string">&#x27;Ok&#x27;</span>, <span class="hljs-string">&#x27;error&#x27;</span>);<br><span class="hljs-keyword">select</span> ifnull(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;default&#x27;</span>);<br><span class="hljs-comment">-- </span><br><span class="hljs-keyword">select</span><br>name,<br>(<span class="hljs-keyword">case</span> <span class="hljs-keyword">when</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">30</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;中年&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;青年&#x27;</span> <span class="hljs-keyword">end</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;年纪&#x27;</span><br><span class="hljs-keyword">from</span> emp;<br><br><span class="hljs-comment">-- 需求：查询mp表的员工姓名和工作地址（北京/上海----&gt;一线城市，其他---&gt;二线城市)</span><br><span class="hljs-keyword">select</span><br>name,<br>(<span class="hljs-keyword">case</span> workaddress <span class="hljs-keyword">when</span> <span class="hljs-string">&#x27;北京&#x27;</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;一线城市&#x27;</span> <span class="hljs-keyword">when</span> <span class="hljs-string">&#x27;上海&#x27;</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;一线城市&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;二线城市&#x27;</span> <span class="hljs-keyword">end</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;工作地址&#x27;</span><br><span class="hljs-keyword">from</span> emp;<br><br><span class="hljs-comment">--</span><br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> score(<br>id <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;ID&#x27;</span>,<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>math <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;数学&#x27;</span>,<br>english <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;英语&#x27;</span>,<br>chinese <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;语文&#x27;</span><br>) comment <span class="hljs-string">&#x27;学员成绩表&#x27;</span>;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> score (id, name, math, english, chinese) <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>,<span class="hljs-number">67</span>,<span class="hljs-number">88</span>,<span class="hljs-number">95</span>), (<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Rose&#x27;</span>,<span class="hljs-number">23</span>,<span class="hljs-number">66</span>,<span class="hljs-number">90</span>), (<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Jack&#x27;</span>,<span class="hljs-number">56</span>,<span class="hljs-number">98</span>,<span class="hljs-number">76</span>);<br><br><span class="hljs-keyword">select</span> <br>id,<br>name,<br>(<span class="hljs-keyword">case</span> <span class="hljs-keyword">when</span> math <span class="hljs-operator">&gt;=</span> <span class="hljs-number">85</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;优秀&#x27;</span> <span class="hljs-keyword">when</span> math <span class="hljs-operator">&gt;=</span> <span class="hljs-number">60</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;及格&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;不及格&#x27;</span> <span class="hljs-keyword">end</span>) <span class="hljs-string">&#x27;数学&#x27;</span>,<br>(<span class="hljs-keyword">case</span> <span class="hljs-keyword">when</span> english <span class="hljs-operator">&gt;=</span> <span class="hljs-number">85</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;优秀&#x27;</span> <span class="hljs-keyword">when</span> english <span class="hljs-operator">&gt;=</span> <span class="hljs-number">60</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;及格&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;不及格&#x27;</span> <span class="hljs-keyword">end</span>) <span class="hljs-string">&#x27;英语&#x27;</span>,<br>(<span class="hljs-keyword">case</span> <span class="hljs-keyword">when</span> chinese <span class="hljs-operator">&gt;=</span> <span class="hljs-number">85</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;优秀&#x27;</span> <span class="hljs-keyword">when</span> chinese <span class="hljs-operator">&gt;=</span> <span class="hljs-number">60</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;及格&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;不及格&#x27;</span> <span class="hljs-keyword">end</span>) <span class="hljs-string">&#x27;语文&#x27;</span><br><span class="hljs-keyword">from</span> score;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs |"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.4 DCL(数据控制语言)</title>
    <link href="/2024/11/26/MySQL/1-4-DCL(%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80)/"/>
    <url>/2024/11/26/MySQL/1-4-DCL(%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="dcl数据控制语言">1.4 DCL(数据控制语言)</h1><p>DCL英文全称是Data ControlLanguage(数据控制语言)，用来管理数据库用户、控制数据库的访问权限。</p><h2 id="管理用户">1. 管理用户</h2><ol type="1"><li>查询用户：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE mysql;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>创建用户:</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;密码&#x27;</span>;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>修改用户密码：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="hljs-keyword">WITH</span> mysql_native_password <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;新密码&#x27;</span>;<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>删除用户：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机名&#x27;</span>;<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>例子：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建用户test，只能在当前主机localhost访问</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;test&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><span class="hljs-comment">-- 创建用户test，能在任意主机访问</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;test1&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;test&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><span class="hljs-comment">-- 修改密码</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;test&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> identified <span class="hljs-keyword">with</span> mysql_native_password <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;1234&#x27;</span>;<br><span class="hljs-comment">-- 删除用户</span><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;test&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="注意事项">注意事项</h3><ul><li>主机名可以使用 % 通配</li></ul><h2 id="权限控制">2. 权限控制</h2><ol type="1"><li>常用权限：</li></ol><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>ALL, ALL PRIVILEGES</td><td>所有权限</td></tr><tr><td>SELECT</td><td>查询数据</td></tr><tr><td>INSERT</td><td>插入数据</td></tr><tr><td>UPDATE</td><td>修改数据</td></tr><tr><td>DELETE</td><td>删除数据</td></tr><tr><td>ALTER</td><td>修改表</td></tr><tr><td>DROP</td><td>删除数据库/表/视图</td></tr><tr><td>CREATE</td><td>创建数据库/表</td></tr></tbody></table><p>更多权限请看<a href="#%E6%9D%83%E9%99%90%E4%B8%80%E8%A7%88%E8%A1%A8" title="权限一览表">权限一览表</a></p><p>查询权限：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> GRANTS <span class="hljs-keyword">FOR</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机名&#x27;</span>;<br></code></pre></td></tr></table></figure><p>授予权限：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> 权限列表 <span class="hljs-keyword">ON</span> 数据库名.表名 <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机名&#x27;</span>;<br></code></pre></td></tr></table></figure><p>撤销权限：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> 权限列表 <span class="hljs-keyword">ON</span> 数据库名.表名 <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机名&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="注意事项-1">注意事项</h3><ul><li>多个权限用逗号分隔</li><li>授权时，数据库名和表名可以用 * 进行通配，代表所有</li></ul>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.3 DQL(数据查询语言)</title>
    <link href="/2024/11/26/MySQL/1-3-DQL(%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80)/"/>
    <url>/2024/11/26/MySQL/1-3-DQL(%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="dql数据查询语言">1.3 DQL（数据查询语言）</h1><p>语法：编写顺序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>字段列表<br><span class="hljs-keyword">FROM</span><br>表名字段<br><span class="hljs-keyword">WHERE</span><br>条件列表<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span><br>分组字段列表<br><span class="hljs-keyword">HAVING</span><br>分组后的条件列表<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><br>排序字段列表<br>LIMIT<br>分页参数<br></code></pre></td></tr></table></figure><h2 id="基础查询">1. 基础查询</h2><ol type="1"><li>查询多个字段：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span>, 字段<span class="hljs-number">2</span>, 字段<span class="hljs-number">3</span>, ... <span class="hljs-keyword">FROM</span> 表名;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>设置别名：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span> [ <span class="hljs-keyword">AS</span> 别名<span class="hljs-number">1</span> ], 字段<span class="hljs-number">2</span> [ <span class="hljs-keyword">AS</span> 别名<span class="hljs-number">2</span> ], 字段<span class="hljs-number">3</span> [ <span class="hljs-keyword">AS</span> 别名<span class="hljs-number">3</span> ], ... <span class="hljs-keyword">FROM</span> 表名;<br><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span> [ 别名<span class="hljs-number">1</span> ], 字段<span class="hljs-number">2</span> [ 别名<span class="hljs-number">2</span> ], 字段<span class="hljs-number">3</span> [ 别名<span class="hljs-number">3</span> ], ... <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>去除重复记录：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure><ul><li>新建表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> emp<br>(<br>    id          <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;编号&#x27;</span>,<br>    workno      <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) comment <span class="hljs-string">&#x27;工号&#x27;</span>,<br>    name        <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>    gender      <span class="hljs-type">char</span>(<span class="hljs-number">1</span>) comment <span class="hljs-string">&#x27;性别&#x27;</span>,<br>    age         tinyint unsigned comment <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>    idcard      <span class="hljs-type">char</span>(<span class="hljs-number">18</span>) comment <span class="hljs-string">&#x27;身份证号&#x27;</span>,<br>    workaddress <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) comment <span class="hljs-string">&#x27;工作地址&#x27;</span>,<br>    entrydate   <span class="hljs-type">date</span> comment <span class="hljs-string">&#x27;入职时间&#x27;</span><br>) comment <span class="hljs-string">&#x27;员工表&#x27;</span>;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp(id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;柳岩&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;123456789012345678&#x27;</span>, <span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-string">&#x27;2000-01-01&#x27;</span>),<br>       (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;张无忌&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;123456789012345670&#x27;</span>, <span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-string">&#x27;2005-09-01&#x27;</span>),<br>       (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;韦一笑&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">38</span>, <span class="hljs-string">&#x27;123456789012345670&#x27;</span>, <span class="hljs-string">&#x27;上海&#x27;</span>, <span class="hljs-string">&#x27;2005-08-01&#x27;</span>),<br>       (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;赵敏&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;123456789012345670&#x27;</span>, <span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-string">&#x27;2009-12-01&#x27;</span>),<br>       (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;小昭&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">16</span>, <span class="hljs-string">&#x27;123456789012345678&#x27;</span>, <span class="hljs-string">&#x27;上海&#x27;</span>, <span class="hljs-string">&#x27;2007-07-01&#x27;</span>),<br>       (<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;杨逍&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">28</span>, <span class="hljs-string">&#x27;12345678901234567X&#x27;</span>, <span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-string">&#x27;2006-01-01&#x27;</span>),<br>       (<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;范瑶&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">40</span>, <span class="hljs-string">&#x27;123456789012345670&#x27;</span>, <span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-string">&#x27;2005-05-01&#x27;</span>),<br>       (<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;黛绮丝&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">38</span>, <span class="hljs-string">&#x27;123456789012345670&#x27;</span>, <span class="hljs-string">&#x27;天津&#x27;</span>, <span class="hljs-string">&#x27;2015-05-01&#x27;</span>),<br>       (<span class="hljs-number">9</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;范凉凉&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">45</span>, <span class="hljs-string">&#x27;123456789012345678&#x27;</span>, <span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-string">&#x27;2010-04-01&#x27;</span>),<br>       (<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-string">&#x27;陈友谅&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">53</span>, <span class="hljs-string">&#x27;123456789012345670&#x27;</span>, <span class="hljs-string">&#x27;上海&#x27;</span>, <span class="hljs-string">&#x27;2011-01-01&#x27;</span>),<br>       (<span class="hljs-number">11</span>, <span class="hljs-string">&#x27;11&#x27;</span>, <span class="hljs-string">&#x27;张士诚&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">55</span>, <span class="hljs-string">&#x27;123456789012345670&#x27;</span>, <span class="hljs-string">&#x27;江苏&#x27;</span>, <span class="hljs-string">&#x27;2015-05-01&#x27;</span>),<br>       (<span class="hljs-number">12</span>, <span class="hljs-string">&#x27;12&#x27;</span>, <span class="hljs-string">&#x27;常遇春&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">32</span>, <span class="hljs-string">&#x27;123456789012345670&#x27;</span>, <span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-string">&#x27;2004-02-01&#x27;</span>),<br>       (<span class="hljs-number">13</span>, <span class="hljs-string">&#x27;13&#x27;</span>, <span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">88</span>, <span class="hljs-string">&#x27;123456789012345678&#x27;</span>, <span class="hljs-string">&#x27;江苏&#x27;</span>, <span class="hljs-string">&#x27;2020-11-01&#x27;</span>),<br>       (<span class="hljs-number">14</span>, <span class="hljs-string">&#x27;14&#x27;</span>, <span class="hljs-string">&#x27;灭绝&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">65</span>, <span class="hljs-string">&#x27;123456789012345670&#x27;</span>, <span class="hljs-string">&#x27;西安&#x27;</span>, <span class="hljs-string">&#x27;2019-05-01&#x27;</span>),<br>       (<span class="hljs-number">15</span>, <span class="hljs-string">&#x27;15&#x27;</span>, <span class="hljs-string">&#x27;胡青牛&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">70</span>, <span class="hljs-string">&#x27;12345678901234567X&#x27;</span>, <span class="hljs-string">&#x27;西安&#x27;</span>, <span class="hljs-string">&#x27;2018-04-01&#x27;</span>),<br>       (<span class="hljs-number">16</span>, <span class="hljs-string">&#x27;16&#x27;</span>, <span class="hljs-string">&#x27;周芷若&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-string">&#x27;2012-06-01&#x27;</span>);<br><br># 查询返回指定字段数据<br><span class="hljs-keyword">select</span> name,workno,age <span class="hljs-keyword">from</span> emp;<br># 查询返回所有字段<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp;<br># 查询工作地址并起别名<br><span class="hljs-keyword">select</span> workaddress <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;工作地址&#x27;</span> <span class="hljs-keyword">from</span> emp;<br><span class="hljs-keyword">select</span> workaddress <span class="hljs-string">&#x27;工作地址&#x27;</span> <span class="hljs-keyword">from</span> emp;<br># 查询工作地址并去重<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> workaddress <span class="hljs-string">&#x27;工作地址&#x27;</span> <span class="hljs-keyword">from</span> emp;<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>转义： / 之后的_不作为通配符</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;/_张三&#x27;</span> <span class="hljs-keyword">ESCAPE</span> <span class="hljs-string">&#x27;/&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="条件查询">2. 条件查询</h2><ol type="1"><li>语法：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件列表;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>条件：</li></ol><table><thead><tr><th>比较运算符</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt; 或 !=</td><td>不等于</td></tr><tr><td>BETWEEN … AND …</td><td>在某个范围内（含最小、最大值）</td></tr><tr><td>IN(…)</td><td>在in之后的列表中的值，多选一</td></tr><tr><td>LIKE 占位符</td><td>模糊匹配（_匹配单个字符，%匹配任意个字符）</td></tr><tr><td>IS NULL</td><td>是NULL</td></tr></tbody></table><table><thead><tr><th>逻辑运算符</th><th>功能</th></tr></thead><tbody><tr><td>AND 或 &amp;&amp;</td><td>并且（多个条件同时成立）</td></tr><tr><td>OR 或 ||</td><td>或者（多个条件任意一个成立）</td></tr><tr><td>NOT 或 !</td><td>非，不是</td></tr></tbody></table><ol start="3" type="1"><li>例子：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 年龄等于30</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br><span class="hljs-comment">-- 年龄小于30</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">&lt;</span> <span class="hljs-number">30</span>;<br><span class="hljs-comment">-- 小于等于</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">&lt;=</span> <span class="hljs-number">30</span>;<br><span class="hljs-comment">-- 没有身份证</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> idcard <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">or</span> idcard <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-comment">-- 有身份证</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> idcard;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> idcard <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>;<br><span class="hljs-comment">-- 不等于</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">!=</span> <span class="hljs-number">30</span>;<br><span class="hljs-comment">-- 年龄在20到30之间</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-keyword">between</span> <span class="hljs-number">20</span> <span class="hljs-keyword">and</span> <span class="hljs-number">30</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">&gt;=</span> <span class="hljs-number">20</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">&lt;=</span> <span class="hljs-number">30</span>;<br><span class="hljs-comment">-- 下面语句不报错，但查不到任何信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-keyword">between</span> <span class="hljs-number">30</span> <span class="hljs-keyword">and</span> <span class="hljs-number">20</span>;<br><span class="hljs-comment">-- 性别为女且年龄小于30</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">&lt;</span> <span class="hljs-number">30</span> <span class="hljs-keyword">and</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;女&#x27;</span>;<br><span class="hljs-comment">-- 年龄等于25或30或35</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-number">25</span> <span class="hljs-keyword">or</span> age <span class="hljs-operator">=</span> <span class="hljs-number">30</span> <span class="hljs-keyword">or</span> age <span class="hljs-operator">=</span> <span class="hljs-number">35</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-keyword">in</span> (<span class="hljs-number">25</span>, <span class="hljs-number">30</span>, <span class="hljs-number">35</span>);<br><span class="hljs-comment">-- 姓名为两个字</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;__&#x27;</span>;<br><span class="hljs-comment">-- 身份证最后为X</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> idcard <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%X&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="聚合查询聚合函数">3. 聚合查询（聚合函数）</h2><ol type="1"><li><p>将一列数据作为一个整体，进行纵向计算。null值不参与聚合函数计算</p></li><li><p>常见聚合函数：</p></li></ol><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>count</td><td>统计数量</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>sum</td><td>求和</td></tr></tbody></table><ol start="3" type="1"><li>语法：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 聚合函数(字段列表) <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>例：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 统计企业员工数量<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> emp;<br># 统计平均年龄<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(age) <span class="hljs-keyword">from</span> emp;<br># 最大年龄<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">max</span>(age) <span class="hljs-keyword">from</span> emp;<br># 最小年龄<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">min</span>(age) <span class="hljs-keyword">from</span> emp;<br># 统计西安地区的年龄之和<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">sum</span>(age) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> workaddress <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;西安&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="分组查询">4. 分组查询</h2><ol type="1"><li>语法：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表名 [ <span class="hljs-keyword">WHERE</span> 条件 ] <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 分组字段名 [ <span class="hljs-keyword">HAVING</span> 分组后的过滤条件 ];<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>where 和 having 的区别：<ol type="1"><li>执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。</li><li>判断条件不同：where不能对聚合函数进行判断，而having可以。</li></ol></li></ol><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女）</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> gender;<br><span class="hljs-comment">-- 根据性别分组，统计男性和女性数量</span><br><span class="hljs-keyword">select</span> gender, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> gender;<br><span class="hljs-comment">-- 根据性别分组，统计男性和女性的平均年龄</span><br><span class="hljs-keyword">select</span> gender, <span class="hljs-built_in">avg</span>(age) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> gender;<br><span class="hljs-comment">-- 年龄小于45，并根据工作地址分组</span><br><span class="hljs-keyword">select</span> workaddress, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">&lt;</span> <span class="hljs-number">45</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> workaddress;<br><span class="hljs-comment">-- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址</span><br><span class="hljs-keyword">select</span> workaddress, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) address_count <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">&lt;</span> <span class="hljs-number">45</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> workaddress <span class="hljs-keyword">having</span> address_count <span class="hljs-operator">&gt;=</span> <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><h3 id="注意事项">注意事项</h3><ul><li>执行顺序：where &gt; 聚合函数 &gt; having</li><li>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</li></ul><h2 id="排序查询">5. 排序查询</h2><ol type="1"><li>语法：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 字段<span class="hljs-number">1</span> 排序方式<span class="hljs-number">1</span>, 字段<span class="hljs-number">2</span> 排序方式<span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>排序方式：</li></ol><ul><li>ASC: 升序（默认）</li><li>DESC: 降序</li></ul><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 根据年龄升序排序</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age <span class="hljs-keyword">ASC</span>;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age;<br><span class="hljs-comment">-- 两字段排序，根据年龄升序排序，入职时间降序排序</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age <span class="hljs-keyword">ASC</span>, entrydate <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><h3 id="注意事项-1">注意事项</h3><p>如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序</p><h2 id="分页查询">6. 分页查询</h2><ol type="1"><li>语法：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表名 LIMIT 起始索引, 查询记录数;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>例子：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询第一页数据，展示10条</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp LIMIT <span class="hljs-number">0</span>, <span class="hljs-number">10</span>;<br><span class="hljs-comment">-- 查询第二页</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp LIMIT <span class="hljs-number">10</span>, <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><h3 id="注意事项-2">注意事项</h3><ul><li>起始索引从0开始，起始索引 = （查询页码 - 1） * 每页显示记录数</li><li>分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT</li><li>如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10</li></ul><h2 id="dql执行顺序">7. DQL执行顺序</h2><ul><li>FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt;LIMIT</li></ul><h2 id="练习">8. 练习</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 查询年龄为<span class="hljs-number">20</span>,<span class="hljs-number">21</span>,<span class="hljs-number">22</span>,<span class="hljs-number">23</span>岁的女性员工信息。<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;女&#x27;</span> <span class="hljs-keyword">and</span> age <span class="hljs-keyword">in</span> (<span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>);<br># 查询性别为男，并且年龄在<span class="hljs-number">20</span><span class="hljs-number">-40</span>岁（含）以内的姓名为三个字的员工。<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;男&#x27;</span> <span class="hljs-keyword">and</span> age <span class="hljs-keyword">between</span> <span class="hljs-number">20</span> <span class="hljs-keyword">and</span> <span class="hljs-number">40</span> <span class="hljs-keyword">and</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;___&#x27;</span>;<br># 统计员工表中，年龄小于<span class="hljs-number">60</span>岁的，男性员工和女性员工的人数。<br><span class="hljs-keyword">select</span> gender, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">&lt;</span> <span class="hljs-number">60</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> gender;<br># 查询所有年龄小于等于<span class="hljs-number">35</span>岁员工的姓名和年龄，并对查询结果按年龄升序排序，如果年龄相同按入职时间降序排序。<br><span class="hljs-keyword">select</span> name, age <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">&lt;=</span> <span class="hljs-number">35</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">asc</span> , entrydate <span class="hljs-keyword">desc</span>;<br># 查询性别为男，且年龄在<span class="hljs-number">20</span><span class="hljs-number">-40</span>岁（含）以内的前<span class="hljs-number">5</span>个员工信息，对查询的结果按年龄升序排序，年龄相同按入职时间升序排序。<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;男&#x27;</span> <span class="hljs-keyword">and</span> age <span class="hljs-keyword">between</span> <span class="hljs-number">20</span> <span class="hljs-keyword">and</span> <span class="hljs-number">40</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">asc</span>, entrydate <span class="hljs-keyword">asc</span> limit <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.2 DML(数据操作语言)</title>
    <link href="/2024/11/26/MySQL/1-2-DML(%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E8%AF%AD%E8%A8%80)/"/>
    <url>/2024/11/26/MySQL/1-2-DML(%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E8%AF%AD%E8%A8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="dml数据操作语言">1.2 DML（数据操作语言）</h1><h2 id="添加数据">1. 添加数据</h2><ol type="1"><li>指定字段：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 (字段名<span class="hljs-number">1</span>, 字段名<span class="hljs-number">2</span>, ...) <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...);<br><br># eg:<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> employee (id, workno, name, gender, age, idcard, entrydate) <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;Itcast&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;123456789712345678&#x27;</span>, <span class="hljs-string">&#x27;2000-01-01&#x27;</span>);<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>全部字段：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...);<br># eg:<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> employee <span class="hljs-keyword">values</span> (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;wj&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;123456789713645678&#x27;</span>, <span class="hljs-string">&#x27;2001-01-01&#x27;</span>);<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>批量添加数据：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 (字段名<span class="hljs-number">1</span>, 字段名<span class="hljs-number">2</span>, ...) <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...), (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...), (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...), (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...), (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...);<br><br># eg:<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> employee <span class="hljs-keyword">values</span> (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;wj&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;123456789713645678&#x27;</span>, <span class="hljs-string">&#x27;2001-01-01&#x27;</span>), (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;zj&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;123456789713645678&#x27;</span>, <span class="hljs-string">&#x27;2001-01-01&#x27;</span>), (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;zw&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;123456789713645678&#x27;</span>, <span class="hljs-string">&#x27;2001-01-01&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="注意事项">注意事项</h3><ul><li>字符串和日期类型数据应该包含在引号中</li><li>插入的数据大小应该在字段的规定范围内</li></ul><h2 id="更新和删除数据">2. 更新和删除数据</h2><ol type="1"><li>修改数据：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> 表名 <span class="hljs-keyword">SET</span> 字段名<span class="hljs-number">1</span> <span class="hljs-operator">=</span> 值<span class="hljs-number">1</span>, 字段名<span class="hljs-number">2</span> <span class="hljs-operator">=</span> 值<span class="hljs-number">2</span>, ... [ <span class="hljs-keyword">WHERE</span> 条件 ];<br># 例：<br><span class="hljs-keyword">UPDATE</span> employee <span class="hljs-keyword">SET</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Jack&#x27;</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>删除数据：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> 表名 [ <span class="hljs-keyword">WHERE</span> 条件 ];<br># eg:<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础篇 1.通用语法及分类 1.1 DDL（数据定义语言）</title>
    <link href="/2024/11/25/MySQL/1-1-DDL%EF%BC%88%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80%EF%BC%89/"/>
    <url>/2024/11/25/MySQL/1-1-DDL%EF%BC%88%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="ddl数据定义语言">1.1 DDL（数据定义语言）</h1><h2 id="mysql">1. MySQL</h2><h3 id="关系型数据库rdbms">1.1 关系型数据库(RDBMS)</h3><ul><li>概念：<ul><li>建立在关系模型基础上，由多张相互连接的二维表组成的数据库。</li></ul></li><li>特点：<ul><li>使用表存储数据，格式统一，便于维护</li><li>使用SQL语言操作，标准统一，使用方便</li></ul></li></ul><h3 id="通用语法及分类">1.2 通用语法及分类</h3><ul><li>DDL: 数据定义语言，用来定义数据库对象（数据库、表、字段）</li><li>DML: 数据操作语言，用来对数据库表中的数据进行增删改</li><li>DQL: 数据查询语言，用来查询数据库中表的记录</li><li>DCL: 数据控制语言，用来创建数据库用户、控制数据库的控制权限</li></ul><h2 id="ddl数据定义语言-1">2. DDL（数据定义语言）</h2><h3 id="数据库操作">1.1 数据库操作</h3><ol type="1"><li>查询所有数据库：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> DATABASES;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>查询当前数据库：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> DATABASE();<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>创建数据库：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE [ IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> ] 数据库名 [ <span class="hljs-keyword">DEFAULT</span> CHARSET 字符集] [<span class="hljs-keyword">COLLATE</span> 排序规则 ];<br># eg:<br><span class="hljs-keyword">create</span> database if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> itcast;<br><span class="hljs-keyword">create</span> database itheima <span class="hljs-keyword">default</span> charset utf8mb4;<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>删除数据库：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> DATABASE [ IF <span class="hljs-keyword">EXISTS</span> ] 数据库名<br># eg:<br><span class="hljs-keyword">drop</span> database if <span class="hljs-keyword">exists</span> test;<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>使用数据库：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE 数据库名;<br></code></pre></td></tr></table></figure><h4 id="注意事项">注意事项</h4><ul><li>UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集</li></ul><h3 id="表操作">1.2 表操作</h3><ol type="1"><li>查询当前数据库所有表：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> TABLES;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>查询表结构：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DESC</span> 表名;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>查询指定表的建表语句：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名;<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>创建表：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>字段<span class="hljs-number">1</span> 字段<span class="hljs-number">1</span>类型 [COMMENT 字段<span class="hljs-number">1</span>注释],<br>字段<span class="hljs-number">2</span> 字段<span class="hljs-number">2</span>类型 [COMMENT 字段<span class="hljs-number">2</span>注释],<br>字段<span class="hljs-number">3</span> 字段<span class="hljs-number">3</span>类型 [COMMENT 字段<span class="hljs-number">3</span>注释],<br>...<br>字段n 字段n类型 [COMMENT 字段n注释]<br>)[ COMMENT 表注释 ];<br><br># eg:<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tb_user(<br>    id <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;编号&#x27;</span>,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>    age <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>    gender <span class="hljs-type">varchar</span>(<span class="hljs-number">1</span>) comment <span class="hljs-string">&#x27;性别&#x27;</span><br>) comment <span class="hljs-string">&#x27;用户表&#x27;</span>;<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> emp(<br>id <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;编号&#x27;</span>,<br>    workno <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) comment <span class="hljs-string">&#x27;工号&#x27;</span>,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>    gender <span class="hljs-type">char</span>(<span class="hljs-number">1</span>) comment <span class="hljs-string">&#x27;性别&#x27;</span>,<br>    age tinyint unsigned comment <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>    idcard <span class="hljs-type">char</span>(<span class="hljs-number">18</span>) comment <span class="hljs-string">&#x27;身份证号&#x27;</span>,<br>    entrydate <span class="hljs-type">date</span> comment <span class="hljs-string">&#x27;入职时间&#x27;</span><br>) comment <span class="hljs-string">&#x27;员工表&#x27;</span>;<br></code></pre></td></tr></table></figure><p>​ <strong>最后一个字段后面没有逗号</strong></p><ol start="5" type="1"><li>添加字段：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> 字段名 类型(长度) [COMMENT 注释] [约束];<br># 例：<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> emp <span class="hljs-keyword">ADD</span> nickname <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) COMMENT <span class="hljs-string">&#x27;昵称&#x27;</span>;<br></code></pre></td></tr></table></figure><ol start="6" type="1"><li>修改数据类型：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 MODIFY 字段名 新数据类型(长度);<br></code></pre></td></tr></table></figure><ol start="7" type="1"><li>修改字段名和字段类型：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];<br># 例：将emp表的nickname字段修改为username，类型为<span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>)<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> emp CHANGE nickname username <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>) COMMENT <span class="hljs-string">&#x27;昵称&#x27;</span>;<br></code></pre></td></tr></table></figure><ol start="7" type="1"><li>删除字段：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">DROP</span> 字段名;<br># eg:<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> emp <span class="hljs-keyword">drop</span> username;<br></code></pre></td></tr></table></figure><ol start="8" type="1"><li>修改表名：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 RENAME <span class="hljs-keyword">TO</span> 新表名<br># eg:<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> emp rename <span class="hljs-keyword">to</span> employee;<br></code></pre></td></tr></table></figure><ol start="9" type="1"><li>删除表：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> [IF <span class="hljs-keyword">EXISTS</span>] 表名;<br></code></pre></td></tr></table></figure><ol start="10" type="1"><li>删除表，并重新创建该表：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> 表名;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0.1 MySQL常见问题（Win11）</title>
    <link href="/2024/11/25/MySQL/0-1-MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2024/11/25/MySQL/0-1-MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="mysql常见问题win11">0.1 MySQL常见问题（Win11）</h1><h2 id="启动停止mysql服务">1. 启动/停止mysql服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">net stop mysql80 <span class="hljs-comment">#停止服务</span><br>net start mysql80 <span class="hljs-comment">#启动服务</span><br></code></pre></td></tr></table></figure><h2 id="mysql80忘记密码">2. MySQL80忘记密码</h2><ol type="1"><li>启动命令行（管理员）<ol type="1"><li>win+R 打开运行</li><li>输入cmd</li><li>按下ctrl + shift + enter 管理员权限启动</li></ol></li><li>停止数据库服务</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">net stop mysql80 <span class="hljs-comment">#停止服务</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>越过密码认证(如果报错转到步骤7)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysqld --console --skip-grant-tables --shared-memory<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>管理员权限打开另一个命令行，输入</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql -u root -p<br></code></pre></td></tr></table></figure><p>提示输入密码时直接回车即可登入</p><ol start="5" type="1"><li>设置新密码</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> mysql.user <span class="hljs-keyword">set</span> authentication_string<span class="hljs-operator">=</span><span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">user</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;root&#x27;</span>;<br>flush privileges;<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br></code></pre></td></tr></table></figure><p>上述'root'@'localhost'，若修改过支持了远程连接，则应该是'root'@'%'，具体可通过user表查看:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>,host <span class="hljs-keyword">from</span> mysql.user <span class="hljs-keyword">where</span> <span class="hljs-keyword">user</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;root&#x27;</span>;<br></code></pre></td></tr></table></figure><ol start="6" type="1"><li>关闭终端，新开一个终端，启动服务并输入密码登录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">net start mysql<br>mysql -u root -p<br></code></pre></td></tr></table></figure><ol start="7" type="1"><li>命令代码无效，两种解决办法</li></ol><p><img src="/2024/11/25/MySQL/0-1-MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/image-20241126105225405.png"></p><ul><li><p>不会保留数据库的数据</p><ul><li>在MySQL安装目录下没有data文件夹和my.ini文件</li><li>先删除mysql服务</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sc delete MySql80<br></code></pre></td></tr></table></figure><ul><li><p>删除完成之后，Win+R，输入services.msc，手动检查mysql80服务有没有正常删除，如果还在运行，一定要先停止</p></li><li><p>新建my.ini配置文件</p><ul><li>简单版</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs txt">[mysql]<br>default-character-set=utf8<br>[mysqld]<br>default-storage-engine=INNODB<br>basedir=C:/Program Files/MySQL/MySQL Server 8.0 <br>datadir=C:/Program Files/MySQL/MySQL Server 8.0/data<br></code></pre></td></tr></table></figure><ul><li>如果不行那就复杂版</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs txt"># For advice on how to change settings please see<br># http://dev.mysql.com/doc/refman/5.6/en/server-configuration-defaults.html<br># *** DO NOT EDIT THIS FILE. It&#x27;s a template which will be copied to the<br># *** default location during install, and will be replaced if you<br># *** upgrade to a newer version of MySQL.<br>[client]<br>default-character-set = utf8mb4<br>[mysql]<br>default-character-set = utf8mb4<br>[mysqld]<br>character-set-client-handshake = FALSE<br>character-set-server = utf8mb4<br>collation-server = utf8mb4_bin<br>init_connect=&#x27;SET NAMES utf8mb4&#x27;<br># Remove leading # and set to the amount of RAM for the most important data<br># cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.<br>innodb_buffer_pool_size = 128M<br># Remove leading # to turn on a very important data integrity option: logging<br># changes to the binary log between backups.<br># log_bin<br># These are commonly set, remove the # and set as required.<br>basedir = C:\Program Files\MySQL\MySQL Server 8.0 <br>datadir =  C:\Program Files\MySQL\MySQL Server 8.0\data<br>port = 3306<br># server_id = .....<br># Remove leading # to set options mainly useful for reporting servers.<br># The server defaults are faster for transactions and fast SELECTs.<br># Adjust sizes as needed, experiment to find the optimal values.<br>join_buffer_size = 128M<br>sort_buffer_size = 16M<br>read_rnd_buffer_size = 16M <br>sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES<br></code></pre></td></tr></table></figure></li><li><p>其中basedir和databir记得改成自己对应的mysql目录</p></li><li><p>在终端执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysqld --initialize-insecure --user=mysql<br></code></pre></td></tr></table></figure><p>会生成data文件夹</p></li><li><p>再输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysqld --install <span class="hljs-string">&quot;MySql80&quot;</span> --defaults-file=<span class="hljs-string">&quot;C:\Program Files\MySQL\MySQL Server 8.0\my.ini&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>最后启动MySQL80服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">net start mysql80<br></code></pre></td></tr></table></figure></li><li><p>登录mysql，不需要密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql -u root -p<br></code></pre></td></tr></table></figure></li><li><p>输入更改密码命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="hljs-keyword">WITH</span> mysql_native_password <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>就结束啦</p></li></ul></li><li><p>保留数据库的数据</p><ul><li><p>概念了解</p><ul><li>Data/data目录：存放着创建的数据库</li><li>my.ini：一些相关配置</li><li>services.msc：可以调出服务程序</li><li>net stop 服务名：可以关闭服务</li><li>net start 服务名：可以启动服务</li><li>-defaults-file：指定服务配置</li><li>–console --skip-grant-tables--shared-memory：跳过密码验证的关键</li></ul></li><li><p>我的data不在安装目录，而是在C:Server 8.0：</p><p><img src="/2024/11/25/MySQL/0-1-MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/image-20241126115855599.png"></p></li><li><p>打开my.ini并插入：skip-grant-tables;</p><p><img src="/2024/11/25/MySQL/0-1-MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/58d9569cfd673bf97b79d1f17289531e.png"></p></li><li><p>运行：services.msc 打开服务后，停止mysql服务</p></li><li><p>管理员权限打开终端，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysqld --defaults-file=“C:\ProgramData\MySQL\MySQL Server 8.0\my.ini” --console --skip-grant-tables --shared-memory<br><span class="hljs-comment"># 解释</span><br><span class="hljs-comment">#mysqld --defaults-file=“这里是你的my.ini配置路径” --console --skip-grant-tables --shared-memory</span><br></code></pre></td></tr></table></figure></li><li><p>打开新的命令提示符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql -u root -p<br></code></pre></td></tr></table></figure><p>回车进入root</p></li><li><p>修改密码输入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> ‘root’@‘localhost’ IDENTIFIED <span class="hljs-keyword">BY</span> ‘<span class="hljs-number">123456</span>’;<br></code></pre></td></tr></table></figure><p>若没有出现Query OK，则执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">flush privileges;<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> ‘root’@‘localhost’ IDENTIFIED <span class="hljs-keyword">BY</span> ‘<span class="hljs-number">123456</span>’;<br></code></pre></td></tr></table></figure></li><li><p>最后修改完毕注用#释掉my.ini这行语句</p><p><img src="/2024/11/25/MySQL/0-1-MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/e6e7751171889e633e30dcd0a3e95a30.png"></p></li><li><p>关闭所有界面，启动mysql，就可以正常输入密码登录了</p></li></ul></li></ul><p>​</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 所有的建表代码如下：</span><br><br><span class="hljs-number">1</span>、约束代码：<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span>(<br><br>id <span class="hljs-type">int</span>  KEY auto_increment COMMENT <span class="hljs-string">&#x27;主键&#x27;</span>,<br><br>name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">unique</span> comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br><br>age <span class="hljs-type">int</span> <span class="hljs-keyword">check</span>( age <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-operator">&amp;&amp;</span> age <span class="hljs-operator">&lt;=</span> <span class="hljs-number">120</span>) comment <span class="hljs-string">&#x27;年龄&#x27;</span>,<br><br>status <span class="hljs-type">char</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;1&#x27;</span> comment <span class="hljs-string">&#x27;状态&#x27;</span>,<br><br> gender <span class="hljs-type">char</span>(<span class="hljs-number">1</span>) comment <span class="hljs-string">&#x27;性别&#x27;</span><br><br><br><br>) comment <span class="hljs-string">&#x27;用户表&#x27;</span>;<br><br><br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span>(name,age,status,gender) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;TOM1&#x27;</span>,<span class="hljs-number">19</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>),(<span class="hljs-string">&#x27;TOM2&#x27;</span>,<span class="hljs-number">25</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>); <br><br><br><br><span class="hljs-number">2</span>、外键约束:<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> dept(<br><br>id <span class="hljs-type">int</span> auto_increment comment <span class="hljs-string">&#x27;ID&#x27;</span>  key,<br><br>name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;部门名称&#x27;</span><br><br>)comment <span class="hljs-string">&#x27;部门表&#x27;</span>;<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> dept(id,name) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;研发部&#x27;</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;市场部&#x27;</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;财务部&#x27;</span>),(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;销售部&#x27;</span>),(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;总经办&#x27;</span>);<br><br><br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> emp<br><br>(<br><br>id <span class="hljs-type">int</span> auto_increment comment <span class="hljs-string">&#x27;ID&#x27;</span>  key,<br><br>name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br><br>age <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;年龄&#x27;</span>,<br><br>job <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) comment <span class="hljs-string">&#x27;职位&#x27;</span>,<br><br>salary <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;薪资&#x27;</span>,<br><br>entrydate <span class="hljs-type">date</span> comment <span class="hljs-string">&#x27;入职时间&#x27;</span>,<br><br>managerid <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;直质领导ID&#x27;</span>,<br><br>dept_id <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;部门ID&#x27;</span><br><br>) comment <span class="hljs-string">&#x27;员工表1&#x27;</span> ;<br><br><br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp(id,name,age, job, salary, entrydate, managerid, dept_id) <span class="hljs-keyword">VALUES</span><br><br>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;金庸&#x27;</span>,<span class="hljs-number">66</span>,<span class="hljs-string">&#x27;总裁&#x27;</span>,<span class="hljs-number">20000</span>,<span class="hljs-string">&#x27;2000-01-01&#x27;</span>,<span class="hljs-keyword">null</span>,<span class="hljs-number">5</span>),<br><br>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;张无忌&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;项目经理&#x27;</span>, <span class="hljs-number">12500</span>, <span class="hljs-string">&#x27;2005-12-05&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>),<br><br>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;杨逍&#x27;</span>,<span class="hljs-number">33</span>,<span class="hljs-string">&#x27;开发&#x27;</span>,<span class="hljs-number">8400</span>,<span class="hljs-string">&#x27;2000-11-03&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>),<br><br>(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;书一笑&#x27;</span>,<span class="hljs-number">48</span>,<span class="hljs-string">&#x27;开发&#x27;</span>,<span class="hljs-number">11000</span>,<span class="hljs-string">&#x27;2002-02-05&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>),<br><br>(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;常遇春&#x27;</span>,<span class="hljs-number">43</span>,<span class="hljs-string">&#x27;开发&#x27;</span>,<span class="hljs-number">10500</span>,<span class="hljs-string">&#x27;2004-09-07&#x27;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>),<br><br>(<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;小昭&#x27;</span>,<span class="hljs-number">19</span>,<span class="hljs-string">&#x27;程序员鼓励师&#x27;</span>,<span class="hljs-number">6600</span>,<span class="hljs-string">&#x27;2004-10-12&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br><br><br><br>P30:<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">table</span> score<br><br>(<br><br>  id   <span class="hljs-type">INT</span> COMMENT <span class="hljs-string">&#x27;编号&#x27;</span>,<br><br>  name  <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) COMMENT <span class="hljs-string">&#x27;姓名&#x27;</span>,<br><br>  math  <span class="hljs-type">INT</span> COMMENT <span class="hljs-string">&#x27;数学&#x27;</span>,<br><br>  english <span class="hljs-type">INT</span> COMMENT <span class="hljs-string">&#x27;英语&#x27;</span>,<br><br>  chinese <span class="hljs-type">INT</span> COMMENT <span class="hljs-string">&#x27;语文&#x27;</span><br><br>) COMMENT <span class="hljs-string">&#x27;学员成绩表&#x27;</span>;<br><br><br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> score<br><br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-number">67</span>, <span class="hljs-number">88</span>, <span class="hljs-number">95</span>),<br><br>    (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>, <span class="hljs-number">23</span>, <span class="hljs-number">66</span>, <span class="hljs-number">90</span>),<br><br>    (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-number">56</span>, <span class="hljs-number">98</span>, <span class="hljs-number">76</span>);<br><br><br><br>P37<span class="hljs-operator">-</span>多表查询：<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student(<br><br>   id <span class="hljs-type">int</span> auto_increment  key comment <span class="hljs-string">&#x27;主键ID&#x27;</span>,<br><br>   name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br><br>   <span class="hljs-keyword">no</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) comment <span class="hljs-string">&#x27;学号&#x27;</span><br><br>)comment <span class="hljs-string">&#x27; 学生表&#x27;</span>;<br><br><br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student <span class="hljs-keyword">values</span> (<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;黛绮丝&#x27;</span>,<span class="hljs-string">&#x27;2000100101&#x27;</span>),(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;谢逊&#x27;</span>,<span class="hljs-string">&#x27;2000100102&#x27;</span>),(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;殷天正&#x27;</span>,<span class="hljs-string">&#x27;2000100103&#x27;</span>),(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;韦一笑&#x27;</span>,<span class="hljs-string">&#x27;2000100104&#x27;</span>);<br><br><br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> course(<br><br>   id <span class="hljs-type">int</span> auto_increment  key comment <span class="hljs-string">&#x27;主键ID&#x27;</span>,<br><br>   name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) comment <span class="hljs-string">&#x27;课程名称&#x27;</span><br><br>)comment <span class="hljs-string">&#x27;课程表&#x27;</span>;<br><br><br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> course <span class="hljs-keyword">values</span> (<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;Java&#x27;</span>),(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;PHP&#x27;</span>),(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;Mysql&#x27;</span>),(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;Hadoop&#x27;</span>);<br><br><br><br><br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student_course(<br><br>   id <span class="hljs-type">int</span> auto_increment comment <span class="hljs-string">&#x27;主键&#x27;</span>  key,<br><br>   studentid <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;学生ID&#x27;</span>,<br><br>   courseid <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;课程ID&#x27;</span>,<br><br>   <span class="hljs-keyword">constraint</span> fk_courseid <span class="hljs-keyword">foreign</span> key (courseid) <span class="hljs-keyword">references</span> course(id),<br><br>   <span class="hljs-keyword">constraint</span> fk_studentid <span class="hljs-keyword">foreign</span> key (studentid) <span class="hljs-keyword">references</span> student(id)<br><br>)comment <span class="hljs-string">&#x27;学生课程中间表&#x27;</span>;<br><br><br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student_course <span class="hljs-keyword">values</span> (<span class="hljs-keyword">null</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>),(<span class="hljs-keyword">null</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>),(<span class="hljs-keyword">null</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>),(<span class="hljs-keyword">null</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),(<span class="hljs-keyword">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<br><br><br><br>P37:一对一<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tb_user(<br><br>  id <span class="hljs-type">int</span> auto_increment  key COMMENT <span class="hljs-string">&#x27;主键ID&#x27;</span>,<br><br>  name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) COMMENT <span class="hljs-string">&#x27;姓名&#x27;</span>,<br><br>  age <span class="hljs-type">int</span> COMMENT <span class="hljs-string">&#x27;年龄&#x27;</span>,<br><br>  gender <span class="hljs-type">char</span>(<span class="hljs-number">1</span>) COMMENT <span class="hljs-string">&#x27;1:男， 2：女&#x27;</span>,<br><br>  phone <span class="hljs-type">char</span>(<span class="hljs-number">11</span>) COMMENT <span class="hljs-string">&#x27;手机号&#x27;</span><br><br>)comment <span class="hljs-string">&#x27;用户基本信息表&#x27;</span>;<br><br><br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tb_user_edu(<br><br>  id <span class="hljs-type">int</span> auto_increment <span class="hljs-keyword">primary</span> key COMMENT <span class="hljs-string">&#x27;主键ID&#x27;</span>,<br><br>  degree <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) COMMENT <span class="hljs-string">&#x27;学历&#x27;</span>,<br><br>  major <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) COMMENT <span class="hljs-string">&#x27;专业&#x27;</span>,<br><br>  primaryschool <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) COMMENT <span class="hljs-string">&#x27;小学&#x27;</span>,<br><br>  middleschool <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) COMMENT <span class="hljs-string">&#x27;中学&#x27;</span>,<br><br>  university <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) COMMENT <span class="hljs-string">&#x27;大学&#x27;</span>,<br><br>  userid <span class="hljs-type">int</span> <span class="hljs-keyword">unique</span> COMMENT <span class="hljs-string">&#x27;用户ID&#x27;</span>,<br><br>  <span class="hljs-keyword">constraint</span> fk_userid <span class="hljs-keyword">foreign</span> key (userid) <span class="hljs-keyword">references</span> tb_user(id)<br><br>)comment <span class="hljs-string">&#x27;用户教育信息表&#x27;</span>;<br><br><br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_user(id,name,age,gender,phone) <span class="hljs-keyword">values</span><br><br>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;黄渤&#x27;</span>,<span class="hljs-number">45</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;18800001111&#x27;</span>),<br><br>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;冰冰&#x27;</span>,<span class="hljs-number">35</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;18800002222&#x27;</span>),<br><br>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;码云&#x27;</span>,<span class="hljs-number">55</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;18800008888&#x27;</span> ),<br><br>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;李彦宏&#x27;</span>,<span class="hljs-number">50</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;18800009999&#x27;</span>);<br><br><br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_user_edu(id, degree, major, primaryschool, middleschool, university, userid) <span class="hljs-keyword">values</span><br><br>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;本科&#x27;</span>,<span class="hljs-string">&#x27;舞蹈&#x27;</span>,<span class="hljs-string">&#x27;静安区第一小学&#x27;</span>,<span class="hljs-string">&#x27;静安区第一中学&#x27;</span>,<span class="hljs-string">&#x27;北京舞蹈学院&#x27;</span>,<span class="hljs-number">1</span>),<br><br>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;硕士&#x27;</span>,<span class="hljs-string">&#x27;表演&#x27;</span>,<span class="hljs-string">&#x27;朝阳区第一小学&#x27;</span>,<span class="hljs-string">&#x27;朝阳区第一中学&#x27;</span>,<span class="hljs-string">&#x27;北京电影学院&#x27;</span>,<span class="hljs-number">2</span>),<br><br>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;本科&#x27;</span>,<span class="hljs-string">&#x27;英语&#x27;</span>,<span class="hljs-string">&#x27;杭州市第一小学&#x27;</span>,<span class="hljs-string">&#x27;杭州市第一中学&#x27;</span>,<span class="hljs-string">&#x27;杭州师范大学&#x27;</span>,<span class="hljs-number">3</span>),<br><br>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;本科&#x27;</span>,<span class="hljs-string">&#x27;应用数学&#x27;</span>,<span class="hljs-string">&#x27;阳泉第一小学&#x27;</span>,<span class="hljs-string">&#x27;阳泉区第一中学&#x27;</span>,<span class="hljs-string">&#x27;清华大学&#x27;</span>,<span class="hljs-number">4</span>);<br><br><br><br>P38:多表查询<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> dept(<br><br>  id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br><br>  name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)<br><br>);<br><br><br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> dept <span class="hljs-keyword">values</span><br><br>   (<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;研发部&#x27;</span>),<br><br>   (<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;市场部&#x27;</span>),<br><br>   (<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;财务部&#x27;</span>),<br><br>   (<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;销售部&#x27;</span>),<br><br>   (<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;总经办&#x27;</span>),<br><br>   (<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;人事部&#x27;</span>);<br><br><br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> emp(<br><br>  id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br><br>  name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),<br><br>  age <span class="hljs-type">int</span>,<br><br>  job <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),<br><br>  salary <span class="hljs-type">int</span>,<br><br>  entrydate <span class="hljs-type">date</span>,<br><br>  managerid <span class="hljs-type">int</span>,<br><br>  dept_id <span class="hljs-type">int</span>,<br><br>  <span class="hljs-keyword">constraint</span> fk_dept <span class="hljs-keyword">foreign</span> key (dept_id) <span class="hljs-keyword">references</span> dept(id)<br><br>);<br><br><br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp <span class="hljs-keyword">values</span><br><br>  (<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;金庸&#x27;</span>, <span class="hljs-number">66</span>, <span class="hljs-string">&#x27;总裁&#x27;</span>, <span class="hljs-number">20000</span>, <span class="hljs-string">&#x27;2000-01-01&#x27;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">5</span>),<br><br>  (<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;张无忌&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;项目经理&#x27;</span>, <span class="hljs-number">12500</span>, <span class="hljs-string">&#x27;2005-12-05&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br><br>  (<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;杨逍&#x27;</span>, <span class="hljs-number">33</span>, <span class="hljs-string">&#x27;开发&#x27;</span>, <span class="hljs-number">8400</span>, <span class="hljs-string">&#x27;2000-11-03&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>),<br><br>  (<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;韦一笑&#x27;</span>, <span class="hljs-number">48</span>, <span class="hljs-string">&#x27;开发&#x27;</span>, <span class="hljs-number">11000</span>, <span class="hljs-string">&#x27;2002-02-05&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>),<br><br>  (<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;常遇春&#x27;</span>, <span class="hljs-number">43</span>, <span class="hljs-string">&#x27;开发&#x27;</span>, <span class="hljs-number">10500</span>, <span class="hljs-string">&#x27;2004-09-07&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>),<br><br>  (<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;小昭&#x27;</span>, <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;程序员鼓励师&#x27;</span>, <span class="hljs-number">6600</span>, <span class="hljs-string">&#x27;2004-10-12&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>),<br><br>  (<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;灭绝&#x27;</span>, <span class="hljs-number">60</span>, <span class="hljs-string">&#x27;财务总监&#x27;</span>, <span class="hljs-number">8500</span>, <span class="hljs-string">&#x27;2002-09-12&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>),<br><br>  (<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;周芷若&#x27;</span>, <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;会计&#x27;</span>, <span class="hljs-number">4800</span>, <span class="hljs-string">&#x27;2006-06-02&#x27;</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>),<br><br>  (<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;丁敏君&#x27;</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&#x27;出纳&#x27;</span>, <span class="hljs-number">5250</span>, <span class="hljs-string">&#x27;2009-05-13&#x27;</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>),<br><br>  (<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;赵敏&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;市场部总监&#x27;</span>, <span class="hljs-number">12500</span>, <span class="hljs-string">&#x27;2004-10-12&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>),<br><br>  (<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;鹿杖客&#x27;</span>, <span class="hljs-number">56</span>, <span class="hljs-string">&#x27;职员&#x27;</span>, <span class="hljs-number">3750</span>, <span class="hljs-string">&#x27;2006-10-03&#x27;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>),<br><br>  (<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;鹤笔翁&#x27;</span>, <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;职员&#x27;</span>, <span class="hljs-number">3750</span>, <span class="hljs-string">&#x27;2007-05-09&#x27;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>),<br><br>  (<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;方东白&#x27;</span>, <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;职员&#x27;</span>, <span class="hljs-number">5500</span>, <span class="hljs-string">&#x27;2009-02-12&#x27;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>),<br><br>  (<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-number">88</span>, <span class="hljs-string">&#x27;销售总监&#x27;</span>, <span class="hljs-number">14000</span>, <span class="hljs-string">&#x27;2004-10-12&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>),<br><br>  (<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;俞莲舟&#x27;</span>, <span class="hljs-number">38</span>, <span class="hljs-string">&#x27;销售&#x27;</span>, <span class="hljs-number">4600</span>, <span class="hljs-string">&#x27;2004-10-12&#x27;</span>, <span class="hljs-number">14</span>, <span class="hljs-number">4</span>),<br><br>  (<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;宋远桥&#x27;</span>, <span class="hljs-number">40</span>, <span class="hljs-string">&#x27;销售&#x27;</span>, <span class="hljs-number">4600</span>, <span class="hljs-string">&#x27;2004-10-12&#x27;</span>, <span class="hljs-number">14</span>, <span class="hljs-number">4</span>),<br><br>  (<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;陈友谅&#x27;</span>, <span class="hljs-number">42</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">2000</span>, <span class="hljs-string">&#x27;2011-10-12&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>);<br><br><br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> salgrade(<br><br>  grade <span class="hljs-type">int</span>,<br><br>  losal <span class="hljs-type">int</span>,<br><br>  hisal <span class="hljs-type">int</span><br><br>);<br><br><br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade<br><br><span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3000</span>),<br><br>    (<span class="hljs-number">2</span>, <span class="hljs-number">3001</span>, <span class="hljs-number">5000</span>),<br><br>    (<span class="hljs-number">3</span>, <span class="hljs-number">5001</span>, <span class="hljs-number">8000</span>),<br><br>    (<span class="hljs-number">4</span>, <span class="hljs-number">8001</span>, <span class="hljs-number">10000</span>),<br><br>    (<span class="hljs-number">5</span>, <span class="hljs-number">10001</span>, <span class="hljs-number">15000</span>),<br><br>    (<span class="hljs-number">6</span>, <span class="hljs-number">15001</span>, <span class="hljs-number">20000</span>),<br><br>    (<span class="hljs-number">7</span>, <span class="hljs-number">20001</span>, <span class="hljs-number">25000</span>),<br><br>    (<span class="hljs-number">8</span>, <span class="hljs-number">25001</span>, <span class="hljs-number">30000</span>);<br><br><br><br>P74:<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> users (<br><br>  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br><br>    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>),<br><br>    phone <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br><br>    email <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>),<br><br>     profession <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>),<br><br>     age <span class="hljs-type">INT</span>,<br><br>     gender <span class="hljs-type">INT</span>,<br><br>     status <span class="hljs-type">INT</span>,<br><br>     createtime DATETIME );<br><br> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> users (id, name, phone, email, profession, age, gender, status, createtime) <span class="hljs-keyword">VALUES</span><br><br>  (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;吕布&#x27;</span>, <span class="hljs-string">&#x27;17799990000&#x27;</span>, <span class="hljs-string">&#x27;lvbu666@163.com&#x27;</span>, <span class="hljs-string">&#x27;软件工程&#x27;</span>, <span class="hljs-number">23</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-string">&#x27;2001-02-02 00:00:00&#x27;</span>),<br><br>  (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;曹操&#x27;</span>, <span class="hljs-string">&#x27;17799990001&#x27;</span>, <span class="hljs-string">&#x27;caocao666@qq.com&#x27;</span>, <span class="hljs-string">&#x27;通讯工程&#x27;</span>, <span class="hljs-number">33</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;2001-03-05 00:00:00&#x27;</span>),<br><br>   (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;赵云&#x27;</span>, <span class="hljs-string">&#x27;17799990002&#x27;</span>, <span class="hljs-string">&#x27;177999900@139.com&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>, <span class="hljs-number">34</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;2002-03-02 00:00:00&#x27;</span>),<br><br>   (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;孙悟空&#x27;</span>, <span class="hljs-string">&#x27;17799990003&#x27;</span>, <span class="hljs-string">&#x27;177999900@sina.com&#x27;</span>, <span class="hljs-string">&#x27;工程造价&#x27;</span>, <span class="hljs-number">54</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;2001-07-02 00:00:00&#x27;</span>),<br><br>   (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;花木兰&#x27;</span>, <span class="hljs-string">&#x27;17799990004&#x27;</span>, <span class="hljs-string">&#x27;19980729@sina.com&#x27;</span>, <span class="hljs-string">&#x27;软件工程&#x27;</span>, <span class="hljs-number">23</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2001-04-22 00:00:00&#x27;</span>),<br><br>   (<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;大乔&#x27;</span>, <span class="hljs-string">&#x27;17799990005&#x27;</span>, <span class="hljs-string">&#x27;daqiao666@sina.com&#x27;</span>, <span class="hljs-string">&#x27;舞蹈&#x27;</span>, <span class="hljs-number">22</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;2001-02-07 00:00:00&#x27;</span>),<br><br>   (<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;露娜&#x27;</span>, <span class="hljs-string">&#x27;17799990006&#x27;</span>, <span class="hljs-string">&#x27;luna_love@sina.com&#x27;</span>, <span class="hljs-string">&#x27;应用数学&#x27;</span>, <span class="hljs-number">24</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;2001-02-08 00:00:00&#x27;</span>),<br><br>  (<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;程咬金&#x27;</span>, <span class="hljs-string">&#x27;17799990007&#x27;</span>, <span class="hljs-string">&#x27;chengyaojin@163.com&#x27;</span>, <span class="hljs-string">&#x27;化工&#x27;</span>, <span class="hljs-number">38</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;2001-05-23 00:00:00&#x27;</span>),<br><br>   (<span class="hljs-number">9</span>, <span class="hljs-string">&#x27;项羽&#x27;</span>, <span class="hljs-string">&#x27;17799990008&#x27;</span>, <span class="hljs-string">&#x27;xiaoyu666@qq.com&#x27;</span>, <span class="hljs-string">&#x27;金属材料&#x27;</span>, <span class="hljs-number">43</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2001-09-18 00:00:00&#x27;</span>),<br><br>  (<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;白起&#x27;</span>, <span class="hljs-string">&#x27;17799990009&#x27;</span>, <span class="hljs-string">&#x27;baiqi666@163.com&#x27;</span>, <span class="hljs-string">&#x27;机械工程及其自动化&#x27;</span>, <span class="hljs-number">27</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;2001-08-16 00:00:00&#x27;</span>),<br><br>  (<span class="hljs-number">11</span>, <span class="hljs-string">&#x27;韩信&#x27;</span>, <span class="hljs-string">&#x27;17799990010&#x27;</span>, <span class="hljs-string">&#x27;hanxin520@163.com&#x27;</span>, <span class="hljs-string">&#x27;无机非金属材料工程&#x27;</span>, <span class="hljs-number">27</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;2001-06-12 00:00:00&#x27;</span>),<br><br>   (<span class="hljs-number">12</span>, <span class="hljs-string">&#x27;荆轲&#x27;</span>, <span class="hljs-string">&#x27;17799990011&#x27;</span>, <span class="hljs-string">&#x27;jingke123@163.com&#x27;</span>, <span class="hljs-string">&#x27;会计&#x27;</span>, <span class="hljs-number">29</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;2001-05-11 00:00:00&#x27;</span>),<br><br>   (<span class="hljs-number">13</span>, <span class="hljs-string">&#x27;兰陵王&#x27;</span>, <span class="hljs-string">&#x27;17799990012&#x27;</span>, <span class="hljs-string">&#x27;lanlinwang666@126.com&#x27;</span>, <span class="hljs-string">&#x27;工程造价&#x27;</span>, <span class="hljs-number">44</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2001-04-09 00:00:00&#x27;</span>),<br><br>   (<span class="hljs-number">14</span>, <span class="hljs-string">&#x27;狂铁&#x27;</span>, <span class="hljs-string">&#x27;17799990013&#x27;</span>, <span class="hljs-string">&#x27;kuangtie@sina.com&#x27;</span>, <span class="hljs-string">&#x27;应用数学&#x27;</span>, <span class="hljs-number">43</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;2001-04-10 00:00:00&#x27;</span>),<br><br>  (<span class="hljs-number">15</span>, <span class="hljs-string">&#x27;貂蝉&#x27;</span>, <span class="hljs-string">&#x27;17799990014&#x27;</span>, <span class="hljs-string">&#x27;8495848374@qq.com&#x27;</span>, <span class="hljs-string">&#x27;软件工程&#x27;</span>, <span class="hljs-number">40</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2001-02-12 00:00:00&#x27;</span>),<br><br>   (<span class="hljs-number">16</span>, <span class="hljs-string">&#x27;妲己&#x27;</span>, <span class="hljs-string">&#x27;17799990015&#x27;</span>, <span class="hljs-string">&#x27;2782382939@qq.com&#x27;</span>, <span class="hljs-string">&#x27;软件工程&#x27;</span>, <span class="hljs-number">31</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;2001-01-30 00:00:00&#x27;</span>),<br><br>   (<span class="hljs-number">17</span>, <span class="hljs-string">&#x27;半月&#x27;</span>, <span class="hljs-string">&#x27;17799990016&#x27;</span>, <span class="hljs-string">&#x27;xiaomin2001@sina.com&#x27;</span>, <span class="hljs-string">&#x27;工业经济&#x27;</span>, <span class="hljs-number">35</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;2000-05-03 00:00:00&#x27;</span>),<br><br>   (<span class="hljs-number">18</span>, <span class="hljs-string">&#x27;赢政&#x27;</span>, <span class="hljs-string">&#x27;17799990017&#x27;</span>, <span class="hljs-string">&#x27;8839434342@qq.com&#x27;</span>, <span class="hljs-string">&#x27;化工&#x27;</span>, <span class="hljs-number">38</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2001-08-08 00:00:00&#x27;</span>),<br><br>   (<span class="hljs-number">19</span>, <span class="hljs-string">&#x27;狄仁杰&#x27;</span>, <span class="hljs-string">&#x27;17799990018&#x27;</span>, <span class="hljs-string">&#x27;jujiamlm816@163.com&#x27;</span>, <span class="hljs-string">&#x27;国际贸易&#x27;</span>, <span class="hljs-number">30</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2007-03-12 00:00:00&#x27;</span>),<br><br>   (<span class="hljs-number">20</span>, <span class="hljs-string">&#x27;安琪拉&#x27;</span>, <span class="hljs-string">&#x27;17799990019&#x27;</span>, <span class="hljs-string">&#x27;jdodmlh@126.com&#x27;</span>, <span class="hljs-string">&#x27;城市规划&#x27;</span>, <span class="hljs-number">51</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;2001-08-15 00:00:00&#x27;</span>),<br><br>   (<span class="hljs-number">21</span>, <span class="hljs-string">&#x27;典韦&#x27;</span>, <span class="hljs-string">&#x27;17799990020&#x27;</span>, <span class="hljs-string">&#x27;ycauanjian@163.com&#x27;</span>, <span class="hljs-string">&#x27;城市规划&#x27;</span>, <span class="hljs-number">52</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;2000-04-12 00:00:00&#x27;</span>),<br><br>   (<span class="hljs-number">22</span>, <span class="hljs-string">&#x27;廉颇&#x27;</span>, <span class="hljs-string">&#x27;17799990021&#x27;</span>, <span class="hljs-string">&#x27;lianpo321@126.com&#x27;</span>, <span class="hljs-string">&#x27;土木工程&#x27;</span>, <span class="hljs-number">19</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;2002-07-18 00:00:00&#x27;</span>),<br><br>   (<span class="hljs-number">23</span>, <span class="hljs-string">&#x27;后羿&#x27;</span>, <span class="hljs-string">&#x27;17799990022&#x27;</span>, <span class="hljs-string">&#x27;altycj2000@139.com&#x27;</span>, <span class="hljs-string">&#x27;城市园林&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;2002-03-10 00:00:00&#x27;</span>),<br><br>   (<span class="hljs-number">24</span>, <span class="hljs-string">&#x27;姜子牙&#x27;</span>, <span class="hljs-string">&#x27;17799990023&#x27;</span>, <span class="hljs-string">&#x27;3748384@qq.com&#x27;</span>, <span class="hljs-string">&#x27;工程造价&#x27;</span>, <span class="hljs-number">29</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;2003-05-26 00:00:00&#x27;</span>);<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.3 磁盘和固态硬盘</title>
    <link href="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-3-%E7%A3%81%E7%9B%98%E5%92%8C%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98/"/>
    <url>/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-3-%E7%A3%81%E7%9B%98%E5%92%8C%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h1 id="磁盘组织与管理"><strong>5.3 磁盘组织与管理</strong></h1><h2 id="磁盘的结构"><strong>1. 磁盘的结构</strong></h2><h3 id="磁盘磁道扇区">1.1 <strong>磁盘、磁道、扇区</strong></h3><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-3-%E7%A3%81%E7%9B%98%E5%92%8C%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98/image-20241122110700006.png"></p><h3 id="如何在磁盘中读写数据">1.2<strong>如何在磁盘中读/写数据</strong></h3><ul><li><p>需要把"磁头"移动到想要读/写的扇区所在的磁道</p></li><li><p>磁盘会转起来, 让目标扇区从磁头下面划过,才能完成对扇区的读/写操作</p></li></ul><h3 id="盘面柱面">1.3 <strong>盘面、柱面</strong></h3><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-3-%E7%A3%81%E7%9B%98%E5%92%8C%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98/image-20241122110727198.png"></p><h3 id="磁盘的物理地址">1.4 <strong>磁盘的物理地址</strong></h3><ul><li>可用 (柱面号, 盘面号,扇区号)来定位任意一个"磁盘块"。在“文件的物理结构”小节中,我们经常提到文件数据存放在外存中的几号块, 这个块号就可以转换成(柱面号,盘面号, 扇区号)的地址转化</li><li>可根据该地址读取一个"块"<ul><li>根据"柱面号"移动磁臂, 让磁头指向指定柱面</li><li>激活指定盘面对应的磁头</li><li>磁盘旋转的过程中, 指定的扇区会从磁头下面划过,这样就完成了对指定扇区的读/写</li></ul></li></ul><h3 id="磁盘的分类">1.5 <strong>磁盘的分类</strong></h3><ul><li><strong>根据磁头是否可移动</strong><ul><li><strong>活动头磁盘</strong><ul><li>磁头可以移动的称为活动头磁盘</li><li>磁臂可以来回伸缩来带动磁头定位磁道</li></ul></li><li><strong>固定头磁盘</strong><ul><li>磁头不可移动的称为固定头磁盘</li><li>这种磁盘中每个磁道都有一个磁头</li></ul></li><li><strong>根据盘片是否可更换</strong><ul><li><strong>可换盘磁盘</strong></li><li><strong>固定盘磁盘</strong></li></ul></li></ul></li></ul><h2 id="磁盘调度算法"><strong>2. 磁盘调度算法</strong></h2><h3 id="一次磁盘读写操作需要的时间">2.1<strong>一次磁盘读/写操作需要的时间</strong></h3><ul><li><strong>寻道时间(寻找时间)</strong>T<sub>S</sub><ul><li>在读/写数据前, 将磁头移动到指定磁道所花的时间<ul><li>启动磁头臂是需要时间的, 假设耗时为s</li><li>移动磁头也是需要时间的, 假设磁头匀速移动, 每跨域一个磁道耗时为m,总共需要跨域n条磁道</li></ul></li><li>寻道时间 T<sub>S</sub> = s + m * n</li></ul></li><li><strong>延迟时间</strong>T<sub>R</sub><ul><li>通过旋转磁盘, 使磁头定位到目标扇区所需要的时间<ul><li>设磁盘转速为r(单位: 转/秒 或 转/分)</li></ul></li><li>平均所需的延迟时间 T<sub>R</sub> = (1/2) * (1/r) = 1/(2r)<ul><li>1/r就是转一圈需要的时间, 找到目标扇区平均需要转半圈,因此再乘以1/2</li></ul></li></ul></li><li><strong>传输时间</strong>T<sub>t</sub><ul><li>从磁盘读/写数据所经历的时间<ul><li>磁盘转速为r, 此次读/写的字节数为b, 每个磁道上的字节数为N</li></ul></li><li>传输时间 T<sub>t</sub> = (1/r)*(b/N) = b/(rN)</li><li>每个磁道要可存N字节的数据, 因此b字节的数据需要b/N个磁道才能存储,而读/写一个磁道</li><li>所需的时间刚好又是转一圈所需要的时间1/r</li></ul></li><li><strong>总的平均读取时间</strong> Ta = Ts + 1/(2r) + b/(rN)<ul><li>延迟时间和传输时间都与磁盘转速相关, 而转速是硬件的固有属性,因此操作系统也无法优化延迟时间和传输时间</li><li>但是操作系统的<strong>磁盘调度算法</strong>会直接影响<strong>寻道时间</strong></li></ul></li></ul><h3 id="磁盘调度算法-1">2.2 <strong>磁盘调度算法</strong></h3><ul><li>先来先服务算法(FCFS)<ul><li>根据进程请求访问磁盘的先后顺序进行调度</li><li>优点: 公平; 如果请求访问的磁道比较集中的话, 算法性能还算过得去</li><li>缺点: 如果有大量进程竞争使用磁盘, 请求访问的磁道很分散,则FCFS在性能上很差, 寻道时间长</li></ul></li><li>最短寻找时间优先(SSTF)<ul><li>SSTF算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短,但是并不能保证总的寻道时间最短<ul><li>其实就是贪心算法的思想, 只是选择眼前最优, 但是总体未必最优</li></ul></li><li>优点: 性能较好, 平均寻道时间短</li><li>缺点: 可能产生"饥饿"现象, 磁头在一个小区域内来回地移动</li></ul></li><li>扫描算法(SCAN)<ul><li>为了防止SSTF算法产生饥饿,可以规定只有磁头移动到最外侧磁道的时候才能往内移动,移动到最内侧磁道的时候才能往外移动, 由于磁头移动的方式很像电梯,因此也叫电梯算法</li><li>优点: 性能较好, 平均寻道时间较短, 不会产生饥饿现象</li><li>缺点:<ul><li>只有到达最边上的磁道时才能改变磁头移动方向</li><li>SCAN算法对于各个位置磁道的响应频率不平均</li></ul></li></ul></li><li>LOOK调度算法<ul><li>如果在磁头移动方向上已经没有别的请求,就可以立即改变磁头移动方向(边移动边观察, 因此叫LOOK)</li><li>优点: 比起SCAN算法, 不需要每次都移动到最外侧或最内侧才改变磁头方向,使寻道时间进一步缩短</li></ul></li><li>循环扫描算法(C-SCAN)<ul><li>规定只有磁头朝某个特定方向移动时才处理磁道访问请求,而返回时直接快速移动至起始端而不处理任何请求</li><li>优点: 比起SCAN来说, 对于各个位置磁道的响应频率很平均</li><li>缺点: 只有到达最边上的磁道时才能改变磁头移动方向</li></ul></li><li>C-LOOK调度算法<ul><li>如果磁头移动的方向上已经没有磁道访问请求了, 就可以立即让磁头返回,并且磁头只需要返回到有磁道访问请求的位置即可</li><li>优点: 比起C-SCAN算法,不需要每次都移动到最外侧或最内侧才改变磁头方向,使寻道时间进一步缩短</li></ul></li></ul><h2 id="减少磁盘延迟时间的方法"><strong>3.减少磁盘延迟时间的方法</strong></h2><h3 id="交替编号">3.1 <strong>交替编号</strong></h3><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-3-%E7%A3%81%E7%9B%98%E5%92%8C%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98/image-20241122111239973.png"></p><h3 id="错位命名">3.2 <strong>错位命名</strong></h3><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-3-%E7%A3%81%E7%9B%98%E5%92%8C%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98/image-20241122111252768.png"></p><h3 id="磁盘地址结构的设计">3.3 <strong>磁盘地址结构的设计</strong></h3><ul><li>使用 (柱面号, 盘面号, 扇区号)的原因<ul><li>在读取地址连续的磁盘块时, 前者不需要经常移动磁头</li></ul></li></ul><h2 id="磁盘的管理"><strong>4. 磁盘的管理</strong></h2><h3 id="磁盘初始化">4.1 <strong>磁盘初始化</strong></h3><ul><li><p>进行<strong>低级格式化(物理格式化)</strong>,<strong>将磁盘的各个磁道划分为扇区</strong>,一个扇区通常可分为头、数据区域(如512B大小)、尾三个部分组成。管理扇区所需要的各种数据结构一般存放在头、尾两个部分,包括扇区校验码(如奇偶校验、CRC循环冗余校验码等,校验码用于校验扇区中的数据是否发生错误)</p></li><li><p><strong>将磁盘分区(分卷，Volume),每个分区由若干柱面组成</strong>(即分为我们熟悉的 C盘、D盘、E盘)</p></li><li><p>进行<strong>逻辑格式化</strong>,<strong>创建文件系统</strong>。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构(如位示图、空闲分区表)</p></li></ul><h3 id="引导块">4.2 <strong>引导块</strong></h3><ul><li><p>计算机开机时需要进行一系列初始化的工作,这些初始化工作是通过执行<strong>初始化程序(自举程序)</strong>完成的</p></li><li><p>初始化程序可以放在ROM(只读存储器)中, ROM中的数据在出厂时就写入了,并且以后不能再修改</p><ul><li>注: ROM一般是出厂时就集成在主板上的</li></ul></li><li><p>将完整初始化程序放在ROM中, 当需要更新自举程序时, 将会很不方便,因为ROM中的数据无法更改</p></li><li><p>在实际中, ROM中只存放很小的"自举装入程序",完整的自举程序存放在磁盘的**启动块(引导块/*启动分区)<strong>上,启动块位于磁盘的固定位置,拥有启动分区的磁盘称为</strong>启动磁盘或系统磁盘(C:盘)**</p></li><li><p>开机时计算机先运行"自举装入程序", 通过执行该程序就可以找到引导块,并将完整的"自举程序"读入内存, 完成初始化</p></li></ul><h3 id="坏块的管理">4.3 <strong>坏块的管理</strong></h3><ul><li><p>坏了、无法正常使用的扇区就是“坏块”。这属于硬件故障,操作系统是无法修复的。应该将坏块标记出来, 以免错误地使用到它</p></li><li><p>对于简单的磁盘,可以在逻辑格式化时(建立文件系统时)对整个磁盘进行坏块检查,标明哪些扇区是坏扇区</p><ul><li>例如: 在FAT表上标明(在这种方式中, 坏块对操作系统不透明)</li></ul></li><li><p>对于复杂的磁盘,<strong>磁盘控制器</strong>(磁盘设备内部的一个硬件部件)会维护一个坏块链表,在磁盘出厂前进行<strong>低级格式化(物理格式化)</strong>时就将坏块链进行初始化,会保留一些"备用扇区", 用于替换坏块,这种方案称为<strong>扇区备用</strong>, 且这种处理方式中,坏块对操作系统透明</p></li></ul><h2 id="固态硬盘ssd"><strong>5. 固态硬盘SSD</strong></h2><figure><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-3-%E7%A3%81%E7%9B%98%E5%92%8C%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98/image-20241122112439752.png" alt="SSD 结构"><figcaption aria-hidden="true">SSD 结构</figcaption></figure><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-3-%E7%A3%81%E7%9B%98%E5%92%8C%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98/image-20241122112356429.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.2 设备独立性软件</title>
    <link href="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/"/>
    <url>/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="io核心子系统"><strong>5.2 I/O核心子系统</strong></h1><h2 id="io核心子系统-1"><strong>1. IO核心子系统</strong></h2><ul><li>I/O软件层次<ul><li>用户层软件</li><li><strong>设备独立性软件</strong></li><li><strong>设备驱动程序</strong></li><li><strong>中断处理程序</strong></li><li>硬件</li></ul></li><li>设备独立性软件、设备驱动程序、中断处理程序属于操作系统的<strong>内核部分</strong>，即“<strong>I/O系统</strong>”或称"<strong>I/O核心子系统</strong>"<ul><li>因此I/O核心子系统要实现的功能其实就是中间三层要实现的功能</li><li>考研中, 我们需要重点理解和掌握的功能是:<ul><li>I/O调度</li><li>设备保护</li><li>假脱机技术(SPOOLing技术)<ul><li>假脱机技术需要使用到磁盘这种设备的<strong>设备独立性软件</strong>提供的服务,所以假脱机技术一般是在<strong>用户层软件</strong>实现的</li></ul></li><li>设备分配与回收</li><li>缓冲区管理(即缓冲与高速缓存)<ul><li>除了假脱机技术外,其他几种功能都是在<strong>设备独立性软件</strong>实现的</li></ul></li></ul></li></ul></li></ul><h3 id="io调度">1.1 <strong>I/O调度</strong></h3><ul><li>用某种算法确定一个好的顺序来处理各个<strong>I/O请求</strong><ul><li>如:磁盘调度(先来先服务、最短寻道优先算法、SCAN算法、C-SCAN算法、LOOK算法、C-LOOK算法)</li><li>当多个磁盘I/O请求到来时, 用某种调度算法确定满足I/O请求的顺序</li><li>同理,打印机等设备也可以用先来先服务、优先级算法、短作业优先等算法来确定I/O调度顺序</li></ul></li></ul><h3 id="设备保护">1.2 <strong>设备保护</strong></h3><ul><li>操作系统需要实现<strong>文件保护功能</strong>,不同的用户对各个文件有不同的访问权限<ul><li>如: 只读、读和写等</li></ul></li><li>在UNIX系统中, <strong>设备被看做是一种特殊的文件</strong>,每个设备也会有对应的<strong>FCB</strong>。当用户请求访问某个设备时,操作系统根据FCB中记录的信息来判断该用户是否有相应的访问权限,以此实现"<strong>设备保护</strong>"的功能(参考"<strong>文件保护</strong>"小节)</li></ul><h2 id="假脱机技术"><strong>2. 假脱机技术</strong></h2><h3 id="脱机技术">2.1 <strong>脱机技术</strong></h3><ul><li><p>手工操作阶段: 主机直接从I/O设备获得数据, 由于设备速度慢,主机速度很快, 人机速度矛盾明显, 主机要浪费很多时间来等待设备</p></li><li><p>批处理阶段:引入了<strong>脱机输入/输出技术</strong>(用<strong>磁带</strong>完成)</p><ul><li>在<strong>外围控制机</strong>的控制下,慢速输入设备的数据先被输入到更快捷的磁带上,之后主机可以从快速的磁带上读入数据, 从而缓解了速度矛盾</li><li><strong>为什么称为"脱机"?</strong><ul><li>脱离主机的控制进行的输入/输出操作</li></ul></li><li>引入脱机技术后, 缓解了CPU与慢速I/O设备的速度矛盾; 另一方面,即使CPU在忙碌, 也可以提前将数据输入到磁带; 即使慢速的输出设备正在忙碌,也可以提前将数据输出到磁带</li></ul></li></ul><h3 id="假脱机技术spooling技术">2.2<strong>假脱机技术(SPOOLing技术)</strong></h3><ul><li><p>是用软件的方式模拟脱机技术</p></li><li><p>SPOOLing系统的组成如下:</p></li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/image-20241122104053709.png"></p><ul><li>在磁盘上开辟出两个存储区域 -- "<strong>输入井</strong>" 和"<strong>输出井</strong>"<ul><li>"输入井"模拟脱机输入时的磁带, 用于收容I/O设备输入的数据</li><li>"输出井"模拟脱机输出时的磁带, 用于收容用户进程输出的数据</li></ul></li><li>要实现SPOOLing技术, <strong>必须要有多道程序技术的支持</strong>,系统会建立"<strong>输入进程</strong>" 和 "<strong>输出进程</strong>"<ul><li>"输入进程"模拟脱机输入时的外围控制机</li><li>"输出进程"模拟脱机输出时的外围控制机</li></ul></li><li><strong>输入缓冲区</strong> 和<strong>输出缓冲区</strong>是在内存中的缓冲区<ul><li>在输入进程的控制下, "输入缓冲区"用于暂存从输入设备输入的数据,之后再转存到输入井中</li><li>在输出进程的控制下, "输出缓冲区"用于暂存从输出井送来的数据,之后再传送到输出设备上</li></ul></li></ul><h3 id="共享打印机原理分析">2.3 <strong>共享打印机原理分析</strong></h3><ul><li><p><strong>独占式设备</strong></p><ul><li>只允许各个进程串行使用的设备, 一段时间内只能满足一个进程的请求</li><li>例子: 若进程1正在使用打印机,则进程2请求使用打印机时必然阻塞等待</li></ul></li><li><p><strong>共享设备</strong></p><ul><li>允许多个进程"同时"使用的设备(宏观上同时使用, 微观上可能是交替使用),可以同时满足多个进程的使用要求</li></ul></li><li><p>打印机是种"独占式设备",但是可以用<strong>SPOOLing技术</strong>改造成"共享设备"</p></li><li><p>原理分析:</p><ul><li>当多个用户进程提出输出打印的请求时，系统会答应它们的请求，但是并不是真正把打印机分配给他们，而是由假脱机管理进程为每个进程做两件事:<ul><li>在磁盘输出井中为进程申请一个空闲缓冲区(也就是说，这个缓冲区是在磁盘上的)，并将要打印的数据送入其中</li><li>为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中(其实就是用来说明用户的打印数据存放位置等信息的)，再将该表挂到假脱机文件队列上。当打印机空闲时，输出进程会从文件队列的队头取出一张打印请求表，并根据表中的要求将要打印的数据从输出井传送到输出缓冲区，再输出到打印机进行打印。用这种方式可依次处理完全部的打印任务</li></ul></li><li>虽然系统中只有一台打印机, 但每个进程提出打印请求时,系统都会为它们在输出井中为其分配一个存储区(相当于分配了一个逻辑设备),使每个用户进程都觉得自己在独占一台打印机, 从而实现对打印机的共享</li><li><strong>SPOOLing技术</strong>可以把一台物理设备虚拟成逻辑上的多台设备,可将独占式设备改造成共享设备</li></ul></li></ul><h2 id="设备的分配与回收"><strong>3. 设备的分配与回收</strong></h2><h3 id="设备分配时应该考虑哪些因素">3.1<strong>设备分配时应该考虑哪些因素</strong></h3><ul><li><strong>设备的固有属性</strong><ul><li>独占设备: 一个时段只能分配给一个进程(如打印机)</li><li>共享设备: 可同时分配给多个进程使用(如磁盘),各进程往往是宏观上同时共享使用设备, 而微观上交替使用</li><li>虚拟设备: 采用SPOOLing技术将独占设备改造成虚拟的共享设备,可同时分配给多个进程使用(如采用SPOOLing技术实现的共享打印机)</li></ul></li><li><strong>设备分配算法</strong><ul><li>先来先服务、优先级高者优先、短任务优先...</li></ul></li><li><strong>设备分配中的安全性</strong><ul><li>从进程运行的安全性上考虑, 设备分配有两种方式:</li><li><strong>安全分配方式</strong>: 为进程分配一个设备后就将进程阻塞,本次I/O完成后才将进程唤醒<ul><li>Eg: 考虑进程请求打印机打印输出的例子</li><li>一个时间段内每个进程只能使用一个设备</li><li>优点: 破坏了"请求和保持"条件, 不会死锁</li><li>缺点: 对于一个进程来说, CPU和I/O设备只能串行工作</li></ul></li><li><strong>不安全分配方式</strong>: 进程发出I/O请求后,系统为其分配I/O设备, 进程可继续执行, 之后还可以发出新的I/O请求,只有某个I/O请求得不到满足时才将进程阻塞<ul><li>一个进程可以同时使用多个设备</li><li>优点: 进程的计算任务和I/O任务可以并行处理, 使进程迅速推进</li><li>缺点:有可能发生死锁(采用死锁避免、死锁的检测和解除处理死锁问题)</li></ul></li></ul></li></ul><h3 id="静态分配和动态分配">3.2 <strong>静态分配和动态分配</strong></h3><ul><li>静态分配: 进程运行前为其分配全部所需资源, 运行结束后归还资源<ul><li>破坏了"请求和保持"条件, 不会发生死锁</li></ul></li><li>动态分配: 进程运行过程中动态申请设备资源</li></ul><h3 id="设备分配管理中的数据结构">3.3<strong>设备分配管理中的数据结构</strong></h3><ul><li><p>”设备、控制器、通道“之间的关系“:</p><ul><li>一个通道可控制多个设备控制器, 每个设备控制器可控制多个设备</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/image-20241122105107110.png"></p></li><li><p><strong>设备控制表(DCT)</strong></p><ul><li>系统为每个设备配置一张DCT, 用于记录设备情况</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/image-20241122104823020.png"></p></li><li><p><strong>控制器控制表(COCT)</strong></p><ul><li>每个设备控制器都会对应一张COCT,操作系统根据COCT的信息对控制器进行操作和管理</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/image-20241122104842310.png"></p></li><li><p><strong>通道控制表(CHCT)</strong></p><ul><li>每个通道都会对应一张CHCT,操作系统根据CHCT的信息对通道进行操作和管理</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/image-20241122104858368.png"></p></li><li><p><strong>系统设备表(SDT)</strong></p><ul><li>记录了系统中全部设备的情况, 每个设备对应一个表目</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/image-20241122105007101.png"></p></li></ul><h3 id="设备分配的步骤">3.4 <strong>设备分配的步骤</strong></h3><ul><li><strong>步骤</strong>:<ul><li>根据进程请求的<strong>物理设备名</strong>查找SDT(注:物理设备名是进程请求分配设备时提供的参数)</li><li>根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程</li><li>根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程</li><li>根据COCT找到CHCT,若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程</li></ul></li><li>注: 只有设备、控制器、通道三者都分配成功时, 这次设备分配才算成功,之后便可启动I/O设备进行数据传送<ul><li>缺点:<ul><li>用户编程时必须使用“物理设备名”，底层细节对用户不透明，不方便编程</li><li>若换了一个物理设备，则程序无法运行</li><li>若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待</li></ul></li><li>改进方法:<ul><li>建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名</li></ul></li></ul></li><li><strong>改进的步骤</strong>:<ul><li>根据进程请求的<strong>逻辑设备名</strong>查找SDT(注:用户编程时提供的逻辑设备名其实就是“设备类型”)</li><li>查找SDT，找到用户进程指定类型的、并且空闲的设备，将其分配给该进程。操作系统在<strong>逻辑设备表(LUT)</strong>中新增一个表项</li><li>根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程</li><li>根据COCT找到CHCT,若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程</li></ul></li><li><strong>逻辑设备表(LUT)</strong><ul><li>逻辑设备表(LUT) 建立了逻辑设备名与物理设备名之间的映射关系</li><li>某用户进程第一次使用设备时使用逻辑设备名向操作系统发出请求，操作系统根据用户进程指定的设备类型(逻辑设备名)查找系统设备表，找到一个空闲设备分配给进程，并在LUT中增加相应表项</li><li>如果之后用户进程再次通过相同的逻辑设备名请求使用设备,则操作系统通过LUT表即可知道用户进程实际要使用的是哪个物理设备了，并且也能知道该设备的驱动程序入口地址</li><li>逻辑设备表的设置问题:<ul><li><strong>整个系统只有一张LUT</strong>:各用户所用的<strong>逻辑设备名不允许重复</strong>，<strong>适用于单用户操作系统</strong></li><li><strong>每个用户一张LUT</strong>:<strong>不同用户的逻辑设备名可重复</strong>，<strong>适用于多用户操作系统</strong></li></ul></li></ul></li></ul><h2 id="缓冲区管理"><strong>4. 缓冲区管理</strong></h2><h3 id="缓冲区的概念">4.1 <strong>缓冲区的概念</strong></h3><ul><li><p>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区</p></li><li><p>使用<strong>硬件作为缓冲区</strong>的成本较高，容量也较小，一般仅用在对速度要求非常高的场合(如**存储器*管理**中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本)</p></li><li><p>一般情况下，更多的是利用<strong>内存作为缓冲区</strong>，“<strong>设备独立性软件</strong>”的缓冲区管理就是要组织管理好这些缓冲区</p></li></ul><h3 id="缓冲区的作用">4.2 <strong>缓冲区的作用</strong></h3><ul><li>缓和CPU与I/O设备之间速度不匹配的矛盾<ul><li>CPU可以把要输出的数据快速地放入缓冲区, 之后就可以做别的事;慢速的I/O设备可以慢慢从缓冲区取走数据</li><li>数据输入时类似</li></ul></li><li>减少对CPU的中断频率，放宽对CPU中断响应时间的限制<ul><li>如果没有缓冲区,字符型设备每输出完一个字符就要向CPU发送一次中断信号</li></ul></li><li>解决数据粒度不匹配的问题<ul><li>如输出进程每次可以生成一块数据, 但I/O设备每次只能输出一个字符</li></ul></li><li>提高CPU与I/O设备之间的并行性</li></ul><h3 id="单缓冲">4.3 <strong>单缓冲</strong></h3><ul><li><p>假设某用户进程请求某种块设备读入若干块的数据。若采用<strong>单缓冲</strong>的策略，操作系统会<strong>在主存中为其分配一个缓冲区</strong>(若题目中没有特别说明，一个缓冲区的大小就是一个块)</p><ul><li>注意:<strong>当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出;当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出</strong></li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/image-20241122105801865.png"></p></li><li><p><strong>每处理一块数据平均需要多久?</strong></p><ul><li><p>T &gt; C</p><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/image-20241122105830197.png"></p></li><li><p>T &lt; C</p><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/image-20241122105915924.png"></p></li><li><p>结论: 采用单缓冲策略, 处理一块数据平均耗时为 Max(C, T) + M</p><ul><li>可以这样理解:</li><li>当T &gt; C时, 认为T极大, 这样一次数据传输时间主要为T, 而由于单缓冲,T与M不能同时执行, 所以传输时间为 T + M</li><li>当T &lt; C时, 认为T无限接近于0, 相当于缓冲区总是满的状态,这样一次的数据传输消耗的时间就是C + M</li></ul></li></ul></li></ul><h3 id="双缓冲">4.4 <strong>双缓冲</strong></h3><ul><li><p>假设某用户进程请求某种块设备读入若干块的数据。若采用<strong>双缓冲</strong>的策略，操作系统会<strong>在主存中为其分配两个缓冲区</strong>(若题目中没有特别说明，一个缓冲区的大小就是一个块)</p></li><li><p><strong>每处理一块数据平均需要多久?</strong></p><ul><li><p>双缓冲题目中, 假设初始状态为: 工作区空, 其中一个缓冲区满,另一个缓冲区空</p></li><li><p>T &gt; C + M</p><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/image-20241122110227430.png"></p></li><li><p>T &lt; C + M</p><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/image-20241122110243845.png"></p></li><li><p>结论: 采用双缓冲策略, 处理一个数据块的平均耗时为 Max(T, C +M)</p><ul><li>可以这样理解:<ul><li>当T &gt; C + M时, 认为T极大, 这样一次数据传输时间为T, 而由于双缓冲,T与M能够同时执行, 所以传输时间为 T</li><li>当T &lt; C + M时, 认为T无限接近于0, 相当于缓冲区总是满的状态,这样一次的数据传输消耗的时间就是C + M</li></ul></li></ul></li></ul></li></ul><h3 id="使用单双缓冲在通信时的区别">4.5<strong>使用单/双缓冲在通信时的区别</strong></h3><ul><li>两台机器之间通信时, 可以配置缓冲区用于数据的发送和接收</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/image-20241122110402354.png"></p><ul><li>显然, 若两个相互通信的机器只设置单缓冲区,在任一时刻只能实现数据的单向传输</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/image-20241122110422084.png"></p><ul><li>若两个相互通信的机器设置双缓冲区,则同一时刻可以实现双向的数据传输</li></ul><h3 id="循环缓冲">4.6 <strong>循环缓冲</strong></h3><ul><li>将多个大小相等的缓冲区链接成一个循环队列</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/image-20241122110437329.png"></p><h3 id="缓冲池">4.7 <strong>缓冲池</strong></h3><ul><li><p><strong>缓冲池</strong>由系统中共用的缓冲区组成</p></li><li><p>这些缓冲区按使用状况可以分为:<strong>空缓冲队列</strong>、装满输入数据的缓冲队列(<strong>输入队列</strong>)、装满输出数据的缓冲队列(<strong>输出队列</strong>)</p></li><li><p>另外，根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区:<strong>用于收容输入数据的工作缓冲区(hin)</strong>、<strong>用于提取输入数据的工作缓冲区(sin)</strong>、<strong>用于收容输出数据的工作缓冲区(hout)</strong>、<strong>用于提取输出数据的工作缓冲区(sout)</strong></p></li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/image-20241122110532369.png"></p><ul><li><strong>原理</strong>:<ul><li>输入进程请求输入数据<ul><li>从 空缓冲队列 队头取出一块空的缓冲区作为收容输入数据的工作缓冲区(hin), 冲满数据后将缓冲区挂到输入队列队尾</li></ul></li><li>计算进程想要取得一块输入数据<ul><li>从 输入队列 队头取下一块缓冲区作为 提取输入数据的工作缓冲区(sin),缓冲区读空后挂到空缓冲队列队尾</li></ul></li><li>计算进程想要将准备好的数据冲入缓冲区<ul><li>从 空缓冲队列 队头取出一块空的缓冲区作为收容输出数据的工作缓冲区(hout), 冲满数据后将缓冲区挂到 输出队列队尾</li></ul></li><li>输出进程请求输出数据<ul><li>从 输出队列 队头取下一块缓冲区作为 提取输出数据的工作缓冲区(sout),缓冲区读空后挂到空缓冲队列 队尾</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第五章 设备管理-5.1 IO管理概述</title>
    <link href="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-1-IO%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-1-IO%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="io管理概述"><strong>5.1 I/O管理概述</strong></h1><h3 id="io设备的概念和分类"><strong>1. IO设备的概念和分类</strong></h3><h3 id="什么是io设备">1.1 <strong>什么是I/O设备?</strong></h3><ul><li><p>"<strong>I/O</strong>"就是"<strong>输入/输出</strong>"(Input/Output)</p></li><li><p>I/O设备就是可以将数据输入到计算机,或者可以接收计算机输出数据的外部设备, 属于计算机中的硬件部件</p><ul><li>鼠标、键盘 -- 典型的输入型设备</li><li>显示器 -- 输出型设备</li><li>移动硬盘 -- 既可输入、又可输出的设备</li></ul></li><li><p>UNIX系统将外部设备抽象为一种特殊的文件,用户可以使用与文件系统相同的方式对外部设备进行操作</p><ul><li>Write操作: 向外部设备写出数据</li><li>Read操作: 从外部设备读入数据</li></ul></li></ul><h3 id="io设备的分类">1.2 <strong>I/O设备的分类</strong></h3><ul><li><strong>按使用特性分类</strong><ul><li>人机交互类外部设备: 数据传输速度慢<ul><li>鼠标、键盘、打印机等 -- 用于人机交互</li></ul></li><li>存储设备: 数据传输速度快<ul><li>移动硬盘、光盘等 -- 用于数据存储</li></ul></li><li>网络通信设备: 数据传输速度介于上述二者之间<ul><li>调制解调器等 -- 用于网络通信</li></ul></li></ul></li><li><strong>按传输速率分类</strong><ul><li>低速设备<ul><li>鼠标、键盘等 -- 传输速率为每秒几个到几百字节</li></ul></li><li>中速设备<ul><li>激光打印机等 -- 传输速率为每秒数千至上万个字节</li></ul></li><li>高速设备<ul><li>磁盘等 -- 传输速率为每秒数千字节至千兆字节的设备</li></ul></li></ul></li><li><strong>按信息交换的单位分类</strong><ul><li><strong>块设备</strong>: 传输速率较高, 可寻址,即对它可随机地读/写任一块<ul><li>磁盘等 -- <strong>数据传输的基本单位是"块"</strong></li></ul></li><li><strong>字符设备</strong>: 传输速率较慢, 不可寻址,在输入/输出时常采用<strong>中断驱动方式</strong><ul><li>鼠标、键盘等 -- <strong>数据传输的基本单位是字符</strong></li><li>中断驱动方式: 一种I/O控制方式</li></ul></li></ul></li></ul><h2 id="io控制器"><strong>2. IO控制器</strong></h2><h3 id="io设备的组成">2.1 <strong>I/O设备的组成</strong></h3><ul><li><strong>机械部件</strong><ul><li>I/O设备的机械部件主要用来执行具体I/O操作</li><li>如我们看得见摸得着的鼠标/键盘的按钮; 显示器的LED屏;移动硬盘的磁臂、磁盘盘面</li></ul></li><li><strong>电子部件</strong>(I/O控制器, 又称设备控制器)<ul><li>I/O设备的电子部件通常是一块插入主板扩充槽的印刷电路板</li></ul></li></ul><h3 id="io控制器的主要功能">2.2<strong>I/O控制器的主要功能</strong></h3><ul><li><p>CPU无法直接控制I/O设备的机械部件,因此I/O设备还要有一个电子部件作为CPU和I/O设备部件之间的"中介",<strong>用于实现CPU对设备的控制</strong></p></li><li><p>这个电子部件就是<strong>I/O控制器</strong>, CPU可控制I/O控制器,又由I/O控制器来控制设备的机械部件</p></li><li><p><strong>主要功能</strong>:</p><ul><li>接受和识别CPU发出的命令<ul><li>如CPU发来的read/write命令,I/O控制器中会有相应的<strong>控制寄存器</strong>来存放命令和参数</li></ul></li><li>向CPU报告设备的状态<ul><li>I/O控制器中会有相应的<strong>状态寄存器</strong>用于记录I/O设备的当前状态</li><li>如: 1表示空闲, 0表示忙碌</li></ul></li><li>数据交换<ul><li>I/O控制器中会设置相应的<strong>数据寄存器</strong>。输出时,数据寄存器用于暂存CPU发来的数据, 之后再由控制器传送设备; 输入时,数据寄存器用于暂存设备发来的数据, 之后CPU从数据寄存器中取走数据</li></ul></li><li>地址识别<ul><li>类似于内存的地址, 为了区分设备控制器中的各个寄存器,也需要给各个寄存器设置一个特定的"地址"。I/O控制器通过CPU提供的"地址"来判断CPU要读/写的是哪个寄存器</li></ul></li></ul></li></ul><h3 id="io控制器的组成">2.3 <strong>I/O控制器的组成</strong></h3><ul><li>值得注意的小细节:<ul><li>一个I/O控制器可能会对应多个设备</li><li>数据寄存器、控制寄存器、状态寄存器可能有多个(如:每个控制/状态寄存器对应一个具体的设备), 且这些寄存器都要有相应的地址,才能方便CPU操作。有的计算机会让这些寄存器占用内存地址的一部分,称为<strong>内存映像I/O</strong>; 另一些计算机则采用I/O专用地址,即<strong>寄存器独立编址</strong></li></ul></li></ul><h3 id="两种寄存器编址方式">2.4 <strong>两种寄存器编址方式</strong></h3><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-1-IO%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0/image-20241121222917201.png"></p><h2 id="io控制方式"><strong>3. IO控制方式</strong></h2><ul><li>需要注意的问题:<ul><li>完成一次读/写操作的流程</li><li>CPU干预的频率</li><li>数据传送的单位</li><li>数据的流向</li><li>主要缺点和主要优点</li></ul></li></ul><h3 id="程序直接控制方式">3.1 <strong>程序直接控制方式</strong></h3><ul><li><p>完成一次读/写操作的流程(以读操作为例):</p><ul><li><p>CPU通过控制线向控制器发出读指令, 于是设备启动,并且状态寄存器设为1(未就绪)</p></li><li><p><strong>轮询</strong>检查控制器的状态(其实就是在不断地执行程序的循环,若状态位一直是1, 说明设备还没准备好要输入的数据,于是CPU会不断地轮询)</p></li><li><p>输入设备准备好数据后将数据传给控制器, 并报告自身状态</p></li><li><p>控制器将输入的数据放到数据寄存器中,并将状态改为0(已就绪)</p></li><li><p>CPU发现设备已就绪, 即可将数据寄存器中的内容读入CPU的寄存器中,再把CPU寄存器中的内容放入内存</p></li><li><p>若还要继续读入数据, 则CPU继续发出读指令</p></li></ul></li><li><p>CPU干预的频率</p><ul><li>很频繁, I/O操作开始之前、完成之后需要CPU的介入,并且在等待I/O完成的过程中CPU需要不断地轮询检查</li></ul></li><li><p>数据传送的单元</p><ul><li>每次读/写一个<strong>字</strong></li></ul></li><li><p>数据的流向</p><ul><li><p>读操作(数据输入): I/O设备 → CPU(指的是CPU的寄存器) →内存</p></li><li><p>写操作(数据输出): 内存 → CPU → I/O设备</p></li><li><p>每个字的读/写都需要CPU的帮助</p></li></ul></li><li><p>主要缺点和主要优点</p><ul><li><p>优点: 实现简单。在读/写指令之后,加上实现循环检查的一系列指令即可(因此才称为"<strong>程序直接控制方式</strong>")</p></li><li><p>缺点: CPU和I/O设备只能串行工作, CPU需要一直轮询检查,长期处于"忙等"状态, CPU利用率低</p></li></ul></li></ul><h3 id="中断驱动方式">3.2 <strong>中断驱动方式</strong></h3><ul><li><p>完成一次读/写操作的流程(以读操作为例):</p><ul><li><p>引入<strong>中断</strong>机制。由于I/O设备速度很慢,因此在CPU发出读/写命令后, 可将等待I/O的进程阻塞,先切换到别的进程执行</p></li><li><p>当I/O完成后, 控制器会向CPU发出一个中断信号, CPU检测到中断信号后,会保存当前进程的运行环境信息, 转去执行中断处理程序处理该中断</p></li><li><p>处理中断的过程中, CPU从I/O控制器读一个字的数据传送到CPU寄存器,再写入主存</p></li><li><p>接着, CPU恢复等待I/O的进程(或其他进程)的运行环境,然后继续执行</p></li></ul></li><li><p>注意:</p><ul><li><p>CPU会在每个指令周期的末尾检查中断</p></li><li><p>中断处理过程中需要保存、恢复进程的运行环境,这个过程是需要一定时间开销的。可见, 如果中断发生的频率太高,也会降低系统性能</p></li></ul></li><li><p>CPU干预的频率</p><ul><li><p>每次I/O操作开始之前、完成之后需要CPU的介入</p></li><li><p>等待I/O完成的过程中CPU可以切换到别的进程执行</p></li></ul></li><li><p>数据传送的单元</p><ul><li>每次读/写一个<strong>字</strong></li></ul></li><li><p>数据的流向</p><ul><li><p>读操作(数据输入): I/O设备 → CPU(指的是CPU的寄存器) →内存</p></li><li><p>写操作(数据输出): 内存 → CPU → I/O设备</p></li></ul></li><li><p>主要缺点和主要优点</p><ul><li><p>优点: 与"程序直接控制方式"相比, 在"中断驱动方式"中,I/O控制器会通过中断信号主动报告I/O已完成,CPU不再需要不停地轮询。CPU和I/O设备可并行工作,CPU利用率得到明显提升</p></li><li><p>缺点: 每个字在I/O设备与内存之间的传输, 都需要经过CPU,而频繁的中断处理会消耗较多的CPU时间</p></li></ul></li></ul><h3 id="dma方式direct-memory-access-直接存储器存取">3.3<strong>DMA方式(Direct Memory Access, 直接存储器存取)</strong></h3><ul><li><p>完成一次读/写操作的流程(以读操作为例):</p><ul><li><p>与"中断驱动方式相比",<strong>DMA方式</strong>(主要用于块设备的I/O控制)有这样几个改进:</p><ul><li><p>数据的传送单位是"块", 不再是一个字、一个字的传送</p></li><li><p>数据的流向是从设备直接放入内存, 或者从内存直接到设备,不再需要CPU作为"快递小哥"</p></li><li><p>仅在传送一个或多个数据块的开始和结束时, 才需要CPU干预</p></li></ul></li></ul></li><li><p>CPU干预的频率</p><ul><li>仅在传送一个或多个数据块的开始和结束时, 才需要CPU干预</li></ul></li><li><p>数据传送的单元</p><ul><li><p>每次读/写一个或多个<strong>块</strong></p><ul><li>注意: 每次读写的只能是连续的多个块,且这些块读入内存后在内存中也必须是连续的</li></ul></li></ul></li><li><p>数据的流向(不再需要经过CPU)</p><ul><li><p>读操作(数据输入): I/O设备 → 内存</p></li><li><p>写操作(数据输出): 内存 → I/O设备</p></li></ul></li><li><p>主要缺点和主要优点</p><ul><li><p>优点: 数据传输以"块"为单位,CPU介入频率进一步降低。数据的传输不再需要先经过CPU再写入内存,数据传输效率进一步增加, CPU和I/O设备的并行性得到提升</p></li><li><p>缺点: CPU每发出一条I/O指令,只能读/写一个或多个连续的数据块。如果要读/写多个离散存储的数据块,或者要将数据分别写到不同的内存区域时, CPU要分别发出多条I/O指令,进行多次中断处理才能完成</p></li></ul></li></ul><h3 id="通道控制方式">3.4 <strong>通道控制方式</strong></h3><ul><li><strong>通道</strong>: 一种硬件, 可以理解为是"弱鸡版的CPU",通道可以识别并执行一系列<strong>通道指令</strong><ul><li><p>与CPU相比, 通道可以执行的指令很单一,并且通道程序是放在主机内存中的, 也就是说通道与CPU共享内存</p></li><li><p>一个通道可以控制多个I/O控制器,一个I/O控制器可以控制多个I/O设备</p></li></ul></li><li>完成一次读/写操作的流程(以读操作为例):</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-1-IO%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0/image-20241122102849425.png"></p><ul><li>CPU干预的频率<ul><li>极低, 通道会根据CPU的指示执行相应的通道程序,只有完成一组数据库的读/写后才需要发出中断信号, 请求CPU干预</li></ul></li><li>数据传送的单元<ul><li>每次读/写<strong>一组数据块</strong></li></ul></li><li>数据的流向(在通道的控制下进行)<ul><li>读操作(数据输入): I/O设备 → 内存</li><li>写操作(数据输出): 内存 → I/O设备</li></ul></li><li>主要缺点和主要优点<ul><li>优点: CPU、通道、I/O设备可并行工作, 资源利用率很高</li><li>缺点: 实现复杂, 需要专门的通道硬件支持</li></ul></li></ul><h2 id="io软件层次结构"><strong>4. IO软件层次结构</strong></h2><h3 id="用户层软件">4.1 <strong>用户层软件</strong></h3><ul><li><p>用户层软件实现了与用户交互的接口,用户可直接使用该层提供的、与I/O操作相关的<strong>库函数</strong>对设备进行操作</p><ul><li>Eg: printf("hello, world!");</li></ul></li><li><p>用户层软件将用户请求翻译成格式化的I/O请求,并通过"系统调用"请求操作系统内核的服务</p><ul><li>Eg: printf("hello world!"); 会被翻译成等价的write系统调用, 当然,用户层软件也会在系统调用时填入相应参数</li></ul></li><li><p>Windows操作系统向外提供了一系列系统调用,但是由于系统调用的格式严格, 使用麻烦,因此在用户层上封装了一系列更方便的库函数接口供用户使用(<strong>WIndowsAPI</strong>)</p></li></ul><h3 id="设备独立性软件设备无关性软件">4.2<strong>设备独立性软件(设备无关性软件)</strong></h3><ul><li><p>与设备的硬件特性无关的功能几乎都在这一层实现</p></li><li><p>主要实现功能:</p><ul><li>向上层提供统一的调用接口(如 read/write<strong>系统调用</strong>)</li><li>设备的保护<ul><li>原理类似于文件保护, <strong>设备被看做是一种特殊的文件</strong>,不同用户对各个文件的访问权限是不一样的, 同理,对设备的访问权限也不一样</li></ul></li><li>差错处理<ul><li>设备独立性软件需要对一些设备的错误进行处理</li></ul></li><li>设备的分配与回收</li><li>数据缓冲区管理<ul><li>可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异</li></ul></li><li><strong>建立逻辑设备名到物理设备名的映射关系</strong>;根据设备类型选择调用相应的<strong>驱动程序</strong><ul><li>用户或用户层软件发出I/O操作相关的系统调用时,需要指明这次要操作的I/O设备的<strong>逻辑设备名</strong><ul><li>Eg: 去学校打印店打印时, 需要选择打印机1/打印机2/打印机3,其实这些都是逻辑设备名</li></ul></li><li><strong>设备独立性软件</strong>需要通过"<strong>逻辑设备表(LUT,Logical UnitTable)</strong>"来确定<strong>逻辑设备</strong>对应的<strong>物理设备</strong>,并找到该设备对应的<strong>设备驱动程序</strong></li><li>操作系统可以采用两种方式管理<strong>逻辑设备表(LUT)</strong>:<ul><li>第一种方式, <strong>整个系统只设置一张LUT</strong>,这就意味着所有用户不能使用相同的逻辑设备名,因此这种方式<strong>只适用于单用户操作系统</strong></li><li>第二种方式, <strong>为每个用户设置一张LUT</strong>,各个用户使用的逻辑设备名可以重复, <strong>适用于多用户操作系统</strong>,系统会在用户登录时为其建立一个用户管理进程,而LUT就存放在用户管理进程的PCB中</li></ul></li><li><strong>为什么不同类型的I/O设备需要有不同的驱动程序处理?</strong><ul><li>各式各样的设备, 外形不同, 其内部的电子部件(I/O控制器)也有可能不同<ul><li>如状态寄存器判断是否忙碌的标志位不同, 有的设备用1表示忙碌,而有的用0表示忙碌</li></ul></li><li>不同设备的内部硬件特性也不同, 这些特性只有厂家才知道,因此厂家须提供与设备相对应的驱动程序, CPU执行驱动程序的指令序列,来完成设置设备寄存器、检查设备状态等工作</li></ul></li></ul></li></ul></li></ul><h3 id="设备驱动程序">4.3 <strong>设备驱动程序</strong></h3><ul><li>主要负责<strong>对硬件设备的具体控制</strong>,将上层发出的一系列命令(如read/write)转化为特定设备"能听得懂"的一系列操作,包括设置设备寄存器、检查设备状态等<ul><li>注: 驱动程序一般会以一个独立进程的方式存在</li></ul></li></ul><h3 id="中断处理程序">4.4 <strong>中断处理程序</strong></h3><ul><li><p>当I/O任务完成时, I/O控制器会发送一个<strong>中断信号</strong>,系统会根据<strong>中断信号类型</strong>找到相应的<strong>中断处理程序</strong>并执行</p></li><li><p>中断处理程序的处理流程如下:</p></li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-1-IO%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0/image-20241122103237525.png"></p><ul><li>可见, <strong>中断处理程序也会和硬件直接打交道</strong></li></ul><h3 id="输入输出应用程序接口驱动程序接口"><strong>5.输入/输出应用程序接口&amp;驱动程序接口</strong></h3><h3 id="输入输出应用程序接口">5.1<strong>输入/输出应用程序接口</strong></h3><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-1-IO%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0/image-20241122103326548.png"></p><ul><li>网络设备接口示例:</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-1-IO%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0/image-20241122103351593.png"></p><h3 id="阻塞非阻塞-io">5.2 <strong>阻塞/非阻塞 I/O</strong></h3><ul><li><strong>阻塞I/O</strong>: 应用程序发出I/O系统调用,<strong>进程需转为阻塞态等待</strong><ul><li>Eg: 字符设备接口 -- 从键盘读一个字符(get系统调用)</li></ul></li><li><strong>非阻塞I/O</strong>: 应用程序发出I/O系统调用,系统调用可迅速返回, <strong>进程无需阻塞等待</strong><ul><li>Eg: 块设备接口 -- 往磁盘写数据(write系统调用)</li></ul></li></ul><h3 id="设备驱动程序接口">5.3 <strong>设备驱动程序接口</strong></h3><ul><li><p>若各公司开发的设备驱动程序接口不统一,则操作系统很难调用设备驱动程序</p></li><li><p><strong>统一标准的设备驱动程序接口</strong></p><ul><li>操作系统规定好设备驱动程序的接口标准,各厂商按要求开发设备驱动程序</li><li>不同的操作系统, 对设备驱动程序接口的标准各不相同,设备厂商必须根据操作系统的接口要求,开发相应的设备驱动程序,设备才能被使用</li></ul></li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-1-IO%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0/image-20241122103448322.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.2 文件系统</title>
    <link href="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="文件系统的结构与虚拟文件系统"><strong>4.2文件系统的结构与虚拟文件系统</strong></h1><h2 id="文件系统的层次结构了解即可"><strong>1.文件系统的层次结构(了解即可)</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20241121221253104.png"></p><ul><li>用一个例子来辅助记忆文件系统的层次结构：<ul><li>假设某用户请求删除文件“D:/工作目录/学生信息.xIsx"的最后100条记录<ul><li>1. 用户需要通过操作系统提供的接口发出上述请求 --<strong>用户接口</strong><ul><li>文件的基本操作 章节相关内容</li></ul></li><li>2.由于用户提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项-- <strong>文件目录系统</strong><ul><li>文件目录 章节相关内容</li></ul></li><li>3.不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限--<strong>存取控制模块(存取控制验证层)</strong><ul><li>文件保护 章节相关内容</li></ul></li><li>4.验证了用户的访问权限之后，需要把用户提供的“记录号”转变为对应的逻辑地址-- <strong>逻辑文件系统与文件信息缓冲区</strong><ul><li>文件的逻辑结构 章节相关内容</li></ul></li><li>5. 知道了目标记录对应的逻辑地址后，还需要转换成实际的物理地址 --<strong>物理文件系统</strong><ul><li>文件的物理结构 章节相关内容</li></ul></li><li>6. 要删除这条记录，必定要对磁盘设备发出请求 --<strong>设备管理程序模块</strong><ul><li>设备管理 章节相关内容</li></ul></li><li>7. 删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收 --<strong>辅助分配模块</strong><ul><li>文件存储空间管理 章节相关内容</li></ul></li></ul></li></ul></li></ul><h2 id="文件系统的全局结构布局"><strong>2.文件系统的全局结构(布局)</strong></h2><h3 id="磁盘出厂到文件系统建立的过程">2.1<strong>磁盘出厂到文件系统建立的过程</strong>:</h3><p>1. <strong>原始磁盘</strong></p><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20241121221040188.png"></p><p>2. <strong>低级格式化(物理格式化)</strong></p><ul><li>划分扇区，检测坏扇区，并用备用扇区替换坏扇区</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20241121221355176.png"></p><p>3. <strong>磁盘分区(分卷，Volume)</strong></p><ul><li>将磁盘分区, 每个分区由若干柱面组成(即分为我们熟悉的C盘、D盘、E盘)</li></ul><p>4. <strong>逻辑格式化</strong></p><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20241121221453868.png"></p><ul><li><p>完成各分区的文件系统初始化</p></li><li><p>i结点区 ：索引结点存放区域</p></li><li><p>注：逻辑格式化后，灰色部分就有实际数据了，白色部分还没有数据</p></li></ul><h3 id="文件系统在内存中的结构">2.2<strong>文件系统在内存中的结构</strong></h3><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20241121221632779.png"></p><h3 id="open-系统调用打开文件背后的过程">2.3 <strong>open系统调用打开文件背后的过程</strong></h3><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20241121221732613.png"></p><h2 id="虚拟文件系统文件系统挂载安装"><strong>3.虚拟文件系统&amp;文件系统挂载(安装)</strong></h2><h3 id="普通的文件系统">3.1 <strong>普通的文件系统</strong></h3><ul><li>不同的存储设备中的文件系统有可能是不同的，提供的系统调用接口也不同</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20241121221942018.png"></p><h3 id="虚拟文件系统vfs">3.2 <strong>虚拟文件系统（VFS）</strong></h3><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20241121222033809.png"></p><ul><li><p><strong>虚拟文件系统的特点</strong>:</p><ul><li>向上层用户进程提供统一标准的系统调用接口，屏蔽底层具体文件系统的实现差异</li><li><strong>VFS</strong>要求下层的文件系统必须实现某些规定的函数功能，一个新的文件系统想要在某操作系统上被使用，就必须满足该操作系统VFS的要求<ul><li>如：open/read/write</li></ul></li><li>每打开一个文件，<strong>VFS</strong>就在主存中新建一个<strong>vnode</strong>，用统一的数据结构表示文件，无论该文件存储在哪个文件系统</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20241121222254313.png"></p><ul><li><p>存在的问题：不同的文件系统，表示文件数据结构各不相同。打开文件后，其在内存中的表示就不同</p><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20241121222313706.png"></p><ul><li>注意：<strong>vnode</strong>只存在于主存中，而<strong>inode</strong>既会被调入主存，也会在外存中存储</li></ul></li><li><p>打开文件后，创建<strong>vnode</strong>，并将文件信息复制到vnode中，vnode的功能指针指向具体文件系统的函数功能</p></li></ul></li></ul><h3 id="文件系统挂载mounting">3.3<strong>文件系统挂载（mounting）</strong></h3><ul><li>即文件系统安装/装载 -- 如何将一个文件系统挂载到操作系统中？<ul><li>文件系统挂载要做的事:<ul><li>在<strong>VFS</strong>中注册新挂载的文件系统，<strong>内存中的挂载表（mountingtable）</strong>包含每个文件系统的相关信息，包含文件系统类型、容量大小等</li><li>新挂载的文件系统，要向<strong>VFS</strong>提供一个<strong>函数地址列表</strong></li><li>将新文件系统加到<strong>挂载点</strong>（mountpoint），也就是将新文件系统挂载在某个父目录下</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第四章 文件管理-4.1 文件系统基础</title>
    <link href="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-1-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-1-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="文件系统"><strong>4.1 文件系统</strong></h1><h2 id="初始文件管理"><strong>1. 初始文件管理</strong></h2><ul><li><strong>文件</strong>：<strong>一组有意义的信息/数据集合</strong></li></ul><h3 id="文件管理">1.1 <strong>文件管理</strong></h3><ul><li><p>计算机中存放了各种各样的文件，一个<strong>文件有哪些属性</strong>？</p></li><li><p><strong>文件内部的数据应该怎样组织起来</strong>？</p></li><li><p><strong>文件之间又应该又应该怎么组织起来</strong>？</p></li><li><p>计算机系统的层次结构从下往上看，<strong>OS应提供哪些功能，才能方便用户、应用程序使用文件</strong>？</p></li><li><p>计算机系统的层次结构从上往下看，<strong>文件数据应该怎么存放在外存（磁盘）上</strong>？</p></li><li><p><strong>如何实现文件的共享和保护</strong></p></li></ul><h3 id="文件的属性">1.2 <strong>文件的属性</strong></h3><ul><li><p><strong>文件名</strong></p><ul><li>由创建文件的用户决定文件名，主要是为了方便用户找到文件，<strong>同一目录下不允许有重名文件</strong></li></ul></li><li><p><strong>标识符</strong></p><ul><li>一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称</li></ul></li><li><p><strong>类型</strong></p><ul><li>指明文件的类型位置：文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，对用户不可见）</li></ul></li><li><p><strong>大小</strong></p><ul><li>指明文件大小</li></ul></li><li><p><strong>创建时间</strong>、<strong>上次修改时间</strong></p></li><li><p><strong>文件所有者信息</strong></p></li><li><p><strong>保护信息</strong></p><ul><li>对文件进行保护的访问控制信息</li></ul></li></ul><h3 id="文件内部的数据应该怎样组织起来">1.3<strong>文件内部的数据应该怎样组织起来？</strong></h3><ul><li><strong>无结构文件</strong>（如文本文件）--由一些二进制或字符流组成，又称“<strong>流式文件</strong>”</li><li><strong>有结构文件</strong>（如数据库表）--由一组相似的<strong>记录</strong>组成，又称“<strong>记录式文件</strong>”<ul><li><strong>记录</strong>是一组相关<strong>数据项</strong>的集合<ul><li><strong>数据项</strong>是文件系统中最基本的数据单位</li></ul></li><li><strong>有结构文件</strong>中，<strong>各个记录间应该如何组织</strong>的问题<ul><li>应该顺序存放？还是用索引表来表示记录间的顺序？--这是“<strong>文件的逻辑结构</strong>”重点要探讨的问题</li></ul></li></ul></li></ul><h3 id="文件之间应该怎样组织起来">1.4<strong>文件之间应该怎样组织起来？</strong></h3><ul><li>用户可以自己创建一层一层的<strong>目录</strong>，各层目录中存放相应的<strong>文件</strong>。<strong>系统中的各个文件就通过一层一层的目录合理有序的组织起来了</strong><ul><li>所谓的“<strong>目录</strong>”其实就是我们熟悉的“<strong>文件夹</strong>”</li><li><strong>目录</strong>其实也<strong>是一种特殊的有结构文件（由记录组成）</strong>，如何实现<strong>文件目录</strong>是之后会重点探讨的问题</li></ul></li></ul><h3 id="操作系统应该向上提供哪些功能">1.5<strong>操作系统应该向上提供哪些功能？</strong></h3><ul><li><p>可以“<strong>创建文件</strong>”（点击新建后，图形化交互进程在背后调用了“<strong>create系统调用</strong>”）</p></li><li><p>可以<strong>“删除文件</strong>”（点击删除后，图形化交互进程在背后调用了"<strong>delete系统调用</strong>"，将文件数据从外存中删除）</p></li><li><p>可以“<strong>读文件</strong>”，将文件数据读入内存，才能让CPU处理（双击后，“记事本”应用程序通过操作系统提供的“<strong>read系统调用</strong>”，将文件数据从外存读入内存，并显示在屏幕上）</p></li><li><p>可以“<strong>写文件</strong>”，将更改过的文件数据写回外存（在“记事本”应用程序中编辑文件内容，点击“保存”后，“记事本”应用程序通过操作系统提供的“<strong>write系统调用</strong>”，将文件数据从内存写回外存）</p></li><li><p>读/写文件之前，需要通过操作系统提供的"<strong>open系统调用</strong>"来“<strong>打开文件</strong>”</p></li><li><p>读/写文件结束之后，需要通过操作系统提供的"<strong>close系统调用</strong>"来“<strong>关闭文件</strong>”</p></li><li><p>可用几个基本操作完成更复杂的操作</p><ul><li>比如：“复制文件”：先创建一个新的空文件，再把源文件读入内存，再将内存中的数据写到新文件中</li></ul></li></ul><h3 id="从上往下看文件应如何存放在外存">1.6<strong>从上往下看，文件应如何存放在外存？</strong></h3><ul><li><strong>外存的结构</strong><ul><li>与内存一样，<strong>外存</strong>也是由一个个<strong>存储单元</strong>组成的，每个存储单元可以存储一定量的数据（如1B）<ul><li><strong>每个存储单元对应一个物理地址</strong></li></ul></li><li>类似于内存分为一个个“内存块”，<strong>外存</strong>会分为一个个“<strong>块/磁盘块/物理块</strong>”。<strong>每个磁盘块的大小是相等的，每块一般包含2的整数幂个地址</strong>（如本例中，一块包含2<sup>10</sup> 个地址，即1KB）。同样类似的是，<strong>文件的逻辑地址</strong>也可以分为<strong>（逻辑块号，块内地址）</strong>，操作系统同样需要将<strong>逻辑地址转换为外存的物理地址（物理块号，块内地址）</strong>的形式。<strong>块内地址的位数取决于磁盘块的大小</strong></li><li><strong>操作系统以“块”为单位为文件分配存储空间</strong>，因此即使一个文件大小只有10B，但它依然需要占用1KB 的磁盘块。<strong>外存中的数据读入内存时同样以块为单位</strong></li></ul></li><li><strong>文件应如何存放在外存？</strong><ul><li>文件数据放在连续的几个磁盘块中？</li><li>文件数据放在离散的几个磁盘块中？此时，应该如何记录各个磁盘块之间的先后顺序呢？</li><li>操作系统又应该怎么管理空闲磁盘块？</li><li>这些都是“<strong>文件的物理结构</strong>”部分会探讨的内容</li></ul></li></ul><h3 id="其他需要由操作系统实现的文件管理功能">1.7<strong>其他需要由操作系统实现的文件管理功能</strong></h3><ul><li><strong>文件共享</strong>：使多个用户可以共享使用一个文件</li><li><strong>文件保护</strong>：如何保证不同的用户对文件有不同的操作权限</li></ul><h2 id="文件的逻辑结构"><strong>2. 文件的逻辑结构</strong></h2><ul><li><p>“<strong>逻辑结构</strong>”：就是指在用户看来，文件内部的数据应该是如何组织起来的</p></li><li><p>“<strong>物理结构</strong>”：指的是在操作系统看来，文件的数据是如何存放在外存中的</p><ul><li>类似于数据结构的“逻辑结构”和“物理结构”</li><li>如“线性表”就是一种逻辑结构，在用户角度看来，线性表就是一组有先后关系的元素序列，如：a,b, c, d, e ……</li><li>“线性表”这种逻辑结构可以用不同的物理结构实现，如：顺序表/链表。顺序表的各个元素在逻辑上相邻，在物理上也相邻；而链表的各个元素在物理上可以是不相邻的。因此，顺序表可以实现“随机访问”，而“链表”无法实现随机访问</li><li>可见，算法的具体实现与逻辑结构、物理结构都有关（文件也一样，文件操作的具体实现与文件的逻辑结构、物理结构都有关）</li></ul></li><li><p>按文件是否有结构分类，可以分为<strong>无结构文件</strong>、<strong>有结构文件</strong>两种</p></li></ul><h3 id="无结构文件">2.1 <strong>无结构文件</strong></h3><ul><li><p><strong>文件内部的数据就是一系列二进制流或字符流组成</strong>。又称“<strong>流式文件</strong>”</p></li><li><p>如：Windows 操作系统中的 .txt文件，文件内部的数据其实就是一系列字符流，没有明显的结构特性。因此也不用探讨无结构文件的“逻辑结构”问题</p></li></ul><h3 id="有结构文件">2.2 <strong>有结构文件</strong></h3><ul><li><p><strong>由一组相似的记录组成</strong>，又称“<strong>记录式文件</strong>”。每条<strong>记录</strong>又若干个<strong>数据项</strong>组成</p><ul><li>如：数据库表文件</li></ul></li><li><p>一般来说，每条<strong>记录</strong>有一个<strong>数据项</strong>可作为<strong>关键字</strong>（作为识别不同记录的ID）</p></li><li><p>根据各条记录的长度（占用的存储空间）是否相等，又可分为<strong>定长记录</strong>和<strong>可变长记录</strong>两种</p></li><li><p><strong>有结构文件的逻辑结构</strong>：根据有结构文件中的各条记录在逻辑上如何组织，可以分为三类</p><ul><li><strong>顺序文件</strong></li><li><strong>索引文件</strong></li><li><strong>索引顺序文件</strong></li></ul></li></ul><h3 id="顺序文件">2.3 <strong>顺序文件</strong></h3><ul><li><p><strong>文件中的记录一个接一个地顺序排列（逻辑上）</strong>，<strong>记录</strong>可以是<strong>定长</strong>的或<strong>可变长</strong>的。各个记录在<strong>物理上</strong>可以<strong>顺序存储</strong>或<strong>链式存储</strong></p><ul><li><strong>顺序存储</strong>：逻辑上相邻的记录物理上也相邻（类似于顺序表）</li><li><strong>链式存储</strong>：逻辑上相邻的记录物理上不一定相邻（类似于链表）</li></ul></li><li><p><strong>顺序文件</strong>还可按<strong>记录之间的关键字顺序</strong>分为：</p><ul><li><strong>串结构</strong>：记录之间的顺序与关键字无关（通常按照记录存入的时间决定记录的顺序）</li><li><strong>顺序结构</strong>：记录之间的顺序按关键字顺序排列</li></ul></li><li><p><strong>思考</strong>:</p><ul><li><p>假设：已经知道了文件的起始地址（也就是第一个记录存放的位置）</p><ul><li>思考1：能否快速找到第 i个记录对应的地址？（即能否实现随机存取）</li><li>思考2：能否快速找到某个关键字对应的记录存放的位置？</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-1-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20241121201519877.png"></p></li><li><p><strong>结论</strong>：定长记录的顺序文件，若物理上采用顺序存储，则可实现随机存取；若能再保证记录的顺序结构，则可实现快速检索（即根据关键字快速找到对应记录）</p><ul><li>注：一般来说，考试题目中所说的“顺序文件”指的是<strong>物理上顺序存储的顺序文件</strong>。之后的讲解中提到的顺序文件也默认如此。可见，顺序文件的<strong>缺点</strong>是<strong>增加/删除一个记录比较困难</strong>（如果是串结构则相对简单）</li></ul></li></ul></li></ul><h3 id="索引文件">2.4 <strong>索引文件</strong></h3><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-1-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20241121201802502.png"></p><ul><li><p>对于可变长记录文件，要找到第 i 个记录，必须先顺序第查找前 i-1个记录，但是很多应用场景中又必须使用可变长记录。如何解决这个问题？</p></li><li><p><strong>索引表</strong>本身是<strong>定长记录的顺序文件</strong>。因此可以快速找到第i 个记录对应的索引项</p></li><li><p>可将<strong>关键字作为索引号内容</strong>，若按关键字顺序排列，则还可以支持按照关键字折半查找</p></li><li><p>每当要增加/删除一个记录时，需要对索引表进行修改。由于索引文件有很快的检索速度，因此主要<strong>用于对信息处理的及时性要求比较高的场合</strong></p></li><li><p>另外，可以用不同的数据项建立多个索引表</p><ul><li>如：学生信息表中，可用关键字“学号”建立一张索引表。也可用“姓名”建立一张索引表。这样就可以根据“姓名”快速地检索文件了</li><li>Eg：SQL 就支持根据某个数据项建立索引的功能</li></ul></li></ul><h3 id="索引顺序文件">2.5 <strong>索引顺序文件</strong></h3><ul><li><p>思考<strong>索引文件</strong>的缺点：每个记录对应一个索引表项，因此索引表可能会很大</p><ul><li>比如：文件的每个记录平均只占8B，而每个索引表项占32个字节，那么索引表都要比文件内容本身大4倍，这样对存储空间的利用率就太低了</li></ul></li><li><p><strong>索引顺序文件</strong>是索引文件和顺序文件思想的结合</p></li><li><p>索引顺序文件中，同样会为文件建立一张<strong>索引表</strong>，但不同的是：<strong>并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项</strong></p><ul><li>在本例中，学生记录按照学生姓名的开头字母进行分组。<strong>每个分组就是一个顺序文件，分组内的记录不需要按关键字排序</strong></li><li>用这种策略确实可以让索引表“瘦身”，但是是否会出现不定长记录的顺序文件检索速度慢的问题呢？<ul><li>若一个顺序文件有10000个记录，则根据关键字检索文件，只能从头开始顺序查找（这里指的并不是定长记录、顺序结构的顺序文件），平均须查找5000 个记录</li><li>若采用索引顺序文件结构，可把 10000 个记录分为 √10000 = 100 组，每组100个记录。则需要先顺序查找索引表找到分组（共100个分组，因此索引表长度为100，平均需要查50 次），找到分组后，再在分组中顺序查找记录（每个分组100个记录，因此平均需要查50次）。可见，采用索引顺序文件结构后，平均查找次数减少为 50 + 50 = 100次</li><li>同理，若文件共有 10<sup>6</sup>个记录，则可分为 1000个分组，每个分组 1000 个记录。根据关键字检索一个记录</li><li>平均需要查找 500 + 500 = 1000次。这个查找次数依然很多，如何解决呢？</li></ul></li></ul></li><li><p><strong>多级索引顺序文件</strong></p><ul><li>为了进一步提高检索效率，可以为顺序文件建立<strong>多级索引表</strong>。例如，对于一个含10<sup>6</sup>个记录的文件，可先为该文件建立一张低级索引表，每 100个记录为一组，故低级索引表中共有10000个表项（即10000个定长记录），再把这 10000个定长记录分组，每组100个，为其建立顶级索引表，故顶级索引表中共有 100个表项</li></ul></li></ul><h2 id="文件目录"><strong>3. 文件目录</strong></h2><ul><li><p>所谓<strong>文件目录</strong>就是我们很熟悉的 Windows操作系统的“文件夹”</p></li><li><p>采用文件目录结构可以使文件之间的组织结构清晰，易于查找</p></li><li><p>编程时也可以很方便的用文件路径找到一个文件</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 如:</span><br>FILE *fp;<br>fp = fopen(“F:\data\myfile.dat”); <span class="hljs-comment">// 用户可以轻松实现“按名存取”</span><br></code></pre></td></tr></table></figure><h3 id="文件目录的实现">3.1 <strong>文件目录的实现</strong></h3><ul><li><p>当我们双击“照片”后，操作系统会在这个<strong>目录表</strong>中找到关键字“照片”对应的<strong>目录项</strong>（也就是<strong>记录</strong>），然后从外存中将“照片”目录的信息读入内存，于是，“照片”目录中的内容就可以显示出来了</p></li><li><p>目录文件中一条一条的<strong>记录</strong>就是一个"<strong>文件控制块（FCB）</strong>"</p><ul><li>FCB实现了文件名和文件之间的映射，使用户（用户程序）可以实现“按名存取”</li><li><strong>FCB的有序集合称为“文件目录”</strong>，<strong>一个FCB就是一个文件目录项</strong></li><li>FCB中包含了文件的基本信息（文件名、物理地址、逻辑结构、物理结构等），存取控制信息（是否可读/可写、禁止访问的用户名单等），使用信息（如文件的建立时间、修改时间等）。最重要，最基本的还是<strong>文件名</strong>、<strong>文件存放的物理地址</strong></li></ul></li><li><p><strong>需要对目录进行哪些操作？</strong></p><ul><li>搜索：当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项</li><li>创建文件：创建一个新文件时，需要在其所属的目录中增加一个目录项</li><li>删除文件：当删除一个文件时，需要在目录中删除相应的目录项</li><li>显示目录：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性</li><li>修改目录：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项（如：文件重命名）</li></ul></li></ul><h3 id="目录结构">3.2 <strong>目录结构</strong></h3><ul><li><strong>单级目录结构</strong><ul><li>早期操作系统并不支持多级目录，<strong>整个系统中只建立一张目录表，每个文件占一个目录项</strong></li><li>单级目录实现了“按名存取”，但是<strong>不允许文件重名</strong></li><li>在创建一个文件时，需要先检查目录表中有没有重名文件，确定不重名后才能允许建立文件，并将新文件对应的目录项插入目录表中</li><li>显然，单级目录结构不适用于多用户操作系统</li></ul></li><li><strong>两级目录结构</strong><ul><li>早期的多用户操作系统，采用<strong>两级目录结构</strong></li><li>分为<strong>主文件目录（MFD，Master FileDirectory）</strong>和<strong>用户文件目录（UFD，User FlieDirectory）</strong></li></ul></li><li><strong>多级目录结构（树形目录结构）</strong><ul><li>用户（或用户进程）要访问某个文件时要用文件路径名标识文件，文件路径名是个字符串</li><li>各级目录之间用“/”隔开。<strong>从根目录出发的路径</strong>称为<strong>绝对路径</strong><ul><li>例如：自拍.jpg 的绝对路径是 “/照片/2015-08/自拍.jpg”</li><li>系统根据绝对路径一层一层地找到下一级目录<ul><li>刚开始<strong>从外存读入根目录的目录表</strong></li><li>找到“照片”目录的存放位置后，从外存读入对应的目录表</li><li>再找到“2015-08”目录的存放位置，再从外存读入对应目录表</li><li>最后才找到文件“自拍.jpg”的存放位置</li><li>整个过程需要3次读磁盘I/O操作</li></ul></li></ul></li><li>很多时候，用户会连续访问同一目录内的多个文件（比如：接连查看“2015-08”目录内的多个照片文件）</li><li>显然，每次都从根目录开始查找，是很低效的，因此可以设置一个“<strong>当前目录</strong>”<ul><li>例如：此时已经打开了“照片”的目录文件，也就是说，这张目录表已调入内存，那么可以把它设置为“当前目录”，当用户想要访问某个文件时，可以使用从当前目录出发的“<strong>相对路径</strong>”</li><li>在 Linux 中，“.”表示当前目录，因此如果“照片”是当前目录，则”自拍.jpg”的相对路径为：<ul><li>“./2015-08/自拍.jpg”<ul><li>从当前路径出发，只需要查询内存中的“照片”目录表，即可知道”2015-08”目录表的存放位置</li><li>从外存调入该目录，即可知道“自拍.jpg”存放的位置了</li></ul></li><li>可见，引入“<strong>当前目录</strong>”和“<strong>相对路径</strong>”后，磁盘I/O的次数减少了。这就提升了访问文件的效率</li></ul></li></ul></li><li><strong>树形目录结构</strong>可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护</li><li>但是，树形结构不便于实现文件的共享，为此，提出了“<strong>无环图目录结构</strong>”</li></ul></li><li><strong>无环图目录结构</strong><ul><li><strong>可以用不同的文件名指向同一个文件</strong>，甚至可以指向同一个目录（共享同一目录下的所有内容）</li><li>需要为<strong>每个共享结点设置一个共享计数器</strong>，用于记录此时有多少个地方在共享该结点<ul><li><strong>索引结点</strong>中设置一个链接计数变量count，用于表示链接到本索引结点上的用户<strong>目录项</strong>数</li></ul></li><li>用户提出删除结点的请求时，只是删除该用户的FCB、并使共享计数器减1，并不会直接删除共享结点。只有共享计数器减为0时，才删除结点</li><li>注意：共享文件不同于复制文件。在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化</li></ul></li></ul><h3 id="索引结点fcb的改进">3.3<strong>索引结点（FCB的改进）</strong></h3><ul><li><p><strong>思考有何好处？</strong></p><ul><li>假设一个FCB是64B，磁盘块的大小为1KB，则每个盘块中只能存放16个FCB。若一个文件目录中共有640个目录项，则共需要占用640 / 16 = 40 个盘块。因此按照某文件名检索该目录，平均需要查询320个目录项，平均需要启动磁盘20次（每次磁盘I/O读入一块）</li><li>若使用<strong>索引结点机制</strong>，文件名占14B，索引结点指针站2B，则每个盘块可存放64个目录项，那么按文件名检索目录平均只需要</li><li>读入 320 / 64 = 5个磁盘块。显然，<strong>这将大大提升文件检索速度</strong></li></ul></li><li><p>当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件</p></li><li><p>存放<strong>在外存中的索引结点</strong>称为“<strong>磁盘索引结点</strong>”，当<strong>索引结点放入内存</strong>后称为“<strong>内存索引结点</strong>”</p></li><li><p>相比之下<strong>内存索引结点中需要增加一些信息</strong>，比如：文件是否被修改、此时有几个进程正在访问该文件等</p></li></ul><h2 id="文件的物理结构"><strong>4. 文件的物理结构</strong></h2><ul><li><strong>操作系统需要对磁盘块进行哪些管理？</strong><ul><li><strong>对非空闲磁盘块的管理</strong>（存放了文件数据的磁盘块）<ul><li>“<strong>文件的物理结构</strong>/文件分配方式”要讨论的问题</li></ul></li><li><strong>对空闲磁盘块的管理</strong><ul><li>"<strong>文件存储空间管理</strong>"要讨论的问题</li></ul></li></ul></li></ul><h3 id="文件的物理结构文件分配方式">4.1<strong>文件的物理结构</strong>（文件分配方式）</h3><ul><li><p>即：文件数据应该怎样存放在外存中？</p></li><li><p><strong>连续分配</strong></p></li><li><p><strong>链接分配</strong></p><ul><li><strong>隐式链接</strong>、<strong>显示链接</strong></li></ul></li><li><p><strong>索引分配</strong></p></li></ul><h3 id="文件块磁盘块">4.2 <strong>文件块、磁盘块</strong></h3><ul><li><p>类似于<strong>内存分页</strong>，<strong>磁盘中的存储单元</strong>也会被分为一个个“<strong>块/磁盘块/物理块</strong>”。很多操作系统中，<strong>磁盘块的大小与内存块、页面的大小相同</strong></p></li><li><p><strong>内存与磁盘之间的数据交换</strong>（即读/写操作、磁盘I/O）都是<strong>以“块”为单位</strong>进行的。即每次读入一块，或每次写出一块</p></li><li><p>在内存管理中，进程的逻辑地址空间被分为一个一个页面</p></li><li><p>同样的，在外存管理中，为了方便对文件数据的管理，<strong>文件的逻辑地址空间也被分为了一个一个的文件“块”</strong></p><ul><li>操作系统为文件分配存储空间都是以块为单位的</li><li>若块的大小是1KB，则1MB大小的文件可以被分为1K个块</li></ul></li><li><p>于是文件的逻辑地址也可以表示为<strong>（逻辑块号，块内地址）</strong>的形式</p><ul><li>用户通过逻辑地址来操作自己的文件，<strong>操作系统要负责实现从逻辑地址到物理地址的映射</strong></li></ul></li></ul><h3 id="连续分配">4.3 <strong>连续分配</strong></h3><ul><li><strong>连续分配</strong>方式要求<strong>每个文件在磁盘上占有一组连续的块</strong></li><li>用户通过逻辑地址来操作自己的文件，<strong>操作系统如何实现从逻辑地址到物理地址的映射？</strong><ul><li>（逻辑块号，块内地址）→（物理块号，块内地址），只需转换块号就行，块内地址保持不变</li><li><strong>用户</strong>给出要访问的<strong>逻辑块号</strong>，操作系统找到该<strong>文件对应的目录项（FCB）</strong><ul><li><strong>物理块号 = 起始块号 + 逻辑块号</strong></li><li>可以直接算出逻辑块号对应的物理块号，因此<strong>连续分配支持顺序访问和直接访问（即随机访问）</strong></li></ul></li><li>当然，还需要检查用户提供的逻辑块号是否合法（ 逻辑块号 ≥ 长度就不合法）</li></ul></li><li>读取某个磁盘块时，需要移动磁头。访问的两个磁盘块相隔越远，移动磁头所需时间就越长。<ul><li>结论：<strong>连续分配的文件在顺序读/写时速度最快</strong></li></ul></li><li>若此时文件A要拓展，需要再增加一个磁盘块（总共需要连续的4个磁盘块）。由于采用连续结构，因此文件A占用的磁盘块必须是连续的。因此只能将文件A全部“迁移”到绿色区域<ul><li>结论：<strong>物理上采用连续分配的文件不方便拓展</strong></li><li>结论：<strong>物理上采用连续分配，存储空间利用率低，会产生难以利用的磁盘碎片，可以用紧凑来处理碎片，但是需要耗费很大的时间代价</strong></li></ul></li><li><strong>总结</strong>:<ul><li>优点：支持顺序访问和直接访问（即随机访问），连续分配的文件在顺序访问时速度最快</li><li>缺点：不方便文件拓展；存储空间利用率低，会产生磁盘碎片</li></ul></li></ul><h3 id="链接分配">4.4 <strong>链接分配</strong></h3><ul><li><strong>链接分配采取离散分配的方式，可以为文件分配离散的磁盘块</strong>，分为<strong>隐式链接</strong>和<strong>显式链接</strong>两种<ul><li>考试题目中遇到未指明隐式/显式的“链接分配”，<strong>默认指的是隐式链接的链接分配</strong></li></ul></li><li><strong>隐式链接</strong><ul><li><strong>如何实现文件的逻辑块号到物理块号的转变？</strong><ul><li><strong>用户</strong>给出要访问的<strong>逻辑块号</strong>i，操作系统找到该<strong>文件对应的目录项（FCB）</strong></li><li>从目录项中找到起始块号（即0号块），将0号逻辑块读入内存，由此知道1号逻辑块存放的物理块号，于是读入1号逻辑块，再找到2号逻辑块的存放位置……以此类推</li><li>因此，<strong>读入i号逻辑块，总共需要 i+1 次磁盘I/O</strong><ul><li>结论：<strong>采用链式分配（隐式链接）方式的文件，只支持顺序访问，不支持随机访问，查找效率低。另外，指向下一个盘块的指针也需要耗费少量的存储空间</strong></li></ul></li></ul></li><li><strong>是否方便拓展文件？</strong><ul><li>若此时要拓展文件，则可以随便找一个空闲磁盘块，挂到文件的磁盘块链尾，并修改文件的FCB</li><li>结论：<strong>采用隐式链接的链接分配方式，很方便文件拓展。另外，所有的空闲磁盘块都可以被利用，不会有碎片问题，外存利用率高</strong></li></ul></li><li><strong>总结</strong>:<ul><li>优点：很方便文件拓展，不会有碎片问题，外存利用率高</li><li>缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间</li></ul></li></ul></li><li><strong>显式链接</strong><ul><li><strong>把用于链接文件各物理块的指针显式地存放在一张表中</strong>，即<strong>文件分配表（FAT，File Allocation Table）</strong><ul><li>假设某个新创建的文件“aaa”依次存放在磁盘块 2 → 5 → 0 → 1</li><li>假设某个新创建的文件“bbb”依次存放在磁盘块 4 → 23 → 3</li><li>注意：<strong>一个磁盘仅设置一张FAT</strong>。开机时，将FAT读入内存，并<strong>常驻内存</strong>。<strong>FAT的各个表项在物理上连续存储，且每一个表项长度相同，因此“物理块号”字段可以是隐含的</strong></li></ul></li><li><strong>如何实现文件的逻辑块号到物理块号的转变？</strong><ul><li><strong>用户</strong>给出要访问的<strong>逻辑块号</strong>i，操作系统找到该<strong>文件对应的目录项（FCB）</strong></li><li>从目录项中找到起始块号，若i&gt;0，则查询内存中的<strong>文件分配表FAT</strong>，往后找到i号逻辑块对应的物理块号。<strong>逻辑块号转换成物理块号的过程不需要读磁盘操作</strong><ul><li>结论：<strong>采用链式分配（显式链接）方式的文件，支持顺序访问，也支持随机访问（想访问i 号逻辑块时，并不需要依次访问之前的 0 ~ i -1号逻辑块），由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问速度快很多</strong></li></ul></li><li>显然，<strong>显式链接也不会产生外部碎片，也可以很方便地对文件进行拓展</strong></li></ul></li><li><strong>总结</strong>:<ul><li>优点：很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高</li><li>缺点：文件分配表的需要占用一定的存储空间</li></ul></li></ul></li></ul><h3 id="索引分配">4.4 <strong>索引分配</strong></h3><ul><li><strong>索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文件的各个逻辑块对应的物理块</strong><ul><li>索引表的功能类似于内存管理中的页表 --建立逻辑页面到物理页之间的映射关系</li></ul></li><li>磁盘中存放索引表的磁盘块称为<strong>索引块</strong>，磁盘中存放文件数据的磁盘块称为<strong>数据块</strong><ul><li>假设某个新创建的文件“aaa”的数据依次存放在磁盘块 2 → 5 → 13 → 9</li><li>7号磁盘块作为“aaa”的索引块，索引块中保存了索引表的内容</li><li>注：在显式链接的链式分配方式中，<strong>文件分配表FAT</strong>是<strong>一个磁盘对应一张</strong>，而索引分配方式中，<strong>索引表</strong>是<strong>一个文件对应一张</strong></li><li><strong>可以用固定的长度表示物理块号</strong>（如：假设磁盘总容量为1TB = 2<sup>40</sup>B，磁盘块大小为 1KB，则共有2<sup>30</sup>个磁盘块，则可用 4B表示磁盘块号），因此，<strong>索引表中的“逻辑块号”可以是隐含的</strong></li></ul></li><li><strong>如何实现文件的逻辑块号到物理块号的转换？</strong><ul><li><strong>用户</strong>给出要访问的<strong>逻辑块号</strong>i，操作系统找到该<strong>文件对应的目录项（FCB）</strong></li><li>从目录项中可知<strong>索引表</strong>存放位置，将索引表从外存读入内存，并查找索引表即可知道i 号逻辑块在外存中的存放位置<ul><li>结论：<strong>索引分配方式可以支持随机访问。文件拓展也很容易实现（只需要给文件分配一个空闲块，并增加一个索引表项即可）但是索引表需要占用一定的存储空间</strong></li></ul></li></ul></li><li>若每个磁盘块1KB，一个索引表项4B，则一个磁盘块只能存放 256个索引项。如果一个文件的大小超过了256块，那么<strong>一个磁盘块</strong>是<strong>装不下文件的整张索引表</strong>的，<strong>如何解决这个问题？</strong><ul><li><strong>链接方案</strong><ul><li>如果索引表太大，一个索引块装不下，那么可以<strong>将多个索引块链接起来存放</strong></li><li>假设磁盘块大小为1KB，一个索引表项占4B，则一个磁盘块只能存放256个索引项</li><li>若一个文件大小为 256 * 256KB = 65,536 KB = 64MB，该文件共有 256 *256 个块，也就对应 256 * 256 个索引项，也就需要 256个索引块来存储，这些索引块用链接方案连起来</li><li>若想要访问文件的最后一个逻辑块，就必须找到最后一个索引块（第256个索引块），而各个索引块之间是用指针链接起来的，因此必须先顺序地读入前255 个索引块<ul><li>缺点：若文件很大，索引表很长，就需要将很多个索引块链接起来。想要找到i 号索引块，必须先依次读入 0 ~i-1号索引块，这就导致磁盘I/O次数过多，查找效率低下这显然是很低效的，如何解决呢？</li></ul></li></ul></li><li><strong>多层索引</strong><ul><li><strong>建立多层索引（原理类似于多级页表）</strong>。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块...</li><li>假设磁盘块大小为1KB，一个索引表项占4B，则一个磁盘块只能存放256个索引项</li><li><strong>若某文件采用两层索引</strong>，则该文件的最大长度可以到256 *256 * 1KB = 65,536 KB = 64MB</li><li>可根据逻辑块号算出应该查找索引表中的哪个表项<ul><li>如：要访问 1026 号逻辑块，则1026 / 256 = 4，1026 % 256 = 2</li><li>因此可以先将一级索引表调入内存，查询 4号表项，将其对应的二级索引表调入内存，再查询二级索引表的2号表项即可知道1026 号逻辑块存放的磁盘块号了。访问目标数据块，需要3次磁盘I/O</li></ul></li><li><strong>若采用三层索引</strong>，则文件的最大长度为256 * 256 * 256 *1KB = 16GB<ul><li>类似的，访问目标数据块，需要4次磁盘I/O</li></ul></li><li><strong>采用 K层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要 K + 1次读磁盘操作</strong><ul><li>缺点：即使是小文件，访问一个数据块依然需要K + 1次读磁盘</li></ul></li></ul></li><li><strong>混合索引</strong><ul><li><strong>多种索引分配方式的结合</strong><ul><li>例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表）、还包含两级间接索引（指向两层索引表）</li><li>优点：对于小文件来说，访问一个数据块所需的读磁盘次数更少</li></ul></li></ul></li></ul></li><li><strong>重要考点</strong>:<ul><li>要会根据多层索引、混合索引的结构计算出文件的最大长度<ul><li>Key：各级索引表最大不能超过一个块</li></ul></li><li>要能自己分析访问某个数据块所需要的读磁盘次数<ul><li>Key：FCB中会存有指向顶级索引块的指针，因此可以根据FCB读入顶级索引块。每次读入下一级的索引块都需要一次读磁盘操作。另外，要注意题目条件-- 顶级索引块是否已调入内存</li></ul></li></ul></li></ul><h2 id="逻辑结构vs物理结构"><strong>5. 逻辑结构VS物理结构</strong></h2><ul><li>逻辑结构中的链式存储和物理结构中的链接分配<ul><li>文件内部各条记录链式存储：由创建文件的用户自己设计的</li><li>文件整体用链接分配：由操作系统决定</li></ul></li><li>逻辑结构中的索引文件和物理结构中的索引分配<ul><li>索引文件的索引表：<ul><li>用户自己建立的，映射：关键字 → 记录存放的逻辑地址</li></ul></li><li>索引分配的索引表：<ul><li>操作系统建立的，映射：逻辑块号 → 物理块号</li></ul></li></ul></li></ul><h2 id="文件存储空间管理"><strong>6. 文件存储空间管理</strong></h2><ul><li>学习时注意从三个方面进行理解:<ul><li>用什么方式记录、组织空闲块？</li><li>如何分配磁盘块</li><li>如何回收磁盘块</li></ul></li></ul><h3 id="存储空间的划分与初始化">6.1<strong>存储空间的划分与初始化</strong></h3><ul><li>安装Windows操作系统的时候，一个必经步骤是为<strong>磁盘分区</strong>（C:盘、D:盘、E:盘）<ul><li>存储空间的划分：将物理磁盘划分为一个个<strong>文件卷（逻辑卷、逻辑盘）</strong></li><li>存储空间的初始化：将各个<strong>文件卷</strong>划分为<strong>目录区</strong>、<strong>文件区</strong><ul><li><strong>目录区</strong>：主要存放文件目录信息（FCB）、用于磁盘存储空间管理的信息</li><li><strong>文件区</strong>：文件区用于存放文件数据</li></ul></li></ul></li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-1-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20241121214207650.png"></p><h3 id="空闲表法">6.2 <strong>空闲表法</strong></h3><ul><li><p>适用于"<strong>连续分配方式</strong>"</p></li><li><p><strong>如何分配磁盘块</strong>:</p><ul><li>与内存管理中的动态分区分配很类似，为一个文件<strong>分配连续的存储空间</strong>。同样<strong>可采用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个区间</strong></li></ul></li><li><p><strong>如何回收磁盘块</strong>:</p><ul><li>与内存管理中的动态分区分配很类似，当回收某个存储区时需要有四种情况:</li><li>回收区的前后都没有相邻空闲区</li><li>回收区的前后都是空闲区</li><li>回收区前面是空闲区</li><li>回收区后面是空闲区</li><li>总之，<strong>回收时需要注意表项的合并问题</strong></li></ul></li></ul><h3 id="空闲链表法">6.3 <strong>空闲链表法</strong></h3><ul><li><strong>空闲盘块链</strong>: 以盘块为单位组成一条空闲链<ul><li>操作系统保存着<strong>链头、链尾指针</strong></li><li><strong>如何分配磁盘块</strong>:<ul><li>若某文件申请 k 个盘块，则从链头开始依次摘下 k个盘块分配，并修改空闲链的链头指针</li></ul></li><li><strong>如何回收磁盘块</strong>:<ul><li>回收的盘块依次挂到链尾，并修改空闲链的链尾指针</li></ul></li><li>适用于<strong>离散分配</strong>的物理结构。为文件分配多个盘块时可能要重复多次操作</li></ul></li><li><strong>空闲盘区链</strong>: 以盘区为单位组成一条空闲链<ul><li>操作系统保存着<strong>链头、链尾指针</strong></li><li><strong>如何分配磁盘块</strong>:<ul><li>若某文件申请 k个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区，分配给文件。若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据</li></ul></li><li><strong>如何回收磁盘块</strong>:<ul><li>若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾</li></ul></li><li><strong>连续分配</strong>、<strong>离散分配</strong>都适用，为一个文件分配多个盘块时效率更高</li></ul></li></ul><h3 id="位示图法">6.4 <strong>位示图法</strong></h3><ul><li><strong>每个二进制位对应一个盘块</strong><ul><li>在本例中，“0” 代表盘块空闲，“1”代表盘块已分配</li></ul></li><li><strong>位示图一般用连续的“字”来表示</strong><ul><li>如本例中一个字的字长是16位</li></ul></li><li><strong>字中的每一位对应一个盘块</strong>，因此可以用<strong>（字号，位号）</strong>对应一个<strong>盘块号</strong>，当然有的题目中也描述为<strong>（行号，列号）</strong></li><li><strong>重要</strong>：要能自已推出<strong>盘块号</strong>与<strong>（字号，位号）</strong>相互转换的公式<ul><li>注意题目条件：<strong>盘块号</strong>、<strong>字号</strong>、<strong>位号</strong>到底是从0开始还是从1开始<ul><li>如本例中盘块号、字号、位号从0开始，若n表示字长，则（字号，位号）=（i，j）的二进制位对应的盘块号b = n * i + j</li><li>b号盘块对应的字号 i = b / n，位号 j = b % n</li></ul></li></ul></li><li><strong>如何分配磁盘块</strong>:<ul><li>若文件需要 k 个块<ul><li>顺序扫描位示图，找到K个相邻或不相邻的“0”</li><li>根据字号、位号算出对应的盘块号，将相应盘块分配给文件</li><li>将相应位设置为“1”</li></ul></li></ul></li><li><strong>如何回收磁盘块</strong>:<ul><li>根据回收的盘块号计算出对应的字号、位号</li><li>将相应二进制位设为“0</li></ul></li><li><strong>连续分配</strong>、<strong>离散分配</strong>都适用</li></ul><h3 id="成组链接法">6.5 <strong>成组链接法</strong></h3><ul><li><p><strong>空闲表法、空闲链表法不适用于大型文件系统</strong>，因为空闲表或空闲链表可能过大</p></li><li><p>UNIX系统中采用了<strong>成组链接法</strong>对磁盘空闲块进行管理</p></li><li><p><strong>文件卷的目录区</strong>中专门用一个磁盘块作为“<strong>超级块</strong>”，当系统启动时需要<strong>将超级块读入内存</strong>，并且要保证内存与外存中的“超级块”数据一致</p><ul><li>注3: <strong>每个分组的盘块数量是存在上限的</strong></li><li>注4:<strong>最后一个分组的盘块数是比其他分组的盘块数少的</strong></li></ul></li><li><p><strong>如何分配磁盘块</strong>:</p><ul><li><p>若文件需要 1 个空闲块</p><ul><li>检查第一个分组的块数是否足够，1 &lt; 100，是足够的</li><li>分配第一个分组中的 1 个空闲块，并修改空闲盘块数</li></ul></li><li><p>若文件需要 100 个空闲块</p><ul><li>检查第一个分组的块数是否足够，100 = 100，是足够的</li><li>分配第一个分组中的100个空闲块。但是由于300号块内存放了再下一组的信息，因此300号块的数据需要复制到超级块中</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-1-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20241121215625563.png"></p></li></ul></li><li><p><strong>如何回收磁盘块</strong>:</p><ul><li>假设每个分组最多为100个空闲块，此时第一个分组已有99个块，还要再回收一块<ul><li>可以将空闲块的信息放到第一个分组当中，并修改空闲盘块数</li></ul></li><li>假设每个分组最多为100个空闲块，此时第一个分组已有100个块，还要再回收一块<ul><li>需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组</li></ul></li></ul></li></ul><h2 id="文件的基本操作"><strong>7. 文件的基本操作</strong></h2><h3 id="创建文件">7.1 <strong>创建文件</strong></h3><ul><li><p>可以“<strong>创建文件</strong>”（点击新建后，图形化交互进程在背后调用了“<strong>create系统调用</strong>”）</p></li><li><p>进行 create 系统调用 时，需要提供的几个主要参数:</p><ul><li>所需的外存空间大小（如：一个盘块，即1KB）</li><li>文件存放路径（“D:/Demo”）</li><li>文件名（这个地方默认为“新建文本文档.txt”）</li></ul></li><li><p>操作系统在处理 create 系统调用时，主要做了两件事:</p><ul><li><strong>在外存中找到文件所需的空间</strong>（结合上小节学习的空闲链表法、位示图、成组链接法等管理策略，找到空闲空间）</li><li>根据文件存放路径的信息找到该目录对应的目录文件（此处就是D:/Demo目录），<strong>在目录中创建该文件对应的目录项</strong>。目录项中包含了文件名、文件在外存中的存放位置等信息</li></ul></li></ul><h3 id="删除文件">7.2 <strong>删除文件</strong></h3><ul><li><p>可以<strong>“删除文件</strong>”（点击删除后，图形化交互进程在背后调用了"<strong>delete系统调用</strong>"，将文件数据从外存中删除）</p></li><li><p>进行 delete 系统调用 时，需要提供的几个主要参数:</p><ul><li>文件存放路径（“D:/Demo”）</li><li>文件名（“test.txt" ）</li></ul></li><li><p>操作系统在处理 delete 系统调用 时，主要做了几件事:</p><ul><li>根据文件存放路径找到相应的目录文件，<strong>从目录中找到文件名对应的目录项</strong></li><li>根据该目录项记录的文件在外存的存放位置、文件大小等信息，<strong>回收文件占用的磁盘块</strong>（回收磁盘块时，根据空闲表法、空闲链表法、位图法等管理策略的不同，需要做不同的处理）</li><li><strong>从目录表中删除文件对应的目录项</strong></li></ul></li></ul><h3 id="打开文件">7.3 <strong>打开文件</strong></h3><ul><li><p>读/写文件之前，需要通过操作系统提供的"<strong>open系统调用</strong>"来“<strong>打开文件</strong>”</p></li><li><p>在很多操作系统中，在对文件进行操作之前，要求用户先使用 open系统调用 “打开文件”，需要提供的几个主要参数:</p><ul><li>文件存放路径（“D:/Demo”）</li><li>文件名（“test.txt”）</li><li>要对文件的操作类型（如：r只读；rw读写等）</li></ul></li><li><p>操作系统在处理 open 系统调用 时，主要做了几件事:</p><ul><li>1.根据文件存放路径找到相应的目录文件，从目录中<strong>找到文件名对应的的目录项</strong>，并检查该用户是否有指定的操作权限</li><li>2.<strong>将目录项复制到内存中的“打开文件表”中</strong>。并将对应表目的编号返回给用户。之后<strong>用户使用打开文件表的编号(即</strong>文件描述符 <strong>)来指明要操作的文件</strong></li></ul></li></ul><h3 id="关闭文件">7.4 <strong>关闭文件</strong></h3><ul><li><p>读/写文件结束之后，需要通过操作系统提供的"<strong>close系统调用</strong>"来“<strong>关闭文件</strong>”</p></li><li><p>进程使用完文件后，要“关闭文件”</p></li><li><p>操作系统在处理 close 系统调用 时，主要做了几件事:</p><ul><li>将进程的打开文件表相应表项删除</li><li>回收分配给该文件的内存空间等资源</li><li>系统打开文件表的打开计数器count减1，若count = 0，则删除对应表项</li></ul></li></ul><h3 id="读文件">7.5 <strong>读文件</strong></h3><ul><li><p>可以“<strong>读文件</strong>”，将文件数据读入内存，才能让CPU处理（双击后，“记事本”应用程序通过操作系统提供的“<strong>read系统调用</strong>”，将文件数据从外存读入内存，并显示在屏幕上）</p></li><li><p>进程使用 read 系统调用 完成写操作:</p><ul><li>需要指明是哪个文件（在支持“打开文件”操作的系统中，<strong>只需要提供文件在打开文件表中的索引号(又称</strong>文件描述符 <strong>)即可</strong>）</li><li>还需要指明要读入多少数据（如：读入1KB）、指明读入的数据要放在内存中的什么位置</li><li>操作系统在处理 read 系统调用时，会从读指针指向的外存中，将指定大小的数据读入用户指定的内存区域中</li></ul></li></ul><h3 id="写文件">7.6 <strong>写文件</strong></h3><ul><li><p>可以“<strong>写文件</strong>”，将更改过的文件数据写回外存（在“记事本”应用程序中编辑文件内容，点击“保存”后，“记事本”应用程序通过操作系统提供的“<strong>write系统调用</strong>”，将文件数据从内存写回外存）</p></li><li><p>进程使用 write 系统调用 完成写操作:</p><ul><li>需要指明是哪个文件（在支持“打开文件”操作的系统中，<strong>只需要提供文件在打开文件表中的索引号(又称</strong>文件描述符 <strong>)即可</strong>）</li><li>还需要指明要写出多少数据（如：写出1KB）、写回外存的数据放在内存中的什么位置</li><li>操作系统在处理write系统调用时，会从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存</li></ul></li></ul><h2 id="文件共享"><strong>8. 文件共享</strong></h2><ul><li><strong>操作系统为用户提供文件共享功能，可以让多个用户共享地使用同一个文件</strong></li><li>注意：<strong>多个用户共享同一个文件，意味着系统中只有“一份”文件数据，并且只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化</strong>。如果是多个用户都"复制"了同一个文件，那么系统中会有“好几份”文件数据。其中一个用户修改了自己的那份文件数据，对其他用户的文件数据并没有影响</li></ul><h3 id="基于索引结点的共享方式硬链接">8.1<strong>基于索引结点的共享方式（硬链接）</strong></h3><ul><li><p>知识回顾：<strong>索引结点</strong>，是一种文件目录瘦身策略。由于检索文件时只需用到文件名，因此可以将除了文件名之外的其他信息放到索引结点中。这样目录项就只需要包含文件名、索引结点指针</p></li><li><p><strong>索引结点</strong>中设置一个链接计数变量count，<strong>用于表示链接到本索引结点上的用户目录项数</strong></p></li><li><p>若count=2，说明此时有两个用户目录项链接到该索引结点上，或者说是有两个用户在共享此文件</p></li><li><p>若某个用户决定“删除”该文件，则只是要把用户目录中与该文件对应的目录项删除，且索引结点的count值减1</p></li><li><p>若count&gt;0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空</p></li><li><p>当count=0时系统负责删除文件</p></li></ul><h3 id="基于符号链的共享方式软链接">8.2<strong>基于符号链的共享方式（软链接）</strong></h3><ul><li><p>当User3访问“ccc”时，操作系统判断文件“ccc”属于<strong>Link类型文件</strong>，于是会<strong>根据其中记录的路径层层查找目录</strong>，最终找到User1的目录表中的“aaa"表项，于是就找到了文件1的索引结点</p></li><li><p><strong>即使软链接指向的共享文件已被删除，Link型文件依然存在，只是通过Link型文件中的路径去查找共享文件会失败</strong>（找不到目录项）</p></li><li><p>由于用软链接的方式访问共享文件时要查询多级目录，会有多次磁盘I/O，因此<strong>用软链接访问共享文件的速度要比硬链接更慢</strong></p></li></ul><h2 id="文件保护"><strong>9. 文件保护</strong></h2><ul><li>保护文件数据的安全</li></ul><h3 id="口令保护">9.1 <strong>口令保护</strong></h3><ul><li><p>为文件设置一个“口令”（如: abc112233），用户请求访问该文件时必须提供“口令”</p><ul><li>口令一般存放在文件对应的FCB或索引结点中。用户访问文件前需要先输入“口令”，操作系统会将用户提供的口令与FCB中存储的口令进行对比，如果正确，则允许该用户访问文件</li></ul></li><li><p>优点：保存口令的空间开销不多，验证口令的时间开销也很小</p></li><li><p>缺点：正确的“口令”存放在系统内部，不够安全</p></li></ul><h3 id="加密保护">9.2 <strong>加密保护</strong></h3><ul><li><p>使用某个"密码"对文件进行加密，在访问文件时需要提供正确的”密码“才能对文件进行正确的解密</p></li><li><p>优点：保密性强，不需要在系统中存储“密码”</p></li><li><p>缺点：编码/译码，或者说加密/解密需要花费一定时间</p></li></ul><h3 id="访问控制">9.3 <strong>访问控制</strong></h3><ul><li><p>在每个文件的FCB（或索引结点）中增加一个<strong>访问控制表（Access-ControlList，ACL）</strong>，该表中记录了各个用户可以对该文件执行哪些操作</p></li><li><p><strong>精简的访问列表</strong>：以“<strong>组</strong>”为单位，<strong>标记各“组”用户可以对文件执行哪些操作</strong>，系统需要管理分组的信息</p><ul><li>如：分为系统管理员、文件主、文件主的伙伴、其他用户几个分组</li><li>当某用户想要访问文件时，系统会检查该用户所属的分组是否有相应的访问权限</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.2 虚拟内存管理</title>
    <link href="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟内存管理"><strong>3.2 虚拟内存管理</strong></h1><h2 id="虚拟内存的基本概念"><strong>1. 虚拟内存的基本概念</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20241121183215528.png"></p><ul><li>在<strong>传统存储管理方式</strong>的基础上引入了<strong>交换技术</strong>、<strong>覆盖技术</strong>，使得内存利用率有所提升，并且能从逻辑上扩充内存容量<ul><li>传统存储管理方式：连续分配、非连续分配</li></ul></li></ul><h3 id="传统存储管理方式的特征缺点">1.1<strong>传统存储管理方式的特征、缺点</strong></h3><ul><li><p>传统存储管理方式中很多暂时用不到的数据也会长期占用内存，导致内存利用率不高</p></li><li><p><strong>一次性</strong></p><ul><li>作业必须一次性全部装入内存后才能开始运行</li><li>这会造成两个问题：<ul><li>作业很大时，不能全部装入内存，导致大作业无法运行</li><li>当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降</li></ul></li></ul></li><li><p><strong>驻留性</strong></p><ul><li>一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束</li><li>事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源</li></ul></li><li><p>传统存储管理方式的这些问题可用<strong>虚拟存储技术</strong>解决</p></li></ul><h3 id="局部性原理">1.2 <strong>局部性原理</strong></h3><ul><li><strong>时间局部性</strong><ul><li>如果执行了程序中的某条<strong>指令</strong>，那么不久后这条指令很有可能再次执行；如果某个<strong>数据</strong>被访问过，不久之后该数据很可能再次被访问（因为程序中存在大量的循环）</li></ul></li><li><strong>空间局部性</strong><ul><li>一旦程序访问了某个<strong>存储单元</strong>，在不久之后，其附近的存储单元也很有可能被访问（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）</li></ul></li><li><strong>应用</strong>：<ul><li><strong>快表</strong>机构就是将近期常访问的页表项副本放到更高速的联想寄存器中</li><li><strong>高速缓冲技术</strong>的思想：将近期会频繁访问到的数据放到更高速的存储器中，暂时用不到的数据放在更低速存储器中</li></ul></li></ul><h3 id="虚拟内存的定义和特征">1.3<strong>虚拟内存的定义和特征</strong></h3><ul><li><strong>定义</strong>:<ul><li>基于<strong>局部性原理</strong>，在程序装入时，可以将程序中<strong>很快会用到的部分装入内存，暂时用不到的部分留在外存</strong>，就可以让程序开始执行</li><li>在程序执行过程中，当<strong>所访问的信息不在内存时</strong>，由<strong>操作系统负责将所需信息从外存调入内存</strong>，然后继续执行程序</li><li>若内存空间不够，由<strong>操作系统</strong>负责<strong>将内存中暂时用不到的信息换出到外存</strong>。在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是<strong>虚拟内存</strong><ul><li>操作系统<strong>虚拟性</strong>的一个体现，实际的物理内存大小没有变，只是在逻辑上进行了扩充</li></ul></li></ul></li><li><strong>特征</strong>:<ul><li>虚拟内存有以下三个主要特征：</li><li><strong>多次性</strong>：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存</li><li><strong>对换性</strong>：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出</li><li><strong>虚拟性</strong>：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量</li></ul></li></ul><h3 id="如何实现虚拟内存技术">1.4<strong>如何实现虚拟内存技术?</strong></h3><ul><li><p>虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。因此，虚拟内存的实现需要建立在<strong>离散分配</strong>的内存管理方式基础上</p></li><li><p><strong>传统的非连续分配存储管理</strong></p><ul><li>基本分页存储管理、基本分段存储管理、基本段页式存储管理</li></ul></li><li><p><strong>虚拟内存的实现</strong></p><ul><li><strong>请求分页存储管理</strong>、<strong>请求分段存储管理</strong>、<strong>请求段页式存储管理</strong></li></ul></li><li><p><strong>主要区别</strong>：</p><ul><li>在程序执行过程中，当<strong>所访问的信息不在内存时</strong>，由<strong>操作系统负责将所需信息从外存调入内存</strong>，然后继续执行程序<ul><li>操作系统要提供<strong>请求调页（或请求调段）</strong>功能</li></ul></li><li>若内存空间不够，由<strong>操作系统</strong>负责<strong>将内存中暂时用不到的信息换出到外存</strong><ul><li>操作系统要提供<strong>页面置换（或段置换）</strong>的功能</li></ul></li></ul></li></ul><h2 id="请求分页管理方式"><strong>2. 请求分页管理方式</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20241121191935173.png"></p><ul><li>注意与<strong>基本分页存储管理</strong>的页表机制、地址变换流程对比学习</li></ul><h3 id="页表机制">2.1 <strong>页表机制</strong></h3><ul><li><p>与基本分页管理相比，<strong>请求分页管理</strong>中，为了实现“<strong>请求调页</strong>”，操作系统需要知道每个页面是否已经调入内存；如果还没调入，那么也需要知道该页面在外存中存放的位置</p></li><li><p>当内存空间不够时，要实现“<strong>页面置换</strong>”，操作系统需要通过某些指标来决定到底换出哪个页面；有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息</p></li></ul><h3 id="缺页中断机构">2.2 <strong>缺页中断机构</strong></h3><ul><li><p>在请求分页系统中，每当<strong>要访问的页面不在内存</strong>时，便产生一个<strong>缺页中断</strong>，然后由操作系统的<strong>缺页</strong></p></li><li><p><strong>中断处理程序处理中断</strong>。此时<strong>缺页的进程阻塞</strong>，放入阻塞队列，<strong>调页完成后再将其唤醒</strong>，放回就绪队列</p></li><li><p>如果<strong>内存中有空闲块</strong>，则<strong>为进程分配一个空闲块</strong>，将所缺页面装入该块，并<strong>修改页表中相应的页表项</strong></p></li><li><p>如果<strong>内存中没有空闲块</strong>，则<strong>由页面置换算法选择一个页面淘汰</strong>，若该页面在内存期间<strong>被修改过</strong>，则要<strong>将其写回外存</strong>。<strong>未修改过</strong>的页面<strong>不用写回外存</strong></p></li><li><p><strong>缺页中断</strong>是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于<strong>内中断</strong></p></li><li><p><strong>一条指令</strong>在执行期间，<strong>可能产生多次缺页中断</strong></p><ul><li>如：copy A toB，即将逻辑地址A中的数据复制到逻辑地址B，而A、B属于不同的页面，则有可能产生两次中断</li></ul></li></ul><h3 id="地址变换机构">2.3 <strong>地址变换机构</strong></h3><ul><li><p>新增步骤1：请求调页（查到页表项时进行判断）</p></li><li><p>新增步骤2：页面置换（需要调入页面，但没有空闲内存块时进行）</p></li><li><p>新增步骤3：需要修改请求页表中的表项</p></li><li><p><strong>过程</strong>:</p></li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20241121191231469.png"></p><ul><li><strong>注意</strong>:<strong>快表</strong>中有的页面一定是在内存中的。若<strong>某个页面被换出外存，则快表中的相应表项也要删除</strong>，否则可能访问错误的页面</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20241121191315690.png"></p><ul><li><strong>补充细节</strong>:<ul><li>只有“写指令”才需要修改“修改位”。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数</li><li>和普通的中断处理一样，缺页中断处理依然需要保留CPU现场</li><li>需要用某种“<strong>页面置换算法</strong>”来决定一个换出页面（下节内容）</li><li>换入/换出页面都需要启动慢速的I/O操作，可见，如果换入/换出太频繁，会有很大的开销</li><li>页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中<ul><li>在具有快表机构的请求分页系统中，访问一个逻辑地址时，若发生缺页，则地址变换步骤是：<ul><li>查快表(未命中)--查慢表(发现未调入内存)--调页(调入的页面对应的表项会直接加入快表)--查快表(命中)--访问目标内存单元</li></ul></li></ul></li></ul></li></ul><h2 id="页面置换算法"><strong>3. 页面置换算法</strong></h2><ul><li>用<strong>页面置换算法</strong>决定应该换出哪个页面，页面的换入、换出需要磁盘I/O，会有较大的开销，因此好的页面置换算法应该追求<strong>更少的缺页率</strong><ul><li>即让换入、换出的次数尽可能地少，尽量将不经常使用的页面换出</li></ul></li></ul><h3 id="最佳置换算法opt">3.1 <strong>最佳置换算法（OPT）</strong></h3><ul><li><strong>最佳置换算法（OPT，Optimal）</strong>：每次选择<strong>淘汰的页面</strong>将是<strong>以后永不使用</strong>，或者<strong>在最长时间内不再被访问的页面</strong>，这样可以保证最低的缺页率</li><li>最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，<strong>最佳置换算法是无法实现的</strong></li></ul><h3 id="先进先出置换算法fifo">3.2<strong>先进先出置换算法（FIFO）</strong></h3><ul><li><strong>先进先出置换算法（FIFO）</strong>：每次选择<strong>淘汰的页面</strong>是<strong>最早进入内存的页面</strong><ul><li>实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块</li></ul></li><li><strong>Belady 异常</strong> --当为进程分配的物理块数增大时，缺页次数不减反增的异常现象<ul><li><strong>只有 FIFO 算法会产生 Belady异常</strong>。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，算法性能差</li></ul></li></ul><h3 id="最近最久未使用置换算法lru">3.3<strong>最近最久未使用置换算法（LRU）</strong></h3><ul><li><p><strong>最近最久未使用置换算法（LRU，least recentlyused）</strong>：每次<strong>淘汰的页面</strong>是<strong>最近最久未使用的页面</strong></p><ul><li>实现方法：赋予每个页面对应的页表项中，<strong>用访问字段记录该页面自上次被访问以来所经历的时间t</strong>。当需要淘汰一个页面时，选择现有页面中t 值最大的，即最近最久未使用的页面</li></ul></li><li><p>该算法的实现需要专门的硬件支持，虽然算法<strong>性能好</strong>，但是<strong>实现困难，开销大</strong></p></li><li><p>在手动做题时，若需要淘汰页面，可以逆向检查此时在内存中的几个页面号。在<strong>逆向扫描过程中最后一个出现的页号就是要淘汰的页面</strong></p></li></ul><h3 id="时钟置换算法clock">3.4<strong>时钟置换算法（CLOCK）</strong></h3><ul><li><p>最佳置换算法 性能最好，但无法实现</p></li><li><p>先进先出置换算法 实现简单，但算法性能差</p></li><li><p>最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大</p></li><li><p><strong>时钟置换算法</strong>是一种性能和开销较均衡的算法，又称<strong>CLOCK算法</strong>，或<strong>最近未用算法（NRU，NotRecently Used）</strong></p><ul><li>实现方法：为每个页面设置一个<strong>访问位</strong>，再将<strong>内存中的页面</strong>都通过链接指针<strong>链接成一个循环队列</strong>。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此<strong>简单的CLOCK算法</strong>选择一个淘汰页面<strong>最多会经过两轮扫描</strong>）</li></ul></li></ul><h3 id="改进型的时钟置换算法">3.5<strong>改进型的时钟置换算法</strong></h3><ul><li><p>简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行I/O操作写回外存。<strong>只有被淘汰的页面被修改过时，才需要写回外存</strong></p></li><li><p>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。<strong>在其他条件都相同时，应优先淘汰没有修改过的页面</strong>，避免I/O操作。这就是<strong>改进型的时钟置换算法</strong>的思想</p><ul><li><strong>修改位=0</strong>，表示<strong>页面没有被修改过</strong>；<strong>修改位=1</strong>，表示<strong>页面被修改过</strong></li><li>为方便讨论，用<strong>（访问位，修改位）</strong>的形式表示各页面状态。如（1，1）表示一个页面近期被访问过，且被修改过</li><li><strong>实现方法</strong>:<ul><li>将所有可能被置换的页面排成一个循环队列</li><li>第一轮：从当前位置开始扫描到第一个（0，0）的帧用于替换<ul><li>本轮扫描不修改任何标志位</li><li>第一优先级：最近没访问，且没修改的页面</li></ul></li><li>第二轮：若第一轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换<ul><li><strong>本轮将所有扫描过的帧访问位设为0</strong></li><li>第二优先级：最近没访问，但修改过的页面</li></ul></li><li>第三轮：若第二轮扫描失败，则重新扫描，查找第一个（0，0）的帧用于替换<ul><li>本轮扫描不修改任何标志位</li><li>第三优先级：最近访问过，但没修改的页面</li></ul></li><li>第四轮：若第三轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换<ul><li>第四优先级：最近访问过，且修改过的页面</li></ul></li><li>由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此<strong>改进型CLOCK置换算法</strong>选择一个淘汰页面<strong>最多会进行四轮扫描</strong></li></ul></li></ul></li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20241121194134402.png"></p><h2 id="页面分配策略抖动工作集"><strong>4.页面分配策略、抖动、工作集</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20241121195528729.png"></p><h3 id="驻留集">4.1 <strong>驻留集</strong></h3><ul><li><p><strong>指请求分页存储管理中给进程分配的物理块的集合</strong></p></li><li><p>在采用了虚拟存储技术的系统中，<strong>驻留集大小一般小于进程的总大小</strong></p></li><li><p>若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少</p></li><li><p>驻留集太大，又会导致多道程序并发度下降，资源利用率降低</p><ul><li>考虑一个极端情况，若某进程共有100个页面，则该进程的驻留集大小为100时进程可以全部放入内存，运行期间不可能再发生缺页。若驻留集大小为1，则进程运行期间必定会极频繁地缺页</li></ul></li><li><p>所以应该选择一个合适的驻留集大小</p></li></ul><h3 id="页面分配置换策略">4.2 <strong>页面分配、置换策略</strong></h3><ul><li><p><strong>固定分配</strong>：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，<strong>驻留集大小不变</strong></p></li><li><p><strong>可变分配</strong>：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，<strong>驻留集大小可变</strong></p></li><li><p><strong>局部置换</strong>：发生缺页时只能选<strong>进程自己的物理块</strong>进行置换</p></li><li><p><strong>全局置换</strong>：可以将<strong>操作系统保留的空闲物理块</strong>分配给缺页进程，也可以将<strong>别的进程持有的物理块</strong>置换到外存，再分配给缺页进程</p></li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20241121194614305.png"></p><ul><li><strong>全局置换</strong>意味着一个进程拥有的物理块数量必然会改变，因此<strong>不可能是固定分配</strong></li><li><strong>固定分配局部置换</strong><ul><li>系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面</li><li>这种策略的缺点是：很难在刚开始就确定应为每个进程分配多少个物理块才算合理</li><li>采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数</li></ul></li><li><strong>可变分配全局置换</strong><ul><li>刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个<strong>未锁定的页面</strong>换出外存，再将该物理块分配给缺页的进程<ul><li>系统会锁定一些页面，这些页面中 的内容不能置换出外存（如：重要的内核数据可以设为“锁定”）</li></ul></li><li>采用这种策略时，只要某进程发生缺页，都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，缺页率会增加</li><li>可变分配<strong>全局</strong>置换：只要缺页就给分配新物理块</li></ul></li><li><strong>可变分配局部置换</strong><ul><li>刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。</li><li>如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度；反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块</li><li>可变分配<strong>局部</strong>置换：要根据发生缺页的频率来动态地增加或减少进程的物理块</li></ul></li></ul><h3 id="何时调入页面">4.3 <strong>何时调入页面</strong></h3><ul><li><strong>预调页策略</strong><ul><li>根据<strong>局部性原理</strong>，一次调入若干个相邻的页面可能比一次调入一个页面更高效<ul><li>主要指<strong>空间局部性</strong>，即：如果当前访问了某个内存单元，在之后很有可能会接着访问与其相邻的那些内存单元</li></ul></li><li>但如果提前调入的页面中大多数都没被访问过，则又是低效的，因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有50%左右</li><li>故这种策略<strong>主要用于进程的首次调入</strong>，由程序员指出应该先调入哪些部分<ul><li>运行前调入</li></ul></li></ul></li><li><strong>请求调页策略</strong><ul><li>进程<strong>在运行期间发现缺页时才将所缺页面调入内存</strong><ul><li>运行时调入</li></ul></li><li>由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘I/O操作，因此I/O开销较大</li></ul></li></ul><h3 id="从何处调入页面">4.4 <strong>从何处调入页面</strong></h3><ul><li><p>系统<strong>拥有足够的对换区空间</strong>：页面的调入、调出都是在<strong>内存</strong>与<strong>对换区</strong>之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前，需将进程相关的数据从<strong>文件区</strong>复制到<strong>对换区</strong></p><ul><li><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20241121195220873.png"></li></ul></li><li><p>系统<strong>缺少足够的对换区空间</strong>：凡是不会被修改的数据都直接从<strong>文件区</strong>调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从<strong>文件区</strong>调入即可。对于可能被修改的部分，换出时需写回磁盘<strong>对换区</strong>，下次需要时再从<strong>对换区</strong>调入</p></li><li><p><strong>UNIX方式</strong>：运行之前进程有关的数据全部放在<strong>文件区</strong>，故未使用过的页面，都可从<strong>文件区</strong>调入。若被使用过的页面需要换出，则写回<strong>对换区</strong>，下次需要时从<strong>对换区</strong>调入</p></li></ul><h3 id="抖动颠簸现象">4.5 <strong>抖动（颠簸）现象</strong></h3><ul><li><p>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为<strong>抖动(颠簸)</strong></p></li><li><p>产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数（<strong>分配给进程的物理块不够</strong>）</p><ul><li>为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率</li><li>为了研究为应该为每个进程分配多少个物理块，Denning提出了进程“<strong>工作集</strong>”的概念</li></ul></li></ul><h3 id="工作集">4.6 <strong>工作集</strong></h3><ul><li><p><strong>驻留集</strong>：指请求分页存储管理中给<strong>进程分配的内存块的集合</strong></p></li><li><p><strong>工作集</strong>：指在某段时间间隔里，<strong>进程实际访问页面的集合</strong></p></li><li><p><strong>工作集大小可能小于窗口尺寸</strong>，实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若干内存块</p></li><li><p>如：窗口尺寸为5，经过一段时间的监测发现某进程的工作集最大为3，那么说明该进程有很好的局部性，可以给这个进程分配3个以上的内存块即可满足进程的运行需要。一般来说，<strong>驻留集大小不能小于工作集大小</strong>，否则进程运行过程中将频繁缺页</p></li><li><p>拓展：</p><ul><li>基于局部性原理可知，进程在一段时间内访问的页面与不久之后会访问的页面是有相关性的。因此，可以根据进程近期访问的页面集合（工作集）来设计一种页面置换算法-- 选择一个不在工作集中的页面进行淘汰</li></ul></li></ul><h2 id="内存映射文件"><strong>5. 内存映射文件</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20241121200153539.png"></p><h3 id="内存映射文件memory-mapped-files">5.1<strong>内存映射文件（Memory-Mapped Files）</strong></h3><ul><li><strong>内存映射文件</strong>：操作系统向上层程序员提供的功能（<strong>系统调用</strong>）<ul><li>方便程序员访问文件数据<ul><li><strong>传统的文件访问方式</strong></li></ul></li></ul></li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20241121195856882.png"></p><ul><li><strong>内存映射文件的访问方式</strong></li><li><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20241121200028984.png"></li><li>方便多个进程共享同一个文件</li><li><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20241121200139553.png"></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第三章 内存管理-3.1 内存管理概念</title>
    <link href="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/"/>
    <url>/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="内存管理"><strong>3.1 内存管理</strong></h1><h2 id="内存的基础知识"><strong>1. 内存的基础知识</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121102355539.png"></p><h3 id="什么是内存-有何作用">1.1 <strong>什么是内存?有何作用?</strong></h3><ul><li><p>内存可存放数据,程序执行前<strong>需要先放到内存中才能被CPU处理</strong> --缓和CPU与硬盘之间的速度矛盾</p></li><li><p>在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。那么，<strong>如何区分各个程序的数据是放在什么地方的呢?</strong></p><ul><li>方案：<strong>给内存的存储单元编地址</strong></li><li>内存中也有一个一个的“小房间”，每个小房间就是一个“<strong>存储单元</strong>"</li><li><strong>内存地址</strong>从0开始，每个地址对应一个存储单元</li><li>如果计算机“<strong>按字节编址</strong>"，则每个存储单元大小为1字节，即 1B，即 8个二进制位</li><li>如果字长为16位的计算机“<strong>按字编址</strong>”，则每个存储单元大小为1个字，每个字的大小为 16 个二进制位</li></ul></li><li><p>补充知识:</p><ul><li>2<sup>10</sup> = 1K（千）</li><li>2<sup>20</sup> = 1M（兆，百万）</li><li>2<sup>30</sup> = 1G（十亿，千兆）</li><li>注:有的题目会告诉我们内存的大小，让我们确定地址长度应该是多少（即要多少个二进制位才能表示相应数目的存储单元）<ul><li>Q: 一台手机/电脑 有 4GB 内存，是什么意思？</li><li>A: 是指该内存中可以存放 4 *2<sup>30</sup>个字节。如果是按字节编址的话，也就是有 4 * 2<sup>30</sup>= 2<sup>32</sup>个“小房间”，这么多“小房间”，需要2<sup>32</sup>个地址才能一一标识，所以地址需要用 32个二进制位来表示（0~2<sup>32</sup> -1）</li></ul></li></ul></li></ul><h3 id="指令的工作原理">1.2 <strong>指令的工作原理</strong></h3><ul><li><p>指令: 操作码 + 若干参数(可能包含地址参数)</p></li><li><p>指令的工作基于“地址”。每个地址对应一个数据的存储单元</p></li><li><p>我们写的代码要翻译成CPU能识别的指令。这些指令会告诉CPU应该去内存的哪个地址读/写数据，这个数据应该做什么样的处理</p></li></ul><h3 id="逻辑地址-vs-物理地址">1.3 <strong>逻辑地址 vs物理地址</strong></h3><ul><li><p><strong>物理地址（绝对地址）</strong>即内存中的实际地址</p></li><li><p>程序经过编译、链接后生成的指令中指明的是<strong>逻辑地址（相对地址）</strong></p><ul><li>即：相对于进程的起始地址而言的地址</li></ul></li></ul><h3 id="从写程序到程序运行">1.4 <strong>从写程序到程序运行</strong></h3><ul><li><p><strong>编译</strong>：由编译程序将用户源代码编译成<strong>若干个目标模块</strong>（编译就是<strong>把高级语言翻译为机器语言</strong>）</p></li><li><p><strong>链接</strong>：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的<strong>装入模块</strong></p></li><li><p><strong>装入</strong>（装载）：由装入程序<strong>将装入模块装入内存</strong>运行</p></li></ul><h3 id="链接的三种方式">1.5 <strong>链接的三种方式</strong></h3><ul><li><strong>静态链接</strong><ul><li><strong>在程序运行之前</strong>，先将各目标模块及它们所需的库函数连接成一个<strong>完整的可执行文件（装入模块）</strong>，之后不再拆开</li></ul></li><li><strong>装入时动态链接</strong><ul><li>将各目标模块装入内存时，<strong>边装入边链接</strong>的链接方式</li></ul></li><li><strong>运行时动态链接</strong><ul><li><strong>在程序执行中需要该目标模块时，才对它进行链接</strong></li><li>其优点是便于修改和更新，便于实现对目标模块的共享</li></ul></li></ul><h3 id="装入的三种方式">1.6 <strong>装入的三种方式</strong></h3><ul><li><strong>绝对装入</strong><ul><li>在<strong>编译</strong>时，如果知道程序将放到内存中的哪个位置，编译程序<strong>将产生绝对地址</strong>的目标代码，装入程序按照装入模块中的地址，将程序和数据装入内存</li><li>绝对装入只适用于<strong>单道程序环境</strong></li><li>程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址</li></ul></li><li><strong>静态重定位(可重定位装入)</strong><ul><li>编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。<strong>装入</strong>时对地址进行“重定位”，<strong>将逻辑地址变换为物理地址</strong>（地址变换是在装入时一次完成的）</li><li><strong>静态重定位</strong>的特点是在一个<strong>作业装入内存时，必须分配其要求的全部内存空间</strong>，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。</li></ul></li><li><strong>动态重定位(动态运行时转入)</strong><ul><li>编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把<strong>地址转换推迟到程序真正要执行时才进行</strong>。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个<strong>重定位寄存器</strong>的支持</li><li>重定位寄存器：存放装入模块存放的起始位置</li></ul></li><li>采用<strong>动态重定位</strong>时<strong>允许程序在内存中发生移动</strong><ul><li>可将程序分配到不连续的存储区中</li><li>在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存</li><li>便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间</li></ul></li></ul><h2 id="内存管理的概念"><strong>2. 内存管理的概念</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121103658059.png"></p><h3 id="内存管理-1">2.1 <strong>内存管理</strong></h3><ul><li>操作系统作为系统资源的管理者，当然也需要对内存进行管理，要管些什么呢？<ul><li>操作系统负责<strong>内存空间的分配与回收</strong></li><li>操作系统需要提供某种技术从逻辑上<strong>对内存空间进行扩充</strong></li><li>操作系统需要提供<strong>地址转换功能</strong>，负责程序的逻辑地址与物理地址的转换</li><li>操作系统需要提供<strong>内存保护</strong>功能。保证各进程在各自存储空间内运行，互不干扰</li></ul></li></ul><h3 id="内存空间的分配与回收">2.2<strong>内存空间的分配与回收</strong></h3><ul><li><p>操作系统要怎么记录哪些内存区域已经被分配出去了，哪些又还空闲？</p></li><li><p>很多位置都可以放，那应该放在哪里？</p></li><li><p>当进程运行结束之后，如何将进程占用的内存空间回收？</p></li><li><p><strong>分配方式</strong>:</p><ul><li><strong>连续分配管理方式</strong><ul><li><strong>连续分配</strong>：<strong>指为用户进程分配的必须是一个连续的内存空间</strong></li><li><strong>单一连续分配</strong>、<strong>固定分区分配</strong>、<strong>动态分区分配</strong></li></ul></li><li><strong>非连续分配管理方式</strong><ul><li><strong>非连续分配</strong>：<strong>指为用户进程分配的可以是一些分散的内存空间</strong></li><li><strong>基本分页存储管理</strong>、<strong>基本分段存储管理</strong>、<strong>段页式存储管理</strong></li></ul></li></ul></li></ul><h3 id="内存空间的扩充">2.3 <strong>内存空间的扩充</strong></h3><ul><li><p>实现虚拟性</p></li><li><p>实现内存空间扩充的相关技术:<strong>覆盖技术</strong>、<strong>交换技术</strong>、<strong>虚拟存储技术</strong></p></li></ul><h3 id="地址转化">2.4 <strong>地址转化</strong></h3><ul><li><p>为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而<strong>逻辑地址到物理地址的转换</strong>（这个过程称为<strong>地址重定位</strong>）应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况</p></li><li><p>三种装入方式:</p><ul><li><strong>绝对装入</strong>: 单道程序阶段，此时还没产生操作系统</li><li><strong>可重定位装入(静态重定位)</strong>:用于早期的多道批处理操作系统</li><li><strong>动态运行时转入(动态重定位)</strong>: 现代操作系统</li></ul></li></ul><h3 id="内存保护">2.5 <strong>内存保护</strong></h3><ul><li>内存保护可采取两种方法：<ul><li>方法一：在CPU中设置一对<strong>上、下限寄存器</strong>，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界<ul><li>假设进程1的逻辑地址空间为 0~179；实际物理地址空间为 100~279</li><li>则上限寄存器存放100, 下限寄存器存放279</li></ul></li><li>方法二：采用<strong>重定位寄存器</strong>（又称<strong>基址寄存器</strong>）和<strong>界地址寄存器</strong>（又称<strong>限长寄存器</strong>）进行越界检查。<strong>重定位寄存器中存放的是进程的起始物理地址</strong>。<strong>界地址寄存器中存放的是进程的最大逻辑地址</strong><ul><li>假设进程1的逻辑地址空间为 0~179；实际物理地址空间为 100~279</li><li>则重定位寄存器存放100, 界地址寄存器存放179</li><li>CPU先通过界地址寄存器判断指令有没有越界,没有的话再通过重定位寄存器计算物理地址</li></ul></li></ul></li></ul><h2 id="覆盖与交换"><strong>3. 覆盖与交换</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121104512608.png"></p><h3 id="覆盖技术">3.1 <strong>覆盖技术</strong></h3><ul><li><p>早期的计算机内存很小，比如 IBM 推出的第一台PC机最大只支持 1MB大小的内存。因此经常会出现内存大小不够的情况。后来人们引入了<strong>覆盖技术</strong>，用来解决“程序大小超过物理内存总和”的问题</p></li><li><p>覆盖技术的思想:</p><ul><li><strong>将程序分为多个段</strong>（多个模块），常用的段常驻内存，不常用的段在需要时调入内存</li><li>内存中分为一个“<strong>固定区</strong>”和若干个“<strong>覆盖区</strong>”</li><li>需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束）</li><li>不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存</li><li>程序按照自身逻辑结构，让那些不可能同时被访问的程序段共享同一个覆盖区</li></ul></li><li><p>缺点:</p><ul><li>必须由程序员声明覆盖结构，操作系统完成自动覆盖。对用户不透明，增加了用户编程负担</li><li>覆盖技术<strong>只用于早期的操作系统中</strong>，现在已成为历史</li></ul></li></ul><h3 id="交换对换技术">3.2 <strong>交换(对换)技术</strong></h3><ul><li><p>内存空间紧张时，系统将<strong>内存</strong>中某些<strong>进程</strong>暂时<strong>换出外存</strong>，把<strong>外存</strong>中某些已具备运行条件的<strong>进程换入内存</strong>（进程在内存与磁盘间动态调度）</p></li><li><p><strong>中级调度（内存调度）</strong>，就是要决定将哪个处于挂起状态的进程重新调入内存</p></li><li><p><strong>思考</strong>:</p><ul><li>应该在外存（磁盘）的什么位置保存被换出的进程？<ul><li>具有对换功能的操作系统中，通常把<strong>磁盘空间</strong>分为<strong>文件区</strong>和<strong>对换区</strong>两部分</li><li><strong>文件区</strong>主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用<strong>离散分配方式</strong></li><li><strong>对换区</strong>空间只占磁盘空间的小部分，<strong>被换出的进程数据就存放在对换区</strong>。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用<strong>连续分配方式</strong>(学过<strong>文件管理</strong>章节后即可理解)，总之，<strong>对换区的I/O速度比文件区的更快</strong></li></ul></li><li>什么时候应该交换？<ul><li>交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停</li><li>例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出</li></ul></li><li>应该换出哪些进程？<ul><li>可优先换出阻塞进程；可换出优先级低的进程；</li><li>为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间…</li></ul></li></ul></li><li><p><strong>注意</strong>：<strong>PCB会常驻内存</strong>，不会被换出外存</p></li></ul><h2 id="连续分配管理方式"><strong>4. 连续分配管理方式</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121110518884.png"></p><ul><li><strong>连续分配</strong>：<strong>指为用户进程分配的必须是一个连续的内存空间</strong></li></ul><h3 id="单一连续分配">4.1 <strong>单一连续分配</strong></h3><ul><li><p>在<strong>单一连续分配方式</strong>中，<strong>内存</strong>被分为<strong>系统区</strong>和<strong>用户区</strong>。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。内存中只能有一道用户程序，<strong>用户程序独占整个用户区空间</strong></p></li><li><p>优点：实现简单；<strong>无外部碎片</strong>；可以采用覆盖技术扩充内存；不一定需要采取内存保护（eg：早期的PC 操作系统 MS-DOS）</p></li><li><p>缺点：只能用于单用户、单任务的操作系统中；<strong>有内部碎片</strong>；存储器利用率极低</p><ul><li><strong>内部碎片</strong>：分配给某进程的内存区域中，如果有些部分没有用上</li><li><strong>外部碎片</strong>：内存中的某些空闲分区由于太小而难以利用</li></ul></li></ul><h2 id="固定分区分配">4.2 <strong>固定分区分配</strong></h2><ul><li><p>20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个<strong>用户空间</strong>划分为<strong>若干个固定大小的分区</strong>，在<strong>每个分区中只装入一道作业</strong>，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式</p></li><li><p><strong>分区大小相等</strong></p><ul><li>缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合（比如：钢铁厂有n个相同的炼钢炉，就可把内存分为n个大小相等的区域存放n个炼钢炉控制程序）</li></ul></li><li><p><strong>分区大小不等</strong></p><ul><li>增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分</li><li>比如：划分多个小分区、适量中等分区、少量大分区</li></ul></li><li><p>操作系统需要建立一个数据结构 --<strong>分区说明表</strong>，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态（是否已分配）。当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”</p></li><li><p>优点：实现简单，<strong>无外部碎片</strong></p></li><li><p>缺点：</p><ul><li><ol type="a"><li>当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能</li></ol></li><li><ol start="2" type="a"><li><strong>会产生内部碎片</strong>，内存利用率低</li></ol></li></ul></li></ul><h3 id="动态分区分配可变分区分配">4.3<strong>动态分区分配</strong>(可变分区分配)</h3><ul><li><p>这种分配方式<strong>不会预先划分内存分区</strong>，而是<strong>在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要</strong>。因此系统分区的大小和数目是可变的</p></li><li><p><strong>思考</strong>:</p><ul><li>系统要用什么样的数据结构记录内存的使用情况？<ul><li>可以通过<strong>空闲分区表</strong>或<strong>空闲分区链</strong>这两种数据结构记录内存使用情况</li><li><strong>空闲分区表</strong>:每个空闲分区对应一个表项。表项中包含分区号、分区大小、分区起始地址等信息</li><li><strong>空闲分区链</strong>:每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息</li></ul></li><li>当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？<ul><li>把一个新作业装入内存时，须按照一定的<strong>动态分区分配算法</strong>，从空闲分区表（或空闲分区链）中选出一个分区分配给该作业</li><li>由于分配算法算法对系统性能有很大的影响，因此人们对它进行了广泛的研究</li></ul></li><li>如何进行分区的分配与回收操作？<ul><li>假设系统采用的数据结构是“空闲分区表”<ul><li>分配<ul><li>可以根据实际分配情况,对空闲分区表进行分区大小修改、删除表项等操作</li></ul></li><li>回收<ul><li>可以根据实际回收情况,对空闲分区表进行合并表项(回收的区域有相邻的空白表项)、新增表项等操作</li></ul></li><li>注：各表项的顺序不一定按照地址递增顺序排列，具体的排列方式需要依据动态分区分配算法来确定</li></ul></li></ul></li></ul></li><li><p><strong>动态分区分配没有内部碎片，但是有外部碎片</strong></p><ul><li>如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些</li><li>“碎片”不能满足进程的需求。可以通过<strong>紧凑（拼凑，Compaction）技术来解决外部碎片</strong></li><li>"紧凑"之后需要把进程的起始地址修改,<strong>进程的起始地址</strong>存放在<strong>PCB</strong>当中,进程上CPU运行之前,会把进程的起始地址放到<strong>重定位寄存器</strong>里</li></ul></li><li><p><strong>动态分区分配</strong>应该采用<strong>动态运行时装入(动态重定位)</strong></p><ul><li>因为通过紧凑技术会导致进程起始地址发生变化,而动态重定位允许程序在内存中发生移动</li></ul></li></ul><h2 id="动态分区分配算法"><strong>5. 动态分区分配算法</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121111606972.png"></p><p><strong>动态分区分配算法</strong>: <strong>在动态分区分配方式中，当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配</strong></p><h3 id="首次适应算法first-fit">5.1 <strong>首次适应算法</strong>(FirstFit)</h3><ul><li><p>算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区</p></li><li><p>如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p></li><li><p>优点：首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来（最佳适应算法的优点）</p></li></ul><h3 id="最佳适应算法best-fit">5.2 <strong>最佳适应算法</strong>(BestFit)</h3><ul><li><p>算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区</p></li><li><p>如何实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p></li><li><p>缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片</p></li></ul><h3 id="最坏适应算法worst-fit">5.3 <strong>最坏适应算法</strong>(WorstFit)</h3><ul><li><p>又称 最大适应算法（Largest Fit）</p></li><li><p>算法思想：为了解决最佳适应算法的问题 --即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用</p></li><li><p>如何实现：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p></li><li><p>缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了</p></li></ul><h3 id="邻近适应算法next-fit">5.4 <strong>邻近适应算法</strong>(NextFit)</h3><ul><li><p>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题</p></li><li><p>如何实现：空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p></li><li><p>缺点：邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用（最大适应算法的缺点）</p></li></ul><p>综合来看，<strong>四种算法中，首次适应算法的效果反而更好</strong></p><h2 id="基本分页存储管理的概念"><strong>6.基本分页存储管理的概念</strong></h2><ul><li><strong>非连续分配</strong>：<strong>指为用户进程分配的可以是一些分散的内存空间</strong></li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121123601201.png"></p><h3 id="什么是分页存储">6.1 <strong>什么是分页存储?</strong></h3><ul><li><p>将<strong>内存空间</strong>分为一个个<strong>大小相等的分区</strong>（比如：每个分区4KB），每个分区就是一个“<strong>页框(PageFrame)</strong>”（<strong>页框</strong>=<strong>页帧</strong>=<strong>内存块</strong>=<strong>物理块</strong>=<strong>物理页面</strong>）。每个页框有一个编号，即“<strong>页框号</strong>”（<strong>页框号</strong>=<strong>页帧号</strong>=<strong>内存块号</strong>=<strong>物理块号</strong>=<strong>物理页号</strong>），<strong>页框号从0开始</strong></p></li><li><p>将<strong>进程的逻辑地址空间</strong>也分为<strong>与页框大小相等</strong>的一个个部分，每个部分称为一个“<strong>页</strong>”或“<strong>页面</strong>”。每个页面也有一个编号，即“<strong>页号</strong>”，<strong>页号也是从0开始</strong></p></li><li><p>注意区分 <strong>页框</strong> vs <strong>页</strong>的概念</p></li><li><p>操作系统<strong>以页框为单位为各个进程分配内存空间</strong>。进程的每个页面分别放入一个页框中。也就是说，进程的<strong>页面</strong>与内存的<strong>页框</strong>有一一对应的关系。<strong>各个页面不必连续存放，可以放到不相邻的各个页框中</strong></p><ul><li>注：进程的最后一个页面可能没有一个页框那么大。也就是说，<strong>分页存储有可能产生内部碎片</strong>，因此页框不能太大，否则可能产生过大的内部碎片造成浪费</li></ul></li></ul><h3 id="页表">6.2 <strong>页表</strong></h3><ul><li>为了能知道进程的每个<strong>页面</strong>在内存中存放的位置，操作系统要为每个进程建立一张<strong>页表</strong><ul><li>注：页表通常存在<strong>PCB</strong>（进程控制块）中</li></ul></li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121112224337.png"></p><h3 id="每个页表项多大占几个字节">6.3<strong>每个页表项多大？占几个字节？</strong></h3><ul><li><p>Eg：假设某系统物理内存大小为 4GB，页面大小为4KB，则每个页表项至少应该为多少字节？</p></li><li><p>内存块大小=页面大小=4KB= 2<sup>12</sup>B</p><ul><li>4GB 的内存总共会被分为 2<sup>32</sup> / 2<sup>12</sup> =2<sup>20</sup>个内存块</li><li>内存块号的范围应该是 0 ~ 2<sup>20</sup> -1</li><li>内存块号至少要用 20 bit 来表示</li><li>内存按字节编址, 则至少要用3B来表示<strong>块号</strong>（3*8=24bit）<ul><li><strong>注意</strong>：页表记录的只是内存块号，而不是内存块的起始地址！<ul><li>j 号内存块的起始地址 = j * 内存块大小</li></ul></li><li><strong>重要考点</strong>：计算机中内存块的数量 →页表项中块号至少占多少字节</li></ul></li></ul></li><li><p><strong>页表项连续存放</strong>，因此<strong>页号可以是隐含的，不占存储空间（类比数组）</strong></p><ul><li>假设页表中的各页表项从内存地址为 X的地方开始连续存放，如何找到页号为 i 的页表项？</li><li>i 号页表项的存放地址 = X + i * 页表项大小</li></ul></li></ul><h3 id="如何通过页表实现逻辑地址到物理地址的转换">6.4<strong>如何通过页表实现逻辑地址到物理地址的转换？</strong></h3><ul><li><strong>进程在内存中连续存放时</strong>，操作系统是如何实现逻辑地址到物理地址的转换的？<ul><li><strong>重定位寄存器</strong>：指明了进程在内存中的起始位置</li><li>物理地址 = 进程在内存中的起始位置 + 逻辑地址</li><li>逻辑地址相对于起始位置的“偏移量”</li></ul></li><li>将进程地址空间<strong>分页</strong>之后，操作系统该如何实现逻辑地址到物理地址的转换？<ul><li>特点：虽然进程的各个<strong>页面是离散存放的</strong>，但是<strong>页面内部是连续存放的</strong></li><li>如果要访问逻辑地址 A，则:<ul><li>确定逻辑地址A 对应的“<strong>页号</strong>”P</li><li>找到P号页面在内存中的起始地址<ul><li>通过查找页表，找到页号P对应的内存块号，计算出内存块号在内存中的起始地址</li></ul></li><li>确定逻辑地址A 的“<strong>页内偏移量</strong>”W</li></ul></li><li>逻辑地址A 对应的物理地址 = P号页面在内存中的起始地址 +页内偏移量W</li></ul></li></ul><h3 id="如何确定一个逻辑地址对应的页号页内偏移量">6.5<strong>如何确定一个逻辑地址对应的页号、页内偏移量？</strong></h3><ul><li><p>Eg：在某计算机系统中，页面大小是50B。某进程逻辑地址空间大小为200B，则逻辑地址110 对应的页号、页内偏移量是多少？</p><ul><li>页号 = 110 / 50 = 2</li><li>页内偏移量 = 110 % 50 = 10</li></ul></li><li><p>页号 = 逻辑地址 / 页面长度 （取除法的整数部分）</p></li><li><p>页内偏移量 = 逻辑地址 % 页面长度（取除法的余数部分）</p></li><li><p><strong>逻辑地址 可以拆分为（页号，页内偏移量）</strong></p></li><li><p>当<strong>页面大小</strong>刚好是<strong>2的整数幂时</strong>:</p></li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121123228264.png"></p><ul><li><strong>总结：页面大小 刚好是 2的整数幂 有什么好处？</strong><ul><li>逻辑地址的拆分更加迅速 -- 如果每个页面大小为2KB，用二进制数表示逻辑地址，则末尾 K位即为页内偏移量，其余部分就是页号。因此，如果让每个页面的大小为 2的整数幂，计算机硬件就可以很方便地得出一个逻辑地址对应的页号和页内偏移量，而无需进行除法运算，从而提升了运行速度</li><li>物理地址的计算更加迅速 --根据逻辑地址得到页号，根据页号查询页表从而找到页面存放的内存块号，将二进制表示的内存块号和页内偏移量拼接起来，就可以得到最终的物理地址</li></ul></li></ul><h3 id="逻辑地址结构">6.6 <strong>逻辑地址结构</strong></h3><ul><li>页面大小刚好是2的整数幂时：</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121123548986.png"></p><ul><li>Tips：有些奇葩题目中<strong>页面大小有可能不是2的整数次幂</strong>，这种情况还是得用最原始的方法计算：<ul><li>页号 = 逻辑地址 / 页面长度 （取除法的整数部分）</li><li>页内偏移量 = 逻辑地址 % 页面长度（取除法的余数部分）</li></ul></li></ul><h2 id="基本地址变换机构"><strong>7. 基本地址变换机构</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121125306825.png"></p><ul><li><strong>基本地址变换机构</strong>：<strong>用于实现逻辑地址到物理地址转换的一组硬件机构</strong></li></ul><h3 id="页表寄存器">7.1 <strong>页表寄存器</strong></h3><ul><li><p><strong>基本地址变换机构</strong>可以借助进程的<strong>页表</strong>将逻辑地址转换为物理地址</p></li><li><p>通常会在系统中设置一个<strong>页表寄存器</strong>(PTR)，存放<strong>页表在内存中的起始地址F</strong>和<strong>页表长度M</strong></p></li><li><p>进程未执行时，页表的始址和页表长度放在<strong>PCB</strong>(进程控制块)中，当进程被调度时，操作系统内核会把它们放到页表寄存器中</p></li></ul><h3 id="设页面大小为l逻辑地址a到物理地址e的变换过程如下">7.2<strong>设页面大小为L，逻辑地址A到物理地址E的变换过程如下</strong>：</h3><ul><li><p>注意: 页面大小是2的整数幂</p></li><li><p>计算<strong>页号P</strong>和<strong>页内偏移量W</strong></p><ul><li>如果用十进制数手算，则 P = A / L， W = A % L</li><li>但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量</li></ul></li><li><p>比较页号P和页表长度M，若 P ≥ M， 则产生越界中断，否则继续执行</p><ul><li>注意：页号是从0开始的，而页表长度至少是1，因此P=M时也会越界</li></ul></li><li><p>页表中页号P对应的 页表项地址 = 页表起始地址F + 页号P * 页表项长度，取出该页表项内容b，即为内存块号</p><ul><li>注意区分<strong>页表项长度</strong>、<strong>页表长度</strong>、<strong>页面大小</strong>的区别</li><li>页表长度：指的是这个页表中总共有几个页表项，即总共有几个页</li><li>页表项长度：指的是每个页表项占多大的存储空间</li><li>页面大小：指的是一个页面占多大的存储空间</li></ul></li><li><p>计算 E = b * L + W，用得到的物理地址E去访存</p><ul><li>如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了</li></ul></li><li><p><strong>动手验证</strong>：</p><ul><li>假设页面大小L = 1KB，最终要访问的内存块号b = 2，页内偏移量W =1023</li><li>① 尝试用E = b * L + W计算目标物理地址</li><li>②尝试把内存块号、页内偏移量用二进制表示，并把它们拼接起来得到物理地址</li><li>对比①、②的结果是否一致</li></ul></li></ul><p><strong>例题</strong>：</p><ul><li>在<strong>分页存储管理</strong>(页式管理)的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，<strong>页式管理中地址是一维的</strong><ul><li>即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位</li></ul></li></ul><h3 id="页表项大小">7.3 <strong>页表项大小</strong></h3><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121125207912.png"></p><h2 id="具有快表的地址变换机构"><strong>8.具有快表的地址变换机构</strong></h2><ul><li><strong>具有快表的地址变换机构</strong>：<strong>是基本地址变换机构的改进版本</strong></li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121163126476.png"></p><h3 id="什么是快表tlb">8.1 <strong>什么是快表(TLB)?</strong></h3><ul><li><strong>快表</strong>，又称<strong>联想寄存器（TLB， translationlookasidebuffer）</strong>，是一种访问速度比内存快很多的<strong>高速缓存</strong>（<strong>TLB不是内存！</strong>），用来存放最近访问的页表项的副本，可以加速地址变换的速度。与此对应，<strong>内存中的页表</strong>常称为<strong>慢表</strong></li><li><strong>引入快表后的地址变换过程</strong>:<ul><li>CPU给出逻辑地址，由某个硬件算得<strong>页号</strong>、<strong>页内偏移量</strong>，将页号与<strong>快表</strong>中的所有页号进行比较</li><li>如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的<strong>内存块号</strong>，再<strong>将内存块号与页内偏移量拼接形成物理地址</strong>，最后，访问该物理地址对应的<strong>内存单元</strong>。因此，<strong>若快表命中</strong>，则访问某个逻辑地址<strong>仅需一次访存</strong>即可</li><li>如果没有找到匹配的页号，则需要访问<strong>内存中的页表</strong>，找到对应页表项，得到页面存放的<strong>内存块号</strong>，再<strong>将内存块号与页内偏移量拼接形成物理地址</strong>，最后，访问该物理地址对应的<strong>内存单元</strong>。因此，<strong>若快表未命中</strong>，则<strong>访问某个逻辑地址需要两次访存</strong><ul><li>注意：<strong>在找到页表项后，应同时将其存入快表</strong>，以便后面可能的再次访问。<strong>若快表己满，则必须按照一定的算法对旧的页表项进行替换</strong></li></ul></li><li>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间</li><li>因为<strong>局部性原理</strong>，一般来说快表的命中率可以达到90%以上<ul><li>例：某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时1us，访问一次内存耗100us。若快表的命中率为90%，那么访问一个逻辑地址的平均耗时是多少?<ul><li>(1 + 100) * 0.9 + (1 + 100 + 100) * 0.1 = 111 us</li><li><strong>有的系统支持快表和慢表同时查找</strong>，如果是这样，平均耗时应该是：</li><li>(1 + 100) * 0.9 + (100 + 100) * 0.1 = 110.9 us</li><li>若未采用快表机制，则访问一个逻辑地址需要：</li><li>100 + 100 = 200us</li><li>显然，引入快表机制后，访问一个逻辑地址的速度快多了</li></ul></li></ul></li></ul></li></ul><h3 id="局部性原理">8.2 <strong>局部性原理</strong></h3><ul><li><strong>时间局部性</strong><ul><li>如果执行了程序中的某条<strong>指令</strong>，那么不久后这条指令很有可能再次执行；如果某个<strong>数据</strong>被访问过，不久之后该数据很可能再次被访问（因为程序中存在大量的循环）</li></ul></li><li><strong>空间局部性</strong><ul><li>一旦程序访问了某个<strong>存储单元</strong>，在不久之后，其附近的存储单元也很有可能被访问（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）</li></ul></li><li>上小节介绍的基本地址变换机构中，每次要访问一个逻辑地址，都需要查询内存中的页表。由于局部性原理，可能连续很多次查到的都是同一个页表项</li></ul><h2 id="两级页表"><strong>9. 两级页表</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121165419159.png"></p><h3 id="单级页表存在的问题">9.1 <strong>单级页表存在的问题</strong></h3><ul><li>某计算机系统按字节寻址，支持 32位的逻辑地址，采用分页存储管理，页面大小为4KB，页表项长度为 4B<ul><li>4KB = 2<sup>12</sup>B，因此页内地址要用12位表示，剩余 20位表示页号</li><li>因此，该系统中用户进程最多有 2<sup>20</sup>页。相应的，一个进程的页表中，最多会有 2<sup>20</sup> = 1M =1,048,576个页表项，所以一个页表最大需要 2<sup>20</sup> * 4B =2<sup>22</sup>B，共需要 2<sup>22</sup> / 2<sup>12</sup> =2<sup>10</sup>个页框存储该页表，需要专门给进程分配2<sup>10</sup> =<strong>1024个连续的页框</strong>来存放它的页表</li><li>根据页号查询页表的方法：K 号页对应的 页表项存放位置 = 页表始址 + K *4</li><li><strong>要在所有的页表项都连续存放的基础上才能用这种方法找到页表项</strong></li><li>根据<strong>局部性原理</strong>可知，很多时候，进程在一段时间内只需要访问某几个页面就可以正常运行了，因此没有必要让整个页表都常驻内存</li></ul></li><li>问题一：<strong>页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框</strong><ul><li>思考：我们是如何解决进程在内存中必须连续存储的问题？<ul><li>将进程地址空间分页，并为其建立一张页表，记录各页面的存放位置</li><li>同样的思路也可用于解决“页表必须连续存放”的问题，把必须连续存放的页表再分页</li><li>可将长长的页表进行分组，<strong>使每个内存块刚好可以放入一个分组</strong>（比如上面的例子中，页面大小4KB，每个页表项4B，每个页面可存放1K个页表项，因此每1K个连续的页表项为一组，每组刚好占一个内存块，再将各组离散地放到各个内存块中）</li><li>另外，要为离散分配的页表再建立一张页表，称为<strong>页目录表</strong>（又称<strong>外层页表</strong>或<strong>顶层页表</strong>）</li></ul></li></ul></li><li>问题二：<strong>没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面</strong><ul><li>可以在需要访问页面时才把页面调入内存（<strong>虚拟存储技术</strong>）,可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存</li><li>若想访问的页面不在内存中，则产生<strong>缺页中断（内中断/异常）</strong>，然后将目标页面从外存调入内存</li></ul></li></ul><h3 id="两级页表的原理地址结构">9.2<strong>两级页表的原理、地址结构</strong></h3><ul><li><strong>如何实现地址变换</strong><ul><li>按照地址结构将逻辑地址拆分成三部分（一级页号、二级页号、页内偏移量）</li><li>从PCB中读出页目录表始址，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置</li><li>根据二级页号查二级页表，找到最终想访问的内存块号</li><li>结合页内偏移量得到物理地址</li></ul></li></ul><h3 id="需要注意的几个细节">9.3 <strong>需要注意的几个细节</strong></h3><ul><li>若分为两级页表后，页表依然很长，则可以采用更多级页表，一般来说<strong>各级页表的大小不能超过一个页面</strong><ul><li>例：某系统按字节编址，采用 40 位逻辑地址，页面大小为4KB，页表项大小为4B，假设采用纯页式存储，则要采用（）级页表，页内偏移量为（）位？<ul><li>页面大小 = 4KB =2<sup>12</sup>B，按字节编址，因此页内偏移量为12位</li><li>页号 = 40 - 12 = 28 位</li><li>页面大小 = 2<sup>12</sup>B，页表项大小 = 4B，则每个页面可存放2<sup>12</sup> / 4 = 2<sup>10</sup>个页表项</li><li>因此各级页表最多包含2<sup>10</sup>个页表项，需要10位二进制位才能映射到2<sup>10</sup>个页表项</li><li>因此每一级的页表对应页号应为10位，总共28位的页号至少要分为三级<ul><li>如果只分为两级页表，则一级页号占 18 位，也就是说页目录表中最多可能有2<sup>18</sup> 个页表项，显然，一个页面是放不下这么多页表项的</li></ul></li></ul></li></ul></li><li>两级页表的访存次数分析（假设没有快表机构）<ul><li>第一次访存：访问内存中的页目录表</li><li>第二次访存：访问内存中的二级页表</li><li>第三次访存：访问目标内存单元</li></ul></li></ul><h2 id="基本分段存储管理方式"><strong>10.基本分段存储管理方式</strong></h2><ul><li><p><strong>基本分段存储管理</strong>：<strong>与“分页”最大的区别就是-- 离散分配时所分配地址空间的基本单位不同</strong></p></li><li><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121172738208.png"></p></li></ul><h3 id="分段">10.1 <strong>分段</strong></h3><ul><li><p>进程的地址空间：按照程序<strong>自身的逻辑</strong>关系<strong>划分为若干个段</strong>，每个段都有一个段名（在低级语言中，程序员使用段名来编程），<strong>每段从0开始编址</strong></p></li><li><p>内存分配规则：以段为单位进行分配，<strong>每个段在内存中占据连续空间，但各段之间可以不相邻</strong></p></li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121171112237.png"></p><ul><li>分段系统的<strong>逻辑地址</strong>结构由<strong>段号（段名）</strong>和<strong>段内地址（段内偏移量）</strong>组成。如：</li></ul><h3 id="段表">10.2 <strong>段表</strong></h3><ul><li>程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称“<strong>段表</strong>”</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121171506496.png"></p><h3 id="分段分页管理的区别">10.3<strong>分段、分页管理的区别</strong></h3><ul><li><p><strong>页</strong>是<strong>信息的物理单位</strong>。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，<strong>对用户是不可见的</strong></p></li><li><p><strong>段</strong>是<strong>信息的逻辑单位</strong>。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。<strong>分段对用户是可见的</strong>，用户编程时需要显式地给出段名</p></li><li><p>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序</p></li><li><p><strong>分页</strong>的用户进程<strong>地址空间是一维的</strong>，程序员只需给出一个记忆符即可表示一个地址</p></li><li><p><strong>分段</strong>的用户进程<strong>地址空间是二维的</strong>，程序员在标识一个地址时，既要给出段名，也要给出段内地址</p></li><li><p><strong>分段</strong>比分页<strong>更容易实现信息的共享和保护</strong></p><ul><li>只需让各进程的段表项指向同一个段即可实现共享；页面不是按逻辑模块划分的，这就很难实现共享</li><li>不能被修改的代码称为<strong>纯代码</strong>或<strong>可重入代码</strong>（不属于临界资源），这样的代码是可以共享的。可修改的代码是不能共享的（比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一致）</li></ul></li><li><p><strong>访问一个逻辑地址需要几次访存</strong>？</p><ul><li><strong>分页（单级页表）</strong>：第一次访存 --查内存中的页表，第二次访存 --访问目标内存单元。总共<strong>两次访存</strong></li><li><strong>分段</strong>：第一次访存 -- 查内存中的段表，第二次访存 --访问目标内存单元。总共<strong>两次访存</strong></li><li>与分页系统类似，分段系统中也可以引入<strong>快表</strong>机构，将近期访问过的段表项放到快表中，这样可以少一次访问，加快地址变换速度</li></ul></li></ul><h2 id="段页式管理方式"><strong>11. 段页式管理方式</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121182311141.png"></p><h3 id="分页分段的优缺点分析">11.1<strong>分页、分段的优缺点分析</strong></h3><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><strong>优点</strong></th><th style="text-align: center;"><strong>缺点</strong></th></tr></thead><tbody><tr><td style="text-align: center;">分页管理</td><td style="text-align: center;">内存空间利用率高，<strong>不会产生外部碎片</strong>，只会有少量的页内碎片</td><td style="text-align: center;">不方便按照逻辑模块实现信息的共享和保护</td></tr><tr><td style="text-align: center;">分段管理</td><td style="text-align: center;">很方便按照逻辑模块实现信息的共享和保护</td><td style="text-align: center;">如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理<strong>会产生外部碎片</strong></td></tr></tbody></table><ul><li>分段管理中产生的外部碎片也可以用“<strong>紧凑</strong>”来解决，只是需要付出较大的时间代价</li></ul><h3 id="分段-分页-段页式管理">11.2 <strong>分段 + 分页 =段页式管理</strong></h3><ul><li>将进程按逻辑模块分段，再将各段分页（如每个页面4KB)</li><li>再将内存空间分为大小相同的内存块/页框/页帧/物理块</li><li>进程前将各页面分别装入各内存块中</li></ul><h3 id="段页式管理的逻辑地址结构">11.3<strong>段页式管理的逻辑地址结构</strong></h3><ul><li><strong>分段系统</strong>的<strong>逻辑地址</strong>结构由<strong>段号（段名）</strong>和<strong>段内地址（段内偏移量）</strong>组成。如：</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121181503259.png"></p><ul><li><strong>段页式系统</strong>的<strong>逻辑地址</strong>结构由<strong>段号</strong>、<strong>页号</strong>、<strong>页内地址（页内偏移量）</strong>组成。如：<ul><li>段号的位数决定了每个进程最多可以分几个段</li><li>页号位数决定了每个段最大有多少页</li><li>页内偏移量决定了页面大小、内存块大小是多少</li></ul></li><li>在上述例子中，若系统是按字节寻址的，则<ul><li>段号占16位，因此在该系统中，每个进程最多有216=64K个段</li><li>页号占4位，因此每个段最多有24=16页</li><li>页内偏移量占12位，因此每个页面每个内存块大小为212=4096=4KB</li></ul></li></ul><h3 id="段表页表">11.4 <strong>段表、页表</strong></h3><ul><li>每个段对应一个段表项，每个段表项由段号、页表长度、页表存放块号（页表起始地址)组成。每个段表项长度相等，段号是隐含的。</li><li>每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，页号是隐含的。</li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121181902465.png"></p><h3 id="段页式管理地址变换过程">11.5<strong>段页式管理地址变换过程</strong></h3><ul><li><p>根据逻辑地址得到段号、页号、页内偏移量</p></li><li><p>判断段号是否越界。若S≥M,则产生越界中断，否则继续执行</p></li><li><p>查询段表找到对应的段表项，段表项的存放地址为F+S*段表项长度</p></li><li><p>检查页号是否越界，若页号≥页表长度，则发生越界中断，否则继续执行</p></li><li><p>根据页表存放块号、页号查询页表找到对应页表项</p></li><li><p>根据内存块号页内偏移量得到最终的物理地址</p></li><li><p>访问目标内存单元</p></li></ul><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121182242000.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.4 死锁</title>
    <link href="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-4-%E6%AD%BB%E9%94%81/"/>
    <url>/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-4-%E6%AD%BB%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="死锁"><strong>2.4 死锁</strong></h1><h2 id="死锁的概念"><strong>1. 死锁的概念</strong></h2><h3 id="什么是死锁">1.1 <strong>什么是死锁?</strong></h3><ul><li><p>在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“<strong>死锁</strong>“</p></li><li><p>发生死锁后若无外力干涉，这些进程都将无法向前推进</p></li></ul><h3 id="死锁饥饿死循环的区别">1.2<strong>死锁、饥饿、死循环的区别</strong></h3><ul><li><strong>死锁</strong><ul><li>各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象</li></ul></li><li><strong>饥饿</strong><ul><li>由于长期得不到想要的资源，某进程无法向前推进的现象。</li><li>比如: 在短进程优先(SPF)算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”</li></ul></li><li><strong>死循环</strong><ul><li>某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的</li></ul></li></ul><table><thead><tr><th></th><th style="text-align: center;"><strong>共同点</strong></th><th style="text-align: center;"><strong>区别</strong></th></tr></thead><tbody><tr><td>死锁</td><td style="text-align: center;">都是进程无法顺利向前推进的现象(故意设计的死循环除外)</td><td style="text-align: center;">死锁一定是“循环等待对方手里的资源”导致的，因此如果有死锁现象，那至少有两个或两个以上的进程同时发生死锁。另外，发生死锁的进程一定处于阻塞态</td></tr><tr><td>饥饿</td><td style="text-align: center;"></td><td style="text-align: center;">可能只有一个进程发生饥饿。发生饥饿的进程既可能是阻塞态(如长期得不到需要的I/0设备)，也可能是就绪态(长期得不到处理机)</td></tr><tr><td>死循环</td><td style="text-align: center;"></td><td style="text-align: center;">可能只有一个进程发生死循环。死循环的进程可以上处理机运行(可以是运行态)，只不过无法像期待的那样顺利推进。死锁和饥饿问题是由于操作系统分配资源的策略不合理导致的，而死循环是由代码逻辑的错误导致的。死锁利饥饿是管理者(操作系统)的问题，死循环是被管理者的问题</td></tr></tbody></table><h3 id="死锁产生的必要条件">1.3 <strong>死锁产生的必要条件</strong></h3><ul><li><p>产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生</p></li><li><p><strong>互斥条件</strong></p><ul><li>只有对必须互斥使用的资源的争抢才会导致死锁(如哲学家的筷子、打印机设备)</li><li>像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的(因为进程不用阻塞等待这种资源)</li></ul></li><li><p><strong>不剥夺条件</strong></p><ul><li>进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放</li></ul></li><li><p><strong>请求和保持条件</strong></p><ul><li>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放</li></ul></li><li><p><strong>循环等待条件</strong></p><ul><li>存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求</li></ul></li><li><p><strong>注意</strong>:</p><ul><li><strong>发生死锁时一定有循环等待，但是发生循环等待时未必死锁(循环等待是死锁的必要不充分条件)</strong></li><li>如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了</li></ul></li></ul><h3 id="什么时候会发生死锁">1.4<strong>什么时候会发生死锁?</strong></h3><ul><li><p>对系统资源的竞争。各进程对不可剥夺的资源(如打印机)的竞争可能引起死锁，对可剥夺的资源(CPU)的竞争是不会引起死锁的</p></li><li><p>进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁</p></li><li><p>信号量的使用不当也会造成死锁。如生产者消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。(可以把互斥信号量、同步信号量也看做是一种抽象的系统资源)</p></li><li><p>总之，<strong>对不可剥夺资源的不合理分配，可能导致死锁</strong></p></li></ul><h3 id="死锁的处理策略">1.5 <strong>死锁的处理策略</strong></h3><ul><li><strong>预防死锁</strong><ul><li>破坏死锁产生的四个必要条件中的一个或几个</li></ul></li><li><strong>避免死锁</strong><ul><li>用某种方法防止系统进入<strong>不安全状态</strong>，从而避免死锁（银行家算法）</li></ul></li><li><strong>死锁的检测和解除</strong><ul><li>允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁</li></ul></li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-4-%E6%AD%BB%E9%94%81/image-20241120201152743.png"></p><h2 id="死锁的处理策略-1"><strong>2. 死锁的处理策略</strong></h2><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-4-%E6%AD%BB%E9%94%81/image-20241120201628724.png"></p><h3 id="预防死锁">2.1 <strong>预防死锁</strong></h3><figure><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-4-%E6%AD%BB%E9%94%81/image-20241120202659002.png" alt="image-20241120202659002"><figcaption aria-hidden="true">image-20241120202659002</figcaption></figure><h4 id="破坏互斥条件">2.1.1 <strong>破坏互斥条件</strong></h4><ul><li><strong>互斥条件</strong><ul><li>只有对必须互斥使用的资源的争抢才会导致死锁</li></ul></li><li>破坏互斥条件:<ul><li>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态，操作系统可以采用<strong>SPOOLing 技术</strong>把独占设备在逻辑上改造成共享设备</li><li>比如: 用<strong>SPOOLing技术</strong>将打印机改造为共享设备</li></ul></li><li>缺点:<ul><li>并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥条件</li></ul></li></ul><h4 id="破坏不剥夺条件">2.1.2 <strong>破坏不剥夺条件</strong></h4><ul><li><strong>不剥夺条件</strong><ul><li>进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放</li></ul></li><li>破坏不剥夺条件:<ul><li>方案一:当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件</li><li>方案二:当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）</li></ul></li><li>缺点:<ul><li>实现起来比较复杂吧</li><li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU</li><li>反复地申请和释放资源会增加系统开销，降低系统吞吐量</li><li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿</li></ul></li></ul><h4 id="破坏请求和保持条件">2.1.3<strong>破坏请求和保持条件</strong></h4><ul><li><strong>请求和保持条件</strong><ul><li>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放</li></ul></li><li>破坏请求和保持条件:<ul><li>可以采用静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了</li></ul></li><li>缺点:<ul><li>该策略实现起来简单，但也有明显的缺点</li><li>有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿</li></ul></li></ul><h4 id="破坏循环等待条件">2.1.4 <strong>破坏循环等待条件</strong></h4><ul><li><strong>循环等待条件</strong><ul><li>存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求</li></ul></li><li>破坏循环等待条件<ul><li>可采用<strong>顺序资源分配法</strong>。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完</li><li>原理分析:<ul><li>一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象</li></ul></li></ul></li><li>缺点:<ul><li>不方便增加新的设备，因为可能需要重新分配所有的编号</li><li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费</li><li>必须按规定次序申请资源，用户编程麻烦</li></ul></li></ul><h3 id="避免死锁">2.2 <strong>避免死锁</strong></h3><ul><li><strong>什么是安全序列?</strong><ul><li>所谓<strong>安全序列</strong>，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成</li></ul></li><li><strong>安全序列、不安全状态、死锁的联系</strong><ul><li>只要能找出一个安全序列，系统就是<strong>安全状态</strong>。当然，安全序列可能有多个</li><li>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了<strong>不安全状态</strong>。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况</li><li><strong>如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁</strong>（处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态）</li><li>因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。这也是“<strong>银行家算法</strong>”的核心思想</li></ul></li></ul><h4 id="银行家算法">2.2.1 <strong>银行家算法</strong></h4><ul><li><p>银行家算法是荷兰学者 Dijkstra为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况。后来该算法被用在操作系统中，<strong>用于避免死锁</strong></p></li><li><p><strong>核心思想</strong>:</p><ul><li>在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待</li></ul></li><li><p><strong>银行家算法</strong>:</p><ul><li>数据结构：<ul><li>长度为m的一维数组Available表示还有多少可用资源</li><li>n * m矩阵Max表示各进程对资源的最大需求数</li><li>n*m矩阵Allocation表示已经给各进程分配了多少资源</li><li>Max-Allocation=Need矩阵表示各进程最多还需要多少资源</li><li>用长度为m的一位数组Request表示进程此次申请的各种资源数</li></ul></li><li>银行家算法步骤： ①检查此次申请是否超过了之前声明的最大需求数②检查此时系统剩余的可用资源是否还能满足这次请求③试探着分配，更改各数据结构④用安全性算法检查此次分配是否会导致系统进入不安全状态</li><li>安全性算法步骤：检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。不断重复上述过程，看最终是否能让所有进程都加入安全序列。</li></ul></li><li><p>系统处于不安全状态未必死锁，但死锁时一定处于不安全状态。系统处于安全状态一定不会死锁。</p></li></ul><h3 id="检测和解除">2.3 <strong>检测和解除</strong></h3><ul><li>如果系统中既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很可能发生死锁。在这种情况下，系统应当提供两个算法：<ul><li><strong>死锁检测算法</strong>:用于检测系统状态，以确定系统中是否发生了死锁</li><li><strong>死锁解除算法</strong>:当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来</li></ul></li></ul><h4 id="死锁的检测">2.3.1 <strong>死锁的检测</strong></h4><ul><li>为了能对系统是否已发生了死锁进行检测，必须:<ul><li>用某种数据结构来保存资源的请求和分配信息</li><li>提供一种算法，利用上述信息来检测系统是否已进入死锁状态</li></ul></li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-4-%E6%AD%BB%E9%94%81/image-20241121093444179.png"></p><ul><li><p>如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去</p></li><li><p>如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程…</p></li><li><p>如果按上述过程分析，最终能消除所有边，就称这个图是<strong>可完全简化的</strong>。此时一定没有发生死锁（相当于能找到一个安全序列）</p></li><li><p>如果最终不能消除所有边，那么此时就是发生了死锁</p></li><li><p><strong>检测死锁的算法</strong></p><ul><li>1）在资源分配图中，找出既不阻塞又不是孤点的进程Pi（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。如下图中，R1没有空闲资源，R2有一个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。消去它所有的请求边和分配变，使之称为孤立的结点。在下图中P1是满足这一条件的进程结点，于是将P1的所有边消去</li><li>2）进程 Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在下图中，P2就满足这样的条件。根据1）中的方法进行一系列简化后，若能消去途中所有的边，则称该图是可完全简化的</li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-4-%E6%AD%BB%E9%94%81/image-20241121093708353.png"></p><ul><li><strong>死锁定理</strong>：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁</li></ul></li></ul><h4 id="死锁的解除">2.3.2 <strong>死锁的解除</strong></h4><ul><li>一旦检测出死锁的发生，就应该立即<strong>解除死锁</strong><ul><li>补充：并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程</li></ul></li><li><strong>解除死锁的主要方法</strong><ul><li>资源剥夺法。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿</li><li>撤销进程法（或称终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来</li><li>进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点</li></ul></li><li>如何决定“对谁动手”<ul><li>进程优先级</li><li>已执行多长时间</li><li>还要多久能完成</li><li>进程已经使用了多少资源</li><li>进程是交互式的还是批处理式的</li></ul></li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-4-%E6%AD%BB%E9%94%81/image-20241121094256016.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.3 同步与互斥</title>
    <link href="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/"/>
    <url>/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="进程的同步与互斥"><strong>2.3 进程的同步与互斥</strong></h1><h2 id="进程同步进程互斥"><strong>1. 进程同步、进程互斥</strong></h2><h3 id="什么是进程同步">1.1 <strong>什么是进程同步?</strong></h3><ul><li>进程具有<strong>异步性</strong>的特征<ul><li>异步性: 各并发执行的进程以各自独立的、不可预知的速度向前推进</li></ul></li><li>如何解决这种异步问题，就是“<strong>进程同步</strong>”所讨论的内容<ul><li><strong>同步</strong>亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上<strong>协调它们的工作次序</strong>而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作</li></ul></li></ul><h3 id="什么是进程互斥">1.2 <strong>什么是进程互斥?</strong></h3><ul><li><p>进程的"<strong>并发</strong>"需要"共享"的支持。各个并发执行的进程不可避免的需要共享一些系统资源(比如内存，又比如打印机、摄像头这样的I/O设备)</p></li><li><p>我们把<strong>一个时间段内只允许一个进程使用(互斥共享方式)</strong>的资源称为<strong>临界资源</strong>。许多物理设备(比如摄像头、打印机)都属于临界资源。此外还有很多变量、数据、内存缓冲区等都属于临界资源，对临界资源的访问，必须<strong>互斥</strong>地进行</p></li><li><p><strong>互斥</strong>亦称间接制约关系，<strong>进程互斥</strong>指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待，当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源</p></li><li><p>对临界资源的互斥访问，可以在逻辑上分为如下四个部分:</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span> &#123;<br>    entry section;    <span class="hljs-comment">/* 进入区: 负责检查是否可进入临界区，若可进入，</span><br><span class="hljs-comment">    则应设置正在访问临界资源的标志(可理解为“上锁”)，以组织其他进程同时进入临界区 */</span><br>    critical section; <span class="hljs-comment">/* 临界区: 访问临界资源的那段代码 */</span><br>    <span class="hljs-built_in">exit</span> section; <span class="hljs-comment">/* 退出区: 负责解除 正在访问临界资源的标志 (可理解为“解锁”) */</span><br>    remainder section; <span class="hljs-comment">/* 剩余区: 做其他处理 */</span><br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure><ul><li><p>注意:</p><ul><li><strong>临界区</strong>是进程中<strong>访问临界资源</strong>的代码段</li><li><strong>进入区</strong>和<strong>退出区</strong>是<strong>负责实现互斥</strong>的代码段</li><li>临界区也可称为"<strong>临界段</strong>"</li></ul></li><li><p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则:</p><ul><li><strong>空闲让进</strong>:临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</li><li><strong>忙则等待</strong>:当已有进程进入临界区时，其他试图进入临界区的进程必须等待</li><li><strong>有限等待</strong>:对请求访问的进程，应保证能在有限时间内进入临界区(保证不会饥饿)</li><li><strong>让权等待</strong>:当进程不能进入临界区时，应立即释放处理机，防止进程忙等待</li></ul></li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-20241120151439304.png"></p><h2 id="进程互斥的软件实现方法"><strong>2.进程互斥的软件实现方法</strong></h2><h3 id="学习提示">2.1 <strong>学习提示</strong>:</h3><p>1. 理解各个算法的思想、原理</p><p>2.结合上小节学习的“实现互斥的四个逻辑部分”，重点理解各算法在<strong>进入区</strong>、<strong>退出区</strong>都做了什么</p><p>3. 分析各算法存在的缺陷(结合"实现互斥要遵循的四个原则"进行分析)</p><h3 id="单标志法">2.2 <strong>单标志法</strong></h3><ul><li>算法思想:两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> turn = <span class="hljs-number">0</span>; <span class="hljs-comment">// turn 表示当前允许进入临界区的进程号</span><br><span class="hljs-comment">// P0进程:                            //P1进程:</span><br><span class="hljs-keyword">while</span> (turn != <span class="hljs-number">0</span>);  ①                <span class="hljs-keyword">while</span> (turn != <span class="hljs-number">1</span>); ⑤   <span class="hljs-comment">// 进入区</span><br>critical section;   ②                critical section;  ⑥   <span class="hljs-comment">// 临界区</span><br>turn = <span class="hljs-number">1</span>;           ③                turn = <span class="hljs-number">0</span>;          ⑦   <span class="hljs-comment">// 退出区</span><br>remainder section;  ④                remainder section; ⑧   <span class="hljs-comment">// 剩余区</span><br></code></pre></td></tr></table></figure><ul><li>turn的初值为0，即刚开始只允许0号进程进入临界区</li><li>若P1先上处理机运行，则会一直卡在⑤，直到P1的时间片用完，发生调度，切换P0上处理机运行。若代码①不会卡住P0，P0可以正常访问临界区，则P0访问临界区期间即使切换回P1，P1依然会卡在⑤<ul><li>因此，该算法可以实现“同一时刻最多只允许一个进程访问临界区”</li></ul></li><li>只能按P0 → P1 → P0 → P1 → ......这样轮流访问。这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问<ul><li>因此，<strong>单标志法</strong>存在的主要问题是:<strong>违背“空闲让进”原则</strong></li></ul></li></ul><h3 id="双标志先检查">2.3 <strong>双标志先检查</strong></h3><ul><li>算法思想:设置一个布尔型数组flag[]，数组中各个元素用来<strong>标记各进程想进入临界区的意愿</strong>，比如“flag[0]=true”意味着0号进程P0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[i]设为true，之后开始访问临界区</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> flag[<span class="hljs-number">2</span>]; <span class="hljs-comment">// 表示进入临界区意愿的数组</span><br>flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// P0进程://P1进程:</span><br><span class="hljs-keyword">while</span> (flag[<span class="hljs-number">1</span>]);①<span class="hljs-keyword">while</span> (flag[<span class="hljs-number">0</span>]); ⑤ <span class="hljs-comment">// 进入区，如果此时P0想进入临界区，P1就一直循环等待</span><br>flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>; ②flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>; ⑥ <span class="hljs-comment">// 进入区，标记为P1 进程想要进入临界区</span><br>critical section;③critical section; ⑦ <span class="hljs-comment">// 访问临界区</span><br>flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;④flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>; ⑧ <span class="hljs-comment">// 访问完临界区，修改标记为 P1 不想使用临界区</span><br>remainder section;remainder section;<br></code></pre></td></tr></table></figure><ul><li><p>若按照①⑤②⑥③⑦......的顺序执行，P0和P1将会同时访问临界区</p></li><li><p>因此，<strong>双标志先检查法</strong>的主要问题是:<strong>违反“忙则等待”原则</strong></p><ul><li>原因在于，进入区的“检查”和“上锁”两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换</li></ul></li></ul><h3 id="双标志后检查">2.4 <strong>双标志后检查</strong></h3><ul><li>算法思想:双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> flag[<span class="hljs-number">2</span>];   <span class="hljs-comment">// 表示进入临界区意愿的数组</span><br>flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// P0进程:    //P1进程:</span><br>flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;     ①flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>; ⑤<span class="hljs-comment">// 进入区，标记为P1进程想要进入临界区</span><br><span class="hljs-keyword">while</span> (flag[<span class="hljs-number">1</span>]);    ② <span class="hljs-keyword">while</span> (flag[<span class="hljs-number">0</span>]);⑥<span class="hljs-comment">// 进入区，如果此时P0想进入临界区，P1就一直循环等待</span><br>critical section;   ③critical section;  ⑦<span class="hljs-comment">// 访问临界区</span><br>flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;    ④flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;   ⑧<span class="hljs-comment">// 访问完临界区，修改标记为 P1 不想使用临界区  </span><br>remainder section;remainder section;  <br></code></pre></td></tr></table></figure><ul><li>若按照①⑤②⑥......的顺序执行，P0和P1将都无法进入临界区</li><li>因此，<strong>双标志后检查法</strong>虽然<strong>解决了“忙则等待”</strong>的问题，但是又<strong>违背了“空闲让进”和“有限等待”原则</strong>，会因各进程都长期无法访问临界资源而产生“饥饿”现象，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区</li></ul><h3 id="peterson算法">2.5 <strong>Peterson算法</strong></h3><ul><li>算法思想：结合双标志法、单标志法的思想，如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”(谦让)，做一个有礼貌的进程</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> flag[<span class="hljs-number">2</span>]; <span class="hljs-comment">// 表示进入临界区意愿的数组, 初始值都是false</span><br><br><span class="hljs-type">int</span> turn = <span class="hljs-number">0</span>; <span class="hljs-comment">// turn 表示优先让哪个进程进入临界区</span><br><br><span class="hljs-comment">// P0进程://P1进程:</span><br>flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>; ①flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>; ⑥ <span class="hljs-comment">// 进入区, 表示自己想进入临界区</span><br>turn = <span class="hljs-number">1</span>;②turn = <span class="hljs-number">0</span>;⑦ <span class="hljs-comment">// 进入区, 可以优先让对方进入临界区</span><br><br><span class="hljs-keyword">while</span> (flag[<span class="hljs-number">1</span>] &amp;&amp;<span class="hljs-keyword">while</span> (flag[<span class="hljs-number">0</span>] &amp;&amp;<br>       turn == <span class="hljs-number">1</span>);③ turn == <span class="hljs-number">0</span>); ⑧ <span class="hljs-comment">//进入区，对方想进, 且最后一次是自己&quot;让梨&quot;, 那自己就循环等待</span><br><br>critical section;④ critical section; ⑨ <span class="hljs-comment">// 访问临界区</span><br>flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;⑤flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>; ⑩ <span class="hljs-comment">// 访问完临界区，表示自己已经不想访问临界区了</span><br>remainder section;remainder section;<br></code></pre></td></tr></table></figure><ul><li>进入区:<ul><li>主动争取</li><li>主动谦让</li><li>检查对方是否也想使用，且最后一次是不是自己说了“客气话”</li></ul></li><li><strong>Peterson算法</strong>用软件方法解决了进程互斥问题，<strong>遵循了空闲让进、忙则等待、有限等待三个原则</strong>，但是依然<strong>未遵循让权等待的原则</strong></li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-20241120161559889.png"></p><h2 id="进程互斥的硬件实现方法"><strong>3.进程互斥的硬件实现方法</strong></h2><h3 id="中断屏蔽方法">3.1 <strong>中断屏蔽方法</strong></h3><ul><li>利用“<strong>开/关中断指令</strong>”实现(与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">关中断; <span class="hljs-comment">// 关中断后即不允许当前进程被中断，也必然不会发生进程切换</span><br>临界区;<br>开中断; <span class="hljs-comment">// 直到当前进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区</span><br></code></pre></td></tr></table></figure><ul><li><p>优点: 简单、高效</p></li><li><p>缺点:不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程(因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险)</p><ul><li>因为关中断只针对单个处理机，其他处理机上的进程还是能够访问临界区</li></ul></li></ul><h3 id="testandset指令">3.2 <strong>TestAndSet指令</strong></h3><ul><li><p>简称 <strong>TS 指令</strong>，也有地方称为<strong>TestAndSetLock 指令</strong>，或 <strong>TSL指令</strong></p></li><li><p>TSL指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成</p></li><li><p>以下是用C语言描述的逻辑:</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 布尔型共享变量 lock 表示当前临界区是否被加锁</span><br><span class="hljs-comment">// true表示已加锁, false表示未加锁</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">TestAndSet</span><span class="hljs-params">(<span class="hljs-type">bool</span> *lock)</span> &#123;<br>    <span class="hljs-type">bool</span> old;<br>    old = *lock;<span class="hljs-comment">// old用来存放lock原来的值</span><br>    *lock = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 无论之前是否已加锁, 都将lock设为true</span><br>    <span class="hljs-keyword">return</span> old; <span class="hljs-comment">// 返回lock原来的值</span><br>&#125;<br><br><span class="hljs-comment">// 以下是使用 TSL 指令实现互斥的算法逻辑</span><br><span class="hljs-keyword">while</span> (TestAndSet(&amp;lock)); <span class="hljs-comment">// &quot;上锁&quot;并&quot;检查&quot;</span><br>临界区代码段...<br>lock = <span class="hljs-literal">false</span>;<span class="hljs-comment">// &quot;解锁&quot;</span><br>剩余区代码段...<br></code></pre></td></tr></table></figure><ul><li><p>原理:</p><ul><li>若刚开始 lock 是 false，则 TSL 返回的 old 值为 false，while循环条件不满足，直接跳过循环，进入临界区</li><li>若刚开始 lock 是 true，则执行 TLS 后 old 返回的值为 true，while循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”</li><li>相比软件实现方法，TSL指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作</li></ul></li><li><p>优点:实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</p></li><li><p>缺点:不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而致“忙等”</p></li></ul><h3 id="swap指令">3.3 <strong>Swap指令</strong></h3><ul><li><p>有的地方也叫 <strong>Exchange 指令</strong>，或简称 <strong>XCHG指令</strong></p></li><li><p>Swap指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成</p></li><li><p>以下是用C语言描述的逻辑:</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Swap指令的作用是交换两个变量的值</span><br>Swap (<span class="hljs-type">bool</span> *a, <span class="hljs-type">bool</span> *b) &#123;<br>    <span class="hljs-type">bool</span> temp;<br>    temp = *a;<br>    *a = *b;<br>    *b = temp;<br>&#125;<br><br><span class="hljs-comment">// 以下是用Swap指令实现互斥的算法逻辑</span><br><span class="hljs-comment">// lock表示当前临界区是否被加锁</span><br><br><span class="hljs-type">bool</span> old = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span> (old == <span class="hljs-literal">true</span>)<br>    Swap(&amp;lock, &amp;old);<br>临界区代码段...<br>lock = <span class="hljs-literal">false</span>;<br>剩余区代码段...<br></code></pre></td></tr></table></figure><ul><li><p>原理:</p><ul><li>逻辑上来看 Swap 和 TSL并无太大区别，都是先记录下此时临界区是否已经被上锁(记录在old变量上)，再将上锁标记 lock 设置为 true，最后检查 old，如果 old 为false则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。</li></ul></li><li><p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</p></li><li><p>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。</p></li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-20241120162657761.png"></p><h2 id="互斥锁"><strong>4. 互斥锁</strong></h2><ul><li>解决临界区最简单的工具就是互斥锁(mutex lock)。<ul><li>一个进程在进入临界区时应获得锁;在退出临界区时释放锁。</li><li>函数acquire()获得锁，而函数release()释放锁。</li></ul></li><li>每个互斥锁有一个布尔变量available,表示锁是否可用。如果锁是可用的，调用acqiure()会成功，且锁不再可用。当一个进程试图获取不可用的锁时，会被阻塞，直到锁被释放。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">acquire()&#123;<br><span class="hljs-keyword">while</span>(!available)<br>        ;<span class="hljs-comment">//忙等待</span><br>available <span class="hljs-literal">false</span>;<span class="hljs-comment">//获得锁</span><br>&#125;<br>release()&#123;<br>available <span class="hljs-literal">true</span>; <span class="hljs-comment">//释放锁</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>acquire(或release()的执行必须是原子操作，因此互斥锁通常采用硬件机制来实现。</p></li><li><p>互斥锁的主要缺点是忙等待，当有一个进程在临界区中，任何其他进程在进入临界区时必须连续循环调用acquire()。当多个进程共享同一CPU时，就浪费了CPU周期。因此，互斥锁通常用于多处理器系统，一个线程可以在一个处理器上等待，不影响其他线程的执行。</p></li><li><p>需要连续循环忙等的互斥锁，都可称为自旋锁(spinlock),如TSL指令、swap指令、单标志法</p></li><li><p>特性：</p><ul><li>需忙等，进程时间片用完才下处理机，违反“让权等待”</li><li>优点：等待期间不用切换进程上下文，多处理器系统中，若上锁的时间短，则等待代价很低常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区</li><li>不太适用于单处理机系统，忙等的过程中不可能解锁</li></ul></li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-20241120163426848.png"></p><h2 id="信号量机制"><strong>5. 信号量机制</strong></h2><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-20241120171150120.png"></p><h3 id="之前学习的这些进程互斥的解决方案分别存在哪些问题">5.1<strong>之前学习的这些进程互斥的解决方案分别存在哪些问题?</strong></h3><ul><li><p>进程互斥的四种软件实现方式（单标志法、双标志先检查、双标志后检查、Peterson算法）</p></li><li><p>进程互斥的三种硬件实现方式（中断屏蔽方法、TS/TSL指令、Swap/XCHG指令）</p><ul><li>在双标志先检查法中，进入区的“检查”、“上锁”操作无法一气呵成，从而导致了两个进程有可能同时进入临界区的问题</li><li>所有的解决方案都无法实现“让权等待”</li></ul></li><li><p>1965年，荷兰学者Dijkstra提出了一种卓有成效的实现进程互斥、同步的方法-- <strong>信号量机制</strong></p></li></ul><h3 id="信号量机制-1">5.2 <strong>信号量机制</strong></h3><ul><li><p>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对<strong>信号量</strong>进行操作，从而很方便的实现了进程互斥、进程同步</p></li><li><p><strong>信号量</strong>其实就是一个变量（可以是一个<strong>整数</strong>，也可以是更复杂的<strong>记录型变量</strong>），可以用一个信号量来<strong>表示系统中某种资源的数量</strong>，比如：系统中只有一台打印机，就可以设置一个初值为1 的信号量</p></li><li><p>原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断/开中断指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题</p></li><li><p>一对原语：<strong>wait(S) 原语</strong>和 <strong>signal(S)原语</strong>，可以把原语理解为我们自己写的函数，函数名分别为wait和signal，括号里的信号量 S 其实就是函数调用时传入的一个参数</p></li><li><p>wait、signal 原语常简称为 <strong>P、V操作</strong>（来自荷兰语proberen 和 verhogen）。因此，做题的时候常把wait(S)、signal(S)两个操作分别写为 <strong>P(S)、V(S)</strong></p></li></ul><h3 id="整型信号量">5.3 <strong>整型信号量</strong></h3><ul><li>用一个<strong>整数型的变量</strong>作为信号量，用来<strong>表示系统中某种资源的数量</strong><ul><li>与普通整数变量的区别：对信号量的操作只有三种，即<strong>初始化、P操作、V操作</strong></li></ul></li><li>检查”和“上锁”一气呵成，避免了并发、异步导致的问题</li><li>存在的问题：不满足“让权等待”原则，会发生“忙等”</li><li>Eg ：某计算机系统中有一台打印机:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> S=<span class="hljs-number">1</span>；<span class="hljs-comment">//初始化整型信号量s,表示当前系统中可用的打印机资源数</span><br><span class="hljs-type">void</span> wait(<span class="hljs-type">int</span> S)&#123;<span class="hljs-comment">//wait原语，相当于&quot;进入区&quot;</span><br>    <span class="hljs-keyword">while</span> (S &lt; <span class="hljs-number">0</span>);  <span class="hljs-comment">//如果资源数不够，就一直循环等待</span><br>    S = S<span class="hljs-number">-1</span>;    <span class="hljs-comment">//如果资源数够，则占用一个资源</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">(<span class="hljs-type">int</span> S)</span>&#123;<span class="hljs-comment">//signal原语，相当于“退出区&quot;</span><br>S=S+<span class="hljs-number">1</span>; <span class="hljs-comment">//使用完资源后，在退出区释放资源</span><br>&#125;<br><br>进程P0:<br>wait(S);<span class="hljs-comment">//进入区，申请资源</span><br>使用打印机资源，，，<span class="hljs-comment">//临界区，访问资源</span><br>signal(S);<span class="hljs-comment">//退出区，释放资源</span><br><br>.....<br>进程Pn:<br>wait(S);<span class="hljs-comment">//进入区，申请资源</span><br>使用打印机资源，，，<span class="hljs-comment">//临界区，访问资源</span><br>signal(S);<span class="hljs-comment">//退出区，释放资源</span><br></code></pre></td></tr></table></figure><h3 id="记录型信号量">5.4 <strong>记录型信号量</strong></h3><ul><li>整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。</li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-20241120164732446.png"></p><ul><li><p>在考研题目中 wait(S)、signal(S) 也可以记为P(S)、V(S)，这对原语可用于实现系统资源的“<strong>申请</strong>”和“<strong>释放</strong>”</p></li><li><p>S.value 的初值表示系统中某种资源的数目</p></li><li><p>对信号量 S 的一次 P操作意味着进程请求一个单位的该类资源，因此需要执行S.value--，表示资源数减1，当S.value &lt; 0时表示该类资源已分配完毕，因此进程应调用 <strong>block原语</strong>进行自我阻塞（当前运行的进程从运行态→阻塞态），主动放弃处理机，并插入该类资源的等待队列S.L 中。可见，该机制遵循了“让权等待”原则，不会出现“忙等”现象</p></li><li><p>对信号量 S 的一次 V操作意味着进程释放一个单位的该类资源，因此需要执行S.value++，表示资源数加1，若加1后仍是 S.value &lt;=0，表示依然有进程在等待该类资源，因此应调用 <strong>wakeup原语</strong>唤醒等待队列中的第一个进程（被唤醒进程从阻塞态→就绪态）</p></li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-20241120165255539.png"></p><h2 id="用信号量实现进程互斥同步前驱关系"><strong>6.用信号量实现进程互斥、同步、前驱关系</strong></h2><h3 id="tips">6.1 <strong>Tips</strong>:</h3><ul><li><p>不要一头钻到代码里，要注意理解信号量背后的含义，<strong>一个信号量对应一种资源</strong></p></li><li><p>信号量的值 =这种资源的剩余数量（信号量的值如果小于0，说明此时有进程在等待这种资源）</p></li><li><p>P( S ) -- 申请一个资源S，如果资源不够就阻塞等待</p></li><li><p>V( S ) --释放一个资源S，如果有进程在等待该资源，则唤醒一个进程</p></li></ul><h3 id="信号量机制实现进程互斥">6.2<strong>信号量机制实现进程互斥</strong></h3><ul><li>分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区)</li><li>设置互斥信号量mutex,.初值为1<ul><li>在进入区P(mutex)一一申请资源</li><li>在退出区V(mutex)一一释放资源</li></ul></li><li>注意：对不同的临界资源需要设置不同的互斥信号量。</li><li>P、V操作必须成对出现。<ul><li>缺少P(nutex)就不能保证临界资源的互斥访问。</li><li>缺少V(mutex)会导致资源永不被释放，等待进程永不被唤醒。</li></ul></li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-20241120170055669.png"></p><h3 id="信号量机制实现进程同步">6.3<strong>信号量机制实现进程同步</strong></h3><ul><li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码)</li><li>设置同步信号量S,初始为0</li><li>在“前操作”之后执行V(S)</li><li>在“后操作”之前执行P(S)<ul><li>技巧口诀：前V后P</li></ul></li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-20241120170744768.png"></p><h3 id="信号量机制实现前驱关系">6.4<strong>信号量机制实现前驱关系</strong></h3><ul><li>其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作）因此，<ul><li>要为每一对前驱关系各设置一个同步信号量</li><li>在“前操作”之后对相应的同步信号量执行V操作</li><li>在“后操作”之前对相应的同步信号量执行P操作</li></ul></li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-20241120171047840.png"></p><h2 id="生产者-消费者问题"><strong>7. 生产者-消费者问题</strong></h2><h3 id="问题描述">7.1 <strong>问题描述</strong>:</h3><ul><li><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用（注：这里的“产品”理解为某种数据）</p></li><li><p>生产者、消费者共享一个初始为空、大小为n的缓冲区。</p></li><li><p>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待</p><ul><li>缓冲区没满→生产者生产，缓冲区满时，生产者必须等待</li></ul></li><li><p>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待</p><ul><li>缓冲区没空→消费者消费，缓冲区空时，消费者必须等待</li></ul></li><li><p>缓冲区是临界资源，各进程必须互斥地访问</p><ul><li>互斥关系</li></ul></li></ul><h3 id="pv操作题目分析步骤">7.2<strong>PV操作题目分析步骤</strong>:</h3><ul><li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系</li><li>整理思路。根据各进程的操作流程确定P、V操作的大致顺序</li><li>设置信号量。并根据题目条件确定信号量初值。（互斥信号量初值一般为1，同步信号量的初</li></ul><p>始值要看对应资源的初始值是多少）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore mutex = <span class="hljs-number">1</span>; <span class="hljs-comment">// 互斥信号量，实现对缓冲区的互斥访问</span><br>semaphore empty = n; <span class="hljs-comment">// 同步信号量，表示空闲缓冲区的数量</span><br>semaphore full = <span class="hljs-number">0</span>; <span class="hljs-comment">// 同步信号量，表示产品的数量，也即非空缓冲区的数量</span><br><br>producer ()&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        生产一个产品;<br>        P(empty); <span class="hljs-comment">// 消耗一个空闲缓冲区 ①</span><br>        P(mutex); <span class="hljs-comment">// ②</span><br>        把产品放入缓冲区; <span class="hljs-comment">// ③</span><br>        V(mutex); <span class="hljs-comment">// ④</span><br>        V(full); <span class="hljs-comment">// 增加一个产品 ⑤</span><br>    &#125;<br>&#125;<br><br>consumer ()&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        P(full); <span class="hljs-comment">// 消耗一个产品（非空缓冲区）⑥</span><br>        P(mutex); <span class="hljs-comment">// ⑦</span><br>        从缓冲区取出一个产品;<br>        V(mutex);<br>        V(empty); <span class="hljs-comment">// 增加一个空闲缓冲区</span><br>        使用产品;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>②③④: 实现互斥是在同一进程中进行一对PV操作</p></li><li><p>⑤⑥:实现两进程的同步关系，是在其中一个进程中执行P，另一进程中执行V</p></li><li><p><strong>实现互斥的P操作一定要在实现同步的P操作之后</strong></p><ul><li>若将该题中producer和consumer内的两个P操作交换，刚开始时若按⑦→⑥(此时由于full==0，消费者进程阻塞)→②(此时由于消费者消费了mutex，mutex==0，生产者进程阻塞)，导致<strong>死锁</strong>的发生</li></ul></li><li><p><strong>V操作不会导致进程阻塞，因此两个V操作顺序可以交换</strong></p></li></ul><h2 id="多生产者-多消费者问题"><strong>8.多生产者-多消费者问题</strong></h2><h3 id="问题描述-1">8.1 <strong>问题描述</strong>:</h3><ul><li><p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果</p></li><li><p>互斥关系（mutex = 1）:</p><ul><li>对缓冲区（盘子）的访问要互斥地进行</li></ul></li><li><p>同步关系（一前一后）:</p><ul><li>父亲将苹果放入盘子后，女儿才能取苹果</li><li>母亲将橘子放入盘子后，儿子才能取橘子</li><li>只有盘子为空时，父亲或母亲才能放入水果<ul><li>“盘子为空”这个事件可以由儿子或女儿触发，事件发生后才允许父亲或母亲放水果</li></ul></li></ul></li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-20241120183700095.png"></p><ul><li><p>此题中可以删去mutex，即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象，原因在于：<strong>本题中的缓冲区大小为1</strong>，在任何时刻，apple、orange、plate三个同步信号量中最多只有一个是1。因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区…</p></li><li><p>总结:</p><ul><li>在生产者-消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，这不是绝对的，要具体问题具体分析</li></ul></li><li><p>建议:</p><ul><li>在考试中如果来不及仔细分析，可以加上互斥信号量，保证各进程一定会互斥地访问缓冲区但需要注意的是，实现互斥的P操作一定要在实现同步的P操作之后，否则可能引起“死锁”</li></ul></li></ul><h2 id="吸烟者问题"><strong>9. 吸烟者问题</strong></h2><p><strong>问题描述</strong>:</p><ul><li>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复（让三个抽烟者轮流地抽烟）<ul><li>组合一：纸+胶水</li><li>组合二：烟草+胶水</li><li>组合三：烟草+纸</li></ul></li><li>互斥关系:<ul><li>桌子可以抽象为容量为1的缓冲区，要互斥访问</li></ul></li><li>同步关系（从事件的角度来分析）:<ul><li>桌上有组合一 → 第一个抽烟者取走东西</li><li>桌上有组合二 → 第二个抽烟者取走东西</li><li>桌上有组合三 → 第三个抽烟者取走东西</li><li>发出完成信号 → 供应者将下一个组合放到桌上</li></ul></li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-20241120190459259.png"></p><p>注：将finish改为1， P(finish) 放在 provider 中 while(1){下一行也是可行的</p><h2 id="读者写者问题"><strong>10. 读者写者问题</strong></h2><p><strong>问题描述</strong>:</p><ul><li><p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。</p></li><li><p>因此要求:</p><ul><li>允许多个读者可以同时对文件执行读操作；</li><li>只允许一个写者往文件中写信息；</li><li>任一写者在完成写操作之前不允许其他读者或写者工作；④写者执行写操作前，应让已有的读者和写者全部退出</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore rw=<span class="hljs-number">1</span>; <span class="hljs-comment">// 用于实现对共享文件的互斥访问</span><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录当前有几个读进程在访问文件</span><br>semaphore mutex = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用于保证对count变量的互斥访问</span><br>semaphore w = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用于保证写进程不会饥饿，实现读写公平</span><br><br>writer() &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        P(w);<br>        P(rw); <span class="hljs-comment">// 写之前“加锁”</span><br>        写文件…<br>        V(rw); <span class="hljs-comment">// 写完了“解锁”</span><br>        V(w);<br>    &#125;<br>&#125;<br><br>reader ()&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        P(w);<br>        P(mutex);<span class="hljs-comment">// 各读进程互斥访问count</span><br>        <span class="hljs-keyword">if</span>(count==<span class="hljs-number">0</span>) <span class="hljs-comment">// 由第一个读进程负责</span><br>        P(rw);<span class="hljs-comment">// 读之前“加锁”</span><br>        count++;<span class="hljs-comment">// 访问文件的读进程数+1</span><br>        V(mutex);<br>        V(w);<br>        读文件…<br>        P(mutex);<span class="hljs-comment">// 各读进程互斥访问count</span><br>        count--;<span class="hljs-comment">// 访问文件的读进程数-1        </span><br>        <br>        <span class="hljs-keyword">if</span>(count==<span class="hljs-number">0</span>)  <span class="hljs-comment">// 由最后一个读进程负责</span><br>        V(rw);<span class="hljs-comment">// 读完了“解锁”</span><br>        V(mutex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>如果不加P(w)也可以完成功能，但当读进程源源不断进入时将会导致写进程“饥饿”</p></li><li><p>P(mutex)保证各读进程对count 的访问是互斥的，对count变量的检查和赋值能够一气呵成</p></li><li><p>总结:</p><ul><li>读者-写者问题为我们解决复杂的互斥问题提供了一个参考思路</li><li>其<strong>核心思想</strong>在于设置了一个<strong>计数器count</strong> 用来记录当前正在访问共享文件的读进程数</li><li>我们可以用count的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出不同的处理</li><li>另外，对 count变量的检查和赋值不能一气呵成导致了一些错误，如果<strong>需要实现“一气呵成”，自然应该想到用互斥信号量</strong></li><li>最后，还要认真体会我们是如何解决“写进程饥饿”问题的</li></ul></li></ul><h2 id="哲学家进餐问题"><strong>11. 哲学家进餐问题</strong></h2><p><strong>问题描述</strong>:</p><ul><li>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，共5根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考</li></ul><p><strong>分析</strong>:</p><ul><li><p>关系分析。系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系</p></li><li><p>整理思路。这个问题中只有互斥关系，但与之前遇到的问题不同的事，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓</p></li><li><p>信号量设置。定义互斥信号量数组chopstick[5]={1,1,1,1,1}用于实现对5个筷子的互斥访问。并对哲学家按0~4编号，哲学家 i左边的筷子编号为 i，右边的筷子编号为 (i+1)%5</p></li></ul><p><strong>解</strong>:</p><p><strong>误解</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 如果5个哲学家并发地拿起了自己左手边的筷子, 每位哲学家循环等待右边的人放下筷子（阻塞）, 会发生“死锁”</span><br>semaphore chopstick[<span class="hljs-number">5</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;;<br>Pi ()&#123; <span class="hljs-comment">// i号哲学家的进程</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        P(chopstick[i]); <span class="hljs-comment">// 拿左</span><br>        P(chopstick[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">5</span>]); <span class="hljs-comment">// 拿右</span><br>        吃饭…<br>        V(chopstick[i]); <span class="hljs-comment">// 放左</span><br>        V(chopstick[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">5</span>]); <span class="hljs-comment">// 放右</span><br>        思考…<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如何防止死锁的发生呢?</strong></p><ul><li><p>可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的</p></li><li><p>要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况</p></li><li><p>仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子更准确的说法应该是:各哲学家拿筷子这件事必须互斥的执行。这就保证了即使一个哲学家在拿筷子拿到一半时被阻塞，也不会有别的哲学家会继续尝试拿筷子。这样的话，当前正在吃饭的哲学家放下筷子后，被阻塞的哲学家就可以获得等待的筷子了</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore chopstick[<span class="hljs-number">5</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;;<br>semaphore mutex = <span class="hljs-number">1</span>; <span class="hljs-comment">// 互斥地取筷子</span><br><span class="hljs-comment">// 这种方法并不能保证只有两边的筷子都可用时，才允许哲学家拿起筷子</span><br>Pi ()&#123; <span class="hljs-comment">// i号哲学家的进程</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        P(mutex);<br>        P(chopstick[i]); <span class="hljs-comment">// 拿左</span><br>        P(chopstick[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">5</span>]); <span class="hljs-comment">// 拿右</span><br>        V(mutex);<br>        吃饭…<br>        V(chopstick[i]); <span class="hljs-comment">// 放左</span><br>        V(chopstick[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">5</span>]); <span class="hljs-comment">// 放右</span><br>        思考…<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结:</p><ul><li>哲学家进餐问题的关键在于解决<strong>进程死锁</strong>。这些进程之间只存在互斥关系，但是与之前接触到的互斥关系不同的是，每个进程都需要同时持有两个临界资源，因此就有“死锁”问题的隐患</li></ul><h2 id="管程"><strong>12. 管程</strong></h2><h3 id="为什么要引入管程">12.1 <strong>为什么要引入管程?</strong></h3><ul><li><p>信号量机制存在的问题: 编写程序困难、易出错</p></li><li><p>能不能设计一种机制，让程序员写程序时不需要再关注复杂的PV操作，让写代码更轻松呢?</p></li><li><p>1973年，Brinch Hansen 首次在程序设计语言(Pascal)中引入了“<strong>管程</strong>”成分 --<strong>一种高级同步机制</strong></p></li></ul><h3 id="管程的组成和基本特征">12.2<strong>管程的组成和基本特征</strong></h3><ul><li><strong>管程是一种特殊的软件模块</strong>，有这些部分组成:<ul><li>局部于管程的共享数据结构说明</li><li>该数据结构进行操作的一组过程<ul><li>跨考Tips: “过程”其实就是“函数”</li></ul></li><li>对局部于管程的共享数据设置初始值的语句</li><li>管程有一个名字</li></ul></li><li><strong>管程的基本特征</strong>:<ul><li>局部于管程的数据只能被局部于管程的过程所访问</li><li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</li><li>每次仅允许一个进程在管程内执行某个内部过程<ul><li>由编译器负责实现各进程<strong>互斥</strong>地进入管程中的过程</li><li>管程中设置条件变量和等待/唤醒操作，以解决<strong>同步</strong>问题</li></ul></li></ul></li><li><strong>如何理解?</strong><ul><li>可以把管程比作Java中的类，管程中的共享数据结构为类中的属性，管程中的一组过程是类中的一组方法</li><li>管程中的方法可以看作是静态同步(staticsynchronized)方法，所以每次仅允许一个进程在管程内执行某个内部过程</li><li>进程只能通过方法对属性进行操作，体现了类的封装思想</li></ul></li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-20241120195614131.png"></p><ul><li>引入管程的目的无非就是要更方便地实现进程互斥和同步。<ul><li>需要在管程中定义共享数据（如生产者消费者问题的缓冲区）</li><li>需要在管程中定义用于访问这些共享数据的“入口”一一其实就是一些函数（如生产者消费者问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品)</li><li>只有通过这些特定的“入口”才能访问共享数据</li><li>管程中有很多“入口”，但是每次只能开放其中一个“入口”，并且只能让一个进程或线程进入（如生产者消费者问题中，各进程需要互斥地访问共享缓冲区。管程的这种特性即可保证一个时间段内最多只会有一个进程在访问缓冲区。注意：这种互斥特性是由编译器负责实现的，程序员不用关心)</li><li>可在管程中设置条件变量及等待/唤醒操作以解决同步问题。可以让一个进程或线程在条件变量上等待（此时，该进程应先释放管程的使用权，也就是让出“入口”）；可以通过唤醒操作将等待在条件变量上的进程或线程唤醒。</li><li>程序员可以用某种特殊的语法定义一个管程（比如：monitorProducerConsumer.endmonitor;),之后其他程序员就可以使用这个管程提供的特定“入口”很方便地使用实现进程同步/互斥了。</li></ul></li></ul><p><img src="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-20241120200148151.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.2 处理机调度</title>
    <link href="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-2-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/"/>
    <url>/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-2-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="处理机的调度"><strong>2.2 处理机的调度</strong></h1><h2 id="调度的概念层次"><strong>1. 调度的概念、层次</strong></h2><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-2-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/image-20241119220317802.png"></p><h3 id="调度的基本概念">1.1 <strong>调度的基本概念</strong></h3><ul><li><p>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理，这些任务的顺序，这就是“调度”研究的问题</p></li><li><p>在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程</p></li><li><p><strong>处理机调度</strong>，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行</p></li></ul><h3 id="调度的三个层次">1.2 <strong>调度的三个层次</strong></h3><ul><li><strong>作业</strong>: 一个具体的任务,用户向系统提交一个作业≈用户让操作系统启动一个程序(来处理一个具体的任务)</li><li><strong>高级调度(作业调度)</strong>: 外存<sub>作业</sub> →内存<sub>进程</sub><ul><li>按一定的原则从<strong>外存</strong>的作业后备队列中挑选一个作业调入内存,并创建进程, 每个作业只调入一次, 调出一次, 作业调入时会建立PCB,调出时才撤销PCB<ul><li>由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序</li><li>高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出</li></ul></li></ul></li><li><strong>中级调度(内存调度)</strong>: 外存<sub>挂起进程</sub> →内存<sub>进程</sub><ul><li>按照某种策略决定将哪个处于<strong>挂起状态</strong>的进程重新调入内存<ul><li>内存不够时, 可将某些进程的数据调出到外存,等内存空闲或者进程需要运行时再重新调入内存,这么做的目的是为了提高内存利用率和系统吞吐量</li><li>暂时调到外存等待的进程状态称为<strong>挂起状态</strong>,被挂起的进程PCB会被组织成<strong>挂起队列</strong><ul><li>值得注意的是，<strong>PCB并不会一起调到外存</strong>，而是会常驻内存</li><li>PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的</li><li>PCB来保持对各个进程的监控、管理</li></ul></li><li>一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高</li></ul></li></ul></li><li><strong>低级调度(进程调度/处理机调度)</strong>: 内存<sub>进程</sub>→ 分配处理机<sub>进程</sub><ul><li>按照某种策略从就绪队列中选取一个进程，将处理机分配给它<ul><li>进程调度是操作系统中<strong>最基本的一种调度</strong>，在一般的操作系统中都必须配置进程调度</li><li>进程调度的频率很高，一般几十毫秒一次</li></ul></li></ul></li></ul><h3 id="三层调度的联系对比">1.3<strong>三层调度的联系、对比</strong></h3><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-2-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/image-20241119220037965.png"></p><h3 id="进程的挂起态与七状态模型">1.4<strong>进程的挂起态与七状态模型</strong></h3><ul><li><p>暂时调到外存等待的进程状态为<strong>挂起状态(挂起态，suspend)</strong></p></li><li><p>挂起态又可以进一步细分为<strong>就绪挂起</strong>、<strong>阻塞挂起</strong>两种状态</p></li><li><p><strong>七状态模型</strong></p></li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-2-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/image-20241119220113000.png"></p><h2 id="进程调度的时机切换与过程方式"><strong>2.进程调度的时机、切换与过程、方式</strong></h2><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-2-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/image-20241119221723926.png"></p><h3 id="进程调度的时机">2.1 <strong>进程调度的时机</strong></h3><ul><li><strong>进程调度(低级调度)</strong>，就是按照某种算法从就绪队列中选择一个进程为其分配处理机</li><li><strong>需要进行进程调度与切换的情况</strong><ul><li>当前运行的进程<strong>主动放弃</strong>处理机<ul><li>进程正常终止</li><li>运行过程中发生异常而终止</li><li>进程主动请求阻塞(如等待I/O)</li></ul></li><li>当前运行的进程<strong>被动放弃</strong>处理机<ul><li>分给进程的时间片用完</li><li>有更紧急的事需要处理(如I/O中断)</li><li>有更高优先级的进程进入就绪队列</li></ul></li></ul></li><li><strong>不能进行进程调度与切换的情况</strong><ul><li>在处理中断的过程中:中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换</li><li>进程在操作系统<strong>内核程序临界区</strong>中，但是进程在普通临界区时是可以进行调度、切换的<ul><li><strong>临界资源</strong>: 一个时间段内只允许一个进程使用的资源,各进程需要<strong>互斥</strong>地访问临界资源</li><li><strong>临界区</strong>: 访问临界资源的那段代码<ul><li>普通临界区访问的临界资源不会直接影响操作系统内核的管理工作</li><li>因此在访问普通临界区时可以进行调度与切换</li></ul></li><li><strong>内核程序临界区</strong>:一般是用来访问某种内核数据结构的，比如进程的就绪队列(由各就绪进程的PCB组成)<ul><li>内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作</li><li>因此在访问内核程序临界区期间不能进行调度与切换</li></ul></li></ul></li><li>在原子操作过程中(原语):原子操作不可中断，要一气呵成(如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列)</li></ul></li></ul><h3 id="进程调度的方式">2.2 <strong>进程调度的方式</strong></h3><ul><li><strong>非剥夺调度方式(非抢占式方式)</strong><ul><li>只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态<ul><li>实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统</li></ul></li></ul></li><li><strong>剥夺调度方式(抢占式方式)</strong><ul><li>当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程<ul><li>可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统</li></ul></li></ul></li></ul><h3 id="狭义的进程调度与进程切换的区别">2.3<strong>"狭义的进程调度"与"进程切换"的区别</strong></h3><ul><li><strong>狭义的进程调度</strong>指的是从就绪队列中选中一个要运行的进程（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要<strong>进程切换</strong>）</li><li><strong>进程切换</strong>是指一个进程让出处理机，由另一个进程占用处理机的过程<ul><li>对原来运行进程各种数据的保存</li><li>对新的进程各种数据的恢复(如:程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块PCB中)</li><li><strong>注意</strong>:<ul><li>进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少</li></ul></li></ul></li><li><strong>广义的进程调度</strong>包含了选择一个进程和进程切换两个步骤</li></ul><h2 id="调度器和闲逛进程"><strong>3. 调度器和闲逛进程</strong></h2><h3 id="调度器调度程序scheduler">3.1<strong>调度器/调度程序(scheduler)</strong></h3><ul><li>支持内核级线程的操作系统,调度程序的处理对象是<strong>内核级线程</strong></li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-2-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/image-20241119221810753.png"></p><h3 id="闲逛进程">3.2 <strong>闲逛进程</strong></h3><ul><li><p>调度程序永远的备胎, 没有其他就绪进程时,运行闲逛进程(idle)</p></li><li><p>特性:</p><ul><li>优先级最低</li><li>可以是0地址指令, 占一个完整的指令周期(指令周期末尾例行检查中断)</li><li>能耗低</li></ul></li></ul><h2 id="调度算法的评价指标"><strong>4. 调度算法的评价指标</strong></h2><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-2-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/image-20241120105220114.png"></p><h2 id="调度算法1"><strong>5. 调度算法（1）</strong></h2><h3 id="各种调度算法的学习思路">5.1<strong>各种调度算法的学习思路</strong></h3><ol type="1"><li><p>算法思想</p></li><li><p>算法规则</p></li><li><p>这种调度算法是用于 作业调度 还是 进程调度？</p></li><li><p>抢占式？非抢占式？</p></li><li><p>优点和缺点</p></li><li><p>是否会导致饥饿</p></li></ol><ul><li><strong>饥饿</strong>: 某进程/作业长期得不到服务</li></ul><h3 id="先来先服务fcfs-first-come-first-serve">5.2<strong>先来先服务（FCFS, First Come First Serve）</strong></h3><ul><li><p>算法思想:主要从“公平”的角度考虑（类似于我们生活中排队买东西的例子）</p></li><li><p>算法规则: 按照作业/进程到达的先后顺序进行服务</p></li><li><p>用于作业/进程调度:用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列</p></li><li><p>是否可抢占: 非抢占式的算法</p></li><li><p>优缺点</p><ul><li>优点：公平、算法实现简单</li><li>缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即，FCFS算法对长作业有利，对短作业不利</li></ul></li><li><p>是否会导致饥饿: 不会</p></li></ul><h3 id="短作业优先sjf-shortest-job-first">5.3 <strong>短作业优先（SJF,Shortest Job First）</strong></h3><ul><li><p>算法思想:追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间</p></li><li><p>算法规则:最短的作业/进程优先得到服务（所谓“最短”，是指要求服务时间最短）</p></li><li><p>用于作业/进程调度:既可用于作业调度，也可用于进程调度。用于进程调度时称为“<strong>短进程优先（SPF,Shortest Process First）</strong>算法”</p></li><li><p>是否可抢占: SJF和SPF是非抢占式的算法。但是也有抢占式的版本 --<strong>最短剩余时间优先算法（SRTN, Shortest Remaining TimeNext）</strong></p><ul><li>最短剩余时间优先算法：每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度</li></ul></li><li><p>优缺点</p><ul><li>优点：“最短的”平均等待时间、平均周转时间<ul><li>1.如果题目中未特别说明，所提到的“短作业/进程优先算法”默认是非抢占式的</li><li>2. 很多书上都会说“SJF调度算法的平均等待时间、平均周转时间最少”，严格来说，这个表述是错误的，不严谨的。<strong>最短剩余时间优先算法得到的平均等待时间、平均周转时间还要更少</strong></li><li>应该加上一个条件“<strong>在所有进程同时可运行时</strong>，采用SJF调度算法的平均等待时间、平均周转时间最少”</li><li>或者说“<strong>在所有进程都几乎同时到达时</strong>，采用SJF调度算法的平均等待时间、平均周转时间最少”</li><li>如果不加上述前提条件，则应该说“抢占式的短作业/进程优先调度算法（最短剩余时间优先,SRNT算法）的平均等待时间、平均周转时间最少”</li><li>3.虽然严格来说，SJF的平均等待时间、平均周转时间并不一定最少，但相比于其他算法（如FCFS），SJF依然可以获得较少的平均等待时间、平均周转时间</li><li>4. 如果选择题中遇到“SJF算法的平均等待时间、平均周转时间最少”的选项，那最好判断其他选项是不是有很明显的错误，如果没有更合适的选项，那也应该选择该选项</li></ul></li><li>缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先</li></ul></li><li><p>是否会导致饥饿:会，如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生“饥饿”现象。如果一直得不到服务，则称为“饿死”</p></li><li><p>FCFS算法是在每次调度的时候选择一个等待时间最长的作业（进程）为其服务。但是没有考虑到作业的运行时间，因此导致了对短作业不友好的间题</p></li><li><p>SJF算法是选择一个执行时间最短的作业为其服务。但是又完全不考虑各个作业的等待时间，因此导致了对长作业不友好的问题，甚至还会造成饥饿问题</p></li></ul><h3 id="高响应比优先hrrn-highest-response-ratio-next">5.4<strong>高响应比优先（HRRN, Highest Response Ratio Next）</strong></h3><ul><li><p>算法思想: 要综合考虑作业/进程的等待时间和要求服务的时间</p></li><li><p>算法规则:在每次调度时先计算各个作业/进程的<strong>响应比</strong>，选择响应比最高的作业/进程为其服务</p><ul><li><span class="math display">\[响应比=\frac{等待时间+要求服务时间}{要求服务时间}\geq 1\]</span></li></ul></li><li><p>用于作业/进程调度: 即可用于作业调度，也可用于进程调度</p></li><li><p>是否可抢占:非抢占式的算法。因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比</p></li><li><p>优缺点</p><ul><li>综合考虑了等待时间和运行时间（要求服务时间）</li><li>等待时间相同时，要求服务时间短的优先（SJF 的优点）</li><li>要求服务时间相同时，等待时间长的优先（FCFS 的优点）</li><li>对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的</li><li>问题</li></ul></li><li><p>是否会导致饥饿: 不会</p></li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-2-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/image-20241120123533015.png"></p><h2 id="调度算法适合交互式系统"><strong>6.调度算法（适合交互式系统）</strong></h2><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-2-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/image-20241120145812395.png"></p><h3 id="时间片轮转rr-round-robin">6.1 <strong>时间片轮转（RR,Round-Robin）</strong></h3><ul><li><p>算法思想:公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</p></li><li><p>算法规则:按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片(如100ms)。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队</p></li><li><p>用于作业/进程调度:用于进程调度(只有作业放入内存建立了相应的进程后，才能被分配处理机时间片)</p></li><li><p>是否可抢占:若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出<strong>时钟中断</strong>来通知CPU时间片已到</p></li><li><p>优缺点</p><ul><li>优点：公平、响应快，适用于分时操作系统</li><li>缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度</li></ul></li><li><p>是否会导致饥饿: 不会</p></li><li><p>补充: 时间片太大或太小分别有什么影响?</p><ul><li>如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大</li><li>另一方面，进程调度、切换是有时间代价的(保存、恢复运行环境)，因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小</li><li>一般来说，设计时间片时要让切换进程的开销占比不超过1%</li></ul></li></ul><h3 id="优先级调度算法">6.2 <strong>优先级调度算法</strong></h3><ul><li><p>算法思想:随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序</p></li><li><p>算法规则: 调度时选择优先级最高的作业/进程</p></li><li><p>用于作业/进程调度:既可以用于作业调度，也可用于进程调度。甚至，还会用于在之后会学习的<strong>I/O调度</strong>中</p></li><li><p>是否可抢占:<strong>抢占式、非抢占式都有</strong>。做题时的区别在于:非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占</p></li><li><p>优缺点</p><ul><li>优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度</li><li>缺点：若源源不断地有高优先级进程到来，则可能导致饥饿</li></ul></li><li><p>是否会导致饥饿: 会</p></li><li><p>补充:</p><ul><li>就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置</li><li>根据优先级是否可以动态改变，可将优先级分为<strong>静态优先级</strong>和<strong>动态优先级</strong>两种<ul><li>静态优先级: 创建进程时确定，之后一直不变</li><li>动态优先级:创建进程时有一个初始值，之后会根据情况动态地调整优先级</li></ul></li><li><strong>如何合理地设置各类进程的优先级?</strong><ul><li>系统进程优先级 高于 用户进程</li><li>前台进程优先级 高于 后台进程</li><li>操作系统更偏好<strong>I/O型进程</strong>(或称<strong>I/O繁忙型进程</strong>)<ul><li>I/O设备和CPU可以并行工作。如果优先让I/O繁忙型进程优先运行的话，则越有可能让I/O设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升</li><li>注:与I/O型进程相对的是<strong>计算型进程</strong>(或称<strong>CPU繁忙型进程</strong>)</li></ul></li></ul></li><li><strong>如果采用的是动态优先级，什么时候应该调整?</strong><ul><li>可以从追求公平、提升资源利用率等角度考虑</li><li>如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级</li><li>如果某进程占用处理机运行了很长时间，则可以适当降低其优先级</li><li>如果发现一个进程频繁地进行I/O操作，则可适当提升其优先级</li></ul></li></ul></li></ul><h3 id="多级反馈队列调度算法">6.3<strong>多级反馈队列调度算法</strong></h3><ul><li><p>算法思想: 对其他调度算法的折中权衡</p></li><li><p>算法规则:</p><ul><li>设置多级就绪队列，各级队列优先级从高到底，时间片从小到大</li><li>新进程到达时先进入第1级队列，按FCFS原则排队等待分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾</li><li>只有第k级队列为空时，才会为k+1级队头的进程分配时间片。当高优先级队列有新进程到达时，会剥夺正在运行的低优先级队列中的进程，并将被剥夺的进程重新放回其所在的低优先级队列的队尾，之后当算法调度到该被剥夺的进程时再重新分配其所在队列对应的时间片</li></ul></li><li><p>用于作业/进程调度: 用于进程调度</p></li><li><p>是否可抢占:抢占式的算法。在k级队列的进程运行过程中，若更上级的队列(1~k-1级)中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾</p></li><li><p>优缺点</p><ul><li>对各类型进程相对公平(FCFS的优点)；</li><li>每个新到达的进程都可以很快就得到响应(RR的优点)；</li><li>短进程只用较少的时间就可完成(SPF的优点)；</li><li>不必实现估计进程的运行时间(避免用户作假)；</li><li>可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程(拓展:可以将因I/O阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级)</li></ul></li><li><p>是否会导致饥饿: 会</p></li><li><p>注：比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括分时操作系统、实时操作系统等)更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也能较好地满足交互式系统的需求。因此这三种算法适合用于交互式系统。（比如UNIX使用的就是多级反馈队列调度算法)</p></li></ul><h2 id="调度算法3"><strong>7. 调度算法（3）</strong></h2><ol type="1"><li>多级队列调度算法</li></ol><figure><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-2-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/image-20241120150022201.png" alt="多级队列调度算法"><figcaption aria-hidden="true">多级队列调度算法</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第二章 进程管理-2.1 进程与线程</title>
    <link href="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <url>/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="进程与线程"><strong>2.1 进程与线程</strong></h1><h2 id="进程的概念组成特征"><strong>1.进程的概念、组成、特征</strong></h2><h3 id="进程的概念">1.1 <strong>进程的概念</strong></h3><ol type="1"><li><strong>程序</strong></li></ol><ul><li>是静态的，就是存放在磁盘里的可执行文件，就是一系列的指令集合</li></ul><ol start="2" type="1"><li><strong>进程</strong></li></ol><ul><li><strong>是动态的，是程序的一次执行过程,是系统进行资源分配和调度的一个独立单位</strong>,同一个程序多次执行会对应多个进程<ul><li>确切来说, 是<strong>进程实体</strong>的执行过程</li><li><strong>调度</strong>:一个进程被“调度”，就是指操作系统决定让这个进程上CPU运行</li><li>当引入<strong>线程</strong>后, 进程不再是CPU调度的基本单位,仅仅是资源分配的基本单位</li></ul></li></ul><h3 id="进程进程实体的组成">1.2<strong>进程(进程实体)的组成</strong></h3><ul><li><p><strong>PCB(Process Control Block, 进程控制块)</strong></p><ul><li><strong>组成</strong>:<ul><li>当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的“身份证号”-- <strong>PID</strong> （Process ID，进程ID）</li><li>记录PID、进程所属用户UID<ul><li>基本的进程描述信息，可以让操作系统区分各个进程</li></ul></li><li>记录给进程分配了哪些资源（如：分配了多少内存、正在使用哪些I/O设备、正在使用哪些文件）<ul><li>可用于实现操作系统对资源的管理</li></ul></li><li>记录进程的运行情况（如：CPU使用时间、磁盘使用情况、网络流量使用情况、进程当前状态[就绪/运行/阻塞...]等）<ul><li>可用于实现操作系统对进程的控制、调度</li></ul></li><li>记录处理机相关信息（如：PSW、PC等各种寄存器的值）<ul><li>可用于实现进程切换</li></ul></li></ul></li><li>这些信息都被保存在一个数据结构PCB中,操作系统需要对各个并发运行的进程进行管理，操作系统对进程进行管理工作所需的信息都存在PCB中</li><li><strong>PCB是进程存在的唯一标志</strong>，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB</li></ul></li><li><p><strong>程序段</strong></p><ul><li>程序代码被编译之后产生的机器指令序列</li></ul></li><li><p><strong>数据段</strong></p><ul><li>进程运行过程中产生的各种数据</li></ul></li><li><p>PCB是给操作系统用的；程序段、数据段是给进程自己用的，与进程自身的运行逻辑有关</p></li><li><p>一个<strong>进程实体（进程映像）</strong>由PCB、程序段、数据段组成。进程是动态的，进程实体（进程映像）是静态的，进程实体反应了进程在某一时刻的状态</p></li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119185534404.png"></p><h3 id="进程的特征">1.3 <strong>进程的特征</strong></h3><ul><li><p>动态性: 进程是程序的一次执行过程, 是动态地产生、变化和消亡的</p><ul><li><strong>动态性是进程最基本的特征</strong></li></ul></li><li><p>并发性: 内存中有多个进程实体, 各进程可并发执行</p></li><li><p>独立性:进程是能独立运行、独立获得资源、独立接受调度的基本单位</p></li><li><p>异步性: 各进程按各自独立的、不可预知的速度向前推推进,操作系统要提供"<strong>进程同步机制</strong>"来解决异步问题</p><ul><li>异步性会导致并发程序执行结果的不确定性</li></ul></li><li><p>结构性: 每个进程都会配置一个PCB, 结构上看,进程由PCB、程序段、数据段组成</p></li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119185730743.png"></p><h2 id="进程的状态与转换进程的组织"><strong>2.进程的状态与转换、进程的组织</strong></h2><h3 id="进程的状态">2.1 <strong>进程的状态</strong></h3><ul><li><p><strong>创建态</strong>(New, 又称: 新建态)</p><ul><li>进程正在被创建时, 它的状态是"创建态",在这个阶段操作系统会为进程分配资源、初始化PCB</li></ul></li><li><p><strong>就绪态</strong>(Ready)</p><ul><li>当进程创建完成后, 便进入"就绪态", 处于就绪态的进程已经具备运行条件,但由于没有空闲CPU,就暂时不能运行</li></ul></li><li><p><strong>运行态</strong>(Running)</p><ul><li>当CPU空闲时, 操作系统就会选择一个就绪进程, 让它上处理机运行</li><li>如果一个进程此时在CPU上运行, 那么这个进程处于"运行态",CPU会执行该进程对应的程序(指令序列)</li><li>单CPU情况下, 同一时刻只会有一个进程处于运行态, 多核CPU情况下,可能有多个进程处于运行态</li></ul></li><li><p><strong>阻塞态</strong>(Blocked/Waiting, 又称: 等待态)</p><ul><li>在进程运行的过程中,可能会请求等待某个事件的发生(如等待某种系统资源的分配,或者等待其他进程的响应)</li><li>在这个事件发生之前, 进程无法继续往下执行,此时操作系统会让这个进程下CPU, 并让它进入"阻塞态"</li><li>当CPU空闲时, 又会选择另一个"就绪态"进程上CPU运行</li></ul></li><li><p><strong>终止态</strong>(Terminated, 又称: 结束态)</p><ul><li><p>一个进程可以执行exit系统调用, 请求操作系统终止该进程,此时该进程会进入"终止态", 操作系统会让这个进程下CPU,并回收内存空间等资源, 最后还要回收该进程的PCB</p></li><li><p>进程的整个生命周期中,大部分时间都处于运行态、就绪态、阻塞态</p></li><li><p>进程PCB中, 会有一个变量state来表示进程的当前状态</p></li></ul></li></ul><h3 id="进程状态的转化">2.2 <strong>进程状态的转化</strong></h3><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119190821500.png"></p><p>注意：不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态（因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求)</p><h3 id="进程的组织">2.3 <strong>进程的组织</strong></h3><ul><li><p>为了对同一个状态下的各个进程进行统一的管理,操作系统会将各个进程的PCB组织起来</p></li><li><p><strong>链接方式</strong></p><ul><li>操作系统根据进程状态的不同, 将相同状态的PCB放入同一个队列之中,很多操作系统还会根据阻塞原因的不同, 再分为多个阻塞队列,优先级较高的就绪进程会被放入就绪队列的队头<ul><li>执行指针 → PCB</li><li>就绪队列指针 → PCB → PCB</li><li>阻塞队列指针 → PCB → PCB</li></ul></li></ul></li><li><p><strong>索引方式</strong></p><ul><li>操作系统根据进程状态的不同, 创建几张索引表,操作系统持有指向各个索引表的指针, 通过索引表找到对应的PCB</li></ul></li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119191200075.png"></p><h2 id="进程控制"><strong>3. 进程控制</strong></h2><h3 id="基本概念">3.1 <strong>基本概念</strong></h3><ul><li><strong>进程控制</strong><ul><li>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能<ul><li>简化理解：反正<strong>进程控制就是要实现进程状态转换</strong></li></ul></li></ul></li><li><strong>如何实现进程控制?</strong><ul><li>用"<strong>原语</strong>"实现<ul><li>原语是一种特殊的程序， 它的执行具有原子性。也就是说，这段程序的运行必须一气呵成，不可中断</li><li>如果不能“一气呵成”，就有可能导致操作系统中的某些关键数据结构信息不统一的情况，这会影响操作系统进行别的管理工作</li></ul></li></ul></li><li><strong>如何实现原语的原子性?</strong><ul><li>可以用“<strong>关中断指令</strong>”和“<strong>开中断指令</strong>”这两个<strong>特权指令</strong>实现原子性<ul><li>正常情况下，CPU每执行完一条指令都会例行检查是否有中断信号需要处理，如果有，则暂停运行当前这段程序，转而执行相应的中断处理程序。CPU执行了关中断指令之后，就不再例行检查中断信号，直到执行开中断指令之后才会恢复检查。这样，关中断、开中断之间的这些指令序列就是不可被中断的，这就实现了“原子性“</li></ul></li></ul></li></ul><h3 id="进程控制相关的原语">3.2 <strong>进程控制相关的原语</strong></h3><ul><li>无论哪个进程控制原语，要做的无非三类事情：<ul><li>更新PCB中的信息</li><li>将PCB插入合适的队列</li><li>分配/回收资源</li></ul></li><li><strong>创建原语</strong></li></ul><figure><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119193358264.png" alt="创建原语"><figcaption aria-hidden="true">创建原语</figcaption></figure><ul><li><strong>撤销原语</strong></li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119194153849.png"></p><ul><li><strong>阻塞原语 &amp; 唤醒原语</strong></li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119194433458.png"></p><ul><li><strong>切换原语</strong></li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119195359883.png"></p><ul><li>指令顺序执行的过程中，很多中间结果是放在各种寄存器中的，CPU中会设置很多“寄存器（PSW、PC、IR、通用寄存器）”，用来存放程序运行过程中所需的某些数据，在<strong>进程切换</strong>时先在PCB中保存这个进程的运行环境（保存一些必要的寄存器信息），当原来的进程再次投入运行时，可以通过PCB恢复它的运行环境</li></ul><h2 id="进程通信"><strong>4. 进程通信</strong></h2><h3 id="什么是进程通信">4.1 <strong>什么是进程通信?</strong></h3><ul><li><strong>进程间通信(Inter-Process Communication,IPC)</strong>是指两个进程之间产生数据交互<ul><li>如b站分享视频到qq群中, 就需要不同进程之间的通信</li></ul></li></ul><h3 id="为什么进程通信需要操作系统支持">4.2<strong>为什么进程通信需要操作系统支持?</strong></h3><ul><li><p>进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立（<strong>进程的独立性</strong>）</p></li><li><p>为了保证安全，一个进程不能直接访问另一个进程的地址空间，但是进程之间的信息交换又是必须实现的，为了保证进程间的安全通信，操作系统提供了一些方法:</p><ul><li>共享存储</li><li>消息传递</li><li>管道通信</li></ul></li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119202143646.png"></p><h3 id="共享存储">4.3 <strong>共享存储</strong></h3><ul><li><p>设置一个<strong>共享区</strong>,将共享内存区映射到进程自己的地址空间中</p><ul><li>通过"<strong>增加页表项/段表项</strong>"即可将同一片共享内存区映射到各个进程的地址空间中</li></ul></li><li><p>为避免出错,各个进程对共享空间的访问应该是<strong>互斥</strong>的,操作系统只负责提供共享空间和同步互斥工具（如<strong>P、V操作</strong>）</p></li><li><p><strong>两种方式</strong>:</p><ul><li><strong>基于存储区的共享</strong>:<ul><li>在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。</li><li>相比之下，这种共享方式速度更快，是一种高级通信方式</li></ul></li><li><strong>基于数据结构的共享</strong>:<ul><li>比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式</li></ul></li></ul></li></ul><h3 id="消息传递">4.4 <strong>消息传递</strong></h3><ul><li>进程间的数据交换以<strong>格式化的消息（Message）</strong>为单位。进程通过操作系统提供的“<strong>发送消息/接收消息</strong>”两个<strong>原语</strong>进行数据交换<ul><li>格式化的消息: 包含<strong>消息头</strong>、<strong>消息体</strong><ul><li>消息头：包括发送进程ID、接受进程ID、消息类型、消息长度等格式化的信息（计算机网络中发送的“报文”其实就是一种格式化的消息）</li><li>消息体：进程间具体传递的信息</li></ul></li></ul></li><li><strong>两种方式</strong>:<ul><li><strong>直接通信方式</strong><ul><li>消息发送进程要指明接收进程的id,消息直接挂到接收进程的消息缓冲队列上</li></ul></li><li><strong>间接通信方式</strong><ul><li>通过"<strong>信箱</strong>"间接地通信,消息要先发送到中间实体（信箱）中,因此又被称为"<strong>信箱通信方式</strong>"</li></ul></li></ul></li></ul><h3 id="管道通信">4.5 <strong>管道通信</strong></h3><ul><li><p>“<strong>管道</strong>”是指用于连接读写进程的一个共享文件，又名pipe文件，其实就是在内存中开辟一个大小固定的缓冲区</p></li><li><p>数据在管道中以数据流的方式进行传输，遵循先进先出的原则</p></li><li><p><strong>管道通信</strong></p><ul><li>管道只能采用<strong>半双工通信</strong>，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道</li><li>各进程要<strong>互斥</strong>地访问管道(由操作系统实现)</li><li>当<strong>管道写满</strong>时，<strong>写进程将阻塞</strong>，直到读进程将管道中的数据取走，即可唤醒写进程<ul><li><strong>只要管道没满，写进程就可以往管道写数据</strong></li></ul></li><li>当<strong>管道读空</strong>时，<strong>读进程将阻塞</strong>，直到写进程往管道中写入数据，即可唤醒读进程<ul><li><strong>只要管道没空，读进程就可以从管道读数据</strong></li></ul></li><li>管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案:<ul><li>一个管道允许多个写进程，一个读进程（官方答案）</li><li>一个管道允许多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据（Linux方案）</li></ul></li></ul></li></ul><h2 id="线程的概念"><strong>5. 线程的概念</strong></h2><h3 id="什么是线程-为什么要引入线程">5.1 <strong>什么是线程,为什么要引入线程?</strong></h3><ul><li>进程是程序的一次执行过程, 传统的进程是程序执行流的最小单位,有的进程可能需要"同时"做很多事,而传统的进程只能串行地执行一系列程序。为此,引入了"<strong>线程</strong>", 来增加并发度, 引入线程后,<strong>线程成为了程序执行流的最小单位</strong><ul><li>线程是一个基本的CPU执行单元, 引入线程之后, 不仅是进程之间可以并发,进程内的各线程之间也可以并发, 从而进一步提升了系统的并发度,使得一个进程内也可以并发处理各种任务</li><li>引入线程后,<strong>进程只作为除CPU之外的系统资源的分配单位</strong></li></ul></li></ul><h3 id="引入线程机制后-有什么变化">5.2 <strong>引入线程机制后,有什么变化?</strong></h3><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119205846943.png"></p><h3 id="线程的属性">5.3 <strong>线程的属性</strong></h3><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119211033315.png"></p><h2 id="线程的实现方式和多线程模型"><strong>6.线程的实现方式和多线程模型</strong></h2><h3 id="线程的实现方式">6.1 <strong>线程的实现方式</strong></h3><ul><li><p><strong>用户级线程(User-Level Thread, ULT)</strong></p><ul><li>历史背景：早期的操作系统（如:早期Unix）只支持进程，不支持线程。当时的“线程”是由线程库实现的，很多编程语言提供了强大的线程库，可以实现线程的创建、销毁、调度等功能</li><li>用户级线程是“代码逻辑”的载体</li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119212407927.png"></p><ul><li><strong>用户级线程的管理工作由谁来完成?</strong><ul><li>用户级线程由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责（包括线程切换），并不是由操作系统完成</li></ul></li><li><strong>用户级线程切换是否需要CPU变态?</strong><ul><li>用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预</li></ul></li><li><strong>操作系统是否能意识到用户级线程的存在?</strong><ul><li>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在，操作系统只能看到包含着多个用户级线程的程序执行的进程</li><li>“用户级线程”就是“从用户视角看能看到的线程”</li></ul></li><li><strong>优缺点</strong><ul><li>优点:用户级线程的切换在用户态即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</li><li>缺点:当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高，多个线程不可在多核处理机上并行运行</li></ul></li></ul></li><li><p><strong>内核级线程(Kernel-Level Thread, KLT,又称“内核支持的线程”)</strong></p><ul><li>由操作系统支持的线程, 大多数现代操作系统都实现了内核级线程,如Windows、Linux</li><li>操作系统只“看得见”内核级线程，因此只有<strong>内核级线程才是处理机分配的单位</strong></li><li>内核级线程是“运行机会”的载体</li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119213816126.png"></p><ul><li><strong>内核级线程的管理工作由谁来完成?</strong><ul><li>内核级线程的管理工作由操作系统内核完成</li></ul></li><li><strong>内核级线程切换是否需要CPU变态?</strong><ul><li>线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成</li></ul></li><li><strong>操作系统是否能意识到内核级线程的存在?</strong><ul><li>操作系统会为每个内核级线程建立相应的<strong>TCB</strong>(ThreadControlBlock，线程控制块)，通过TCB对线程进行管理。“内核级线程”就是“从操作系统内核视角看能看到的线程”</li></ul></li><li><strong>优缺点</strong><ul><li>优点:当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行</li><li>缺点:一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大</li></ul></li></ul></li></ul><h3 id="多线程模型">6.2 <strong>多线程模型</strong></h3><ul><li><p>在支持内核级线程的系统中，根据<strong>用户级线程</strong>和<strong>内核级线程</strong>的<strong>映射关系</strong>，可以划分为几种多线程模型</p></li><li><p><strong>一对一模型</strong></p><ul><li>一个用户级线程映射到一个内核级线程，每个用户进程有与用户级线程同数量的内核级线程</li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119213900964.png"></p><ul><li>优点:当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</li><li>缺点:一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大</li></ul></li><li><p><strong>多对一模型</strong></p><ul><li>多个用户级线程映射到一个内核级线程，且一个进程只被分配一个内核级线程</li><li>退化为纯粹的用户级线程管理方式</li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119213936402.png"></p><ul><li>优点:用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</li><li>缺点:当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高，多个线程不可在多核处理机上并行运行</li></ul></li><li><p><strong>多对多模型</strong></p><ul><li>n 用户及线程映射到 m 个内核级线程(n &gt;= m)， 每个用户进程对应 m个内核级线程</li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119214026494.png"></p><ul><li>克服了多对一模型并发度不高的缺点(一个阻塞全体阻塞)，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点,内核级线程中可以运行任意一个有映射关系的用户级线程代码,只有m个内核级线程中正在运行的代码逻辑都阻塞时, 这个进程才会阻塞</li></ul></li></ul><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119214325834.png"></p><h2 id="线程的状态与转换"><strong>7. 线程的状态与转换</strong></h2><h3 id="线程的状态与转换-1">7.1 <strong>线程的状态与转换</strong></h3><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119214437515.png"></p><h3 id="线程的组织与控制">7.2 <strong>线程的组织与控制</strong></h3><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20241119214535741.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.6 虚拟机</title>
    <link href="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-6-%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <url>/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-6-%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟机"><strong>1.6 虚拟机</strong></h1><h2 id="虚拟机-1">1. <strong>虚拟机</strong></h2><ul><li><p>使用虚拟化技术, 将一台物理机器虚拟化为多台虚拟机器(VirtualMachine, VM), 每个虚拟机器都可以独立运行一个操作系统</p></li><li><p>同义术语: 虚拟机管理程序/虚拟机监控程序/Virtual MachineMonitor/Hypervisor</p></li></ul><figure><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-6-%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20241119165138528.png" alt="两类虚拟机"><figcaption aria-hidden="true">两类虚拟机</figcaption></figure><ul><li>支持虚拟化的CPU通常分更多指令等级<ul><li>Ring 3: 最低权限的一些指令 → Ring 0: 最高权限的一些指令</li><li>VMware、VirtualBox就属于第二轮VMM</li></ul></li></ul><h2 id="两类虚拟机管理程序的对比">2.<strong>两类虚拟机管理程序的对比</strong></h2><figure><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-6-%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20241119165622367.png" alt="对比"><figcaption aria-hidden="true">对比</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.5 操作系统引导</title>
    <link href="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-5-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC/"/>
    <url>/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-5-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统引导"><strong>1.5 操作系统引导</strong></h1><h2 id="什么是操作系统引导">1. <strong>什么是操作系统引导?</strong></h2><ul><li>开机的时候, 怎么让操作系统运行起来?</li></ul><h2 id="磁盘里边有哪些相关数据">2.<strong>磁盘里边有哪些相关数据?</strong></h2><ul><li><strong>主引导记录(MBR)</strong><ul><li>包含<strong>磁盘引导程序</strong>和<strong>分区表</strong></li><li>分区表: 说明了每个磁盘分区占据多少空间、地址范围</li></ul></li><li>C:盘<ul><li>是这个磁盘的<strong>活动分区</strong>, 安装了操作系统</li><li><strong>引导记录(PBR)</strong><ul><li>负责找到"启动管理器", "启动管理器"是完整的操作系统初始化程序,其存放在根目录中的某个位置</li><li>Windows中"启动管理器"存放在 根目录下</li></ul></li><li>根目录</li><li>其他</li></ul></li><li>其他盘</li></ul><h2 id="操作系统引导过程">3. <strong>操作系统引导过程</strong></h2><ul><li><strong>主存(内存)</strong><ul><li><strong>RAM</strong><ul><li>日常用语电脑内存、手机内存通常就是指代RAM</li></ul></li><li><strong>ROM</strong><ul><li>存储了基本输入输出系统<strong>BIOS</strong>,其内部包含了ROM引导程序, 即自举程序</li></ul></li></ul></li><li><strong>引导过程</strong>:<ul><li>CPU从一个特定主存地址开始, 取指令,执行ROM中的引导程序(先进行硬件自检, 再开机)</li><li>将磁盘的第一块 -- 主引导记录读入内存, 执行磁盘引导程序,扫描分区表</li><li>从活动分区(又称主分区, 即安装了操作系统的分区)读入分区引导记录,执行其中的程序</li><li>从根目录下找到完整的操作系统初始化程序(即 启动管理器 )并执行,完成"开机"的一系列动作</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.4 操作系统结构</title>
    <link href="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
    <url>/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统体系结构">1.4 操作系统体系结构</h1><figure><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20241119160018312.png" alt="计算机系统的层次结构"><figcaption aria-hidden="true">计算机系统的层次结构</figcaption></figure><h2 id="操作系统的内核">1. <strong>操作系统的内核</strong></h2><figure><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20241119160322830.png" alt="操作系统内核"><figcaption aria-hidden="true">操作系统内核</figcaption></figure><ul><li><strong>内核</strong>是操作系统最基本、最核心的部分</li><li>实现操作系统内核功能的那些程序就是<strong>内核程序</strong></li></ul><h3 id="大内核">1.1 <strong>大内核</strong></h3><ul><li><p>内核中包含了时钟管理、中断处理、原语以及进程管理、存储器管理、设备管理等功能</p></li><li><p>由于大内核中包含的功能多,CPU只需进行少量的状态切换便可完成应用程序请求的系统调用,但同时也导致了大内核代码庞大, 不方便管理的问题</p></li></ul><h3 id="微内核">1.2 <strong>微内核</strong></h3><ul><li><p>只包含了与硬件关联较紧密的模块,如时钟管理、中断处理、原语等</p></li><li><p>微内核内部功能少, 结构清晰, 方便维护,但也要求CPU需要进行多次的状态切换来满足应用程序请求的进程、存储器、设备等服务</p></li></ul><figure><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20241119160746125.png" alt="大内核与微内核"><figcaption aria-hidden="true">大内核与微内核</figcaption></figure><figure><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20241119160818121.png" alt="操作系统的体系结构"><figcaption aria-hidden="true">操作系统的体系结构</figcaption></figure><h2 id="外核">2. 外核</h2><figure><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20241119161000144.png" alt="操作系统结构"><figcaption aria-hidden="true">操作系统结构</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.3 操作系统运行环境</title>
    <link href="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/"/>
    <url>/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统运行环境">1.3 操作系统运行环境</h1><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/image-20241119150939015.png"></p><h2 id="操作系统的运行机制">1. <strong>操作系统的运行机制</strong></h2><h3 id="程序是如何运行的">1.1 <strong>程序是如何运行的?</strong></h3><ul><li>一条高级语言的代码翻译过来可能会对应多条二进制机器指令</li><li>程序运行的过程其实是CPU执行一条一条的机器指令的过程<ul><li>"指令"就是处理机(CPU)能识别、执行的最基本命令</li></ul></li></ul><h3 id="内核程序-vs-应用程序">1.2 <strong>内核程序 vs应用程序</strong></h3><ul><li><strong>应用程序</strong><ul><li>普通程序员写的程序就是"应用程序"</li></ul></li><li><strong>内核程序</strong><ul><li>微软、苹果有一帮人负责实现操作系统, 他们写的是"内核程序"</li><li>由很多内核程序组成了"<strong>操作系统内核</strong>",或简称"<strong>内核(Kernel)</strong>"</li><li>内核是操作系统最重要最核心的部分, 也是最接近硬件的部分, 甚至可以说,一个操作系统只要有内核就够了(eg: Docker→ 仅需Linux内核)</li></ul></li></ul><h3 id="特权指令-vs-非特权指令">1.3 <strong>特权指令 vs非特权指令</strong></h3><ul><li><strong>特权指令</strong><ul><li>操作系统内核作为"管理者", 有时会让CPU执行一些"特权指令", 如:内存清零指令, 这些指令影响重大, 只允许"管理者" --即操作系统内核来使用</li></ul></li><li><strong>非特权指令</strong><ul><li>应用程序只能使用"非特权指令", 如: 加法指令、减法指令</li><li>在CPU设计和生产的时候就划分了特权指令和非特权指令，因此CPU执行一条指令前就能判断出其类型</li></ul></li></ul><h3 id="用户态-vs-内核态">1.4 <strong>用户态 vs 内核态</strong></h3><ul><li>CPU有两种状态: "<strong>内核态</strong>" 和"<strong>用户态</strong>"<ul><li>CPU中有一个寄存器叫<strong>程序状态字寄存器(PSW)</strong>,其中有一个二进制位能够表示CPU为用户态还是内核态</li><li>内核态=核心态=<strong>管态</strong>;用户态=<strong>目态</strong></li></ul></li><li><strong>用户态</strong><ul><li>处于用户态时, 说明此时正在运行的是应用程序,此时只能执行非特权指令</li></ul></li><li><strong>核心态</strong><ul><li>处于核心态时, 说明此时正在运行的是内核程序,此时可以执行特权指令</li></ul></li><li><strong>两种状态的切换</strong><ul><li><strong>内核态 → 用户态</strong><ul><li>执行一条特权指令 -- 修改PSW的标志位为"用户态",这个动作意味着操作系统将主动让出CPU特权</li></ul></li><li><strong>用户态 → 内核态</strong><ul><li>由"<strong>中断</strong>"引发, 硬件自动完成变态过程,触发中断信号意味着操作系统将强行夺回CPU的使用权</li><li>除了非法使用特权指令之外, 还有很多事件会触发中断信号。一个共性是:但凡需要操作系统介入的地方, 都会触发中断信号</li></ul></li><li><strong>示例</strong>:<ol type="1"><li>刚开机时, CPU为"内核态", 操作系统内核程序先上CPU运行</li><li>开机完成后, 用户可以启动某个应用程序</li><li>操作系统内核程序在合适的时候主动让出CPU, 让该应用程序上CPU运行<ul><li>操作系统内核在让出CPU之前,会用一条特权指令把PSW的标志位设置为"用户态"</li></ul></li><li>应用程序运行在"用户态"</li><li>此时黑客在应用程序中植入了一条特权指令, 企图破坏系统</li><li>CPU发现接下来要执行的这条指令是特权指令, 但是自己又处于"用户态"</li><li>这个非法事件会引发一个<strong>中断信号</strong><ul><li>CPU检测到中断信号后, 会立即变为"内核态", 并停止运行当前的应用程序,转而运行处理中断信号的内核程序</li></ul></li><li>"中断"使操作系统再次夺回CPU的控制权</li><li>操作系统会对引发中断的事件进行处理,处理完了再把CPU使用权交给应用程序</li></ol></li></ul></li></ul><h2 id="中断和异常"><strong>2. 中断和异常</strong></h2><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/image-20241119154048407.png"></p><ul><li>“<strong>中断</strong>”是让操作系统内核夺回CPU使用权的唯一途径</li></ul><h3 id="内中断异常">2.1 内中断(异常)</h3><ul><li>与当前执行的指令有关，中断信号来源于CPU内部</li><li><strong>示例</strong>:<ol type="1"><li>试图在用户态下执行特权指令</li><li>执行除法指令时发现除数为 0<ul><li>若当前执行的指令是非法的，则会引发一个中断信号</li></ul></li><li>有时候应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令 --<strong>陷入指令</strong><ul><li><strong>(访管指令)</strong>，该指令会引发一个内部中断信号</li><li>执行“陷入指令”，意味着应用程序主动地将CPU控制权还给操作系统内核</li><li>“<strong>系统调用</strong>”就是通过陷入指令完成的</li></ul></li></ol></li><li><strong>分类</strong>:<ul><li><strong>陷阱、陷入(trap)</strong><ul><li>由陷入指令引发，是应用程序故意引发的</li></ul></li><li><strong>故障(fault)</strong><ul><li>由错误条件引起的，可能被内核程序修复</li><li>内核程序修复故障后会把CPU使用权还给应用程序，让它继续执行下去</li><li>如：<strong>缺页故障(缺页中断)</strong></li></ul></li><li><strong>终止(abort)</strong><ul><li>由致命错误引起，内核程序无法修复该错误</li><li>因此一般不再将CPU使用权还给引发终止的应用程序，而是直接终止该应用程序</li><li>如： 整数除0、非法使用特权指令</li></ul></li></ul></li></ul><h3 id="外中断中断">2.2 <strong>外中断(中断)</strong></h3><ul><li>与当前执行的指令无关，中断信号来源于CPU外部</li><li>每一条指令执行结束时，CPU都会例行检查是否有外中断信号</li><li><strong>示例</strong>:<ul><li>时钟中断 -- 由时钟部件发来的中断信号<ul><li>时钟部件每隔一个时间片（如 50ms）会给CPU发送一个时钟中断信号</li></ul></li><li>I/O中断 -- 由输入/输出设备发来的中断信号<ul><li>如打印机打印完成后, 向CPU发送中断信号,CPU根据中断信号执行对应的<strong>中断处理程序</strong></li></ul></li></ul></li><li><strong>注意</strong>：<ul><li>大多数的教材、试卷中，“<strong>中断</strong>”特指狭义的中断，即<strong>外中断</strong>。而<strong>内中断</strong>一般称为“<strong>异常</strong>”</li></ul></li><li><strong>中断机制的基本原理</strong><ul><li>不同的中断信号，需要用不同的<strong>中断处理程序</strong>来处理</li><li>当CPU检测到中断信号后，会根据中断信号的类型去查询“<strong>中断向量表</strong>”，以此来找到相应的中断处理程序在内存中的存放位置</li></ul></li></ul><h2 id="系统调用"><strong>3. 系统调用</strong></h2><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/image-20241119155457023.png"></p><h3 id="什么是系统调用">3.1 <strong>什么是系统调用?</strong></h3><ul><li><p>操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括<strong>命令接口</strong>和<strong>程序接口</strong>，其中，程序接口由一组<strong>系统调用</strong>组成</p></li><li><p>“系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求获得操作系统内核的服务</p></li></ul><h3 id="系统调用与库函数的区别">3.2<strong>系统调用与库函数的区别</strong></h3><table><thead><tr><th style="text-align: center;">普通应用程序</th><th style="text-align: center;">可直接进行系统调用，也可使用库函数。有的库函数涉及系统调用，有的不涉及</th></tr></thead><tbody><tr><td style="text-align: center;">编程语言</td><td style="text-align: center;">向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使程序员编程更加方便</td></tr><tr><td style="text-align: center;">操作系统</td><td style="text-align: center;">向上提供系统调用，使得上层程序能请求内核的服务</td></tr><tr><td style="text-align: center;">裸机</td><td style="text-align: center;"></td></tr></tbody></table><ul><li><p>不涉及系统调用的库函数：如的“取绝对值”的函数</p></li><li><p>涉及系统调用的库函数：如“创建一个新文件”的函数</p></li><li><p>总之，部分库函数是对系统调用的进一步封装，应用程序可以使用库函数进行间接系统调用，也可以进行直接系统调用</p></li></ul><h3 id="为什么系统调用是必须的">3.3<strong>为什么系统调用是必须的?</strong></h3><ul><li><strong>生活场景</strong>:<ul><li>去学校打印店打印论文，你按下了 WPS 的“打印”选项，打印机开始工作。你的论文打印到一半时，另一位同学按下了 Word的“打印”按钮，开始打印他自己的论文。</li></ul></li><li><strong>思考</strong>:<ul><li>如果两个进程可以随意地、并发地共享打印机资源(<strong>同时共享</strong>)，会发生什么情况？<ul><li>两个进程并发运行，打印机设备交替地收到 WPS 和 Word两个进程发来的打印请求，结果两篇论文的内容混杂在一起了</li></ul></li></ul></li><li><strong>解决方法</strong>:<ul><li>由操作系统内核对共享资源进行统一的管理，并向上提供 “系统调用”，用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求，以此来实现不同的进程对打印机资源的<strong>互斥共享</strong>，内核会对各个请求进行协调处理</li></ul></li></ul><h3 id="什么功能要用系统调用实现">3.4<strong>什么功能要用系统调用实现?</strong></h3><ul><li><p>应用程序通过系统调用请求操作系统的服务。而系统中的各种<strong>共享资源</strong>都由操作系统内核统一掌管，因此凡是<strong>与共享资源有关的操作</strong>（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作</p></li><li><p><strong>功能分类(了解即可)</strong>:</p><ul><li>设备控制: 完成设备的 请求/释放/启动 等功能</li><li>文件管理: 完成文件的 读/写/创建/删除 等功能</li><li>进程控制: 完成进程的 创建/撤销/阻塞/唤醒 等功能</li><li>进程通信: 完成进程之间的 消息传递/信号传递 等功能</li><li>内存管理: 完成内存的 分配/回收 等功能</li></ul></li></ul><h3 id="系统调用的过程">3.5 <strong>系统调用的过程</strong></h3><ul><li><p>传递系统调用参数（将系统调用需要的参数放到某些通用寄存器中） →执行陷入指令（用户态）→执行相应的内核程序（根据寄存器中的参数判断用户需要哪种系统调用服务）处理系统调用（核心态）→返回应用程序</p></li><li><p><strong>注意</strong>:</p><ul><li><strong>陷入指令</strong>是在<strong>用户态</strong>执行的，执行陷入指令之后立即引发一个内中断，使CPU进入核心态</li><li><strong>发出系统调用请求</strong>是在<strong>用户态</strong>，而<strong>对系统调用的相应处理</strong>在<strong>核心态</strong>下进行</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.2 操作系统发展历程</title>
    <link href="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/"/>
    <url>/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统发展历程">1.2 操作系统发展历程</h1><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/image-20241119125703536.png"></p><h2 id="手工操作阶段">1. <strong>手工操作阶段</strong></h2><ul><li><p>程序员将程序放入纸带机上(慢) → 计算机读取纸带(慢) →计算机计算(快) → 输出纸带(慢) → 程序员获取计算结果(慢)</p></li><li><p><strong>主要缺点</strong>:</p><ul><li>用户独占全机、人机速度矛盾导致资源利用率低</li></ul></li></ul><h2 id="批处理阶段">2. <strong>批处理阶段</strong></h2><h3 id="单道批处理系统">2.1 <strong>单道批处理系统</strong></h3><ol type="1"><li><p>引入<strong>脱机输入/输出技术</strong>（用<strong>外围机</strong>+<strong>磁带</strong>完成），并由监督程序(操作系统雏形)负责控制作业的输入、输出</p></li><li><p><strong>为什么称为"脱机"?</strong></p><ol type="1"><li>脱离主机的控制进行的输入/输出操作</li><li>程序员将程序放入纸带机上 → 外围机将纸带数据放入磁带中 →计算机读取磁带(磁带读写速度比纸带机快很多) → 计算机计算 →输出计算结果到磁带</li></ol></li><li><p><strong>主要优点</strong>:</p><ol type="1"><li>缓解了一定程度的人机速度矛盾，资源利用率有所提升</li></ol></li><li><p><strong>主要缺点</strong>:</p><ol type="1"><li>内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序。CPU有大量的时间是在空闲等待I/O完成。资源利用率依然很低</li></ol></li></ol><h3 id="多道批处理系统">2.2 <strong>多道批处理系统</strong></h3><ol type="1"><li><p>操作系统正式诞生，用于支持多道程序并发运行，每次往内存中读入多道程序</p></li><li><p><strong>主要优点</strong>：</p><ol type="1"><li>多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大</li></ol></li><li><p><strong>主要缺点</strong>:</p><ol type="1"><li>用户响应时间长，没有人机交互功能（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行eg：无法调试程序/无法在程序运行过程中输入一些参数）</li></ol></li></ol><h2 id="分时操作系统">3. <strong>分时操作系统</strong></h2><ol type="1"><li><p>计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互</p></li><li><p><strong>主要优点</strong>:</p><ol type="1"><li>用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在</li></ol></li><li><p><strong>主要缺点</strong>:</p><ol type="1"><li>不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性</li></ol></li></ol><h2 id="实时操作系统">4. <strong>实时操作系统</strong></h2><ol type="1"><li><p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件</p></li><li><p>实时操作系统的主要特点是<strong>及时性</strong>和<strong>可靠性</strong></p></li><li><p><strong>硬实时系统</strong></p><ol type="1"><li>必须在绝对严格的规定时间内完成处理</li></ol></li><li><p><strong>软实时系统</strong></p><ol type="1"><li>能接受偶尔违反时间规定</li></ol></li><li><p><strong>主要优点</strong>:</p><ol type="1"><li>能够优先响应一些紧急任务，某些紧急任务不需时间片排队</li></ol></li></ol><h2 id="其他操作系统">5. <strong>其他操作系统</strong></h2><ol type="1"><li>网络操作系统<ol type="1"><li>是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信（如：WindowsNT就是 一种典型的网络操作系统，网站服务器就可以使用）</li></ol></li><li>分布式操作系统<ol type="1"><li>主要特点是分布性和并行性</li><li>系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务</li></ol></li><li>个人计算机操作系统<ol type="1"><li>如 Windows XP、MacOS，方便个人使用</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.1 操作系统的基本概念</title>
    <link href="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统的基本概念">1.1 操作系统的基本概念</h1><h2 id="os概念">1. OS概念</h2><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20241119123556782.png"></p><h3 id="计算机系统的层次结构">1.1 计算机系统的层次结构</h3><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20241119121839269.png"></p><ul><li>用户可以通过调用命令接口的方式以及使用GUI与操作系统进行直接交互</li><li>应用程序通过调用程序接口的方式与操作系统进行直接交互</li><li>裸机(纯硬件)包括CPU、内存、硬盘、主板等</li></ul><h3 id="操作系统概念">1.2 操作系统概念</h3><ul><li>操作系统(OperatingSystem,OS)是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配；</li><li>以提供给用户和其他软件方便的接口和环境；</li><li>它是计算机系统中最基本的系统软件。</li></ul><ol type="1"><li>操作系统是系统资源的管理者<ol type="1"><li>以提供给用户和其他软件方便的接口和环境</li></ol></li><li>向上层提供方便易用的服务<ol type="1"><li>它是计算机系统中最基本的系统软件</li></ol></li><li>是最接近硬件的一层软件</li></ol><h2 id="os功能和目标">2. OS功能和目标</h2><h3 id="系统资源的管理者">2.1 系统资源的管理者</h3><ul><li>用QQ和朋友视频聊天的过程：<ul><li>Step 1：在各个文件夹中找到 QQ 安装的位置（如 D:/Tencent/QQ/Bin）<ul><li>逐层打开文件夹， 找到QQ.exe 这个程序（可执行文件）的存放位置</li><li>文件管理</li></ul></li><li>Step 2：双击打开 QQ.exe<ul><li>需要把该程序相关数据放入内存</li><li>存储器管理, 执行一个程序前需要将该程序放到内存中，才能被CPU处理</li></ul></li><li>Step 3：QQ 程序正常运行<ul><li>对应的进程被处理机（CPU）处理</li><li>处理机管理</li></ul></li><li>Step 4：开始和朋友视频聊天<ul><li>需要将摄像头设备分配给进程</li><li>设备管理</li></ul></li></ul></li></ul><h3 id="向上层提供方便易用的服务">2.2<strong>向上层提供方便易用的服务</strong></h3><ul><li><strong>封装思想</strong><ul><li>操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可</li></ul></li><li><strong>提供的服务</strong><ul><li>GUI：图形化用户接口（Graphical User Interface）</li><li><strong>联机命令接口</strong> = <strong>交互式命令接口</strong><ul><li>如Windows命令行指令</li><li>特点: 用户说一句, 系统跟着做一句</li></ul></li><li><strong>脱机命令接口</strong> = <strong>批处理命令接口</strong><ul><li>如执行Windows中的*.bat文件</li><li>特定: 用户说一堆, 系统跟着做一堆</li></ul></li><li><strong>程序接口</strong>(由一系列系统调用组成)<ul><li>可以在程序中进行<strong>系统调用(广义指令)</strong>来使用程序接口,普通用户不能直接使用程序接口, 只能通过程序代码间接使用</li><li>系统调用类似于函数调用，是应用程序请求操作系统服务的唯一方式</li></ul></li></ul></li></ul><h3 id="作为最接近硬件的层次">2.3<strong>作为最接近硬件的层次</strong></h3><ol type="1"><li><p>需要实现对硬件机器的拓展</p></li><li><p>没有任何软件支持的计算机称为<strong>裸机</strong></p><ol type="1"><li>在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器</li></ol></li><li><p>通常把覆盖了软件的机器称为<strong>扩充机器</strong>，又称之为<strong>虚拟机</strong></p></li><li><p><strong>操作系统对硬件机器的拓展</strong></p><ol type="1"><li>将CPU、内存、磁盘、显示器、键盘等硬件合理地组织起来，让各种硬件能够相互协调配合，实现更多更复杂的功能</li><li>普通用户无需关心这些硬件在底层是怎么组织起来工作的，只需直接使用操作系统提供的接口即可</li></ol></li></ol><h2 id="操作系统的特征">3. 操作系统的特征</h2><p><img src="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20241119125617317.png"></p><h3 id="并发">3.1 <strong>并发</strong></h3><ul><li>两个或多个事件在同一时间间隔内发生。这些事情宏观上是同时发生的,但微观上是交替发生的</li></ul><ol type="1"><li><strong>并行</strong><ol type="1"><li>指两个或多个事件在同一时刻同时发生</li></ol></li><li><strong>操作系统的并发性</strong><ol type="1"><li>是指计算机系统中“同时”运行着多个程序, 这些程序宏观上看是同时运行着,而微观上看是交替运行的</li><li>操作系统就是伴随着“多道程序技术”而出现的。因此，操作系统和程序并发是一起诞生的</li></ol></li><li><strong>注意</strong><ol type="1"><li><strong>单核CPU</strong>同一时刻只能执行一个程序，各个程序只能并发地执行</li><li><strong>多核CPU</strong>同一时刻可以同时执行多个程序，多个程序可以并行地执行</li></ol></li></ol><h3 id="共享">3.2 <strong>共享</strong></h3><ul><li>并发与共享是两个最基本的特征, 二者互为存在条件<ul><li>如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义</li><li>如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发</li></ul></li><li><strong>共享</strong>即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用<ul><li><strong>互斥共享</strong><ul><li>系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源</li></ul></li><li><strong>同时共享</strong><ul><li>系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问</li><li>所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享）</li></ul></li></ul></li></ul><h3 id="虚拟">3.3 <strong>虚拟</strong></h3><p>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体是实际存在的,逻辑上的对应物是用户感受到的</p><ul><li><strong>空分复用技术</strong><ul><li>虚拟存储器运行着远大于实际存储器内存大小的程序</li></ul></li><li><strong>时分复用技术</strong><ul><li>微观上处理机在各个微小的时间段内交替着为各个进程服务</li></ul></li><li>显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，没有并发性，就谈不上虚拟性</li></ul><h3 id="异步">3.4 <strong>异步</strong></h3><ul><li>在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性</li><li>只有系统拥有并发性，才有可能导致异步性</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.7 万维网WWW</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-7-%E4%B8%87%E7%BB%B4%E7%BD%91WWW/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-7-%E4%B8%87%E7%BB%B4%E7%BD%91WWW/</url>
    
    <content type="html"><![CDATA[<h1 id="万维网www">6.7 万维网WWW</h1><blockquote><p>即 World WideWeb，是一个大规模的、联机式的信息储藏所，是运行在因特网上的一个分布式应用。</p></blockquote><figure><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-7-%E4%B8%87%E7%BB%B4%E7%BD%91WWW/image-20241118192932067.png" alt="万维网文档"><figcaption aria-hidden="true">万维网文档</figcaption></figure><ol type="1"><li><p>统一资源定位符URL</p><blockquote><p>万维网使用统一资源定位符URL来指明因特网上任何种类“资源”的位置。</p><p>其一般形式为：<code>&lt;协议&gt;：/∥&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;</code></p></blockquote></li><li><p>超文本传输协议HTTP</p><blockquote><p>超文本传输协议 HTTP (HyperText Transfer Protocol)定义了浏览器（即万维网客户进程）怎样向万维网服务器请求万维网文档以及万维网服务器怎样把万维网文档传送给浏览器。</p></blockquote><ol type="1"><li><p>HTTP1.0</p><blockquote><p>采用非持续连接方式。每次浏览器要请求一个文件都要与服务器建立TCP连接(80端口)，当收到响应后就立即关闭连接。</p><p>每请求一个文档就要有两倍的TT的开销。若一个网页上有很多引用对象（例如图片等），那么请求每一个对象都需要花费2RTT的时间。为了减小时延，浏览器通常会建立多个并行的TCP连接同时请求多个对象。但是，这会大量占用万维网服务器的资源，特别是万维网服务器往往要同时服务于大量客户的请求，这会使其负担很重。</p></blockquote></li><li><p>HTTP1.1</p><blockquote><ol type="1"><li><p>采用持续连接方式。万维网服务器在发送响应后仍然保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。</p></li><li><p>为了进一步提高效率，还可采用流水线方式，即浏览器在收到HTTP的响应报文之前就能够连续发送多个请求报文。</p></li></ol></blockquote></li></ol></li><li><p>HTTP两种报文——请求报文和响应报文</p><blockquote><p>报文中的每一个字段都是一些ASCII码串，并且每个字段的长度都是不确定的。</p></blockquote><ol type="1"><li><p>请求报文格式 <img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-7-%E4%B8%87%E7%BB%B4%E7%BD%91WWW/image-20241118222527016.png"></p></li><li><p>响应报文格式 <img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-7-%E4%B8%87%E7%BB%B4%E7%BD%91WWW/1689763996008.png" alt="1689763996008"></p></li></ol></li><li><p>Cookie技术</p><blockquote><p>Cookie提供了一种机制使得万维网服务器能够“记住”用户，而无需用户主动提供用户标识信息。也就是说，Cookie是一种<strong>对无状态的HTTP进行状态化</strong>的技术。</p></blockquote><figure><img src="https://raw.githubusercontent.com/Ag-epiphany/typora_Pictures/main/image-20230719184205348.png" alt="image-20230719184205348"><figcaption aria-hidden="true">image-20230719184205348</figcaption></figure></li><li><p>万维网缓存（Web缓存）</p><blockquote><p>在万维网中还可以使用缓存机制以提高万维网的效率。可位于客户机，也可位于中间系统上，位于中间系统上的Web缓存又称为代理服务器。</p></blockquote><figure><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-7-%E4%B8%87%E7%BB%B4%E7%BD%91WWW/image-20230719183530450.png" alt="image-20230719183530450"><figcaption aria-hidden="true">image-20230719183530450</figcaption></figure><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>Last-Modified</td><td>最后修改时间</td></tr><tr><td>Expires</td><td>有效期</td></tr></tbody></table><ol type="1"><li>若过了最后有效期，则在客户机发来请求时，代理服务器向原始服务器发送请求得到新的数据<ol type="1"><li>若原始服务器的数据也未更改，则发回一个不带实体数据的响应报文，代理服务器收到后更新有效期，将数据发给客户机</li><li>若原始服务器的数据更改，那么发回新数据的响应报文，代理服务器更新数据以及两个字段并将新数据发给客户机</li></ol></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.6 电子邮件</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-6-%E7%94%B5%E5%AD%90%E5%8D%8F%E8%AE%AE/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-6-%E7%94%B5%E5%AD%90%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="电子邮件">6.6 电子邮件</h1><h2 id="电子邮件系统">1. 电子邮件系统</h2><blockquote><p>电子邮件系统采用客户/服务器方式。三个主要组成构件：用户代理，邮件服务器以及电子邮件所需的协议</p></blockquote><ol type="1"><li>用户代理是用户与电子邮件系统的接口，又称为电子邮件客户端软件</li><li>邮件服务器是电子邮件系统的基础设施。因特网上所有的SP都有邮件服务器，其功能是发送和接收邮件，同时还要负责维护用户的邮箱。</li><li>协议包括邮件发送协议（例如SMTP)和邮件读取协议（例如POP3)。</li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-6-%E7%94%B5%E5%AD%90%E5%8D%8F%E8%AE%AE/image-20241118190659564.png"></p><h2 id="简单邮件传送协议smtp">2. 简单邮件传送协议SMTP</h2><ol type="1"><li><p>基本工作原理</p><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-6-%E7%94%B5%E5%AD%90%E5%8D%8F%E8%AE%AE/image-20241118191131692.png"></p></li><li><p>SMTP协议只能传送ASCII码文本数据，不能传送可执行文件或其他的二进制对象。</p></li><li><p>SMTP不能满足传送多媒体邮件（例如带有图片、音频或视频数据）的需要。并且许多其他非英语国家的文字(例如中文、俄文、甚至带有重音符号的法文或德文)也无法用SMTP传送。</p></li><li><p>为解决SMTP传送非ASCII码文本的问题，提出了多用途因特网邮件扩展MIME</p><ol type="1"><li>增加了5个新的邮件首部字段，这些字段提供了有关邮件主体的信息。</li><li>定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。</li><li>定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变。</li></ol></li><li><p>实际上，MIME不仅仅用于SMTP,也用于后来的同样面向ASCII字符的HTTP。</p></li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-6-%E7%94%B5%E5%AD%90%E5%8D%8F%E8%AE%AE/image-20241118191715497.png"></p><h2 id="电子邮件的格式">3. 电子邮件的格式</h2><ul><li>一个电子邮件有信封和内容两部分。而内容又由首部和主体两部分构成。</li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-6-%E7%94%B5%E5%AD%90%E5%8D%8F%E8%AE%AE/image-20241118191547061.png"></p><ol type="1"><li>高亮部分为比较重要的部分，为必填项。</li></ol><h2 id="邮件读取协议">4. 邮件读取协议</h2><ol type="1"><li><p>邮局协议POP3</p><blockquote><p>非常简单、功能有限的邮件读取协议。用户只能以下载并删除方式或下载并保留方式从邮件服务器下载邮件到用户方计算机。不允许用户在邮件服务器上管理自己的邮件。</p></blockquote></li><li><p>因特网邮件访问协议IMAP</p><blockquote><p>功能比POP3强大的邮件读取协议。用户在自己的计算机上就可以操控邮件服务器中的邮箱，就像在本地操控一样，因此IMAP是一个联机协议。</p></blockquote></li><li><p>POP3和IMAP4都采用基于TCP连接的客户/服务器方式。</p><ol type="1"><li>POP3使用端口110</li><li>IMAP4使用端口143</li></ol></li></ol><h2 id="基于万维网的电子邮件">5. 基于万维网的电子邮件</h2><ul><li>通过浏览器登录（提供用户名和口令）邮件服务器万维网网站就可以撰写、收发、阅读和管理电子邮件。这种工作模式与IMAP很类似，不同的是用户计算机无需安装专门的用户代理程序，只需要使用通用的万维网浏览器。</li><li>这种工作摸式在用户浏览器与邮件服务器网站之间使用HTTP协议，而邮件服务器之间使用SMTP协议。</li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-6-%E7%94%B5%E5%AD%90%E5%8D%8F%E8%AE%AE/image-20241118192409368.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.5 文件传送协议FTP</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-5-%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AEFTP/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-5-%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AEFTP/</url>
    
    <content type="html"><![CDATA[<h2 id="文件传送协议ftp">6.5 文件传送协议FTP</h2><ol type="1"><li>FTP提供交互式的访问，允许客户指明文件的类型与格式（如指明是否使用ASCII码），并允许文件具有存取权限（如访问文件的用户必须经过授权，并输入有效的口令）</li><li>FTP屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件</li></ol><h2 id="基本原理">1. 基本原理</h2><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-5-%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AEFTP/image-20230719151544230.png"></p><ol type="1"><li>FTP客户和服务器之间要建立以下两个并行的TCP连接<ol type="1"><li>控制连接，在<strong>整个会话期间一直保持打开</strong>，用于传送FTP相关<strong>控制命令</strong></li><li>数据连接，用于文件传输，在<strong>每次文件传输时才建立</strong>，<strong>传输结束就关闭</strong></li></ol></li><li>默认情况下，FTP使用TCP 21端口进行控制连接，TCP 20端口进行数据连接。但是，是否使用TCP20端口建立数据连接与传输模式有关，主动方式使用TCP20端口 被动方式由服务器和客户端自行协商决定。</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.4 域名系统DNS</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-4-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-4-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS/</url>
    
    <content type="html"><![CDATA[<h1 id="域名系统dns">6.4 域名系统DNS</h1><h2 id="dns介绍">1. DNS介绍</h2><ol type="1"><li>域名系统DNS是因特网使用的命名系统，用来把便于人们记忆的具有特定含义的主机名（例如www.hust.cn),转换为便于机器处理的IP地址。</li><li>因特网是否可以只使用1台DNS服务器？<ol type="1"><li>这种做法并不可取。因为因特网的规摸很大，这样的域名服务器肯定会因为超负荷而无法正常工作，而且一旦域名服务器出现故障，整个因特网就会瘫痪。</li><li>早在1983年，因特网就开始采用层次结构的命名树作为主机的名字(即域名)，并使用分布式的域名系统DNS</li><li>DNS使大多数域名都在本地解析，仅少量解折需要在因特网上通信，因此系统效率很高。</li><li>由于DNS是分布式系统，即使单个计算机出了故障，也不会妨碍整个系统的正常运行</li></ol></li><li>域名和IP地址的映射关系必须保存在域名服务器中，供所有其他应用查询。显然不能将所有信息都储存在一台域名服务器中。DNS使用分布在各地的域名服务器来实现域名到IP地址的转换。</li><li>DNS报文使用运输层的UDP协议进行封装，运输层端口号为53</li></ol><h2 id="层次树状域名结构">2. 层次树状域名结构</h2><ol type="1"><li>因特网采用层次树状结构的域名结构 …三级域名.二级域名.顶级域名<ol type="1"><li>每一级的域名都由英文字母和数字组成，不超过63个字符，不区分大小写字母。</li><li>级别最低的域名写在最左边，而级别最高的顶级域名写在最右边。</li><li>完整的域名不超过255个字符。</li></ol></li><li>域名系统既不规定一个域名需要包含多少个下级域名，也不规定每一级的域名代表什么意思。</li><li>各级域名由其上一级的域名管理机构管理，而最高的顶级域名则由因特网名称与数字地址分配机构CANN进行管理。</li></ol><h3 id="域名层次划分">2.1 域名层次划分</h3><ol type="1"><li>顶级域名TLD（Top Level Domain）<ol type="1"><li>国家顶级域名nTLD<ol type="1"><li>采用IS03166的规定。如cn表示中国，us表示美国，uk表示英国、等等。</li></ol></li><li>通用顶级域名<ol type="1"><li>最常见的通用顶级域名有七个，即：com(公司企业)、net(网络服务机构)、org(非营利性组织)、int(国际组织)、edu(美国教育结构)、gov(美国政府部门)、mil(美国军事部门)。</li></ol></li><li>反向域（arpa）<ol type="1"><li>用于反向域名解析，即IP地址反向解析为域名。</li></ol></li></ol></li><li>在国家顶级域名下注册的二级域名均由该国家自行确定。例如，顶级域名为j的日本，将其教育和企业机构的二级域名定为ac和co,而不用edu和com。</li><li>我国则将二级域名划分为以下两类：<ol type="1"><li>类别域名<ol type="1"><li>共七个：ac(科研机构)、com(工、商、金融等企业)、edu(教育机构)、gov(政府部门)、net(提供网络服务的机构)、mil(军事机构)和org(非营利性组织)。</li></ol></li><li>行政区域名<ol type="1"><li>共34个，适用于我国的各省、自治区、直辖市。例如：b为北京市、sh为上海市、js为江苏省，等等。</li></ol></li></ol></li><li>顶级域名由ICANN管理，顶级域名以下的二级域名，三级域名等，都由其上一级域名管理机构自行管理。</li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-4-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS/image-20241118165949003.png"></p><h3 id="域名服务器类型">2.2 域名服务器类型</h3><ul><li>域名和IP地址的映射关系必须保存在域名服务器中，供所有其他应用查询。显然不能将所有信息都储存在一台域名服务器中。DNS使用分布在各地的域名服务器来实现域名到IP地址的转换。</li></ul><ol type="1"><li>根域名服务器<ol type="1"><li>根域名服务器是最高层次的域名服务器。每个根域名服务器都知道所有的顶级域名服务器的域名及其IP地址。因特网上共有13个不同IP地址的根域名服务器。</li><li>尽管我们将这13个根域名服务器中的每一个都视为单个的服务器，但“每台服务器”实际上是由许多分布在世界各地的计算机构成的服务器群集。当本地域名服务器向根域名服务器发出查询请求时，路由器就把查询请求报文转发到离这个DNS客户最近的一个根域名服务器。这就加快了DNS的查询过程，同时也更合理地利用了因特网的资源。</li><li>根域名服务器通常并不直接对域名进行解析，而是返回该域名所属顶级域名的顶级域名服务器的IP地址。</li></ol></li><li>顶级域名服务器<ol type="1"><li>这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名。当收到DNS查询请求时就给出相应的回答（可能是最后的结果，也可能是下一级权限域名服务器的P地址)。</li></ol></li><li>权限域名服务器<ol type="1"><li>这些域名服务器负责管理某个区的域名。每一个主机的域名都必须在某个权限域名服务器处注册登记。因此权限域名服务器知道其管辖的域名与IP地址的映射关系。</li><li>另外，权限域名服务器还知道其下级域名服务器的地址</li></ol></li><li>本地域名服务器<ol type="1"><li>本地域名服务器不属于上述的域名服务器的等级结构。当一个主机发出DNS请求报文时，这个报文就首先被送往该主机的本地域名服务器。</li><li>本地域名服务器起着代理的作用，会将该报文转发到上述的域名服务器的等级结构中。</li><li>每一个因特网服务提供者ISP，一个大学一个大学里的学院，都可以拥有一个本地域名服务器，它有时也称为默认域名服务器。本地域名服务器离用户较近，一般不超过几个路由器的距离，也有可能就在同一个局域网中。</li><li>本地域名服务器的IP地址需要直接配置在需要域名解析的主机中，</li></ol></li></ol><h2 id="dns域名解析两种方式">3. DNS域名解析两种方式</h2><ul><li>递归解析和迭代解析</li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-4-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS/image-20230718233234205.png"></p><ol type="1"><li>为了提高DNS的查询效率，并减轻根域名服务器的负荷和减少因特网上的DNS查询报文数量，在域名服务器和主机中广泛地使用了高速缓存。</li><li>DNS报文使用运输层的UDP协议进行封装，运输层端口号为53</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.3 动态主机配置协议DHCP</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-3-%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AEDHCP/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-3-%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AEDHCP/</url>
    
    <content type="html"><![CDATA[<h1 id="动态主机配置协议dhcp">6.3 动态主机配置协议DHCP</h1><ul><li>动态主机配置协议DHCP(Dynamic Host ConfigurationProtocol))提供了一种机制，称为即插即用连网。</li><li>这种机制允许一台计算机加入新网络时可自动获取P地址等网络配置信息而不用手工参与。</li></ul><ol type="1"><li><p>DHCP报文在运输层使用UDP协议封装</p><ol type="1"><li>DHCP客户使用的UDP端口号为68</li><li>DHCP服务器使用的UDP端口号为67</li></ol></li><li><p>客户端向DHCP服务器申请IP的全过程</p></li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-3-%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AEDHCP/image-20241118164104548.png"></p><ul><li>使用ARP检测所分配到的IP地址是否已被网络中其他主机占用：<ul><li>若被占用：给DHCP服务器发送“DHCPDECLINE”报文敬销IP地址租约，并重新发送“DHCP DISCOVER”报文；</li><li>若未被占用：可以使用租约中的P地址与网络中其他主机通信了。</li></ul></li><li>使用ARP确保所选IP地址未被网络中其他主机占用</li></ul><table><thead><tr><th>报文</th><th>包含字段</th></tr></thead><tbody><tr><td>DHCP DISCOVER</td><td>事务ID，DHCP的MAC地址</td></tr><tr><td>DHCP OFFER</td><td>事务ID，配置信息：IP地址，子网掩码，地址租期，默认网关，DNS服务器</td></tr><tr><td>DHCP REQUEST</td><td>事务ID，DHCP的MAC地址，接受的租约中的IP地址，提供此租约的DHCP服务器的IP地址</td></tr></tbody></table><ol start="3" type="1"><li>DHCP中继代理</li></ol><blockquote><p>路由器不会转发普通的广播分组，并且我们也不希望在每个网络中都配置一台DHCP服务器，所以DHCP中继代理出现了。</p></blockquote><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-3-%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AEDHCP/image-20241118164332043.png"></p><ul><li>DHCP DISCOVER:DHCP发现报文</li><li>DHCP OFFER:DHCP提供报文</li><li>DHCP REQUEST:DHCP请求报文</li><li>DHCP ACK:DHCP确认报文</li><li>DHCP NACK:DHCP否认报文</li><li>DHCP RELEASE:DHCP释放报文</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.2 客户服务器方式和对等方式</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-2-%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%B9%E5%BC%8F%E5%92%8C%E5%AF%B9%E7%AD%89%E6%96%B9%E5%BC%8F/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-2-%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%B9%E5%BC%8F%E5%92%8C%E5%AF%B9%E7%AD%89%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="客户服务器方式cs和对等方式p2p方式">6.2客户/服务器方式（C/S）和对等方式（P2P方式）</h1><ul><li>网络应用程序运行在处于网络边缘的不同的端系统上，通过彼此间的通信来共同完成某项任务。</li><li>开发一种新的网络应用首先要考虑的问题就是网络应用程序在各种端系统上的组织方式和它们之间的关系。目前流行的主要有以下两种：<ul><li>客户/服务器(Client/Server,C/S)方式</li><li>对等(Peer-to-Peer,P2P)方式</li></ul></li></ul><h2 id="客户服务器clientservercs方式">1.客户/服务器(Client/Server,C/S)方式</h2><ul><li>C/S方式<ul><li>客户和服务器是指通信中所涉及的两个应用进程。</li><li>客户/服务器方式所描述的是进程之间服务和被服务的关系。</li><li>客户是服务请求方，服务器是服务提供方。</li><li>服务器总是处于运行状态，并等待客户的服务请求。服务器具有固定端口号（例如HTTP服务器的默认端口号为80)，而运行服务器的主机也具有固定的P地址。</li></ul></li><li>C/S方式是因特网上传统的、同时也是最成熟的方式，很多我们熟悉的网络应用采用的都是C/S方式。包括万维网WWW、电子邮件、文件传输FTP等。</li><li>基于C/S方式的应用服务通常是服务集中型的，即应用服务集中在网络中比客户计算机少得多的服务器计算机上。<ul><li>由于一台服务器计算机要为多个客户机提供服务，在C/S应用中，常会出现服务器计算机跟不上众多客户机请求的情况。</li><li>为此，在C/S应用中，常用计算机群集（或服务器场）构建一个强大的虚拟服务器。</li></ul></li></ul><h2 id="对等方式p2p方式">2. 对等方式（P2P方式）</h2><ul><li><p>P2P方式</p><ul><li>在P2P方式中，没有固定的服务请求者和服务提供者，分布在网络边缘各端系统中的应用进程是对等的，被称为对等方。</li><li>对等方相互之间直接通信，每个对等方既是服务的请求者，又是服务的提供者。</li></ul></li><li><p>目前，在因特网上流行的P2P应用主要包括P2P文件共享、即时通信、P2P流媒体、分布式存储等。</p></li><li><p>基于P2P的应用是服务分散型的，因为服务不是集中在少数几个服务器计算机中，而是分散在大量对等计算机中，这些计算机并不为服务提供商所有，而是为个人控制的桌面计算机和笔记本电脑，它们通常位于住宅、校园和办公室中。</p></li><li><p>P2P方式的最突出特性之一就是它的可扩展性。因为系统每增加一个对等方，不仅增加的是服务的请求者，同时也增加了服务的提供者，系统性能不会因规摸的增大而降低。</p></li><li><p>P2P方式具有成本上的优势，因为它通常不需要庞大的服务器设施和服务器带宽。为了降低成本，服务提供商对于将P2P方式用于应用的兴趣越来越大。</p></li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-2-%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%B9%E5%BC%8F%E5%92%8C%E5%AF%B9%E7%AD%89%E6%96%B9%E5%BC%8F/image-20241118162748601.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.1 应用层概述</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-1-%E5%BA%94%E7%94%A8%E5%B1%82%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-1-%E5%BA%94%E7%94%A8%E5%B1%82%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="应用层">6.1 应用层</h1><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-1-%E5%BA%94%E7%94%A8%E5%B1%82%E6%A6%82%E8%BF%B0/image-20241118161627816.png"></p><ul><li>应用层是计算机网络体系结构的最顶层，是设计和建立计算机网络的最终目的，也是计算机网络中发展最快的部分。<ul><li>早期基于文本的应用（电子邮件、远程登绿、文件传输、新闻组）<ul><li>20世纪90年代将因特网带入干家万户的万维网WWW</li></ul></li><li>当今流行的即时通信、P2P文件共享及各种音视频应用计算设备的小型化和“无处不在”，宽带住宅接入和无线接入的日益普及和迅速发展，为未来更多的新型应用提供了广阔的舞台。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.9 TCP报文段的首部格式</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-9-TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-9-TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="tcp报文段的首部格式">5.9 TCP报文段的首部格式</h1><ul><li>为了实现可靠传输，TCP采用了面向字节流的方式。</li><li>但TCP在发送数据时，是从发送缓存取出一部分或全部字节并给其添加一个首部使之成为TCP报文段后进行发送。<ul><li>一个TCP报文段由首部和数据载荷两部分构成；</li><li>TCP的全部功能都体现在它首部中各字段的作用。</li></ul></li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-9-TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F/image-20241118153709722.png"></p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>源端口</td><td>占16比特，写入源端口号，用来标识发送该TCP报文段的应用进程</td></tr><tr><td>目的端口</td><td>占16比特，写入目的端口号，用来标识接收该TCP报文段的应用进程</td></tr><tr><td>序号</td><td>占32比特，取值范围[0,2<sup>32</sup>-1]，序号增加到最后一个后，下一个序号就又回到0。<br>指出本TCP报文段数据载荷的第一个字节的序号。</td></tr><tr><td>确认号</td><td>占32比特，取值范围[0,2<sup>32</sup>-1]，确认号增加到最后一个后，下一个确认号就又回到0。<br>指出期望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，同时也是对之前收到的所有数据的确认。</td></tr><tr><td>确认标志位ACK</td><td>取值为1时确认号字段才有效：取值为0时确认号字段无效</td></tr><tr><td>数据偏移</td><td>占4比特，并以4字节为单位。<br>用来指出TCP报文段的数据载荷部分的起始处距离TCP报文段的起始处有多远。</td></tr><tr><td>保留</td><td>占6比特，保留为今后使用，但目前应置为0。</td></tr><tr><td>窗口</td><td>占16比特，以字节为单位。指出发送本报文段的一方的接收窗口。<br>窗口值作为接收方让发送方设置其发送窗口的依据。<br>这是以接收方的接收能力来控制发送方的发送能力，称为流量控制。</td></tr><tr><td>校验和</td><td>占16比特，检查范围包括TCP报文段的首部和数据载荷两部分。<br>在计算校验和时，要在TCP报文段的前面加上12字节的伪首部。</td></tr><tr><td>同步标志位SYN</td><td>在TCP连接建立时用来同步序号</td></tr><tr><td>终止标志位FIN</td><td>用来释放TCP连接。</td></tr><tr><td>复位标志位RST</td><td>用来复位TCP连接。<br>当RST=1时，表明TCP连接出现了异常，必须释放连接，然后再重新建立连接。<br>RST置1还用来拒绝一个非法的报文段或拒绝打开一个TCP连接。</td></tr><tr><td>推送标志位PSH</td><td>接收方的TCP收到该标志位为1的报文段会尽快上交应用进程。<br>而不必等到接收缓存都填满后再向上交付。</td></tr><tr><td>紧急标志位URG</td><td>取值为1时紧急指针字段有效：取值为0时紧急指针字段无效。</td></tr><tr><td>紧急指针</td><td>占16比特，以字节为单位，用来指明紧急数据的长度。</td></tr><tr><td>选项</td><td>1. 最大报文段长度MSS选项：TCP报文段数据载荷部分的最大长度。<br>2.窗口扩大选项：为了扩大窗口（提高吞吐率）<br>3. 时间戳选项：<br> a.用来计算往返时间RTT<br> b.用于处理序号超范围的情况，又称为防止序号绕回PAWS。<br>4.选择确认选项<br>选项的作用是为了扩展TCP报文段首部的功能</td></tr><tr><td>填充</td><td>由于选项的长度可变，因此使用填充来确保报文段首部能被4整除<br>(因为数据偏移字段，也就是首部长度字段，是以4字节为单位的)</td></tr></tbody></table><ul><li>紧急数据：<ul><li>当发送方有紧急数据时，可将紧急数据插队到发送缓存的最前面，并立刻封装到一个TCP报文段中进行发送。</li><li>紧急指针会指出本报文段数据载荷部分包含了多长的紧急数据，紧急数据之后是普通数据。</li><li>接收方将紧急数据部分取出，并直接上交应用程序，而不必在接受缓存中排队。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.8 TCP的运输连接管理</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-8-TCP%E7%9A%84%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-8-TCP%E7%9A%84%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="tcp的运输连接管理">5.8 TCP的运输连接管理</h1><ul><li>TCP是面向连接的协议，它基于运输连接来传送TCP报文段。</li><li>TCP运输连接的建立和释放是每一次面向连接的通信中必不可少的过程。</li><li>TCP运输连接有以下三个阶段：<ul><li>建立TCP连接</li><li>数据传送</li><li>释放TCP连接</li></ul></li><li>TCP的运输连接管理就是使运输连接的建立和释放都能正常地进行。</li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-8-TCP%E7%9A%84%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/image-20241118150137225.png"></p><h2 id="tcp的连接建立三次握手">1. TCP的连接建立（三次握手）</h2><blockquote><p>TCP的连接建立要解决以下三个问题：</p><ol type="1"><li>使TCP双方能够确知对方的存在</li><li>使TCP双方能够协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）</li><li>使TCP双方能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。</li></ol></blockquote><ol type="1"><li><p>三次握手建立连接的过程</p><blockquote><p>也就是使用三个TCP报文建立连接</p><ul><li>传输控制块<ul><li>TCP连接表</li><li>指向发送和接收缓存的指针</li><li>指向重传队列的指针</li><li>当前的发送和接收序号</li></ul></li></ul></blockquote><figure><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-8-TCP%E7%9A%84%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/image-20230718175005023.png" alt="image-20230718175005023"><figcaption aria-hidden="true">image-20230718175005023</figcaption></figure></li><li><p>两报文建立连接会发生以下问题 <img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-8-TCP%E7%9A%84%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/image-20230718175045894.png" alt="image-20230718175045894"></p></li><li><p>注意(1)TCP的标准规定，SYN=1的报文段不能携带数据，但要消耗掉一个序号。(2)TCP的标准规定，普通的确认报文段如果不携带数据，则不消耗序号。</p></li></ol><h2 id="tcp的连接释放四次挥手">2. TCP的连接释放（四次挥手）</h2><ol type="1"><li><p>四报文挥手过程 <img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-8-TCP%E7%9A%84%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/image-20230718182458129.png" alt="image-20230718182458129"></p></li><li><p>若不等待2MSL则有可能发生以下情况</p><blockquote><p>最后一个确认报文丢失，导致服务器进程陷入最后确定状态，无法进入关闭状态</p></blockquote><figure><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-8-TCP%E7%9A%84%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/image-20230718182524772.png" alt="image-20230718182524772"><figcaption aria-hidden="true">image-20230718182524772</figcaption></figure></li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-8-TCP%E7%9A%84%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/image-20241118153322909.png"></p><ul><li>TCP服务器进程每收到一次TCP客户进程的数据，就重新设置并启动保活计时器(2小时定时)</li><li>若保活计时器定时周期内未收到TCP客户进程发来的数据，则当保活计时器到时后，TCP服务器进程就向TP客户进程发送一个探测报文段，以后则每隔75秒钟发送一次。若一连发送10个探测报文段后仍无TCP客户进程的响应，TCP服务器进程就认为TCP客户进程所在主机出了故障，接着就关闭这个连接。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.7 TCP可靠传输的实现</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-7-TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-7-TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="tcp可靠传输的实现">5.7 TCP可靠传输的实现</h1><ol type="1"><li><p>TCP基于以<strong>字节为单位的滑动窗口</strong>来实现可靠传输。</p><ol type="1"><li><p>发送方在未收到接收方的确认时，可将发送窗口内还未发送的数据全部发送出去</p></li><li><p>接收方只接收序号落入发送窗口内的数据</p><blockquote><p>虽然发送方的发送窗口是根据接收方的接收窗口设置的，但在同一时刻，发送方的发送窗口并不总是和接收方的接收窗口一样大。</p></blockquote></li><li><p>网络传送窗口值需要经历一定的时间滞后，井且这个时间还是不确定的。</p></li><li><p>发送方还可能根据网络当时的拥塞情况适当减小自己的发送窗口尺寸</p></li></ol></li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-7-TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20241118144647353.png"></p><ol start="2" type="1"><li><p>对于不按序到达的数据应如何处理，TCP并无明确规定</p><ol type="1"><li>如果接收方把不按序到达的数据一律丢弃，那么接收窗口的管理将会比较简单，但这样做对网络资源的利用不利，因为发送方会重复传送较多的数据。</li><li>TCP通常对不按序到达的数据是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程</li><li>TCP要求接收方必须有累积确认和捎带确认机制，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。<ol type="1"><li>接收方不应过分推迟发送确认，否则会导致发送方不必要的超时重传，这反而浪费了网络的资源。</li><li>TCP标准规定，确认推迟的时间不应超过0.5秒。若收到一连串具有最大长度的报文段，则必须每隔一个报文段就发送一个确认</li><li>梢带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。</li></ol></li></ol></li><li><p>TCP的通信是全双工通信。</p><blockquote><p>通信中的每一方都在发送和接收报文段。因此，每一方都有自己的发送窗口和接收窗口。在谈到这些窗口时，一定要弄清楚是哪一方的窗口。</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.6 TCP超时重传时间的选择</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-6-TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4%E7%9A%84%E9%87%8D%E4%BC%A0/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-6-TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4%E7%9A%84%E9%87%8D%E4%BC%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="tcp超时重传的时间的选择rto">5.6TCP超时重传的时间的选择（RTO）</h1><ul><li>利用每次测量得到的RTT样本，计算加权平均往返时间RTTs(又称为平滑的往返时间)。</li><li>超时重传的时间应略大于RTTs的值。</li></ul><ol type="1"><li><p>计算RTT<sub>S</sub> <span class="math display">\[初始RTT_S = 测得的第一个RTT\]</span> <span class="math display">\[RTTs = (1-\alpha)\times 旧的RTTs + \alpha \times 新的RTT样本\]</span> 建议 <span class="math inline">\(\alpha\)</span> =0.125</p></li><li><p>计算RTT<sub>D</sub> <span class="math display">\[初始RTT_D = \frac{RTT_1}{2}\\RTT_D = (1 - \beta) \times 旧的RTT_D + \beta \times \vert RTT_S -新的RTT样本 \vert\]</span> 建议<span class="math inline">\(\beta\)</span> = 0.25</p></li><li><p>针对出现超时重传时无法测准往返时间RTT的问题，Kan提出了一个算法：在计算加权平均往返时间RTTs时，只要报文段重传了，就不采用其往返时间RTT样本。也就是出现重传时，不重新计算RTTs,进而超时重传时间RTO也不会重新计算。</p></li><li><p>这又引起了新的问题。设想出现这样的情况：报文段的时延突然增大了很多，并目之后很长一段时间都会保持这种时延。因此在原来得出的重传时间内，不会收到确认报文段。于是就重传报文段。但根据Kar算法，不考虑重传的报文段的往返时间样本。这样，超时重传时间就无法更新。这会导致报文段反复被重传。</p></li><li><p>因此，要对Kan算法进行修正。方法是：报文段每重传一次，就把超时重传时间RTO增大一些。典型的做法是将新RTO的值取为旧RTO值的2倍。</p></li><li><p>计算超时重传时间 <span class="math display">\[RTO = RTT_S + 4 \times RTT_D\]</span>只要某报文段超时重传，就将RTO设为原来的两倍，而不是按照上述公式计算</p></li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-6-TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4%E7%9A%84%E9%87%8D%E4%BC%A0/image-20241118125512601.png"></p><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-6-TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4%E7%9A%84%E9%87%8D%E4%BC%A0/image-20241118125933926.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.5 TCP的拥塞控制</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-5-TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-5-TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="tcp拥塞控制">5.5 TCP拥塞控制</h1><ol type="1"><li>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏。这种情况就叫做拥塞(congestion)。</li><li>在计算机网络中的链路容量（即带宽）、交换结点中的缓存和处理机等，都是网络的资源。</li><li>若出现拥塞而不进行控制，整个网络的吞吐量将随输入负荷的增大而下降。</li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-5-TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/image-20241118122339061.png"></p><h2 id="拥塞避免算法">1. 拥塞避免算法</h2><ul><li>下面介绍这四种拥塞控制算法的基本原理，假定如下条件：<ul><li>数据是单方向传送，而另一个方向只传送确认。</li><li>接收方总是有足够大的缓存空间，因而发送方发送窗口的大小由网络的拥塞程度来决定。</li><li>以最大报文段MSS的个数为讨论问题的单位，而不是以字节为单位。</li></ul></li></ul><h3 id="慢开始与拥塞避免算法">1.1 慢开始与拥塞避免算法</h3><ol type="1"><li><p>发送方维护一个叫做拥塞窗口cwd的状态变量，其值取决于网络的拥塞程度，并且动态变化。</p><ol type="1"><li><p>拥塞窗口cwd的维护原则</p><ol type="1"><li>只要网络没有出现拥塞，拥塞窗口就再增大一些；</li><li>但只要网络出现拥塞，拥塞窗口就减少一些。</li><li>具体做法<ol type="1"><li>发生超时重传后，将门限ssthresh设为拥塞窗口的一半，并将当前拥塞窗口设为1</li><li>重新运行开始慢开始算法</li></ol></li></ol></li><li><p>判断出现网络拥塞的依据</p><blockquote><p>没有按时收到应当到达的确认报文（即发生超时重传）。</p></blockquote></li></ol></li><li><p>发送方将拥塞窗口作为发送窗口swnd,即 swnd=cwnd。</p></li><li><p>维护一个慢开始门限ssthresh状态变量</p><ol type="1"><li>当cwnd&lt;ssthresh时，使用慢开始算法</li><li>当cwnd&gt;ssthresh时，停止使用慢开始算法而改用拥塞避免算法：</li><li>当cwnd=ssthresh时，既可使用慢开始算法，也可使用拥塞避免算法。</li></ol></li><li><p>慢开始指数增长，从1开始，每次×2</p></li><li><p>拥塞避免，拥塞窗口每次加1</p></li><li><p>出现拥塞，ssthresh值更新为cwnd的一半</p></li><li><p>cwnd值置为1，再重新开始慢开始算法</p></li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-5-TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/image-20241118123625970.png"></p><ul><li><p>“慢开始”是指一开始向网络注入的报文段少，并不是指拥塞窗口cwd增长速度慢；</p></li><li><p>“拥塞避免”并非指完全能够避免拥塞，而是指在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞</p></li><li><p>慢开始和拥塞避免算法是1988年提出的TCP拥塞控制算法(TCPTahoe版本)</p></li><li><p>1990年又增加了两个新的拥塞控制算法（改进TCP的性能），这就是快重传和快恢复(TCPReno.版本)。</p><ul><li>有时，个别报文段会在网络中丢失，但实际上网络并未发生拥塞。<ul><li>这将导致发送方超时重传，并误认为网络发生了拥塞；</li><li>发送方把拥塞窗口cwd又设置为最小值1，并错误地启动慢开始算法，因而降低了传输效率</li></ul></li></ul></li><li><p>采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。</p></li><li><p>所谓快重传，就是使发送方尽快进行重传，而不是等超时重传计时器超时再重传。</p></li></ul><h3 id="快重传与快恢复">1.2 快重传与快恢复</h3><ol type="1"><li>要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认</li><li>即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。</li><li>发送方一旦<strong>收到3个连续的重复确认</strong>，就将相应的报文段立即重传，而不是等该报文段的超时重传计时器超时再重传。</li><li>对于个别丢失的报文段，发送方不会出现超时重传，也就不会误认为出现了拥塞（进而降低拥塞窗口cwd为1）。使用快重传可以使整个网络的吞吐量提高约20%。</li><li>发送方一旦收到3个重复确认，就知道现在只是丢失了个别的报文段。于是不启动慢开始算法，而执行<strong>快恢复算法</strong><ol type="1"><li>发送方将慢开始<strong>门限ssthresh值</strong>和<strong>拥塞窗口cwnd值</strong>调整为<strong>当前窗口的一半</strong></li><li>开始执行拥塞避免算法。</li><li>也有的快恢复实现是把快恢复开始时的拥塞窗口cwnd值再增大一些，即等于新的ssthresh+3。<ol type="1"><li>既然发送方收到3个重复的确认，就表明有3个数据报文段已经离开了网络，这3个报文段不再消耗网络资源而是停留在接收方的接收缓存中，可见现在网络中不是堆积了报文段而是减少了3个报文段。因此可以适当把拥塞窗口扩大些。</li></ol></li></ol></li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-5-TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/image-20241118124545558.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.4 TCP的流量控制</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-4-TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-4-TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="tcp流量控制">TCP流量控制</h2><ul><li><p>所谓流量控制 ( flow control)就是让发送方的发送速率不要太快，要让接收方来得及接收。</p></li><li><p>TCP接收方利用自己的接收窗口的大小来限制发送方发送窗口的大小。</p></li></ul><p><span class="math display">\[发送窗口 = Min(发送方拥塞窗口，接受方接收窗口)\]</span></p><figure><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-4-TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/image-20241118120929780.png" alt="image-20241118120929780"><figcaption aria-hidden="true">image-20241118120929780</figcaption></figure><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-4-TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/image-20241118121512615.png"></p><p>注意</p><ol type="1"><li>TCP发送方收到接收方的零窗口通知后，应启动持续计时器。持续计时器超时后，向接收方发送零窗口探测报文。</li></ol><blockquote><p>若是零窗口探测报文传输过程中丢失，则在其重发计数器超时后重发该报文</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.3 UDP和TCP的对比</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-3-UDP%E5%92%8CTCP%E7%9A%84%E5%AF%B9%E6%AF%94/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-3-UDP%E5%92%8CTCP%E7%9A%84%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<h1 id="udp和tcp的对比">5.3 UDP和TCP的对比</h1><ul><li>用户数据报协议UDP:(User Datagram Protocol)<ul><li>无连接</li></ul></li><li>传输控制协议TCP：Transmission Control Protocol<ul><li>面向连接</li></ul></li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-3-UDP%E5%92%8CTCP%E7%9A%84%E5%AF%B9%E6%AF%94/image-20241118111939771.png"></p><ul><li>UDP支持单播、多播以及广播</li><li>TCP仅支持单播</li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-3-UDP%E5%92%8CTCP%E7%9A%84%E5%AF%B9%E6%AF%94/image-20241118112226603.png"></p><ul><li>UDP是面向应用报文的</li><li>TCP是面向字节流的</li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-3-UDP%E5%92%8CTCP%E7%9A%84%E5%AF%B9%E6%AF%94/image-20241118112458492.png"></p><ul><li>UDP向上层提供无连接不可靠传输服务(适用于IP电话、视频会议等实时应用)</li><li>TCP向上层提供面向连接的可靠传输服务(适用于要求可靠传输的应用，例如文件传输)</li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-3-UDP%E5%92%8CTCP%E7%9A%84%E5%AF%B9%E6%AF%94/image-20241118112750466.png"></p><ul><li>UDP用户数据报首部仅8字节</li><li>TCP报文段首部最小20字节，最大60字节</li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-3-UDP%E5%92%8CTCP%E7%9A%84%E5%AF%B9%E6%AF%94/image-20241118112843761.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.2 运输层端口号、复用与分用的概念</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-2-%E8%BF%90%E8%BE%93%E5%B1%82%E7%AB%AF%E5%8F%A3%E5%8F%B7-%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%88%86%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-2-%E8%BF%90%E8%BE%93%E5%B1%82%E7%AB%AF%E5%8F%A3%E5%8F%B7-%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%88%86%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="运输层端口号复用分用">5.2 运输层端口号，复用，分用</h1><h2 id="端口号">1. 端口号</h2><ol type="1"><li><p>因为因特网上的计算机并不是使用统一的操作系统，不同的操作系统又使用不同格式的进程标识符，为了使运行不同操作系统的计算机的应用进程之间能够进行网络通信，就必须使用统一的方法对TCP/IP体系的应用进程进行标识。</p></li><li><p>TCP/IP体系的运输层使用端口号来区分应用层的不同应用进程，端口号使用16比特表示，取值范围[0,65535]。</p></li></ol><figure><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-2-%E8%BF%90%E8%BE%93%E5%B1%82%E7%AB%AF%E5%8F%A3%E5%8F%B7-%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%88%86%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5/image-20241118110803598.png" alt="端口号的划分"><figcaption aria-hidden="true">端口号的划分</figcaption></figure><ol start="3" type="1"><li>端口号只具有本地意义，即端口号只是为了标识本计算机应用层中的各进程，在因特网中，不同计算机中的相同端口号是没有联系的。</li></ol><h2 id="发送方的复用和接收方的分用">2. 发送方的复用和接收方的分用</h2><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-2-%E8%BF%90%E8%BE%93%E5%B1%82%E7%AB%AF%E5%8F%A3%E5%8F%B7-%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%88%86%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5/image-20241118111045703.png"></p><ol type="1"><li>TCP/IP体系的应用层常用协议所使用运输层的熟知端口号</li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-2-%E8%BF%90%E8%BE%93%E5%B1%82%E7%AB%AF%E5%8F%A3%E5%8F%B7-%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%88%86%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5/image-20241118111132310.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.1 运输层概述</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-1-%E8%BF%90%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-1-%E8%BF%90%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="运输层概述">5.1 运输层概述</h1><ul><li><p>实际上在计算机网络中进行通信的真正实体是位于通信两端主机中的进程</p></li><li><p>如何为运行在不同主机上的应用进程提供直接的通信服务是运输层的任务，运输层协议又称为端到端协议。</p></li><li><p>运输层向高层用户屏蔽了下面网络核心的细节（如网络拓扑、所采用的路由选择协议等)，它使应用进程看见的就好像是在两个运输层实体之间有一条端到端的逻辑通信信道。</p></li><li><p>根据应用需求的不同，因特网的运输层为应用层提供了两种不同的运输协议，即面向连接的TCP和无连接的UDP,这两种协议就是本章要讨论的主要内容。</p></li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-1-%E8%BF%90%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0/image-20241118110058782.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.9 虚拟专用网VPN与网络地址转换NAT</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-9-%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91VPN%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2NAT/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-9-%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91VPN%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2NAT/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟专用网络vpn与网络地址转换nat">4.9虚拟专用网络VPN与网络地址转换NAT</h1><h2 id="vpn">1. VPN</h2><ul><li>利用公用的因特网作为本机构各专用网之间的通信载体，这样的专用网又称为虚拟专用网。</li><li>VPN要保证传输数据的安全性，会将原始的内部数据报进行加密，然后再将其封装成为在因特网上发送到的外部数据报。</li></ul><ol type="1"><li>VPN类型<ol type="1"><li>同一机构内不同部门的内部网络所构成的虚拟专用网VPN又称为内联网VPN</li><li>有时一个机构的VPN需要有某些外部机构（通常就是合作伙伴）参加进来。这样的VPN就称为外联网VPN</li><li>在外地工作的员工需要访问公司内部的专用网络时，只要在任何地点接入到因特网，运行驻留在员工PC中的VPN软件，在员工的PC和公司的主机之间建立VPN隧道，即可访问专用网络中的资源。这种VPN称为远程接入VPN。</li></ol></li></ol><h2 id="nat">2. NAT</h2><ul><li>NAT能使大量使用内部专用地址的专用网络用户共享少量外部全球地址来访问因特网上的主机和资源。</li><li>传统NAT是将每个本地IP转换为一个公有IP，意味着路由器中NAT映射表记录N个全球IP，则对应的子网最多只能有N台主机，这不符预期。</li></ul><ol type="1"><li>由于绝大多数的网络应用都是使用运输层协议TCP或UDP来传送数据，因此可以利用运输层的端口号和IP地址一起进行转换。<ol type="1"><li>这样用一个全球P地址就可以使多个拥有本地地址的主机同时和因特网上的主机进行通信。这种将端口号和P地址一起进行转换的技术叫作网络地址与端口号转换NAPT(Network Address and Port Translation)。</li></ol></li><li>收到来自外网的IP数据报后，在NAPT转换表中找不到相应的记录！</li><li>对于一些P2P网络应用，需要外网主机主动与内网主机进行通信，在通过NAT时会遇到问题，需要网络应用自己使用一些特殊的NAT穿越技术来解决问题。</li><li>由于NAT对外网屏蔽了内网主机的网络地址，能为内网的主机提供一定的安全保护。</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-9-%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91VPN%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2NAT/image-20241118104142578.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.8 网际控制报文协议</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-8-%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-8-%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="网际控制报文协议icmp">4.8 网际控制报文协议ICMP</h1><ul><li>为了更有效地转发P数据报和提高交付成功的机会，在网际层使用了网际控制报文协议<ul><li>主机或路由器使用ICMP来发送差错报告报文和询问报文</li><li>ICMP报文被封装在IP数据报中发送</li></ul></li></ul><h2 id="五种差错报告报文">1. 五种差错报告报文</h2><h3 id="终点不可达">1.1 终点不可达</h3><ol type="1"><li>当路由器或主机不能交付数据报时，就向源点发送终点不可达报文。</li><li>具体可再根据ICMP的代码字段细分为目的网络不可达、目的主机不可达、目的协议不可达、目的端口不可达、目的网络未知、目的主机未知等13种错误。</li></ol><h3 id="源点抑制">1.2 源点抑制</h3><ol type="1"><li>当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢。</li></ol><h3 id="时间超过">1.3 时间超过</h3><ol type="1"><li>当路由器收到一个目的1P地址不是自己的P数据报，会将其生存时间TTL字段的值减1。</li><li>若结果不为0，则将该P数据报转发出去；若结果为0，除丢弃该P数据报外，还要向源点发送时间超过报文。</li></ol><h3 id="参数问题">1.4 参数问题</h3><ol type="1"><li>当路由器或目的主机收到P数据报后，根据其首部中的检验和字段发现首部在传输过程中出现了误码，就丢弃该数据报，并向源点发送参数问题报文。</li></ol><h3 id="改变路由重定向">1.5 改变路由(重定向)</h3><ol type="1"><li>路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）。</li></ol><h2 id="当发生以下情况时不应该发送imcp差错报告报文">2.当发生以下情况时不应该发送IMCP差错报告报文</h2><ol type="1"><li>对ICMP差错报告报文不再发送ICMP差错报告报文</li><li>对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文</li><li>对具有多播地址的数据报都不发送ICMP差错报告报文</li><li>对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送ICMP差错报告报文</li></ol><h2 id="常用的icmp询问报文">3. 常用的ICMP询问报文</h2><ol type="1"><li>回送请求和回答</li><li>ICMP回送请求报文是由主机回或路由器向一个特定的目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。<ol start="2" type="1"><li>这种询问报文用来测试目的站是否可达及了解其有关状态。</li></ol></li><li>时间戳请求和回答<ol type="1"><li>ICMP时间戳请求报文是请某个主机或路由器回答当前的日期和时间。</li><li>在ICMP时间戳回答报文中有一个32位的字段，其中写入的整数代表从1900年1月1日起到当前时刻一共有多少秒。</li><li>这种询问报文用来进行时钟同步和测量时间</li></ol></li></ol><h2 id="icmp应用">4. ICMP应用</h2><h3 id="分组网间探测ping">4.1 分组网间探测（PING）</h3><blockquote><p>Packet Internet Groper</p></blockquote><ol type="1"><li>用来测试主机或路由器间的连通性</li><li>应用层直接使用网际层的ICMP(没有通过运输层的TCP或UDP)</li><li>使用ICMP回送请求和回答报文</li></ol><h3 id="跟踪路由">4.2 跟踪路由</h3><blockquote><p>traceroute</p><p>用来测试P数据报从源主机到达目的主机要经过哪些路由器</p></blockquote><ol type="1"><li><p>Windows版本</p><blockquote><p>tracert命令 应用层直接使用网际层ICMP使用了ICMP回送请求和回答报文以及差错报告报文</p></blockquote></li><li><p>Unix版本</p><blockquote><p>traceroute命令 在运输层使用UDP协议 仅使用ICMP差错报告报文</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.7 IPv4数据报的首部格式</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-7-IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-7-IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="ip数据报的首部格式">4.7 IP数据报的首部格式</h1><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-7-IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F/image-20230717175105117.png"></p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>版本</td><td>占4比特，表示IP协议的版本。<br>通信双方使用的P协议的版本必须一致。<br>目前广泛使用的IP协议版本号为4（即IPv4)<br></td></tr><tr><td>首部长度<br></td><td>占4比特，表示IP数据报首部的长度。<br>该字段的取值以4字节为单位。<br>最小十进制取值为5，表示P数据报首部只有20字节固定部分；<br>量大十进制取值为15，表示1P数据报首部包含20字节固定部分和最大40字节可变部分。<br></td></tr><tr><td>区分服务</td><td>占8比特，用来获得更好的服务。利用该字段的不同数值可提供不同等级的服务质量。<br>只有在使用区分服务时，该字段才起作用。一般情况下都不使用该字段。</td></tr><tr><td>总长度</td><td>占16比特，表示IP数据报的总长度（首部+数据载荷），最大取值为十进制的65535，以字节为单位。</td></tr><tr><td>标识</td><td>占16比特，属于同一个数据报的各分片数据报应该具有相同的标识。<br>IP软件维持一个计数器，每产生一个数据报，计数器值加1，并将此值赋给标识字段。</td></tr><tr><td>标志</td><td>占3比特，各比特含义如下：<br>DF位：1表示不允许分片：0表示允许分片；<br>MF位：1表示后面还有分片：0表示 这是最后一个分片；<br>保留位：必须为0</td></tr><tr><td>片偏移</td><td>占13比特，指出分片数据报的数据载荷部分偏移其在原数据报的位置有多少个单位。<br>片偏移以8个字节为单位。</td></tr><tr><td>生存时间TTL</td><td>占8比特，表示P数据报的生存时间。<br>现在以“跳数”为单位，路由器转发P数据报时，将1P数据报首部中的该字段的值减1，若不为0就转发。否则就丢弃</td></tr><tr><td>首部校验和</td><td>1P数据报每经过一个路由器，路由器都要重新计算首部检验和，因为某些字段<br>（生存时间，标志，片偏移等）的取值可能发生变化</td></tr><tr><td>源IP地址和目的IP地址</td><td>略</td></tr><tr><td>填充</td><td>IP数据报首部大小必须为4字节的整数倍</td></tr><tr><td>可选字段长度</td><td>从1个字节到40个字节不等。用来支持排错、测量及安全等措施<br>但一般不使用</td></tr><tr><td>协议</td><td>占8比特，指明IPV4数据报的数据部分是何种协议数据单元。<br>常用的一些协议和相应的协议字段值如下。<br><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-7-IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F/image-20241117220627692.png" alt="image-20241117220627692"></td></tr></tbody></table><h2 id="ipv4分片">1. IPV4分片</h2><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-7-IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F/image-20241117215341102.png"></p><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-7-IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F/image-20241117220158751.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.6 路由选择协议</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="路由选择协议">4.6 路由选择协议</h1><h2 id="路由选择协议-1">1. 路由选择协议</h2><blockquote><p>早期RFC文档中，使用“网关”这个词指代路由器，现代使用“路由器”指代路由器，两者为同一设备的不同名称</p></blockquote><h3 id="静态路由选择">1.1 静态路由选择</h3><ol type="1"><li>由人工配置的网络路由、默认路由、特定主机路由，黑洞路由等都属于静态路由。</li><li>这种人工配置方式简单、开销小，但不能及时适应网络状态（流量、拓扑等）的变化</li><li>一般只在小规模网络中采用。</li></ol><h3 id="动态路由选择">1.2 动态路由选择</h3><ol type="1"><li>路由器通过路由选择协议自动获取路由信息比较复杂、开销比较大，</li><li>能较好地适应网络状态的变化</li><li>适用于大规模网络</li></ol><h3 id="因特网所采用的路由选择协议的主要特点">1.3因特网所采用的路由选择协议的主要特点</h3><ol type="1"><li>自适应<ol type="1"><li>动态路由选择，能较好地适应网络状态的变化</li></ol></li><li>分布式<ol type="1"><li>路由器之间交换路由信息</li></ol></li><li>分层次<ol type="1"><li>将整个因特网划分为许多较小的自治系统AS(Autonomous System）</li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117204127866.png"></p><h3 id="因特网采用分层次的路由选择协议">1.4因特网采用分层次的路由选择协议</h3><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117204721689.png"></p><ol type="1"><li>一般一个ISP负责的所有网络作为一个自治系统<ol type="1"><li>内部网关协议（IGP）和外部网关协议（EGP）是协议分类的总称，不是具体的协议名</li></ol></li><li>路由选择协议</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117204849446.png"></p><ol start="3" type="1"><li>路由器的基本结构</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117204931573.png"></p><ol start="4" type="1"><li>路由表一般仅包含从目的网络到下一跳的映射</li><li>路由表需要对网络拓扑变化的计算最优化<ol type="1"><li>转发表是从路由表得出的</li><li>转发表的结构应当使查找过程最优化</li></ol></li></ol><h2 id="路由信息rip协议工作原理">2. 路由信息RIP协议工作原理</h2><ol type="1"><li>路由信息协议RIP(Routing InformationProtocol)是内部网关协议IGP中最先得到广泛使用的协议之一，其相关标准文档为RFC1058。</li><li>RIP要求自治系统AS内的每一个路由器都要维护从它自己到AS内其他每一个网络的距离记录。这是一组距离，称为“距离向量”。</li><li>RIP使用跳数(Hop Count)作为度量(Metric)来衡量到达目的网络的距离。<ol type="1"><li>路由器到直连网络的距离定义为1。路由器到非直连网络的距离定义为所经过的路由器数加1。</li><li>允许一条路径最多只能包含15个路由器。“距离”等于16时相当于不可达。因此，RIP只适用于小型互联网。</li></ol></li><li>RIP认为好的路由就是“距离短”的路由，也就是所通过路由器数量最少的路由</li><li>当到达同一目的网络有多条“距离相等”的路由时，可以进行等价负载均衡</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117205628647.png"></p><h3 id="特点">2.1 特点</h3><ol type="1"><li>仅和相邻路由器交换信息</li><li>交换的信息是自己的路由表</li><li>周期性交换该信息</li></ol><h3 id="rp的基本工作流程">2.2 RP的基本工作流程</h3><ol type="1"><li>路由器刚开始工作时，只知道自己到直连网络的距离为1。</li><li>每个路由器仅和相邻路由器周期性地交换并更新路由信息。</li><li>若干次交换和更新后，每个路由器都知道到达本AS内各网络的最短距离和下一跳地址，称为收敛。</li></ol><h3 id="更新规则">2.3 更新规则</h3><ol type="1"><li>发现了新的网络，添加</li><li>到达目的网络，相同下一跳，最新消息，更新</li><li>到达目的网络，不同下一跳，新路由优势，更新</li><li>到达目的网络，不同下一跳，新路由劣势，不更新</li><li>到达目的网络，不同下一跳，等价负载均衡</li></ol><ul><li>RIP存在“坏消息传播得慢”的问题</li></ul><blockquote><p>坏消息传播得慢”又称为路由环路或距离无穷计数问题，这是距离向量算法的一个固有问题。</p></blockquote><ul><li>可以采取多种措施减少出现该问题的概率或减小该问题带来的危害。<ul><li>限制最大路径距离为15(16表示不可达)</li><li>当路由表发生变化时就立即发送更新报文（即“触发更新”），而不仅是周期性发送</li><li>让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向传送（即“水平分割”）</li></ul></li></ul><h2 id="开放最短路径ospf协议的工作原理">3.开放最短路径OSPF协议的工作原理</h2><h3 id="ospf协议">3.1 OSPF协议</h3><ol type="1"><li>开放最短路径优先OSPF(Open Shortest PathFirst),是为克服RIP的缺点在1989年开发出来的。</li><li>“开放”表明OSPF协议不是受某一家厂商控制，而是公开发表的。</li><li>“最短路径优先”是因为使用了Dijkstra提出的最短路径算法SPF。</li><li>OSPF是基于链路状态的，而不像RIP那样是基于距离向量的。</li><li>OSPF采用SPF算法计算路由，从算法上保证了不会产生路由环路。</li><li>OSPF不限制网络规模，更新效率高，收敛速度快。</li></ol><h3 id="链路">3.2 链路</h3><ol type="1"><li>链路状态是指本路由器都和哪些路由器相邻，以及相应链路的“代价”(cost)。</li><li>“代价”用来表示费用、距离、时延、带宽，等等。这些都由网络管理人员来决定。</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117211227799.png"></p><ol type="1"><li>OSPF相邻路由器之间通过交互问候(Hllo)分组，建立和维护邻居关系。<ol type="1"><li>Hello分组封装在IP数据报中，发往组播地址224.0.0.5；</li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117211306170.png"></p><ol start="2" type="1"><li>发送周期为10秒<ol type="1"><li>40秒未收到来自邻居路由器的Hlo分组，则认为该邻居路由器不可达。</li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117211527755.png"></p><h3 id="链路状态通告">3.3 链路状态通告</h3><blockquote><p>使用OSPF的每个路由器都会产生链路状态通告 LSA (Link StateAdvertisement)。</p></blockquote><ol type="1"><li>LSA中包含以下内容：<ol type="1"><li>直连网络的链路状态信息</li><li>邻居路由器的链路状态信息</li></ol></li><li>LSA被封装在链路状态更新分组LSU中，采用洪泛法发送。使用OSPF的每个路由器都有一个链路状态数据库LSDB，用于存储LSA。</li><li>通过各路由器洪泛发送封装有自己LSA的LSU分组，各路由器的LSDB最终将达到一致。</li><li>使用OSPF的各路由器基于LSDB进行最短路径优先SPF计算，构建出各自到达其他各路由器的最短路径，即构建各自的路由表。</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117211848406.png"></p><h3 id="ospf共有五种分组类型">3.4 OSPF共有五种分组类型</h3><ol type="1"><li>问候分组（Hello）<ol type="1"><li>用来发现和维护邻居路由器的可达性。</li></ol></li><li>数据库描述分组（DD）<ol type="1"><li>向邻居路由器给出自己的链路状态数据库中的所有链路状态项目的摘要信息</li></ol></li><li>链路状态请求分组（LSR）<ol type="1"><li>向邻居路由器请求发送某些链路状态项目的详细信息。</li></ol></li><li>链路状态更新分组（LSU）<ol type="1"><li>路由器使用这种分组将其链路状态进行洪泛发送，即用洪泛法对全网更新链路状态。</li></ol></li><li>链路确认分组（LSA）<ol type="1"><li>这是对链路状态更新分组的确认分组。</li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20230717155343654.png"></p><h3 id="ospf的基本工作过程">3.5 OSPF的基本工作过程</h3><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20230717155522453.png"></p><ol type="1"><li>OSPF在多点接入的网络中路由器邻里关系的建立<ol type="1"><li>选举指定路由器DR(designated router)和备用的指定路由器BDR(backupdesignated router)</li><li>所有的非DR/BDR只与DR/BDR建立邻居关系，即非DR/BDR之间通过DR/BDR交换信息</li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20230717155708575.png"></p><ol start="2" type="1"><li>为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统再划分为若干个更小的范围，叫做区域(Area)<ol type="1"><li>划分区域的好处就是把利用洪泛法交换链路状体信息的范围局限于每一个区域而不是整个自治系统，这就减少了整个网络上的通信量。</li><li>每个区域不大于200个路由器</li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117213232150.png"></p><h2 id="边界网关协议bgp的基本工作原理">4.边界网关协议BGP的基本工作原理</h2><h3 id="bgp原理">4.1 BGP原理</h3><ol type="1"><li>BGP只能是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由</li><li>BGP要解决的问题<ol type="1"><li>在不同自治系统内，度量路由的“代价”（距离，带宽，费用等)可能不同。因此，对于自治系统之间的路由选择，使用“代价”作为度量来寻找最佳路由是不行的。</li><li>自治系统之间的路由选择必须考虑相关策略（政治，经济，安全等）</li></ol></li></ol><h3 id="交换路由的过程">4.2 交换路由的过程</h3><ol type="1"><li><p>在配置BGP时，每个自治系统的管理员要选择至少一个路由器作为该自治系统的“BGP发言人”，不同自治系统的BGP发言人要交换路由信息，首先必须建立TCP连接，端口号为179</p></li><li><p>在此TCP连接上交换BGP报文以建立BGP会话</p></li><li><p>利用BGP会话交换路由信息（例如，增加新的路由，或撤销过时的路由，以及报告出错的情况等）</p><blockquote><p>使用TCP连接交换路由信息的两个BGP发言人，彼此称为对方的邻站(neighbor)或对等站(peer)</p></blockquote></li><li><p>BGP发言人除了运行BGP外，还必须运行自己所在自治系统所使用的内部网关协议IGP,例如OSPF或RIP。</p></li><li><p>当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各自治系统的较好的路由。也就是构造出树形结构、不存在回路的自治系统连通图。</p></li></ol><h3 id="bgp适用于多级结构的因特网">4.3 BGP适用于多级结构的因特网</h3><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117214100280.png"></p><h3 id="bgp-4四种报文类型">4.4 BGP-4四种报文类型</h3><table><thead><tr><th style="text-align: center;">报文</th><th style="text-align: left;">说明</th></tr></thead><tbody><tr><td style="text-align: center;">OPEN(打开)报文</td><td style="text-align: left;">用来与相邻的另一个BGP发言人建立关系，使通信初始化</td></tr><tr><td style="text-align: center;">UPDATE(更新)报文</td><td style="text-align: left;">用来通告某一路由的信息，以及列出要撤销的多条路由</td></tr><tr><td style="text-align: center;">KEEPALIVE(保活)报文</td><td style="text-align: left;">用来周期性地证实邻站的连通性。</td></tr><tr><td style="text-align: center;">NOTIFICATION(通知)报文</td><td style="text-align: left;">用来发送检测到的差错。</td></tr></tbody></table><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117214318616.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.5 静态路由配置及其可能产生的路由环路问题</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-5-%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%B6%E5%8F%AF%E8%83%BD%E4%BA%A7%E7%94%9F%E7%9A%84%E8%B7%AF%E7%94%B1%E7%8E%AF%E8%B7%AF%E9%97%AE%E9%A2%98/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-5-%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%B6%E5%8F%AF%E8%83%BD%E4%BA%A7%E7%94%9F%E7%9A%84%E8%B7%AF%E7%94%B1%E7%8E%AF%E8%B7%AF%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="静态路由配置及其可能产生的路由环路问题">4.5静态路由配置及其可能产生的路由环路问题</h1><ul><li>静态路由配置是指用户或网络管理员使用路由器的相关命令给路由器人工配置路由表。<ul><li>这种人工配置方式简单、开销小。但不能及时适应网络状态（流量、拓扑等）的变化。</li><li>一般只在小规模网络中采用。</li></ul></li></ul><h2 id="使用静态路由配置可能出现以下导致产生路由环路的错误">1.使用静态路由配置可能出现以下导致产生路由环路的错误</h2><h3 id="配置错误">1.1 配置错误</h3><ul><li>解决方法：<ul><li>IP数据报头部设置一个生存期，每经过一次路由转发，其值减一，当其值小于等于0时被丢弃</li><li>为了防止P数据报在路由环路中永久兜圈，在IP数据报首部设有生存时间TTL字段。</li><li>IP数据报进入路由器后，TTL字段的值减1。若TTL的值不等于0，则被路由器转发，否则被丢弃。</li></ul></li></ul><h3 id="聚合了不存在的网络">1.2 聚合了不存在的网络</h3><ul><li>静态配置不存在的IP网络为黑洞路由</li></ul><h3 id="网络故障">1.3 网络故障</h3><ul><li>静态配置故障的IP网络为黑洞路由，当其故障修复后，再自动添加回来并设置黑洞路由无效，若再故障，则删除并设置之前的黑洞路由有效</li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-5-%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%B6%E5%8F%AF%E8%83%BD%E4%BA%A7%E7%94%9F%E7%9A%84%E8%B7%AF%E7%94%B1%E7%8E%AF%E8%B7%AF%E9%97%AE%E9%A2%98/image-20241117203152226.png"></p><h2 id="路由条目的类型">2. 路由条目的类型</h2><ol type="1"><li>直连网络</li><li>静态路由（人工配置）</li><li>动态路由（路由选择协议）</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-5-%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%B6%E5%8F%AF%E8%83%BD%E4%BA%A7%E7%94%9F%E7%9A%84%E8%B7%AF%E7%94%B1%E7%8E%AF%E8%B7%AF%E9%97%AE%E9%A2%98/image-20241117202703876.png"></p><ol start="4" type="1"><li>特定主机路由<ol type="1"><li><p>特殊的静态路由条目</p></li><li><p>默认路由（目的网络为0.0.0.0，地址掩码为0.0.0.0）</p><blockquote><p>当路由表查找不到目标网络时，使用该路由</p></blockquote></li><li><p>特定主机路由（目的网络为特定主机的1P地址，地址掩码为255.255.255.255）</p></li><li><p>黑洞路由（下一跳为null0)</p></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.4 IP数据包的发送和转发过程</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-4-IP%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E5%8F%91%E9%80%81%E5%92%8C%E8%BD%AC%E5%8F%91%E8%BF%87%E7%A8%8B/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-4-IP%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E5%8F%91%E9%80%81%E5%92%8C%E8%BD%AC%E5%8F%91%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="ip数据报发送和转发过程">4.4 IP数据报发送和转发过程</h1><ul><li>分为两部分<ul><li>主机发送IP数据报</li><li>路由器发送IP数据报</li></ul></li></ul><h2 id="主机发送数据报">1. 主机发送数据报</h2><ul><li>判断目的主机是否与自己在同一个网络（判断方法请参看本节课相关示例）<ul><li>若在同一个网络，则属于直接交付：</li><li>若不在同一个网络，则属于间接交付，传输给主机所在网络的默认网关(路由器)，由默认网关帮忙转发；</li></ul></li></ul><h2 id="路由器转发数据报">2. 路由器转发数据报</h2><ul><li>检查IP数据报首部是否出错：<ul><li>若出错，则直接丢弃该P数据报并通告源主机；</li><li>若没有出错，则进行转发；</li></ul></li><li>根据IP数据报的目的地址在路由表中查找匹配的条目(查找方法请参看本节课相关示例)：<ul><li>若找到匹配的条目，则转发给条目中指示的下一跳；</li><li>若找不到，则丢弃该P数据报并通告源主机；</li></ul></li></ul><h2 id="隔离">3. 隔离</h2><ul><li>中继器和集线器工作在物理层，既不隔离冲突域也不隔离广播域。</li><li>网桥和交换机（多端口网桥）工作在数据链路层，可以隔离冲突域，不能隔离广播域。</li><li>路由器工作在网络层，既隔离冲突域，也隔离广播域。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.3 IPv4</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/</url>
    
    <content type="html"><![CDATA[<h1 id="ipv4">4.3 IPv4</h1><h2 id="ipv4地址概述">1. IPv4地址概述</h2><blockquote><p>给因特网上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的32比特的标识符。</p></blockquote><ol type="1"><li>在TCP/IP体系中，IP地址是一个最基本的概念，我们必须把它弄清楚。</li><li>IPv4地址就是给因特网(Internet)上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的32比特的标识符。</li><li>IP地址由因特网名字和数字分配机构ICANN(Internet Corporation forAssigned Names and Numbers)进行分配.</li><li>我国用户可向亚太网络信息中心APNIC(Asia Pacific Network InformationCenter)申请IP地址，需要缴费。</li><li>2011年2月3日，互联网号码分配管理局IANA(由ICANN行使职能)宣布，IPV4地址已经分配完毕。</li><li>我国在2014至2015年也逐步停止了向新用户和应用分配IPv4地址。同时全面开展商用部署IPv6。</li></ol><h3 id="十进制表示">1.1 十进制表示</h3><blockquote><p>32比特的1Pv4地址不方便阅读、记录以及输入等，因此IPv4地址采用点分十进制表示方法以方便用户使用。</p><p>八位一组，中间用 <code>.</code> 隔开</p></blockquote><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/image-20230716135419296.png"></p><h2 id="分类编址的ipv4地址">2. 分类编址的IPv4地址</h2><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/image-20230716142505440.png"></p><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/image-20230716142540603.png"></p><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/image-20241117190912535.png"></p><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/image-20230716142559662.png"></p><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/image-20230716141719165.png"></p><h2 id="划分子网的ipv4地址">3. 划分子网的IPv4地址</h2><ol type="1"><li>从主机号中借用一部分比特来作为子网号</li><li>子网掩码<ol type="1"><li>子网掩码使用连续的比特1来对应网络号和子网号</li><li>子网掩码使用连续的比特0来对应主机号</li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/image-20230716165915602.png"></p><ol start="3" type="1"><li>为新增网络申请新的网络号会带来以下弊端：<ol type="1"><li>需要等待时间和花费更多的费用</li><li>会增加其他路由器中路由表记录的数量</li><li>浪费原有网络号中剩余的大量IP地址</li></ol></li><li>默认子网掩码</li></ol><figure><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/image-20230716170001375.png" alt="默认子网掩码"><figcaption aria-hidden="true">默认子网掩码</figcaption></figure><h2 id="无分类编址的ipv4地址">4. 无分类编址的IPv4地址</h2><ol type="1"><li>无分类域间路由选择（CIDR）消除了传统的A类、B类和C类地址，以及划分子网的概念。</li><li>为此，因特网工程任务组ETF又提出了采用无分类编址的方法来解决P地址紧张的问题，同时还专门成立Pv6工作组负责研究新版本P以彻底解决P地址耗尽问题。</li><li>1993年，IETF发布了无分类域间路由选择CIDR(Classless Inter-DomainRouting)的RFC文档：RFC1517~1519和1520。</li><li>CIDR消除了传统的A类、B类和C类地址，以及划分子网的概念：</li><li>CIDR可以更加有效地分配IPv4的地址空间，并且可以在新的PV6使用之前允许因特网的规模继续增长。</li><li>CIDR可以更加有效地分配IPV4的地址空间，并且可以在新的PV6使用之前允许因特网的规模继续增长。如：192.8.32.3/20</li><li>CIDR实际上是将网络前缀都相同的连续的1P地址组成一个“CIDR地址块”。</li></ol><h2 id="路由聚合">4.1 路由聚合</h2><ul><li>构造超网，找到相同接口的多个地址的最长公共前缀，其余位归0，将该地址记录下来，那些地址删除即将它们合并成一个地址</li><li>网络前缀越长，地址块越小，路由越具体</li><li>若路由器查表转发分组时发现有多条路由可选，则选择网络前缀最长的那条，这称为最长前缀匹配。因为这样的路由更具体</li></ul><h2 id="ipv4地址的应用规划">5. IPv4地址的应用规划</h2><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/image-20230716214234227.png"></p><ul><li>变长的子网掩码是CIDR技术的应用</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.2 网络层提供的两种服务</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-2-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-2-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="网络层提供的两种服务">4.2 网络层提供的两种服务</h1><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-2-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1/image-20230716133452655.png"></p><h2 id="虚电路服务">1. 虚电路服务</h2><ol type="1"><li>可靠通信由网络来保证</li><li>必须建立网络层的连接</li><li>虚电路VC(Virtual Circuit)通信双方沿着已建立的虚电路发送分组，目的主机的地址仅在连接建立阶段使用，之后每个分组的首部只需携带一条虚电路的编号（构成虚电路的每一段链路都有一个虚电路编号)。这种通信方式如果再使用可靠传输的网络协议，就可使所发送的分组最终正确到达接收方（无差错按序到达、不丢失、不重复)。</li><li>通信结束后，需要释放之前所建立的虚电路。</li><li>很多广域分组交换网都使用面向连接的虚电路服务。<ol type="1"><li>例如，曾经的X.25和逐渐过时的帧中继FR、异步传输模式ATM等。</li></ol></li></ol><h2 id="数据报服务">2. 数据报服务</h2><ol type="1"><li>无连接的数据报服务</li><li>可靠通信应当由用户主机来保证</li><li>不需要建立网络层连接</li><li>每个分组可走不同的路径</li><li>每个分组的首部必须携带目的主机的完整地址这种通信方式所传送的分组可能误码、丢失、重复和失序。</li><li>由于网络本身不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价格低廉（与电信网的交换机相比较）。</li><li>因特网采用了这种设计思想，也就是将复杂的网络处理功能置于因特网的边缘（用户主机和其内部的运输层)，而将相对简单的尽最大努力的分组交付功能置于因特网核心。</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.1 网络层概述</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-1-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-1-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="网络层">4.1 网络层</h1><h2 id="网络层-1">1. 网络层</h2><ol type="1"><li>网络层的主要任务是实现网络互连，进而实现数据包在各网络之间的传输</li><li>要实现网络层任务，需要解决以下主要问题：<ol type="1"><li>网络层向运输层提供怎样的服务（可靠传输 还是 不可靠传输）<ol type="1"><li>如果网络层对传输错误（分组丢失，分组失序等）不采取任何措施，那么就是不可靠服务</li><li>TCP/IP网络体系结构提供的就是无连接，不可靠的传输服务（IP协议）</li></ol></li><li>网络层寻址问题</li><li>路由选择问题</li></ol></li><li>因特网(Internet)是目前全世界用户数量最多的互联网，它使用TCP/IP协议栈。</li><li>由于TCP/IP协议栈的网络层使用网际协议IP,它是整个协议栈的核心协议，因此在TCP/IP协议栈中网络层常称为网际层。</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-1-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0/image-20241117185613994.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.11 虚拟局域网VLAN</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-11-%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91VLAN%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-11-%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91VLAN%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟局域网vlan">3.11 虚拟局域网（VLAN）</h1><ol type="1"><li>以太网交换机工作在数据链路层（也包括物理层）</li><li>使用一个或多个以太网交换机互连起来的交换式以太网，其所有站点都属于同一个广播域。随着交换式以太网规模的扩大，广播域相应扩大。</li><li>巨大的广播域会带来很多弊端：<ol type="1"><li>广播风暴</li><li>难以管理和维护</li><li>潜在的安全问题</li></ol></li><li>广播风暴会浪费网络资源和各主机的CPU资源！网络中会频繁出现广播信息<ol type="1"><li>TCP/IP协议栈中的很多协议都会使用广播：<ol type="1"><li>地址解析协议ARP(已知IP地址，找出其相应的MAC地址)</li><li>路由信息协议RIP(一种小型的内部路由协议)</li><li>动态主机配置协议DHCP(用于自动配置IP地址)</li><li>NetBEUI: Windows下使用的广播型协议</li><li>IPX/SPX: Novell网络的协议栈</li><li>Apple Talk: Apple公司的网络协议栈</li></ol></li></ol></li></ol><h2 id="分割广播域的方法">1. 分割广播域的方法</h2><ul><li><p>使用路由器可以隔离广播域</p></li><li><p>虚拟局域网VLAN(Virtual Local AreaNetwork)是一种将局域网内的设备划分成与物理位置无关的逻辑组的技术，这些逻辑组具有某些共同的需求。</p></li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-11-%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91VLAN%E6%A6%82%E8%BF%B0/image-20241117181858889.png"></p><blockquote><p>虚拟局域网是一种将局域网内的设备划分成与物理位置无关的逻辑组的技术，这些逻辑组具有某些共同的需求。即作用是像路由器一样分割广播域。</p></blockquote><ol type="1"><li><p>802.1Q帧对以太网帧进行了扩展，插入了4字节的VLAN标记 <img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-11-%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91VLAN%E6%A6%82%E8%BF%B0/image-20241117182055735.png"></p></li><li><p>VLAN标记的最后12比特称为VLAN标识符VID,它唯一地标志了以太网帧属于哪一个VLAN.</p><ol type="1"><li>V1D的取值范围是0~4095 ( 0 ~ 2<sup>12</sup>-1 )</li><li>0和4095都不用来表示VLAN，因此用于表示VLAN的V1D的有效取值范围是1~4094</li></ol></li><li><p>802.1Q帧是由交换机来处理的，而不是用户主机来处理的。</p><ol type="1"><li>当交换机收到普通的以太网帧时，会将其<strong>插入4字节的VLAN标记</strong>转变为802.1Q帧，简称“打标签”</li><li>当交换机转发802.1Q帧时，可能会<strong>删除其4字节VLAN标记</strong>转变为普通以太网帧，简称“去标签”</li></ol></li></ol><h2 id="交换机端口类型">2. 交换机端口类型</h2><ol type="1"><li><p>交换机有三种端口类型</p><ol type="1"><li>Access</li><li>Trunk</li><li>Hybrid</li></ol></li><li><p>Access端口一般用于连接用户计算机</p><ol type="1"><li>Access端口只能属于一个VLAN</li><li>Access端口的PVID值与端口所属VLAN的ID相同（默认为1）</li><li>Access端口接收处理方法：<ol type="1"><li>一般只接受“未打标签”的普通以太网MAC帧。</li><li>根据接收帧的端口的PVID给帧“打标签”，即插入4字节VLAN标记字段，字段中的VID取值与端口的PVID取值相等。</li></ol></li></ol></li><li><p>Trunk端口一般用于交换机之间或交换机与路由器之间的互连</p><ol type="1"><li>Trunk端口可以属于多个VLAN</li><li>用户可以设置Trunk端口的PVID值。默认情况下，Trunki端口的PVID值为1。</li><li>Trunk端口发送处理方法：<ol type="1"><li>对VID等于PVID的帧，“去标签”再转发；</li><li>Trunk端口接收处理方法：接收“未打标签”的帧，根据接收帧的端口的PVID给帧“打标签”，即插入4字节</li><li>VLAN标记字段，字段中的VID取值与端口的PVID取值相等。</li></ol></li></ol></li><li><p>Hybrid端口</p><ol type="1"><li>既可用于交换机之间或交换机，与路由器之间的互连（同Trunk端口），也可用于交换机与用户计算机之间的互连（同Access端口）</li><li>Hybrid端口可以属于多个VLAN(同Trunk端口)</li><li>用户可以设置Hybrid端口的PVID值。默认情况下，Hybrid端口的PVID值为1（同Trunk端口）</li><li>Hybrid端口发送处理方法（与Trunk端口不同）<ol type="1"><li>查看帧的VID是否在端口的“去标签”列表中：</li><li>若存在，则“去标签”后再转发；</li><li>若不存在，则直接转发；</li></ol></li><li>Hybrid端口接收处理方法（同Trunk端口）<ol type="1"><li>接收“未打标签”的帧，根据接收帧的端口的PVID给帧"打标签”，即插入4字节VLAN标记字段，字段中的VID取值与端口的PVID取值相等。</li><li>接收“已打标签的帧”：</li></ol></li></ol></li></ol><ul><li>交换机各端口的缺省VLAN ID,在思科交换机上称为NativeVLAN,即本征VLAN。</li><li>在华为交换机上称为Port VLAN ID,即端口VLAN ID,简记为PVID。</li></ul><figure><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-11-%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91VLAN%E6%A6%82%E8%BF%B0/image-20241117184056860.png" alt="image-20241117184056860"><figcaption aria-hidden="true">image-20241117184056860</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.10 以太网交换机的生成树协议STP</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-10-%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AESTP/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-10-%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AESTP/</url>
    
    <content type="html"><![CDATA[<h2 id="以太网交换机的生成树协议stp">3.10以太网交换机的生成树协议STP</h2><ul><li>为提高以太网的可靠性，需要添加冗余链路，但添加冗余链路会形成网络环路，网络环路会造成很多问题：<ul><li>广播风暴<ul><li>大量消耗网络资源，使得网络无法正常转发其他数据帧：</li></ul></li><li>主机收到重复的广播帧<ul><li>大量消耗主机资源</li></ul></li><li>交换机的帧交换表震荡（漂移）<ul><li>某记录在错误的记录之间来回震荡</li></ul></li></ul></li><li>STP正是为了解决这一问题而出现。<ul><li>不论交换机之间采用怎样的物理连接，交换机都能够自动计算并构建一个逻辑上没有环路的网络，其逻辑拓扑结构必须是树型的（无逻辑环路）</li><li>最终生成的树型逻辑拓扑要确保连通整个网络。</li><li>当首次连接交换机或网络物理拓扑发生变化时（有可能是人为改变或故障），交换机都将进行生成树的重新计算。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.9 以太网交换机自学习和转发帧的流程</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-9-%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA%E8%87%AA%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%BD%AC%E5%8F%91%E5%B8%A7%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-9-%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA%E8%87%AA%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%BD%AC%E5%8F%91%E5%B8%A7%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="以太网自学习和转发帧">3.9 以太网自学习和转发帧</h1><ul><li>以太网交换机工作在数据链路层（也包括物理层）<ul><li>以太网交换机收到帧后，在帧交换表中查找帧的目的MAC地址所对应的接口号，然后通过该接口转发帧。</li></ul></li><li>以太网交换机是一种即插即用设备，刚上电启动时其内部的帧交换表是空的。随着网络中各主机间的通信，<ul><li>以太网交换机通过自学习算法自动逐渐建立起帧交换表。</li></ul></li></ul><ol type="1"><li>收到帧后进行登记。登记的内容为帧的源MAC地址及进入交换机的接口号</li><li>根据帧的目的MAC地址和交换机的帧交换表对帧进行转发，有以下三种情况：<ol type="1"><li>明确转发：交换机知道应当从哪个（回或哪些）接口转发该帧（单播，多播，广播）</li><li>盲目转发：交换机不知道应当从哪个端口转发帧，只能将其通过除进入交换机的接口外的其他所有接口转发（也称为泛洪）</li><li>明确丢弃：交换机知道不应该转发该帧，将其丢弃。比如：源MAC地址和目的MAC地址在表中记录为同一个端口</li></ol></li><li>帧交换表中的每条记录都有自己的有效时间，到期删除。原因如下：<ol type="1"><li>交换机的接口改接了另一台主机</li><li>主机更换了网卡</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.8 集线器与交换机的区别</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-8-%E9%9B%86%E7%BA%BF%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-8-%E9%9B%86%E7%BA%BF%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="集线器hub和交换机switch的区别">3.8集线器（HUB）和交换机（SWITCH）的区别</h1><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-8-%E9%9B%86%E7%BA%BF%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB/image-20241117174351414.png"></p><h2 id="集线器hub">1. 集线器HUB</h2><ol type="1"><li>使用集线器的以太网在逻辑上仍是一个总线网，各站共享总线资源，使用的还是CSMA/CD协议：</li><li>集线器只工作在物理层，它的每个接口仅简单地转发比特，不进行碰撞检测（由各站的网卡检测）：<ol type="1"><li>集线器一般都有少量的容错能力和网络管理功能。例如，若网络中某个网卡出了故障，不停地发送帧。此时，集线器可以检测到这个问题，在内部断开与出故障网卡的连线，使整个以太网仍然能正常工作。</li></ol></li><li>使用集线器HUB在物理层扩展以太网</li></ol><h2 id="交换机">2. 交换机</h2><blockquote><p>前提：交换机已完成自学习</p></blockquote><ol type="1"><li>以太网交换机通常都有多个接口。每个接口都可以直接与一台主机回或另一个以太网交换机相连。一般都工作在全双工方式。</li><li>以太网交换机具有并行性，能同时连通多对接口，使多对主机能同时通信，无碰撞（不使用CSMA/CD协议）。</li><li>以太网交换机一般都具有多种速率的接口，例如：10Mb/s、100Mb/s、1Gb/s、10Gb/s接口的多种组合。<ol type="1"><li>以太网交换机工作在数据链路层（也包括物理层），它收到帧后，在帧交换表中查找帧的目的MAC地址所对应的接口号，然后通过该接口转发帧。</li><li>以太网交换机是一种即插即用设备，其内部的帧交换表是通过自学习算法自动地逐渐建立起来的。</li></ol></li><li>帧的两种转发方式：<ol type="1"><li>存储转发</li><li>直通交换：采用基于硬件的交叉矩阵（交换时延非常小，但不检查帧是否右差错)</li></ol></li></ol><h2 id="比较">3. 比较</h2><ol type="1"><li>交换机性能远超集线器，而且价格不高，所以市场上集线器已被淘汰</li><li>交换机不会改变源目MAC地址</li><li>交换机全双工传输</li><li>交换机即插即用</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-8-%E9%9B%86%E7%BA%BF%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB/image-20241117175352287.png"></p><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-8-%E9%9B%86%E7%BA%BF%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB/image-20241117175440399.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.7 MAC地址 IP地址以及ARP协议</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-7-MAC%E5%9C%B0%E5%9D%80-IP%E5%9C%B0%E5%9D%80-ARP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-7-MAC%E5%9C%B0%E5%9D%80-IP%E5%9C%B0%E5%9D%80-ARP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="mac地址ip地址arp地址">3.7 MAC地址，IP地址，ARP地址</h1><ul><li>MAC地址是以太网的MAC子层所使用的地址</li><li>IP地址是TCP/小P体系结构网际层所使用的地址</li><li>ARP协议属于TCP/IP体系结构的网际层，其作用是已知设备所分配到的1P地址，使用ARP协议可以通过该P地址获取到设备的MAC地址；</li><li>尽管IP地址和ARP协议属于TCP/IP体系结构的网际层（而不属于数据链路层)，但是它们与MAC地址存在一定的关系，并且我们日常的网络应用都离不开MAC地址、IP地址以及ARP协议。</li></ul><h2 id="mac地址">1. MAC地址</h2><ul><li>又称硬件地址，物理地址，属于数据链路层范畴</li><li>当多个主机连接在同一个广播信道上，要想实现两个主机之间的通信，则每个主机都必须有一个唯一的标识，即一个数据链路层地址</li></ul><ol type="1"><li>一般情况下，用户主机会包含两个网络适配器：有线局域网适配器（有线网卡）和无线局域网适配器（无线网卡)。</li><li>每个网络适配器都有一个全球唯一的MAC地址。而交换机和路由器往往拥有更多的网络接口，所以会拥有更多的MAC地址。综上所述，严格来说，MAC地址是对网络上各接口的唯一标识，而不是对网络上各设备的唯一标识。</li><li>在每个主机发送的帧中必须携带标识发送主机和接收主机的地址。由于这类地址是用于媒体接入控制MAC(MediaAccess Control),因此这类地址被称为MAC地址：<ol type="1"><li>MAC地址一般被固化在网卡（网络适配器）的电可擦可编程只读存储器EEPROM中，因此MAC地址也被称为硬件地址；</li><li>MAC地址有时也被称为物理地址。请注意：这并不意味着MAC地址属于网络体系结构中的物理层！</li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-7-MAC%E5%9C%B0%E5%9D%80-IP%E5%9C%B0%E5%9D%80-ARP%E5%8D%8F%E8%AE%AE/image-20241117152902875.png"></p><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-7-MAC%E5%9C%B0%E5%9D%80-IP%E5%9C%B0%E5%9D%80-ARP%E5%8D%8F%E8%AE%AE/image-20241117153926503.png"></p><h2 id="ip地址">2. IP地址</h2><blockquote><p>IP地址是因特网(Internet)上的主机和路由器所使用的地址，属于网络层范畴</p><p>用于标识两部分信息：</p><ol type="1"><li>网络编号：标识因特网上数以百万计的网络</li><li>主机编号：标识同一网络上不同主机（或路由器各接口）</li></ol></blockquote><ol type="1"><li>数据包转发过程中，源IP地址和目的IP地址不变源MAC地址和目的MAC地址逐个链路改变</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-7-MAC%E5%9C%B0%E5%9D%80-IP%E5%9C%B0%E5%9D%80-ARP%E5%8D%8F%E8%AE%AE/image-20241117154839729.png"></p><h2 id="arp协议">3. ARP协议</h2><blockquote><p>解析IP地址 得到相应的MAC地址，属于网络层范畴</p></blockquote><ul><li><p>内容步骤</p><ol type="1"><li>源主机在自己的ARP高速缓存表中查找目的主机的1P地址所对应的MAC地址，若找到了，则可以封装MAC帧进行发送；若找不到，则发送ARP请求（封装在广播MAC帧中）</li><li>目的主机收到ARP请求后，将源主机的IP地址与MAC地址记录到自己的ARP高速缓存表中，然后给源主机发送ARP响应（封装在单播MAC帧中)，ARP响应中包含有目的主机的IP地址和MAC地址</li></ol></li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-7-MAC%E5%9C%B0%E5%9D%80-IP%E5%9C%B0%E5%9D%80-ARP%E5%8D%8F%E8%AE%AE/image-20241117173649451.png"></p><ol type="1"><li><p>作用范围</p></li><li><p>逐段链路或逐段网络使用</p></li><li><p>ARP高速缓存表中记录了每个IP地址对应的MAC地址，以及这个地址对的类型类型分为静态类型和动态类型</p><ol type="1"><li>静态类型手动配置，可设置系统重启后这些静态类型的地址对是否仍然有效</li><li>动态类型是通过上述ARP请求以及ARP相应得到的，有效时间很短，2分钟左右</li></ol></li><li><p>ARP协议不能跨网络使用</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.6 媒体接入控制</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="媒体接入控制mac">3.6 媒体接入控制（MAC）</h1><ul><li>共享信道要着重考虑的一个问题就是如何协调多个发送和接收站点对一个共享传输媒体的占用，即媒体接入控制MAC(MediumAccess Control)。</li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117135016262.png"></p><ul><li>随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局域网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术。</li></ul><h2 id="静态划分信道">1. 静态划分信道</h2><ul><li>信道复用技术<ul><li>复用(Multiplexing)是通信技术中的一个重要概念。复用就是通过一条物理线路同时传输多路用户的信号。</li><li>当网络中传输媒体的传输容量大于多条单一信道传输的总通信量时，可利用复用技术在一条物理线路上建立多条通信信道来充分利用传输媒体的带宽。</li></ul></li></ul><h3 id="频分复用fdm">1.1 频分复用（FDM）</h3><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117135153544.png"></p><ul><li>频分复用的所有用户同时占用不同的频带资源并行通信。</li></ul><h3 id="时分复用tdm">1.2 时分复用（TDM）</h3><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117135256698.png"></p><ul><li>时分复用的所有用户在不同的时间占用同样的频带宽度。</li></ul><h3 id="波分复用wdm">1.3 波分复用（WDM）</h3><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117135344436.png"></p><h3 id="码分复用">1.4 码分复用</h3><ol type="1"><li>CDM的每一个用户可以在同样的时间使用同样的频带进行通信。</li><li>由于各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。</li><li>CDM最初是用于军事通信的，因为这种系统所发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li><li>在CDMA中，每一个比特时间再划分为m个短的间隔，称为码片(Chip)。通常m的值是64或128</li><li>使用CDMA的每一个站被指派一个唯一的码片码片序列<ol type="1"><li>一个站如果要发送比特1，则发送它自己的码片码片序列；</li><li>一个站如果要发送比特0，则发送它自己的码片序列的二进制反码</li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117140108915.png"></p><ol start="6" type="1"><li>码片序列挑选原则</li></ol><ul><li>分配给每个站的码片序列必须各不相同，实际常采用伪随机码序列。</li><li>分配给每个站的码片序列必须相互正交（规格化内积为0）</li></ul><p><span class="math display">\[A \bullet B = \frac{1}{m} \times \sum_{i=1}^{m}A_i \times B_i\]</span></p><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117140433653.png"></p><h2 id="动态接入控制随机接入">2. 动态接入控制——随机接入</h2><h3 id="csmacd协议">2.1 CSMA/CD协议</h3><ul><li>载波监听 多址接入 / 碰撞检测</li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117142251276.png"></p><ul><li>以太网还采取一种叫做强化碰撞的措施。这就是当发送帧的站点一旦检测到碰撞，除了立即停止发送帧外，还要再继续发送32比特或48比特的人为干扰信号(JammingSignal),以便有足够多的碰撞信号使所有站点都能检测出碰撞。</li></ul><h3 id="工作原理">2.2 工作原理</h3><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117142509113.png"></p><ol start="2" type="1"><li><p>争用期（碰撞窗口）</p><ol type="1"><li>发送帧的主机最多经过以太网端到端往返传播时延2τ这么长时间，就可检测到本次传输是否发生了碰撞，2τ称为争用期：</li><li>经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</li><li>以太网规定2τ的取值为512比特时间（即发送512比特所耗费的时间），对于10Mbps的以太网，2τ即为51.2 μs。</li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117142629341.png"></p><ol start="3" type="1"><li>最小帧长</li></ol><p><span class="math display">\[最小帧长 = 争用期 \times 数据传输速率（带宽）\]</span></p><ul><li>最小帧长的设置是因为源主机将帧发送完毕以后，便不会再管这个帧，此时发生碰撞导致目标主机丢弃该帧，不会重发。</li><li>以太网规定最小帧长为64字节，即512比特(512比特时间即为争用期)：<ul><li>如果要发送的数据非常少，那么必须加入一些填充字节，使帧长不小于64字节。</li><li>以太网的最小帧长确保了主机可在帧发送完成之前就检测到该帧的发送过程中是否遭遇了碰撞：</li><li>如果在争用期（共发送64字节）没有检测到碰撞，那么后续发送的数据就一定不会发生碰撞；</li><li>如果在争用期内检测到碰撞，就立即中止发送，这时已经发送出去的数据一定小于64字节，因此凡长度小于64字节的帧都是由于碰撞而异常中止的无效帧。</li></ul></li></ul><ol start="4" type="1"><li>最大帧长</li></ol><ul><li>最大帧长的设置是因为不能使某个主机长时间独占共享媒介，否则过于影响其它主机的数据发送</li></ul><ol start="5" type="1"><li>截断二进制指数退避算法</li></ol><p><span class="math display">\[随机退避时间=争用期\times随机数r,\\其中r从离散的整数集合0,1，…，(2k.1)中随机取出一个，\]</span></p><p><span class="math display">\[k = Min(重传次数，10)\]</span> -若连续多次发生碰撞，就表明可能有较多的主机参与竞争信道。但使用上述退避算法可使重传需要推迟的平均时间随重传次数而增大（这也称为动态退避），因而减)小发生碰撞的概率，有利于整个系统的稳定。-当重传达16次仍不能成功时，这表明同时打算发送数据的主机太多以至于连续发生碰撞，则丢弃该帧并向高层报告。</p><ol start="6" type="1"><li>以太网信道利用率</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117143437511.png"></p><ol start="7" type="1"><li>考虑以下这种理想情况：<ol type="1"><li>各主机发送帧都不会产生碰撞，总线一旦空闲就有某个主机立即发送帧：</li><li>发送一帧占用总线的时间为T0+T，而帧本身的发送时间是T0,</li><li>理想情况公式：</li></ol></li></ol><p><span class="math display">\[S_{max} = \frac{T_0}{T_0 + \tau} = \frac{1}{1+\frac{\tau}{T_0}}\]</span></p><ul><li>信道利用率受传播时延限制，所以以太网端到端的距离收到限制，以太网帧的长度最好尽量长些</li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117143601933.png"></p><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117143649489.png"></p><h2 id="csmaca协议">3. CSMA/CA协议</h2><ul><li><p>载波监听 多址接入 / 碰撞避免</p></li><li><p>载波监听多址接入/碰撞避免CSMA/CA(Carrier Sense MultipleAccess/Collision Avoidance)</p></li></ul><ol type="1"><li>既然CSMA/CD协议已经成功地应用于使用广播信道的有线局域网，那么同样使用广播信道的无线局域网能不能也使用CSMA/CD协议呢？</li><li>在无线局域网中，仍然可以使用载波监听多址接入CSMA,即在发送帧之前先对传输媒体进行载波监听。若发现有其他站在发送帧，就推迟发送以免发生碰撞。</li><li>在无线局域网中，不能使用碰撞检测CD,原因如下：<ol type="1"><li>由于无线信道的传输条件特殊，其信号强度的动态范围非常大，无线网卡上接收到的信号强度往往会远远小于发送信号的强度（可能相差百万倍）。如果要在无线网卡上实现碰撞检测CD,对硬件的要求非常高。</li><li>即使能够在硬件上实现无线局域网的碰撞检测功能，但由于无线电波传播的特殊性（存在隐蔽站问题)，进行碰撞检测的意义也不大。</li></ol></li><li>802.11无线局域网使用CSMA/CA协议，在CSMA的基础上增加了一个碰撞避免CA功能，而不再实现碰撞检测功能。</li><li>由于不可能避免所有的碰撞，并且无线信道误码率较高，802.11标准还使用了数据链路层确认机制（停止-等待协议）来保证数据被正确接收。</li><li>802.11的MAC层标准定义了两种不同的媒体接入控制方式：<ol type="1"><li>分布式协调功能DCF(Distributed CoordinationFunction)。在DCF方式下，没有中心控制站点，每个站点使用CSMA/CA协议通过争用信道来获取发送权，这是802.11定义的默认方式。</li><li>点协调功能PCF(Point CoordinationFunction)。PCF方式使用集中控制的接入算法(一般在接入点AP实现集中控制)，是802.11定义的可选方式，在实际中较少使用。</li></ol></li></ol><h3 id="帧间间隔ifsinterframe-space">3.1 帧间间隔IFS(InterFrameSpace)</h3><ol type="1"><li>802.11标准规定，所有的站点必须在持续检测到信道空闲一段指定时间后才能发送帧，这段时间称为帧间间隔FS。</li><li>帧间间隔的长短取决于该站点要发送的帧的类型：<ol type="1"><li>高优先级帧需要等待的时间较短，因此可优先获得发送权：</li><li>低优先级帧需要等待的时间较长。若某个站的低优先级帧还没来得及发送，而其他站的高优先级帧已发送到信道上，则信道变为忙态，因而低优先级帧就只能再推迟发送了。这样就减少了发生碰撞的机会。</li></ol><blockquote><p>无法在无线局域网中使用碰撞检测，所以还使用了停止-等待协议来实现可靠传输</p></blockquote></li><li>短帧间间隔（SIFS）和 长时间间隔（DIFS），常用的两种帧间间隔如下：<ol type="1"><li>短帧间间隔SIFS(28μs),是最短的帧间间隔，用来分隔开属于一次对话的各帧。一个站点应当能够在这段时间内从发送方式切换到接收方式。使用SIFS的帧类型有ACK帧、CTS帧、由过长的MAC帧分片后的数据帧、以及所有回答AP探询的帧和在PCF方式中接入点AP发送出的任何帧。</li><li>DCF帧间间隔DIFS(128μS),它比短帧间间隔SIFS要长得多，在DCF方式中用来发送数据帧和管理帧。</li></ol></li></ol><h3 id="退避算法">3.2 退避算法</h3><ol type="1"><li>在执行退避算法时，站点为退避计时器设置一个随机的退避时间<ol type="1"><li>当退避计时器的时间减小到零时，就开始发送数据；</li><li>当退避计时器的时间还未减小到零时而信道又转变为忙状态，这时就冻结退避计时器的数值，重新等待信道变为空闲，再经过时间DIFS后，继续启动退避计时器。</li></ol></li><li>在进行第i次退避时，退避时间在时隙编号0,1,......,2<sup>i+2</sup>-1中随机选择一个，然后乘以基本退避时间（也就是一个时隙的长度）就可以得到随机的退避时间。这样做是为了使不同站点选择相同退避时间的概率减少。当时隙编号达到255时（对应于第6次退避)就不再增加了。</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117150202751.png"></p><ol start="3" type="1"><li><p>何时执行退避算法</p><ol type="1"><li>在发送数据帧之前检测到信道处于忙状态时</li><li>在每一次重传一个数据帧时</li><li>在每一次成功发送后要连续发送下一个帧时（这是为了避免一个站点长时间占用信道）<img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117145612604.png" alt="image-20241117145612604"></li></ol></li><li><p>信道预约</p><ol type="1"><li>为了尽可能减少碰撞的概率和降低碰撞的影响，802.11标准允许要发送数据的站点对信道进行预约。</li><li>802.11标准允许要发送数据的站点对信道进行预约，即在发送数据帧之前先发送请求发送RTS帧。在收到响应允许发送CTS帧后，就可发送数据帧。<ol type="1"><li>源站在发送数据帧之前先发送一个短的控制帧，称为请求发送RTS(Request ToSend),它包括源地址、目的地址以及这次通信（包括相应的确认帧)所需的持续时间。</li><li>若目的站正确收到源站发来的RTS顿，且媒体空闲，就发送一个响应控制帧，称为允许发送CTS(ClearToSend),它也包括这次通信所需的持续时间（从RTS帧中将此持续时间复制到CTS帧中）。</li><li>源站收到CTS帧后，再等待一段时间S1FS后，就可发送其数据帧。</li><li>若目的站正确收到了源站发来的数据帧，在等待时间SFS后，就向源站发送确认帧ACK。</li></ol></li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117150514559.png"></p><ul><li>除源站和目的站以外的其他各站，在收到CTS帧（或数据帧）后就推迟接入到无线局域网中。这样就保证了源站和目的站之间的通信不会受到其他站的干扰。</li><li>如果RTS帧发生碰撞，源站就收不到CTS帧，<strong>需执行退避算法重传RTS帧。</strong></li><li>由于RTS帧和CTS帧很短，发送碰撞的概率、碰撞产生的开销及本身的开销都很小。而对于一般的数据帧，其<strong>发送时延往往大于传播时延</strong>（因为是局域网），碰撞的概率很大，且一旦发生碰撞而导致数据帧重发，则浪费的时间就很多，因此用很小的代价对信道进行预约往往是值得的。802.11标准规定了3种情况供用户选择：<ol type="1"><li>使用RTS帧和CTS帧</li><li>不使用RTS帧和CTS帧</li><li>只有当数据帧的长度超过某一数值时才使用RTS帧和CTS帧</li></ol></li></ul><ol start="5" type="1"><li>虚拟载波监听<ol type="1"><li>除RTS帧和CTS帧会携带通信需要持续的时间，数据帧也能携带通信需要持续的时间，这称为802.11的虚拟载波监听机制。</li></ol></li><li>由于利用虚拟载波监听机制，站点只要监听到RTS帧、CTS帧或数据帧中的任何一个，就能知道信道被占用的持续时间，而不需要真正监听到信道上的信号，因此虚拟载波监听机制能减少隐蔽站带来的碰撞问题。</li></ol><figure><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117150646126.png" alt="image-20241117150646126"><figcaption aria-hidden="true">image-20241117150646126</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.5 点对点协议PPP</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-5-%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-5-%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/</url>
    
    <content type="html"><![CDATA[<h1 id="点对点协议ppp">3.5 点对点协议（PPP）</h1><h2 id="ppp">1. PPP</h2><ol type="1"><li>点对点协议PPP(Point-to-PointProtocol)是目前使用最广泛的点对点数据链路层协议。</li><li>PPP协议是因特网工程任务组IETF在1992年制定的。经过1993年和1994年的修订，现在的PPP协议已成为因特网的正式标准[RFC1661,RFC1662]。</li><li>PPP协议为在点对点链路传输各种协议数据报提供了一个标准方法，主要由以下三部分构成：<ol type="1"><li>对各种协议数据报的封装方法（封装成帧）</li><li>链路控制协议LCP<ol type="1"><li>用于建立、配置以及测试数据链路的连接</li></ol></li><li>一套网络控制协议NCPs<ol type="1"><li>其中的每一个协议支持不同的网络层协议</li></ol></li></ol></li></ol><figure><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-5-%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/image-20241117132354632.png" alt="image-20241117132354632"><figcaption aria-hidden="true">image-20241117132354632</figcaption></figure><h2 id="帧格式">2. 帧格式</h2><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-5-%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/image-20241117132538280.png"></p><h2 id="透明传输">3. 透明传输</h2><h3 id="面向字节的异步链路采用插入转义字符的字节填充法">3.1面向字节的异步链路采用插入转义字符的字节填充法</h3><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-5-%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/image-20241117132827308.png"></p><h3 id="面向比特的同步链路采用插入比特0的比特填充法">3.2面向比特的同步链路采用插入比特0的比特填充法</h3><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-5-%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/image-20241117132942711.png"></p><h2 id="差错检测">4. 差错检测</h2><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-5-%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/image-20241117133033065.png"></p><h2 id="工作状态">5. 工作状态</h2><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-5-%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/image-20241117133237492.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.4 可靠传输</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-4-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-4-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/</url>
    
    <content type="html"><![CDATA[<h1 id="可靠传输">3.4 可靠传输</h1><h2 id="可靠传输的基本概念">1. 可靠传输的基本概念</h2><ol type="1"><li>使用差错检测技术（例如循环冗余校验CRC)，接收方的数据链路层就可检测出帧在传输过程中是否产生了误码（比特错误）。</li></ol><h3 id="数据链路层向上层提供的服务类型">1.1数据链路层向上层提供的服务类型</h3><ol type="1"><li>不可靠传输服务：<ul><li>仅仅丢弃有误码的帧，其他什么也不做</li></ul></li><li>可靠传输服务：<ul><li>想办法实现发送端发送什么，接收端就收到什么。</li></ul></li><li>一般情况下，有线链路的误码率比较低，为了减小开销，并不要求数据链路层向上提供可靠传输服务。即使出现了误码，可靠传输的问题由其上层处理。</li><li>无线链路易受干扰，误码率比较高，因此要求数据链路层必须向上层提供可靠传输服务。</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-4-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/image-20241117101000494.png"></p><h3 id="传输差错">1.2 传输差错</h3><ul><li>比特差错只是传输差错中的一种。</li><li>从整个计算机网络体系结构来看，传输差错还包括分组丢失、分组失序以及分组重复。</li><li>分组丢失、分组失序以及分组重复这些传输差错，一般不会出现在数据链路层，而会出现在其上层。</li><li>可靠传输服务并不仅局限于数据链路层，其他各层均可选择实现可靠传输。</li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-4-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/image-20241117101226369.png"></p><h2 id="可靠传输的实现机制">2. 可靠传输的实现机制</h2><h3 id="停止-等待协议sw">2.1 停止-等待协议（SW）</h3><ul><li>属于自动请求重传协议（ARQ）</li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-4-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/image-20230714151117181.png"></p><ol type="1"><li><p>接收端检测到数据分组有误码时，将其丢弃并等待发送方的超时重传。但对于误码率较高的点对点链路，为使发送方尽早重传，也可给发送方发送NAK分组。</p></li><li><p>为了让接收方能够判断所收到的数据分组是否是重复的，需要给数据分组编号。由于停止-等待协议的停等特性，只需1个比特编号就够了，即编号0和1</p></li><li><p>为了让发送方能够判断所收到的ACK分组是否是重复的，需要给ACK分组编号，所用比特数量与数据分组编号所用比特数量一样。数据链路层一般不会出现ACK分组迟到的情况，因此在数据链路层实现停止-等待协议可以不用给ACK分组编号。</p></li><li><p>超时计时器设置的重传时间应仔细选择。一般可将重传时间选为略大于“从发送方到接收方的平均往返时间”</p><ol type="1"><li>在数据链路层点对点的往返时间比较确定，重传时间比较好设定。</li><li>然而在运输层，由于端到端往返时间非常不确定，设置合适的重传时间有时并不容易。</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-4-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/image-20241117102422301.png"></p></li><li><p>当往返时延RTT远大于数据帧发送时延TD时（例如使用卫星链路），信道利用率非常低。若出现重传，则对于传送有用的数据信息来说，信道利用率还要降低。</p></li><li><p>为了克服停止-等待协议信道利用率很低的缺点，就产生了另外两种协议，即后退N帧协议GBN和选择重传协议SR。</p></li></ol><h3 id="回退n帧协议gbn">2.2 回退N帧协议（GBN）</h3><ul><li>是一种滑动窗口协议</li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-4-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/image-20230714153916944.png"></p><ol type="1"><li>可退N帧协议在流水线传输的基础上利用发送窗回来限制发送方连续发送数据分组的数量，是一种连续ARQ协议。</li><li>在协议的工作过程中发送窗口和接收窗口不断向前滑动，因此这类协议又称为滑动窗回协议。</li><li>由于回退N帧协议的特性，当通信线路质量不好时。其信道利用率并不比停止等待协议高，</li></ol><h3 id="选择重传协议sr">2.3 选择重传协议SR</h3><ol type="1"><li>回退N帧协议的接收窗口尺寸W只能等于1，因此接收方只能按序接收正确到达的数据分组。</li><li>一个数据分组的误码就会导致其后续多个数据分组不能被接收方按序接收而丢弃（尽管它们无乱序和误码)。这必然会造成发送方对这些数据分组的超时重传，显然这是对通信资源的极大浪费。</li><li>为了进一步提高性能，可设法只重传出现误码的数据分组。因此，接收窗口的尺寸W不应再等于1（而应大于1），以便接收方先收下失序到达但无误码并且序号落在接收窗口内的那些数据分组，等到所缺分组收齐后再一并送交上层。这就是选择重传协议。</li></ol><ul><li>注意：<ul><li>选择重传协议为了使发送方仅重传出现差错的分组，接收方不能再采用累积确认，而需要对每个正确接收到的数据分组进行逐一确认！</li></ul></li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-4-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/image-20230714174218114.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.3 差错检测</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-3-%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-3-%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="差错检测">3.3 差错检测</h1><ul><li>实际的通信链路都不是理想的，比特在传输过程中可能会产生差错；1可能会变成0，而0也可能变成1。这称为比特差错。</li></ul><h2 id="误码率">1. 误码率</h2><ul><li><p>在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率BER(BitError Rate)。</p></li><li><p>使用<strong>差错检测码</strong>来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一。</p></li></ul><h2 id="奇偶校验">2. 奇偶校验</h2><ul><li>在待发送的数据后面添加1位奇偶校验位，使整个数据（包括所添加的校验位在内）中”1”的个数为奇数（奇校验）或偶数（偶校验）。</li></ul><ol type="1"><li>如果有奇数个位发生误码，则奇偶性发生变化，可以检查出误码；</li><li>如果有偶数个位发生误码，则奇偶性不发生变化，不能检查出误码</li></ol><ul><li>缺陷：漏检率较高</li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-3-%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B/image-20241117100050296.png"></p><h2 id="循环冗余校验crccyclic-redundancy-check">3.循环冗余校验CRC(Cyclic Redundancy Check)</h2><ol type="1"><li>收发双方约定好一个生成多项式G(x)</li><li>发送方基于待发送的数据和生成多项式计算出差错检测码（冗余码），将其添加到待传输数据的后面一起传输</li><li>接收方通过生成多项式来计算收到的数据是否产生了误码</li></ol><figure><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-3-%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B/image-20241117100258487.png" alt="CRC"><figcaption aria-hidden="true">CRC</figcaption></figure><figure><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-3-%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B/image-20241117100334787.png" alt="生成多项式"><figcaption aria-hidden="true">生成多项式</figcaption></figure><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-3-%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B/image-20241117100543010.png"></p><ul><li><strong>做除法的意思是，做异或运算</strong></li></ul><ol type="1"><li>检错码只能检测出帧在传输过程中出现了差错，但并不能定位错误，因此无法纠正错误。</li><li>要想纠正传输中的差错，可以使用冗余信息更多的纠错码进行前向纠错。但纠错码的开销比较大，在计算机网络中较少使用。</li><li>循环冗余校验CRC有很好的检错能力（漏检率非常低），虽然计算比较复杂，但非常易于用硬件实现，因此被广泛应用于数据链路层。</li><li>在计算机网络中通常采用我们后续课程中将要讨论的检错重传方式来纠正传输中的差错，或者仅仅是丢弃检测到差错的帧，这取决于数据链路层向其上层提供的是可靠传输服务还是不可靠传输服务。</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.2 封装成帧</title>
    <link href="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-2-%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7/"/>
    <url>/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-2-%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="封装成帧">3.2 封装成帧</h1><h2 id="帧">1. 帧</h2><ul><li><p>封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧。</p></li><li><p>帧头和帧尾的作用之一就是帧定界.</p></li></ul><figure><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-2-%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7/image-20241117092740511.png" alt="帧"><figcaption aria-hidden="true">帧</figcaption></figure><h2 id="透明传输">2. 透明传输</h2><ul><li>数据链路层对上层交付的传输数据没有任何限制，就好像数据链路层不存在一样。</li></ul><ol type="1"><li>面向字节的物理链路使用字节填充（或称字符填充）的方法实现透明传输</li><li>面向比特的物理链路使用比特填充的方法实现透明传输。</li><li>为了提高帧的传输效率，应当使帧的数据部分的长度尽可能大些。</li></ol><figure><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-2-%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7/image-20241117093119688.png" alt="透明传输"><figcaption aria-hidden="true">透明传输</figcaption></figure><ul><li>考虑到差错控制等多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即最大传送单元MTU(Maximum Transfer Unit)</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.1 数据链路层概述</title>
    <link href="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-1-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-1-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="数据链路层概述">3.1 数据链路层概述</h1><ul><li>数据链路层以帧为单位传输和处理数据。</li></ul><ol type="1"><li>链路 (Link)</li></ol><ul><li>就是从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换结点。</li></ul><ol start="2" type="1"><li>数据链路(Data Link)</li></ol><ul><li>是指把实现通信协议的硬件和软件加到链路上，就构成了数据链路。</li></ul><h2 id="使用点对点信道的数据链路层三个重要问题">1.使用点对点信道的数据链路层三个重要问题</h2><ol type="1"><li>封装成帧</li><li>差错检测</li><li>可靠传输<ol type="1"><li>尽管误码是不能完全避免的，但若能实现发送方发送什么接收方就能收到什么，就称为可靠传输。</li></ol></li></ol><h2 id="使用广播信道的数据链路层">2. 使用广播信道的数据链路层</h2><ol type="1"><li>共享式以太网的媒体接入控制协议CSMA/CD</li><li>802.11局域网的媒体接入控制协议CSMA/CA</li></ol><h2 id="数据链路层的互连设备">3. 数据链路层的互连设备</h2><ol type="1"><li>网桥和交换机的工作原理</li><li>集线器(物理连接设备)与交换机的区别</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.5 信道的极限容量</title>
    <link href="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-5-%E4%BF%A1%E9%81%93%E7%9A%84%E6%9E%81%E9%99%90%E5%AE%B9%E9%87%8F/"/>
    <url>/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-5-%E4%BF%A1%E9%81%93%E7%9A%84%E6%9E%81%E9%99%90%E5%AE%B9%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="信道极限容量">2.5 信道极限容量</h1><ul><li>在信道带宽一定的情况下，根据奈氏准则和香农公式，要想提高信息的传输速率就必须采用多元制（更好的调制方法）和努力提高信道中的信噪比。</li></ul><h2 id="奈式准则">1. 奈式准则</h2><ul><li>理想低通信道的最高码元传输速率=2W Baud=2W(单位：码元/秒)</li><li>理想带通信道的最高码元传输速率=W Baud=W(单位：码元/秒)</li></ul><h2 id="香农公式-单位bits">2. 香农公式 单位:bit/s</h2><p><span class="math display">\[c = W \times log_2(1 + \frac{S}{N})\\\]</span></p><p><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-5-%E4%BF%A1%E9%81%93%E7%9A%84%E6%9E%81%E9%99%90%E5%AE%B9%E9%87%8F/image-20241116162248949.png"></p><p><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-5-%E4%BF%A1%E9%81%93%E7%9A%84%E6%9E%81%E9%99%90%E5%AE%B9%E9%87%8F/image-20241116162436085.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.4 编码与调制</title>
    <link href="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-4-%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6/"/>
    <url>/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-4-%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="编码与调制">2.4 编码与调制</h1><p><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-4-%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6/image-20241116160902949.png"></p><h2 id="常用编码">1. 常用编码</h2><ul><li>码元：在使用时间域的波形表示数字信号时代表不同离散数值的基本波形。</li></ul><ol type="1"><li>不归零编码（存在同步问题）<ul><li>需要额外一根传输线来传输时钟信号使发送方和接收方同步</li></ul></li><li>归零编码（自同步，编码效率低）</li><li>曼彻斯特编码（传统以太网）</li></ol><p><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-4-%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6/image-20241116161158338.png"></p><h2 id="编码与调制-1">2. 编码与调制</h2><h3 id="基本调制方法">2.1 基本调制方法</h3><p><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-4-%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6/image-20241116161357102.png"></p><ol type="1"><li>调幅、调频、调相</li><li>混合调制</li></ol><p><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-4-%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6/image-20241116161941515.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.3 传输方式</title>
    <link href="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-3-%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F/"/>
    <url>/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-3-%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="传输方式">2.3 传输方式</h1><h2 id="串并行">1. 串并行</h2><ol type="1"><li><p>串行传输</p></li><li><p>并行传输</p></li></ol><h2 id="同步异步">2. 同步异步</h2><ol type="1"><li><p>同步传输</p></li><li><p>异步传输</p></li><li><p>收发双方时钟同步的方法</p></li></ol><ul><li>外同步：在收发双方之间添加一条单独的时钟信号线</li><li>内同步：发送端将时钟同步信号编码到发送数据中一起传输(例如曼彻斯特编码)</li></ul><figure><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-3-%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F/image-20241116160018725.png" alt="image-20241116160018725"><figcaption aria-hidden="true">image-20241116160018725</figcaption></figure><h2 id="单双工">3. 单双工</h2><ul><li>单向通信（单工）广播</li><li>双向交替通信（半双工） 对讲机</li><li>双向同时通信（全双工）电话</li></ul><figure><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-3-%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F/image-20241116160356202.png" alt="image-20241116160356202"><figcaption aria-hidden="true">image-20241116160356202</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.2 物理层下面的传输媒体</title>
    <link href="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-2-%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93/"/>
    <url>/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-2-%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<h1 id="物理层下面的传输媒体">2.2 物理层下面的传输媒体</h1><h2 id="传输媒体">1. 传输媒体</h2><h3 id="导引型传输媒体">1.1 导引型传输媒体</h3><ol type="1"><li><p>双绞线</p><ol type="1"><li>绞合的作用<ul><li>抵御部分来自外界的电磁波干扰</li><li>减少相邻导线的电磁干扰</li></ul></li><li><figure><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-2-%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93/image-20241116144027376.png" alt="image-20241116144027376"><figcaption aria-hidden="true">image-20241116144027376</figcaption></figure></li></ol></li><li><p>同轴电缆</p><ul><li>基带同轴电缆(50Ω) 数字传输，过去用于局域网</li></ul></li></ol><ul><li>宽带同轴电缆(75Ω)，模拟传输，目前主要用于有线电视<ul><li>同轴电缆价格较贵且布线不够灵活和方便，随着集线器的出现，在局域网领域基本上都是采用双绞线作为传输媒体。</li></ul></li></ul><ol start="3" type="1"><li><p>光纤</p><ol type="1"><li><figure><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-2-%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93/image-20241116144053439.png" alt="image-20241116144053439"><figcaption aria-hidden="true">image-20241116144053439</figcaption></figure></li><li>纤芯直径<ul><li>多模光纤：50微米，62.5微米</li><li>单模光纤：9微米，包层直径125微米</li></ul></li><li>工作波长<ul><li>0.85微米（衰减较大）</li><li>1.30微米（衰减较小）</li><li>1.55微米（衰减较小）</li></ul></li><li>光纤的优点<ul><li>通信容量大 (25000~30000GHz的带宽)</li><li>传输损耗小，远距离传输时更加经济。</li><li>抗雷电和电磁干扰性能好。这在大电流脉冲干扰的环境下尤为重要</li><li>无串音干扰，保密性好，不易被窃听。</li><li>体积小，重量轻。</li></ul></li><li>光纤的缺点<ul><li>割接需要专用设备</li><li>光电接口价格较贵</li></ul></li><li><figure><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-2-%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93/image-20241116144351388.png" alt="image-20241116144351388"><figcaption aria-hidden="true">image-20241116144351388</figcaption></figure></li><li><figure><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-2-%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93/image-20241116144534158.png" alt="image-20241116144534158"><figcaption aria-hidden="true">image-20241116144534158</figcaption></figure></li></ol></li><li><p>电力线</p></li></ol><h3 id="非导引型传输媒体">1.2 非导引型传输媒体</h3><ol type="1"><li>微波通信（2~40GHz）</li><li>红外线</li><li>可见光</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.1 物理层的基本概念</title>
    <link href="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-1-%E7%89%A9%E7%90%86%E5%B1%82%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-1-%E7%89%A9%E7%90%86%E5%B1%82%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="物理层的基本概念">2.1 物理层的基本概念</h1><h2 id="传输媒体">1. 传输媒体</h2><ol type="1"><li>导引型传输媒体<ul><li>双绞线</li><li>同轴电缆</li><li>光纤</li><li>电力线</li></ul></li><li>非导引型传输媒体<ul><li>微波通信（2~40GHz）</li><li>红外线</li><li>可见光</li></ul></li></ol><h2 id="主要任务">2. 主要任务</h2><blockquote><ol type="1"><li>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流。</li><li>物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体是什么。</li></ol></blockquote><ol type="1"><li><p>机械特性</p><blockquote><p>指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置</p></blockquote></li><li><p>电气特性</p><blockquote><p>指明在接口电缆的各条 线上出现的电压的范围。</p></blockquote></li><li><p>功能特性</p><blockquote><p>指明某条线上出现的某一电平的电压表示何种意义。</p></blockquote></li><li><p>过程特性</p><blockquote><p>指明对于不同功能的各种可能事件的出现顺序。</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.6 计算机体系结构</title>
    <link href="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <url>/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络体系结构">1.6 计算机网络体系结构</h1><h2 id="常见的计算机网络体系结构">1. 常见的计算机网络体系结构</h2><ol type="1"><li><p>OSI体系结构（开放系统互连参考模型）</p></li><li><p>TCP/IP体系结构</p></li></ol><p><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20241115214722039.png"></p><p><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20241115214533994.png"></p><ul><li>IP协议可以为各种网络应用提供服务 (Everything over IP)</li><li>使用IP协议互连不同的网络接口 (IP over everything)</li></ul><h2 id="计算机网络体系结构分层的必要性">2.计算机网络体系结构分层的必要性</h2><p>总线型网络</p><ul><li>如何标识网络中的各主机（主机编址问题，例如MAC地址）</li><li>如何从信号所表示的一连串比特流中区分出地址和数据</li><li>如何协调各主机争用总线</li></ul><blockquote><p>"分层“可将庞大而复杂的问题，转化为若干较小的局部问题，而这些较小的局部问题就比较易于研究和处理。</p></blockquote><table><thead><tr><th style="text-align: center;">体系结构</th><th style="text-align: center;">解决问题</th></tr></thead><tbody><tr><td style="text-align: center;">应用层</td><td style="text-align: center;">解决通过应用进程的交互来实现特定网络应用的问题</td></tr><tr><td style="text-align: center;">表示层</td><td style="text-align: center;">解决通信双方交换信息的表示问题</td></tr><tr><td style="text-align: center;">会话层</td><td style="text-align: center;">解决进程之间进行会话问题</td></tr><tr><td style="text-align: center;">运输层</td><td style="text-align: center;">解决进程之间基于网络的通信问题</td></tr><tr><td style="text-align: center;">网络层</td><td style="text-align: center;">解决分组在多个网络上传输（路由）问题</td></tr><tr><td style="text-align: center;">数据链路层</td><td style="text-align: center;">解决分组在一个网络（或一段链路）上传输的问题</td></tr><tr><td style="text-align: center;">物理层</td><td style="text-align: center;">解决使用何种信号来传输比特的问题</td></tr></tbody></table><ul><li>表示层的任务是实现与数据表示相关的功能，主要包括数据字符集的转换、数据格式化、文本压缩、数据加密以及解密等工作。</li></ul><h2 id="计算机网络体系结构中的专用术语">3.计算机网络体系结构中的专用术语</h2><table><thead><tr><th style="text-align: center;">术语</th><th style="text-align: left;">解释</th></tr></thead><tbody><tr><td style="text-align: center;">实体</td><td style="text-align: left;">任何可发送或接收信息的硬件或软件进程</td></tr><tr><td style="text-align: center;">对等实体</td><td style="text-align: left;">收发双方相同层次中的实体</td></tr><tr><td style="text-align: center;">协议</td><td style="text-align: left;">控制两个对等实体进行逻辑通信的规则的集合</td></tr><tr><td style="text-align: center;">协议三要素</td><td style="text-align: left;">语法，语义，同步</td></tr><tr><td style="text-align: center;">语法</td><td style="text-align: left;">定义所交换信息的格式</td></tr><tr><td style="text-align: center;">语义</td><td style="text-align: left;">定义收发双方所要完成的操作</td></tr><tr><td style="text-align: center;">同步</td><td style="text-align: left;">定义收发双方的时序关系<br><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20241115225450275.png" alt="image-20241115225450275"></td></tr><tr><td style="text-align: center;">服务</td><td style="text-align: left;">在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务<br><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20241115225634091.png" alt="image-20241115225634091"></td></tr><tr><td style="text-align: center;">服务访问点</td><td style="text-align: left;">在同一系统中相邻两层的实体交换信息的逻辑接口，用于区分不同的服务类型<br>1.数据链路层的服务访问点为帧的“类型”字段。<br>2.网络层的服务访问点为IP数据报首部中的“协议字段”。<br>3.运输层的服务访问点为“端口号”</td></tr><tr><td style="text-align: center;">服务原语</td><td style="text-align: left;">上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令称为服务原语</td></tr><tr><td style="text-align: center;">协议数据单元PDU</td><td style="text-align: left;">对等层次之间传送的数据包称为该层的协议数据单元</td></tr><tr><td style="text-align: center;">服务数据单元SDU</td><td style="text-align: left;">同一系统内，层与层之间交换的数据包称为服务数据单元<br>多个SDU可以合成为一个PDU；一个SDU也可划分为几个PDU</td></tr></tbody></table><figure><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20241115225112571.png" alt="实体"><figcaption aria-hidden="true">实体</figcaption></figure><figure><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20241115225152230.png" alt="协议"><figcaption aria-hidden="true">协议</figcaption></figure><ol type="1"><li>协议是“水平的”，服务是“垂直的</li><li>实体看得见相邻下层所提供的服务，但并不知道实现该服务的具体协议。也就是说，下面的协议对上面的实体是"透明"的。</li></ol><figure><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20241115225809482.png" alt="SDU PDU"><figcaption aria-hidden="true">SDU PDU</figcaption></figure><h2 id="练习题">练习题：</h2><ol type="1"><li>在OSI参考模型中，自下而上第一个提供端到端服务的层次是：（B）A.数据链路层 B.传输层 C.会话层 D.应用层<ul><li><figure><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20241115230545942.png" alt="image-20241115230545942"><figcaption aria-hidden="true">image-20241115230545942</figcaption></figure></li></ul></li><li>下列选项中，不属于网络体系结构所描述的内容是 C A.网络的层次B.每一层使用的协议 C.协议的内部实现细节 D.每一层必须完成的功能</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.5 计算机网络的性能指标</title>
    <link href="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-5-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/"/>
    <url>/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-5-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络的性能指标">1.5 计算机网络的性能指标</h1><table><thead><tr><th style="text-align: center;">指标</th><th style="text-align: left;">评测</th></tr></thead><tbody><tr><td style="text-align: center;">速率</td><td style="text-align: left;">连接在计算机网络上的主机在数字信道上传送比特的速率，也称为比特率或数据率<br>bit/s（b/s，bps)，kb/s，Mb/s，Gb/s</td></tr><tr><td style="text-align: center;">带宽</td><td style="text-align: left;">用来表示网络的通信线路所能传送数据的能力，单位为Hz<br>因此网络带宽表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据量”<br>与速率指标相同</td></tr><tr><td style="text-align: center;">吞吐量</td><td style="text-align: left;">吞吐量表示在单位时间内通过某个网络（或信道、接口）的数据量。<br>吞吐量被经常用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。<br>吞吐量受网络的带宽或额定速率的限制。</td></tr><tr><td style="text-align: center;">时延</td><td style="text-align: left;">网络时延由三部分组成，分别为发送时延，传播时延，处理时延<br>网卡的发送速率，信道带宽，交换机的接口速率共同决定了发送时延<br><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-5-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/image-20241115211453147.png"></td></tr><tr><td style="text-align: center;">时延带宽积</td><td style="text-align: left;">1.若发送端连续发送数据，则在所发送的第一个比特即将到达终点时，<br>发送端就已经发送了时延带宽积个比特。<br>2.链路的时延带宽积又称为以比特为单位的链路长度。</td></tr><tr><td style="text-align: center;">往返时间（RTT）</td><td style="text-align: left;">双向交互一次所需的时间<br>从源主机发送分组开始，直到源主机收到来自目的主机的确认分组为止</td></tr><tr><td style="text-align: center;">利用率</td><td style="text-align: left;">分为信道利用率，网络利用率<br>信道利用率：表示某信道有百分之几的时间是被利用的<br>网络利用率：全网络的信道利用率加权平均<br>信道利用率并非越高越好，高利用率会引发高时延</td></tr><tr><td style="text-align: center;">丢包率</td><td style="text-align: left;">丢包率即分组丢失率，是指在一定的时间范围内，传输过程中丢失的分组数量与总分组数量的比率。<br>丢包率具体可分为接口丢包率、结点丢包率、链路丢包率、路径丢包率、网络丢包率等<br></td></tr></tbody></table><ol type="1"><li><p>补充</p><ol type="1"><li>时延计算公式</li></ol></li></ol><p><span class="math display">\[发送时延 = \frac{分组长度}{发送速率}\\\\\]</span></p><p><span class="math display">\[发送时延 = \frac{信道长度}{电磁波传播速率}\]</span></p><ol start="2" type="1"><li>时延带宽积</li></ol><p><span class="math display">\[时延带宽积 = 传播时延 \times 带宽\]</span></p><ul><li>处理时延一般不计算</li></ul><ol start="3" type="1"><li><p>网络当前时延与信道利用率之间的关系 <span class="math display">\[D为网络当前时延，D_0为网络空闲时的时延，U为信道利用率\\\]</span></p></li><li><p>丢包率计算公式 <span class="math display">\[丢包率 = \frac{一定时间范围内丢失的分组数量}{总分组数量}\]</span></p><p><span class="math display">\[D = \frac{D_0}{1-U}\]</span></p></li><li><p>分组丢失的两种情况</p><ol type="1"><li>分组在传输过程中出现误码，被结点丢弃</li><li>分组到达一台队列已满的分组交换机时被丢弃，在通信量较大时就可能造成网络拥塞。</li></ol></li><li><p>丢包率反映了网络的拥塞情况</p><ol type="1"><li>无拥塞时路径丢包率为0</li><li>轻度拥塞时路径丢包率为1%~4%</li><li>严重拥塞时路径丢包率为5%~15%</li></ol></li><li><p>n个分组，m段链路，忽略处理时延，总时延的计算（假设分组等长，各链路长度相同，带宽相同）<span class="math display">\[总时延 = n个分组的发送时延 + 1个分组的发送时延 \times (m-1) +1段链路的传播时延 \times m\]</span></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.4 计算机网络的定义和分类</title>
    <link href="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%86%E7%B1%BB/"/>
    <url>/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络的定义和分类">1.4 计算机网络的定义和分类</h1><h2 id="定义">1. 定义</h2><ol type="1"><li><p>简单定义：一些<strong>互相连接</strong>的，<strong>自治</strong>的计算机的<strong>集合</strong></p><blockquote><p>互连：是指计算机之间可以通过有线或无线的方式进行数据通信；自治：是指独立的计算机，它有自己的硬件和软件，可以单独运行使用；集合：是指至少需要两台计算机。</p></blockquote></li><li><p>计算机网络的较好的定义</p><blockquote><p>计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号)。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</p></blockquote><ol type="1"><li>计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机等智能硬件</li><li>计算机网络并非专门用来传送数据，而是能够支持很多种的应用（包括今后可能出现的名种应用)</li></ol></li></ol><h2 id="分类">2. 分类</h2><h3 id="按交换技术分类">2.1 按交换技术分类</h3><ol type="1"><li>电路交换网路</li><li>报文交换网络</li><li>分组交换网络</li></ol><h3 id="按使用者分类">2.2 按使用者分类</h3><ol type="1"><li><p>公用网</p><blockquote><p>电信公司出资建造,给电信公司缴纳费用即可使用</p></blockquote></li><li><p>专用网</p><blockquote><p>不向外人提供服务</p></blockquote></li></ol><h3 id="按传输介质分类">2.3 按传输介质分类</h3><ol type="1"><li><p>有线网路</p><blockquote><p>包括双绞线网络,光纤网络等</p></blockquote></li><li><p>无线网络</p><blockquote><p>WIFI应用普遍</p></blockquote></li></ol><h3 id="按覆盖范围分类">2.4 按覆盖范围分类</h3><ol type="1"><li><p>广域网(WAN)</p><blockquote><p>可以覆盖一个国家,地区甚至几个洲</p><p>WAN是因特网的核心部分,为核心路由器提供远距离高速连接</p></blockquote></li><li><p>城域网(MAN)</p><blockquote><p>覆盖一个街区,或几个城市</p><p>通常作为城市骨干网,互连学校,企业,机构的局域网</p></blockquote></li><li><p>局域网(LAN)</p><blockquote><p>覆盖一个实验室,一幢楼,一个校园等</p></blockquote></li><li><p>个域网(PAN)</p><blockquote><p>即无线个人区域网(WPAN),在各人工作的地方,将属于个人使用的电子设备用无线技术连接起来的网络</p></blockquote></li></ol><h3 id="按拓扑结构分类">2.5 按拓扑结构分类</h3><ol type="1"><li>总线型网络</li></ol><p><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%86%E7%B1%BB/image-20230712140101315.png"></p><ol start="2" type="1"><li>星型网络</li></ol><p><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%86%E7%B1%BB/image-20230712140145867.png"></p><ol start="3" type="1"><li>环型网络</li></ol><p><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%86%E7%B1%BB/image-20230712140251758.png"></p><ol start="4" type="1"><li>网状型网络</li></ol><p><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%86%E7%B1%BB/image-20230712140454142.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.3 三种交换方式</title>
    <link href="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-3-%E4%B8%89%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F/"/>
    <url>/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-3-%E4%B8%89%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="三种交换方式">1.3 三种交换方式</h1><h2 id="电路交换circuit-switching">1. 电路交换(Circuit Switching)</h2><ul><li>电话交换机接通电话线的方式称为电路交换，中间设备是电话交换机</li><li>从通信资源的分配角度来看，交换(Switching)就是按照某种方式动态地分配传输线路的资源；</li><li>当使用电路交换来传送计算机数据时，其线路的传输效率往往很低。</li><li>不适合计算机传输数据，因为占用通信资源，却迟迟不使用，造成通信资源的浪费</li></ul><figure><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-3-%E4%B8%89%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F/image-20241115203653573.png" alt="电话交换机"><figcaption aria-hidden="true">电话交换机</figcaption></figure><ol type="1"><li>电话交换的三个步骤<ol type="1"><li>建立连接（分配通信资源）</li><li>通话（一直占用通信资源）</li><li>释放连接（归还通信资源）</li></ol></li><li>优点<ol type="1"><li>通信时延小</li><li>有序传输</li><li>没有冲突</li><li>适用范围广</li><li>实时性强</li><li>控制简单</li></ol></li><li>缺点<ol type="1"><li>建立连接时间长</li><li>线路独占，使用效率低</li><li>灵活性差</li><li>难以规格化</li></ol></li></ol><h2 id="分组交换packet-switching">2. 分组交换(Packet Switching)※</h2><p><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-3-%E4%B8%89%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F/image-20241115204514266.png"></p><blockquote><p>通常把表示消息的整块数据称为一个报文</p></blockquote><ol type="1"><li><p>步骤</p><ol type="1"><li><p>发送方：构造分组，发送分组</p></li><li><p>路由器：缓存分组，转发分组</p></li><li><p>接收方：接收分组，还原报文</p></li></ol></li><li><p>优点</p><ol type="1"><li>无需建立连接</li><li>线路利用率高</li><li>简化了存储管理</li><li>加速传输</li><li>减少出错概率和重发数据量</li></ol></li><li><p>缺点</p><ol type="1"><li><p>引起了转发时延</p></li><li><p>需要传输额外的信息量</p></li><li><p>对于数据报服务，存在失序、丢失或重复分组的问题;</p><p>对于虚电路服务存在呼叫建立、数据传输和虚电路释放三个过程</p></li></ol></li></ol><h2 id="报文交换message-switching">3. 报文交换(Message Switching)</h2><blockquote><p>与分组交换类似，但对报文大小没有限制，也不分组，现代已很少使用该方法</p></blockquote><ol type="1"><li>优点<ol type="1"><li>无需建立连接</li><li>动态分配线路</li><li>提高线路可靠性</li><li>提高线路利用率</li><li>提供多目标服务</li></ol></li><li>缺点<ol type="1"><li>引起了转发时延</li><li>需要较大存储缓存空间</li><li>需要传输额外的信息量</li></ol></li></ol><p><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-3-%E4%B8%89%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F/image-20241115204815895.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HCTA：多智能体强化学习中的分层合作任务分配</title>
    <link href="/2024/11/15/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/HCTA%EF%BC%9A%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%88%86%E5%B1%82%E5%90%88%E4%BD%9C%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/"/>
    <url>/2024/11/15/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/HCTA%EF%BC%9A%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%88%86%E5%B1%82%E5%90%88%E4%BD%9C%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="hctahierarchical-cooperative-task-allocation-in-multi-agent-reinforcement-learning">HCTA:HierarchicalCooperative Task Allocation in Multi-Agent Reinforcement Learning</h1><h2 id="主要内容">1. 主要内容</h2><ol type="1"><li><strong>子任务选择</strong>：</li></ol><ul><li>基于行动链的长期行为特征动态选择每个智能体适合的子任务。</li></ul><ol start="2" type="1"><li><strong>层次化策略学习</strong>：</li></ol><ul><li>结合上述子任务分解和选择，形成层次化合作策略学习框架。在上层动态选择子任务，并在下层根据上层的任务分配结果指导具体决策策略的学习。</li></ul><ol start="3" type="1"><li><strong>双时序分辨率框架</strong>：</li></ol><ul><li>HCTA使用双时序分辨率框架，在低时序分辨率的时标上进行任务选择，然后在高时序分辨率的时标上进行策略学习。</li></ul><ol start="4" type="1"><li><strong>实验验证</strong>：</li></ol><ul><li>在StarCraftII环境中进行广泛的实验，以评估HCTA框架在不同难度级别上的表现，并与其他基线算法进行比较。</li></ul><p>这些方法共同构成了文章提出的HCTA框架，旨在通过层次化和动态的任务分配来提高多智能体系统在复杂任务中的合作效率和学习效果。</p><ul><li>在本文中，我们的目标是使<strong>个体的子组能够通过人类在处理复杂任务时使用的分解思想来学习解决不同的子任务。</strong></li></ul><h2 id="子任务分解">2. 子任务分解</h2><p>在文章中提到的HCTA（Hierarchical Cooperative TaskAllocation）框架中，子任务的分解是通过以下步骤实现的：</p><ol type="1"><li><strong>行动表示学习（Action RepresentationLearning）</strong>：</li></ol><ul><li>首先，框架通过行动表示学习来实现子任务的分解。这是通过创建一个能够反映行动对环境和其他智能体影响的表示（即<code>za = fθ(a; θe)</code>）来完成的，其中<code>za</code>是行动的表示，<code>a</code>是行动本身，<code>θ</code>是学习到的参数。</li></ul><ol start="2" type="1"><li><strong>行动空间聚类（Action Space Clustering）</strong>：</li></ol><ul><li>基于行动表示的结果，整个行动空间被聚类分解为多个子行动空间，每个子行动空间对应一个子任务。这样的分解减少了每个子任务的行动空间维度，使得相应的智能体在具有相似效果的行动空间中搜索。</li></ul><ol start="3" type="1"><li><strong>行动链模型（Action Chain Model）</strong>：</li></ol><ul><li>使用行动链模型来学习行动编码器。每个智能体选择多个时间步的行动表示作为行动链编码器的输入。通过自注意力机制，智能体学习与自身属性相关的多步行动的累积效应。</li></ul><ol start="4" type="1"><li><strong>子任务定义（Subtask Definition）</strong>：</li></ol><ul><li>文章中对子任务的定义是：对于一个给定的合作多智能体任务<code>G</code>，一个角色<code>ρi</code>是一个包含子任务<code>ϕi</code>的元组，<code>ϕi</code>由<code>⟨Ai, Ii, S, P, R, Ωi, O, γ⟩</code>组成，其中<code>Ai</code>是子任务的行动空间，<code>Ii</code>是智能体的子集，且满足<code>Ii ⊂ I</code>，<code>∪iIi = I</code>，<code>Ii ∩ Ij = ∅</code>（对于<code>i ≠ j</code>）。</li></ul><ol start="5" type="1"><li><strong>长期行为链（Long-term Behavior Chain）</strong>：</li></ol><ul><li>基于行动链的结果，生成反映智能体行为特征的长期行动链。这个长期行为链用于动态选择适合每个智能体的子任务。</li></ul><p>通过这些步骤，HCTA框架能够将复杂的多智能体任务分解为更小、更易于管理的子任务，每个子任务都涉及一个较小的行动观察空间，从而使智能体能够更有效地专注于特定的子任务。这种分解方法不仅提高了任务分配的效率，还降低了计算复杂度，并使得智能体能够更好地协作以完成复杂的任务。</p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
      <category>多智能体强化学习任务分配</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
      <tag>科研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向兵棋推演的强化学习分层任务优化技术研究</title>
    <link href="/2024/11/15/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E9%9D%A2%E5%90%91%E5%85%B5%E6%A3%8B%E6%8E%A8%E6%BC%94%E7%9A%84%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%88%86%E5%B1%82%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    <url>/2024/11/15/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E9%9D%A2%E5%90%91%E5%85%B5%E6%A3%8B%E6%8E%A8%E6%BC%94%E7%9A%84%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%88%86%E5%B1%82%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="主要内容">1. 主要内容</h2><p>论文深入探讨了分层控制结构的多智能体强化学习算法在兵棋推演环境中的应用，旨在优化复杂和不确定环境下的任务分配和多智能体任务的执行过程。主要研究内容包括：</p><ol type="1"><li>针对实时兵棋推演环境，设计了兵棋AI的状态空间和动作空间，并生成了敌我对抗态势的关键特征信息。通过离散化连续动作的操作优化了原始动作空间，简化了多智能体的交互过程，加快了网络学习速度。</li><li>提出了一种融合注意力机制的DQN算法（ADQN），通过嵌入网络和注意力对输入进行向量化处理后输入DQN网络，将环境分解为独立的子环境，并重新定义特定于子任务的动作-价值函数，有效提高了在复杂环境中进行任务分配的质量和效率。</li><li>基于深度强化学习的多级控制结构，提出了多智能体分层自主决策算法（ADQN-MAPPO），结合了多智能体近端策略优化算法与ADQN算法，通过将复杂任务划分成子任务进行分配后再执行，增强了智能体自主决策的能力，提高了算法模型的训练速度和决策能力。</li></ol><p>论文通过在山地3v3和水田3v3的兵棋推演环境中的实验，验证了ADQN-MAPPO算法在得分能力、胜率、步均推理时间以及模型的泛化能力等方面的优越性能。研究结果对进一步提升分层控制结构的多智能体强化学习算法在兵棋推演以及其他复杂应用环境中的性能和应用范围提供了参考意义。</p><h2 id="分层决策框架">2. 分层决策框架</h2><p>这篇论文中提出的分层决策框架是为了解决兵棋推演环境中的多智能体任务分配和执行问题。分层决策框架包括两个主要层次：任务分配层和智能体决策层。以下是这两个层次的详细介绍：</p><h3 id="任务分配层">2.1 任务分配层</h3><p>任务分配层的目的是将全局任务分解为多个子任务，并将这些子任务分配给不同的智能体。这一层主要关注如何在多智能体系统中高效地分配任务，以便每个智能体可以专注于自己的子任务，从而提高整体任务执行的效率和效果。</p><ul><li><strong>状态空间和动作空间设计</strong>：在这一层中，状态空间包括了整个环境的总体状态，如战场上的地形、敌我双方的兵力部署等。动作空间则由子任务的编号集合构成，意味着每个智能体的动作是选择一个子任务来执行。</li><li><strong>子任务设计</strong>：根据兵棋推演游戏的特性，将总体任务细分为行军、进攻、防御、支援、夺控等子任务。每个子任务由任务名称、编号、类型、关系、目标等元素组成。</li><li><strong>ADQN算法</strong>：提出了一种融合注意力机制的DQN算法（ADQN），用于处理任务分配问题。ADQN算法通过智能体对子任务的执行，将环境分解为独立的子环境，并重新定义特定于子任务的动作-价值函数。</li></ul><h3 id="智能体决策层">2.2 智能体决策层</h3><p>智能体决策层根据任务分配层分配的子任务，每个智能体需要做出具体的行动决策来完成任务。这一层主要关注智能体如何在局部环境中做出最优决策。</p><ul><li><strong>MAPPO算法</strong>：在这一层中，使用了多智能体近端策略优化算法（MAPPO），它是一种适用于多智能体环境的强化学习算法，可以处理分布式部分可观察马尔可夫决策过程（DEC-POMDP）。</li><li><strong>策略网络和评价网络</strong>：每个智能体都有自己的策略网络，根据局部观测信息产生动作。同时，有一个全局评价网络根据全局环境信息生成状态价值，用于指导策略网络的更新。</li><li><strong>分层架构的优势</strong>：通过分层架构，上层任务分配网络可以在更大的时间尺度上运行，而下层智能体策略网络则在更细的尺度上做出决策。这种分层方法有助于提高智能体在兵棋推演环境中的决策效率和效果。</li></ul><h3 id="adqn-mappo算法">2.3 ADQN-MAPPO算法</h3><p>ADQN-MAPPO算法是将ADQN算法和MAPPO算法结合的分层决策框架。这种框架通过将复杂任务分解为子任务，并在不同的抽象层次上学习策略，解决了大规模复杂环境下的决策问题。ADQN-MAPPO算法在实验中表现出了优越的性能，包括更高的得分能力、胜率以及更快的收敛速度。</p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
      <category>多智能体强化学习任务分配</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
      <tag>科研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于分层强化学习的多智能体博弈对抗策略</title>
    <link href="/2024/11/15/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E5%9F%BA%E4%BA%8E%E5%88%86%E5%B1%82%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%8D%9A%E5%BC%88%E5%AF%B9%E6%8A%97%E7%AD%96%E7%95%A5/"/>
    <url>/2024/11/15/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E5%9F%BA%E4%BA%8E%E5%88%86%E5%B1%82%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%8D%9A%E5%BC%88%E5%AF%B9%E6%8A%97%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="主要内容">1. 主要内容</h2><h3 id="研究内容">1.1 研究内容</h3><ul><li>提出了一种结合任务可解释性的指挥官-集群多智能体分层强化学习算法，提高算法在复杂博弈场景中的收敛速度。</li><li>设计了一种结合软决策树的多智能体分层强化学习算法，增强了策略的解释性。</li><li>基于模糊决策树建立了博弈对抗策略，通过挖掘战法规则，模拟人的决策过程。</li><li>在联合作战实验平台上设计了空战博弈场景和海空联合作战场景，验证了所提算法的有效性。</li></ul><h3 id="算法设计与实验验证">1.2 算法设计与实验验证</h3><ul><li>设计了指挥官-集群分层强化学习算法，并通过实验验证了其在收敛性、解释性与作战效能方面的优势。</li><li>设计了结合软决策树的分层强化学习算法，验证了其在策略解释性和算法收敛性方面的优势。</li><li>提出了基于模糊决策树的博弈对抗策略，并通过实验验证了其分类效果和战法规则提取效果。</li></ul><h3 id="实验环境与设置">1.3 实验环境与设置</h3><ul><li>使用了“StarCraft2”作为实验平台，设计了多种博弈场景，包括简单同构智能体控制场景、复杂同构智能体控制场景和复杂异构智能体控制场景。</li></ul><h3 id="结论与展望">1.4 结论与展望</h3><ul><li>论文提出的分层强化学习算法在多智能体博弈对抗中具有实际应用价值和潜力，尤其在提高指挥部快速决策能力和军队快速反应打击能力上。</li><li>论文还指出了研究的局限性，并对未来的研究方向提出了展望，包括消除上层智能体学习训练结果对模型性能的负面影响，以及针对模糊环境下多层次、多目标的决策问题开展研究。</li></ul><h2 id="研究方法">2. 研究方法</h2><ul><li><strong>分层强化学习（HRL）</strong>：文章采用分层强化学习方法来处理多智能体复杂博弈场景中的策略优化问题。这种方法通过将复杂的决策问题分解为多个层次，使得学习过程更加高效和可解释。</li><li><strong>结合任务可解释性</strong>：文章提出了结合任务可解释性的指挥官-集群分层强化学习算法，通过模仿学习设计可解释的子任务，引入专家经验，提高算法的收敛速度。</li><li><strong>软决策树</strong>：为了增强策略的解释性，文章设计了结合软决策树的分层强化学习算法，通过引入线性权重表示状态特征与决策结果之间的因果逻辑。</li><li><strong>模糊决策树</strong>：文章进一步挖掘战法规则，建立基于模糊决策树的博弈对抗策略，模拟人的决策过程，并提取模糊决策树中隐藏的战术规则。</li></ul><h2 id="算法实现">3. 算法实现</h2><ul><li><strong>指挥官-集群分层强化学习算法（HES）</strong>：文章实现了一种指挥官-集群分层强化学习算法，该算法包含上层指挥官决策模型和下层集群作战模型，通过可解释子任务实现信息传递。</li><li><strong>结合软决策树的分层强化学习算法（HEE）</strong>：文章实现了一种结合软决策树的分层强化学习算法，该算法在HES算法框架基础上，将软决策树结构融入宏观决策过程中。</li><li><strong>基于模糊决策树的博弈对抗策略（FDTGAS）</strong>：文章实现了一种基于模糊决策树的博弈对抗策略，通过预处理对抗数据，构建模糊决策树，并从中提取战法规则。</li></ul><h2 id="上层决策模型的主要特点和实现细节">4.上层决策模型的主要特点和实现细节：</h2><h3 id="指挥官-集群分层强化学习算法hes中的上层决策模型">4.1指挥官-集群分层强化学习算法（HES）中的上层决策模型</h3><ul><li><strong>指挥官决策模型</strong>：模拟战争中高级指挥官的决策过程，基于战争总体形势的变化制定总体作战规划，并将战斗子任务分配给下层战斗单位。</li><li><strong>任务可解释性</strong>：结合任务可解释性思想，设计可解释的子任务，将专家经验引入到分层框架中，引导智能体进行定向学习，提高算法的收敛速度。</li></ul><h3 id="结合软决策树的分层强化学习算法hee中的上层决策模型">4.2结合软决策树的分层强化学习算法（HEE）中的上层决策模型</h3><ul><li><strong>软决策树（SDT）</strong>：引入软决策树结构，改进传统的决策树模型，使其可以替代神经网络拟合动作价值函数，增强模型的可解释性。</li><li><strong>线性权重</strong>：在软决策树的叶子节点引入线性模型，通过线性权重表示状态特征与决策结果之间的因果逻辑，增强策略的解释性。</li></ul><h3 id="基于模糊决策树的博弈对抗策略中的上层决策模型">4.3基于模糊决策树的博弈对抗策略中的上层决策模型</h3><ul><li><strong>模糊决策树</strong>：构建模糊决策树模拟人的决策过程，处理高维度数据集中的模糊性和不确定性，提高分类的准确率和模型的泛化能力。</li><li><strong>战法规则提取</strong>：从模糊决策树中提取隐含的战法规则，建立以IF-THEN规则形式表示的博弈对抗策略。</li></ul><h3 id="实现细节">4.4 实现细节</h3><ul><li><strong>神经网络建模</strong>：上层决策模型通常采用神经网络进行建模，使用深度学习技术来处理高维数据和复杂的决策问题。</li><li><strong>参数更新</strong>：上层决策模型的参数通过梯度下降法进行更新，利用经验回放机制和策略梯度方法来优化模型性能。</li><li><strong>目标分解</strong>：上层智能体学习目标的分解策略，将复杂的任务分解为多个子目标，通过子目标的实现逐步达成最终目标。</li></ul><h3 id="应用场景">4.5 应用场景</h3><ul><li><strong>联合作战实验平台</strong>：在空战博弈场景和海空联合作战场景中，上层决策模型负责制定整体作战策略，指导下层作战单元执行具体的作战任务。</li></ul><h2 id="上层决策模型的具体实现细节">5. 上层决策模型的具体实现细节</h2><h3 id="指挥官-集群分层强化学习算法hes的上层决策模型">5.1指挥官-集群分层强化学习算法（HES）的上层决策模型</h3><h4 id="设计理念">设计理念</h4><ul><li><strong>指挥官角色</strong>：模拟高级指挥官的决策过程，负责在战争或博弈的宏观层面上制定战略。</li><li><strong>任务分解</strong>：将复杂的任务分解为可解释的子任务，这些子任务对下层集群作战模型来说是具体的战术目标。</li></ul><h4 id="实现细节-1">实现细节</h4><ul><li><strong>神经网络架构</strong>：使用神经网络来拟合指挥官的决策策略，该网络输入全局观测状态，输出子任务或战术目标。</li><li><strong>模仿学习</strong>：基于专家经验设计可解释的子任务，通过模仿学习将专家知识整合到神经网络的训练过程中。</li><li><strong>参数更新</strong>：利用梯度下降方法更新神经网络参数，以最小化损失函数，提高决策质量。</li></ul><h3 id="结合软决策树的分层强化学习算法hee的上层决策模型">5.2结合软决策树的分层强化学习算法（HEE）的上层决策模型</h3><h4 id="设计理念-1">设计理念</h4><ul><li><strong>软决策树（SDT）</strong>：引入软决策树来增强策略的解释性，SDT结合了神经网络的非线性建模能力和决策树的可解释性。</li></ul><h4 id="实现细节-2">实现细节</h4><ul><li><strong>树结构优化</strong>：对传统的软决策树结构进行改进，引入线性权重来表示状态特征与决策结果之间的因果逻辑。</li><li><strong>线性叶子节点</strong>：在SDT的叶子节点使用线性模型，这些模型通过学习状态特征的权重来预测动作价值。</li><li><strong>在线学习</strong>：SDT模型支持在线学习，能够根据实时数据更新模型参数，增强模型对新态势的适应能力。</li></ul><h3 id="基于模糊决策树的博弈对抗策略的上层决策模型">5.3基于模糊决策树的博弈对抗策略的上层决策模型</h3><h4 id="设计理念-2">设计理念</h4><ul><li><strong>模糊决策树</strong>：利用模糊决策树处理高维度数据集中的模糊性和不确定性，提高决策的准确性和泛化能力。</li></ul><h4 id="实现细节-3">实现细节</h4><ul><li><strong>属性模糊化</strong>：将连续型属性转换为模糊集合，并通过隶属度函数计算属性值在模糊集合中的隶属度。</li><li><strong>分裂属性选择</strong>：基于分类不确定性选择分裂属性，以最小化节点的平均模糊信息熵。</li><li><strong>战法规则提取</strong>：从模糊决策树中提取IF-THEN形式的战法规则，为博弈对抗提供具体的策略指导。</li></ul><h3 id="通用实现细节">5.4 通用实现细节</h3><h4 id="损失函数与优化">损失函数与优化</h4><ul><li><strong>损失函数</strong>：设计损失函数以衡量模型预测与实际结果之间的差异，常用的损失函数包括均方误差等。</li><li><strong>优化算法</strong>：采用Adam优化器等高级优化算法来更新模型参数，提高训练效率和模型性能。</li></ul><h4 id="训练与验证">训练与验证</h4><ul><li><strong>训练过程</strong>：通过与环境的交互不断收集数据，利用这些数据训练上层决策模型。</li><li><strong>验证与测试</strong>：在不同的博弈场景中验证上层决策模型的有效性，调整模型参数以适应不同的战术需求。</li></ul><p>这些实现细节共同构成了上层决策模型的核心，使其能够在多智能体博弈对抗中发挥关键作用。通过这些细节的实现，上层决策模型能够提供有效的战略指导，并与下层执行模型协同工作，实现整体任务目标。</p><p>[1]乔天润.基于分层强化学习的多智能体博弈对抗策略[D].东南大学,2023.DOI:10.27014/d.cnki.gdnau.2023.001144.</p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
      <category>多智能体强化学习任务分配</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
      <tag>科研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于多智能体强化学习的分层决策优化方法</title>
    <link href="/2024/11/15/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%88%86%E5%B1%82%E5%86%B3%E7%AD%96%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"/>
    <url>/2024/11/15/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%88%86%E5%B1%82%E5%86%B3%E7%AD%96%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="主要内容">1. 主要内容</h1><ol type="1"><li><strong>背景与目的</strong>：<ul><li>随着信息技术和人工智能的发展，大数据驱动的辅助决策方法变得更加科学和准确。</li><li>强化学习在决策优化方面具有优势，但传统方法难以解决多层次、多目标的决策优化问题，尤其是在长周期决策优化问题中，学习奖励的滞后性限制了效率。</li></ul></li><li><strong>方法论</strong>：<ul><li>提出基于多智能体强化学习的分层决策优化方法，应用目标分解思想解决长期决策优化问题。</li><li>该方法基于强化学习理论，使具有层级关系的多智能体相互合作，上层智能体学习目标的分解策略，下层智能体学习完成目标的行动策略。</li></ul></li></ol><h1 id="研究方法">2. 研究方法</h1><p>文章中提到的分层决策优化方法（HDQ）算法的具体实现涉及以下几个关键步骤：</p><ol type="1"><li><strong>定义智能体和环境交互</strong>：<ul><li>强化学习基于马尔可夫决策过程（MDP），包含状态集合 ( S )，动作集合 (A )，状态转移矩阵 ( P )，奖励集合 ( R )，以及折扣率 ( )。</li></ul></li><li><strong>目标分解与层级决策</strong>：<ul><li>将长期目标 ( G ) 分解为子目标 ( g_t )，并通过计算状态 ( s_t )与子目标 ( g_t ) 之间的距离 ( dis(gt, st) ) 来判断子目标是否完成。</li></ul></li><li><strong>智能体的层级结构</strong>：<ul><li>设计具有层级关系的上层智能体 ( _1 ) 和下层智能体 ( _2 )。</li><li>上层智能体学习目标的分解策略，下层智能体学习实现子目标的行动策略。</li></ul></li><li><strong>神经网络建模</strong>：<ul><li>使用深度Q网络（DQN）作为值函数逼近器，引入神经网络来估计动作价值 (Q(s, a; ) )。</li><li>采用Dueling DQN来缓解高估Q值的问题，引入优势函数 ( A(s, a) )。</li></ul></li><li><strong>智能体的参数更新</strong>：<ul><li>智能体参数交替更新，共同学习完成团队任务的最佳策略。</li><li>使用梯度下降法更新神经网络参数 ( )，学习率 ( )。</li></ul></li><li><strong>实验设计与数据预处理</strong>：<ul><li>从MIMIC-IV数据库中提取脓毒症患者数据，包括性别、年龄、体重、SOFA评分等45个特征。</li><li>使用均值插值方法处理缺失值，最大最小归一化方法消除特征量纲。</li></ul></li><li><strong>状态和动作空间的定义</strong>：<ul><li>状态空间通过K-means算法聚类降维，定义700个不同的状态类别。</li><li>子目标基于SOFA评分，动作空间定义为两种药物组成的二维矩阵。</li></ul></li><li><strong>奖励函数的设计</strong>：<ul><li>设计分段常数函数作为奖励函数，根据患者的生存状态和状态改善情况给予不同的奖励。</li></ul></li></ol><p>[1]张倩,李天皓,白春光.基于多智能体强化学习的分层决策优化方法[J].电子科技大学学报(社科版),2022,24(06):90-96.DOI:10.14071/j.1008-8105(2022)-1056.</p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
      <category>多智能体强化学习任务分配</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
      <tag>科研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于层次控制的多智能体对抗研究</title>
    <link href="/2024/11/14/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E5%9F%BA%E4%BA%8E%E5%B1%82%E6%AC%A1%E6%8E%A7%E5%88%B6%E7%9A%84%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%AF%B9%E6%8A%97%E7%A0%94%E7%A9%B6/"/>
    <url>/2024/11/14/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E5%9F%BA%E4%BA%8E%E5%B1%82%E6%AC%A1%E6%8E%A7%E5%88%B6%E7%9A%84%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%AF%B9%E6%8A%97%E7%A0%94%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="主要内容">1. 主要内容</h1><ul><li>针对复杂动作状态空间场景下单智能体策略学习问题，提出了一种基于预训练模型的分层强化学习算法。该算法分为三个层次：<ul><li>首先，基于先验知识为每个子策略设计了适宜其相应时间的宏动作；</li><li>其次是子策略控制器，其核心是基于监督学习的方法，训练能够适应不同需要的子策略，基于随机的宏动作产生子策略监督学习的数据，并且子策略只学习胜利时的操作轨迹；</li><li>最后是智能体的高级策略控制器，基于策略梯度算法进行扩展，屏蔽了底层繁琐的动作，只对于下层的子策略进行选择，使得作为决策的神经网络参数能够做出更好的动作。</li></ul></li><li>针对复杂动作状态空间场景下多智能体策略学习问题，提出了一种基于双向协调网络的多智能体强化学习算法。该算法基于Actor-Critic框架，其特点是：<ul><li>基于全局信息训练Critic网络，用以解决场景中马尔可夫性缺失问题；</li><li>采用双向RNN网络结构，用以解决场景中多智能体信息通信问题；</li><li>使用动作映射算法，使得智能体选择收益最高的合法联合动作。</li></ul></li><li>基于上述研究成果和《星际争霸2》对抗学习环境，将单智能体强化学习算法和多智能体强化学习算法进行有机融合，设计实现了一个基于层次控制的多智能体强化学习原型系统，并进行实验验证。</li></ul><h1 id="研究方法">2. 研究方法</h1><p>这篇论文的主要研究方法和算法集中在解决复杂动作状态空间下的多智能体对抗问题，具体包括以下几个方面：</p><ol type="1"><li><strong>基于预训练模型的分层强化学习算法</strong>：<ul><li><strong>宏动作设计</strong>：将复杂的动作序列打包成宏动作，减少智能体需要学习的原子动作数量。</li><li><strong>子策略控制器</strong>：基于监督学习的方法训练子策略，每个子策略对应一个宏动作。</li><li><strong>高级策略控制器（APC）</strong>：基于策略梯度算法扩展，负责在子策略之间进行选择。</li></ul></li><li><strong>基于双向协调网络的多智能体强化学习算法（BiC-DDPG）</strong>：<ul><li><strong>集中训练分散执行</strong>：解决多智能体对抗场景下马尔可夫性缺失问题，提高算法收敛性。</li><li><strong>Bi-RNN网络结构</strong>：实现智能体合作时的信息通信。</li><li><strong>动作映射算法</strong>：将连续的原始联合动作映射到合法离散联合动作空间，解决复杂联合动作空间下的智能体决策问题。</li></ul></li><li><strong>深度学习和强化学习算法</strong>：<ul><li><strong>深度神经网络</strong>：使用深度神经网络结构（如ResNet50）作为子策略的神经网络结构。</li><li><strong>强化学习算法</strong>：包括Q学习、DQN、策略梯度、Actor-Critic算法等。</li></ul></li><li><strong>实验验证</strong>：<ul><li>在《星际争霸2》环境中进行实验验证，包括全流程对抗和微操作对抗环境。</li><li>设计了不同难度的对抗场景，以及不同的子策略训练和测试。</li></ul></li><li><strong>原型系统实现</strong>：<ul><li>将单智能体和多智能体强化学习算法融合，设计实现了一个基于层次控制的多智能体强化学习原型系统。</li><li>在Python-sc2接口上复现SMAC接口对于观察数据、奖励机制以及动作空间的设计，并部署BiC-DDPG算法。</li></ul></li><li><strong>算法优化和调整</strong>：<ul><li>对算法的参数进行调整，以适应不同的实验环境和场景。</li><li>通过实验结果分析算法的性能和有效性。</li></ul></li></ol><p>[1]王功举.基于层次控制的多智能体对抗研究[D].军事科学院,2021.DOI:10.27193/d.cnki.gjsky.2021.000110.</p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
      <category>多智能体强化学习任务分配</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
      <tag>科研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.3 无监督学习-强化学习-吴恩达</title>
    <link href="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/"/>
    <url>/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="强化学习">强化学习</h2><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013185527334.png"></p><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013185513926.png"></p><ul><li>状态、动作、奖励和下一个状态(s, a, R(s), s')</li></ul><h3 id="回报">1. 回报</h3><ul><li>折扣因子</li></ul><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013191147456.png"></p><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013191515723.png"></p><h3 id="决策">2. 决策</h3><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013191936751.png"></p><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013192130503.png"></p><ul><li><p>马尔可夫决策过程 MDP</p></li><li><p>在马尔可夫决策过程中，未来只取决于你现在所处的位置，而不取决于你是如何到达这里的。</p></li></ul><h3 id="状态-动作价值函数">3. 状态-动作价值函数</h3><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013214059896.png"></p><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013214515098.png"></p><h4 id="贝尔曼方程">3.1 贝尔曼方程</h4><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013220256063.png"></p><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013221245911.png"></p><ul><li>如果你从状态s开始，你将采取行动a，然后在此之后采取最佳行动，那么你将随着时间的推移看到一些奖励序列。</li></ul><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013221652384.png"></p><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013221916868.png"></p><h3 id="随机强化学习">4. 随机强化学习</h3><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013222607911.png"></p><h3 id="连续状态">5. 连续状态</h3><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013222846102.png"></p><ul><li>连续马尔可夫 MTP</li></ul><h3 id="学习状态值函数">6. 学习状态值函数</h3><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013223922575.png"></p><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013224639866.png"></p><ul><li>不知道Q，随机猜测</li></ul><h3 id="dqn">7. DQN</h3><ul><li>意思是神经网络里的参数随机初始化，然后(s',a')输入，得到maxQ的预测</li></ul><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013225256166.png"></p><ul><li>交给神经网络训练的参数y中一部分是随机初始化神经网络生成的，但还有一部分是包含了当前状态的信息的，所以当训练次数增多后，外部的输入信息会逐步冲刷掉初始化的随机信息，给出真正的Q函数估计。</li></ul><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013225733542.png"></p><h4 id="贪婪算法">7.1 贪婪算法</h4><ul><li>使用高ε开始，逐步降低直到0.01</li></ul><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013230506858.png"></p><h4 id="小批量和软更新">7.2 小批量和软更新</h4><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013230853479.png"></p><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013231149426.png"></p><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013231255361.png"></p><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013231653864.png"></p><h3 id="局限性">8. 局限性</h3><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013232030585.png"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>ML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.2 无监督学习-推荐系统-吴恩达</title>
    <link href="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/"/>
    <url>/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="推荐系统">推荐系统</h2><h3 id="使用每个特征数据">1. 使用每个特征数据</h3><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013091417801.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013092525171.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013092709205.png"></p><h3 id="协同过滤算法">2. 协同过滤算法</h3><ul><li>假设已经有了w和b，猜测特征x</li></ul><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013093541589.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013094256436.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013094536963.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013095022269.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013095116749.png"></p><ul><li><p>这种协同过滤是从多个用户收集数据，用户之间的这种协作可帮助您预测未来甚至其他用户的评级。</p></li><li><p>推荐系统的一个非常常见的用例是当您有二进制标签时，例如用户喜欢、喜欢或与项目交互的标签。</p></li></ul><h3 id="二进制标签">3.二进制标签</h3><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013095506383.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013095650568.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013095901608.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013100113430.png"></p><ul><li>分类不用正则化</li></ul><h3 id="均值归一化">4. 均值归一化</h3><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013143727458.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013144130791.png"></p><ul><li>对未知用户，预测评分为均值</li></ul><h3 id="协同过滤tensorflow实现">5. 协同过滤Tensorflow实现</h3><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013144725579.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013144803015.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013145539351.png"></p><h3 id="寻找相关特征">6. 寻找相关特征</h3><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013145951931.png"></p><ul><li>协同过滤的局限性</li></ul><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013150021292.png"></p><ul><li><p>冷启动问题</p></li><li><p>边缘信息</p></li></ul><h3 id="基于内容的过滤算法">7. 基于内容的过滤算法</h3><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013150639264.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013150936617.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013151110932.png"></p><ul><li>如何计算V</li></ul><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013151407807.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013151905392.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013152534237.png"></p><h3 id="从大型目录中推荐">8. 从大型目录中推荐</h3><ul><li>两个步骤：检索和排名</li></ul><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013152823434.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013153036731.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013153343967.png"></p><h3 id="基于内容的tensorflow实现">9. 基于内容的Tensorflow实现</h3><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013154612258.png"></p><h3 id="降低特征数量">10. 降低特征数量</h3><ul><li>PCA主成分分析法，特征降为二维或者三维，便于可视化</li></ul><h4 id="pca算法">10.1 PCA算法</h4><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013170727751.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013171217861.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013171447596.png"></p><ul><li><p>当使用线性回归来预测目标输出Y并且PCA试图获取大量特征并平等对待它们并减少很好地表示数据所需的轴数</p></li><li><p>因此，如果您尝试预测y的值，则应使用线性回归;如果您尝试减少数据集中的特征数量，例如将其可视化，则应使用PCA。</p></li></ul><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013172253829.png"></p><ul><li>每个特征的方差贡献率</li></ul><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013172530272.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013172923497.png"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>ML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.1 无监督学习-无监督学习-吴恩达</title>
    <link href="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/"/>
    <url>/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="无监督学习">无监督学习</h2><h3 id="聚类">1. 聚类</h3><h4 id="k-means">1.1 k-means</h4><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012125528206.png"></p><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012125536447.png"></p><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012130426099.png"></p><ul><li>如果一个集群训练样本为零，可以消除该集群，最终得到k-1；另一种方法是重新初始化该集群质心</li></ul><h4 id="优化目标">1.2 优化目标</h4><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012145049473.png"></p><h4 id="初始化">1.3 初始化</h4><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012150757199.png"></p><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012151542672.png"></p><h4 id="选择聚类数量">1.4 选择聚类数量</h4><ul><li>肘法</li></ul><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012151925053.png"></p><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012152146445.png"></p><h3 id="异常检测">2. 异常检测</h3><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012152706177.png"></p><h4 id="密度估计">2.1 密度估计</h4><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012152845235.png"></p><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012153346742.png"></p><h4 id="高斯正态分布">2.2 高斯正态分布</h4><ul><li>最大似然估计</li></ul><h4 id="异常检测算法">2.3 异常检测算法</h4><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012154133115.png"></p><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012154923207.png"></p><h4 id="开发与评估异常检测系统.">2.4 开发与评估异常检测系统.</h4><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012215712447.png"></p><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012220215931.png"></p><ul><li><p>这种替代方案的缺点是，在调整算法后，您没有公平的方法来判断它在未来示例中的实际效果如何，因为您没有测试集。</p></li><li><p>当你的数据集很小的时候，特别是当你有异常的数量时，你的数据集很小，这可能是你最好的选择。</p></li></ul><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013082659472.png"></p><h4 id="异常检测vs监督学习">2.5 异常检测vs监督学习</h4><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013084827450.png"></p><ul><li>例子</li></ul><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013084924028.png"></p><h4 id="选择用什么特征">2.6 选择用什么特征</h4><ul><li>特征改变为高斯分布</li></ul><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013085546244.png"></p><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013090207839.png"></p><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013090413780.png"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>ML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.4 深度学习-决策树-吴恩达</title>
    <link href="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/"/>
    <url>/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="决策树">决策树</h2><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012075401986.png"></p><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012075410387.png"></p><ul><li><p>根节点 决策节点 叶节点</p></li><li><p>决策树学习算法的工作是，从所有可能的决策树中，尝试选择一个希望在训练集上表现良好的树，然后理想地泛化到新数据，例如交叉验证和测试集</p></li></ul><h3 id="学习过程">1. 学习过程</h3><ul><li>决策树学习的第一步是，我们必须决定在根节点使用什么特征。</li></ul><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012081611286.png"></p><ul><li><p>决策 2：何时停止分裂？</p><ul><li>当一个节点完全是一类时</li><li>当分裂一个节点会导致树超过最大深度时</li><li>当纯度分数的提高低于一个阈值时</li><li>当节点中的样本数量低于一个阈值时</li></ul></li><li><p>您可能想要限制决策树深度的一个原因是确保我们的树不会变得太大和笨重，其次，通过保持树小，它不太容易过度拟合。</p></li></ul><h3 id="纯度">2. 纯度</h3><h4 id="熵-entropy">2.1 熵 entropy</h4><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012082638836.png"></p><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012082823450.png"></p><ul><li><p>选择拆分信息增益</p></li><li><p>减少熵</p></li><li><p>信息增益 分之前的熵减去分后熵的加权平均</p></li><li><p>停止标准，每次信息增益如果太小停止分类</p></li></ul><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012083632353.png"></p><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012083921344.png"></p><h4 id="整合">2.2 整合</h4><ul><li>从根节点开始，包含所有样本</li><li>计算所有可能特征的信息增益，并选择信息增益最高的特征</li><li>根据选定的特征划分数据集，并创建树的左分支和右分支</li><li>持续重复分裂过程，直到满足停止条件：<ul><li>当一个节点完全是一类时</li><li>当分裂一个节点会导致树超过最大深度时</li><li>额外分裂的信息增益小于阈值时</li><li>当节点中的样本数量低于阈值时</li></ul></li></ul><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012084601880.png"></p><ul><li>递归分类</li></ul><h3 id="独热编码-one-hot">3. 独热编码 one-hot</h3><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012085239987.png"></p><ul><li><p>通过one-hot编码，您可以让决策树处理可以采用两个以上离散值的特征，您还可以将其应用于新网络或线性回归或逻辑回归训练。</p></li><li><p>连续值</p></li><li><p>尝试不同的阈值，计算纯度</p></li></ul><h3 id="回归树">4. 回归树</h3><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012090404205.png"></p><ul><li>尝试减少方差</li></ul><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012091154958.png"></p><h3 id="使用多个决策树">5. 使用多个决策树</h3><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012092643280.png"></p><h4 id="有放回的采样">5.1 有放回的采样</h4><ul><li><p>构建新的数据集</p></li><li><p>随机森林算法 Random Forest Algorithm</p></li></ul><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012093230276.png"></p><ul><li>随机化特征选择<ul><li>在每个节点选择用于分裂的特征时，如果有n个特征可用，随机选择一个包含k个特征的子集（k&lt; n），并允许算法仅从这个特征子集中进行选择。</li></ul></li><li>k的选择（根号n，log2(n)）</li></ul><h4 id="xgboost-extreme-gradient-boosting">5.2 XGBoost (extreme GradientBoosting)</h4><ul><li>提升树的开源实现</li><li>快速高效的实现</li><li>默认分裂标准和停止分裂标准的好选择</li><li>内置正则化以防止过拟合</li><li>机器学习竞赛中极具竞争力的算法（例如：Kaggle竞赛）</li></ul><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012094738491.png"></p><h3 id="何时使用决策树">6. 何时使用决策树</h3><ul><li>表格数据</li></ul><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012095356821.png"></p><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012095814528.png"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>ML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.3 深度学习-在机器学习项目中下一步该做什么-吴恩达</title>
    <link href="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/"/>
    <url>/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="在机器学习项目中下一步该做什么">在机器学习项目中下一步该做什么</h2><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011083027133.png"></p><h3 id="模型评估">1. 模型评估</h3><p>训练集分为两个子集</p><ul><li><p>training set</p></li><li><p>test set</p></li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011083802084.png"></p><p>不包含正则化项</p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011084012544.png"></p><figure><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011084442975.png" alt="image-20231011084442975"><figcaption aria-hidden="true">image-20231011084442975</figcaption></figure><p>就是相比于之前计算在测试集和训练集上误差的那两个公式，我们更常用模型分类错误的次数除以总的预测次数来表示误差</p><p>就是对于逻辑回归来说，可以通过计算误判占比的方法来代表成本函数，比如testset中误判的占比是10％，那么J test就是0.1</p><h4 id="分为三个子集训练集交叉验证集测试集">1.1分为三个子集，训练集、交叉验证集、测试集</h4><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011091646019.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011091757791.png"></p><ul><li><p>选择最小的交叉验证集误差对应的模型</p></li><li><p>用测试集来评估泛化误差</p></li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011092256493.png"></p><h4 id="偏差和方差">1.2 偏差和方差</h4><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011093159868.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011093401564.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011093433520.png"></p><ul><li>正则化如何影响偏差和方差，从而影响算法的性能</li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011093859951.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011094124259.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011094256539.png"></p><h4 id="指定一个用于性能评估的基准">1.3 指定一个用于性能评估的基准</h4><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011103735186.png"></p><p>竞争算法</p><h4 id="学习曲线">1.4 学习曲线</h4><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011104512509.png"></p><ul><li>训练集变大，误差增大</li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011104852894.png"></p><ul><li>这给出了这个结论，也许有点令人惊讶，如果学习算法具有高偏差，获得更多的训练数据本身就没有那么大的希望。</li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011105426342.png"></p><ul><li>所以在这种情况下，可能仅仅通过增加训练集的大小来降低交叉验证误差并让你的算法表现得越来越好，这与高偏差情况不同，在这种情况下你唯一要做的就是获得更多的训练数据，实际上并不能帮助您了解算法性能。</li></ul><h4 id="如何改进">1.5 如何改进</h4><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011110222504.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011110708303.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011111707005.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011112028987.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011112250065.png"></p><h3 id="机器学习开发的迭代">2. 机器学习开发的迭代</h3><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011112605831.png"></p><ul><li>垃圾邮件分类</li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011112929003.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011113910756.png"></p><h4 id="误差分析">2.1 误差分析</h4><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011114442995.png"></p><h4 id="数据增强">2.2 数据增强</h4><ul><li>旋转图像扭曲放大缩小</li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011115040740.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011115116926.png"></p><ul><li>音频增强</li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011115211067.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011115324412.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011131113956.png"></p><h4 id="迁移学习-transfer-learning">2.3 迁移学习 Transfer learning</h4><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011163140324.png"></p><ul><li><p>数据集小选择1，数据集大选择2</p></li><li><p>先在大的数据集训练（监督与训练），再在小的训练称为微调</p></li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011163230072.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011163351440.png"></p><h4 id="机器学习项目全周期">2.4 机器学习项目全周期</h4><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011163931188.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011164414049.png"></p><h4 id="倾斜数据集的误差指标">2.5 倾斜数据集的误差指标</h4><ul><li>精确度和召回率</li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011165618174.png"></p><ul><li>精度和召回率</li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011170439331.png"></p><ul><li>F1score 更强调P和R中较低的那个 调和平均值</li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011170740787.png"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>ML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.2 深度学习-Tenserflow实现-吴恩达</title>
    <link href="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/"/>
    <url>/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="tenserflow实现">Tenserflow实现</h2><h3 id="模型训练步骤">1. 模型训练步骤</h3><figure><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010125603129.png" alt="模型训练步骤"><figcaption aria-hidden="true">模型训练步骤</figcaption></figure><h4 id="epochs-and-batches">1.1 Epochs and batches</h4><p>在上述的 <code>compile</code> 语句中，<code>epochs</code>的数量被设置为10。这指定了整个数据集在训练过程中应该被应用10次。在训练期间，你会看到描述训练进度的输出，看起来像这样：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Epoch</span> <span class="hljs-number">1</span>/<span class="hljs-number">10</span><br><span class="hljs-attribute">6250</span>/<span class="hljs-number">6250</span><span class="hljs-meta"> [==============================] - 6s 910us/step - loss: 0.1782</span><br></code></pre></td></tr></table></figure><p>第一行 <code>Epoch 1/10</code>描述了模型当前正在运行的是哪个训练周期。为了提高效率，训练数据集被分成了“批次”。在Tensorflow中，默认的批次大小是32。我们的扩展数据集中有200000个样本，或者6250个批次。第二行的符号<code>6250/6250 [====</code> 描述了已经执行了哪个批次。</p><h4 id="创建模型">1.2 创建模型</h4><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010125701208.png"></p><h4 id="交叉熵损失函数">1.3 交叉熵损失函数</h4><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010130715345.png"></p><ul><li>回归和分类使用不同的损失代价函数</li></ul><h4 id="梯度下降">1.4 梯度下降</h4><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010130841602.png"></p><p>多层感知器：多层神经网路</p><h3 id="激活函数">2. 激活函数</h3><h4 id="relu-activation">2.1 ReLU Activation</h4><p>This week, a new activation was introduced, the Rectified Linear Unit(ReLU).</p><p>𝑎=𝑚𝑎𝑥(0,𝑧)</p><figure><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010204558837.png" alt="ReLU"><figcaption aria-hidden="true">ReLU</figcaption></figure><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010204715345.png"></p><ul><li><p>二分类问题，sigmoid激活函数是最自然的选择，输出层使用</p></li><li><p>回归模型，输出有正有负，预测明天的股票价格，输出层使用线性激活函数</p></li><li><p>回归模型，输出为非负，预测房屋价格，非负，输出层选择ReLU函数</p></li><li><p>隐藏层选择Relu函数，ReLU计算速度更快，效率高，但事实证明更重要的第二个原因是ReLU函数仅在图形的一部分变平;左边这里是完全平坦的，而sigmoid激活函数，它在两个地方变得平坦。梯度下降就会很慢，减慢学习速度</p></li><li><p>为什么要使用激活函数？</p><ul><li>若所有层都是用线性激活函数，那就变成了线性回归</li></ul></li></ul><h3 id="多分类问题">3. 多分类问题</h3><h4 id="softmax函数">3.1 Softmax函数</h4><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010212144511.png"></p><h4 id="代价函数">3.2 代价函数</h4><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010212557352.png"></p><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010220105018.png"></p><h4 id="tenserflow-实现">3.3 Tenserflow 实现</h4><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010220327241.png"></p><h4 id="改进实现">3.4 改进实现</h4><p>避免计算过程中出现过大或者过小值造成计算错误，改进方法在计算过程中进行了重新排列</p><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010221115720.png"></p><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010221418604.png"></p><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010221520301.png"></p><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010221537117.png"></p><h3 id="多标签分类">4. 多标签分类</h3><p>一个神经网络同时检测多个目标</p><h3 id="更快的训练方法">5. 更快的训练方法</h3><h4 id="adam算法">5.1 Adam算法</h4><p>自动调节α</p><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010231015869.png"></p><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010231157191.png"></p><h3 id="其他的网络层">6. 其他的网络层</h3><p>密集层</p><p>卷积层</p><ul><li><p>更快的计算</p></li><li><p>需要更少的训练数据，不太会过拟合</p></li></ul><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010231710233.png"></p><h3 id="计算图">7. 计算图</h3><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010235541548.png"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>ML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.1 深度学习-神经网络-吴恩达</title>
    <link href="/2024/11/13/ML/class2-week1-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E5%90%B4%E6%81%A9%E8%BE%BE/"/>
    <url>/2024/11/13/ML/class2-week1-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E5%90%B4%E6%81%A9%E8%BE%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="神经网络">神经网络</h2><ul><li><p>输入层 输入为特征向量</p></li><li><p>隐藏层</p></li><li><p>输出层</p></li></ul><p><strong>Tensorflow and Keras</strong></p><ul><li>TensorFlow 是由谷歌开发的一个机器学习包。2019年，谷歌将 Keras 集成到TensorFlow 中，并发布了 TensorFlow 2.0。Keras 是由 François Chollet独立开发的框架，它为 TensorFlow创建了一个简单、以层为中心的接口。本课程将使用 Keras 接口。</li></ul><h3 id="前向传播算法">前向传播算法</h3><p><img src="/2024/11/13/ML/class2-week1-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231009222124079.png"></p><ul><li><p>从左到右向前计算，称为前向传播。</p></li><li><p>离输出层越近，隐藏层神经元越少。</p></li></ul><p><img src="/2024/11/13/ML/class2-week1-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231009222647437.png"></p><ul><li><p>两个特征，第一个隐藏层有三个神经元，激活函数为sigmoid，输出为a1，第二层同理；</p></li><li><p>输入向量要写成二维矩阵形式 x = np.array([[200,17]])1x2矩阵。</p></li></ul><p><img src="/2024/11/13/ML/class2-week1-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231009224920509.png"></p><p><img src="/2024/11/13/ML/class2-week1-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231009224946845.png"></p><ul><li>将权重拟合到数据（反向传播）如果数据被归一化，那么这个过程将会进行得更快。</li></ul>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>ML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.3 有监督机器学习回归和分类-逻辑回归-吴恩达</title>
    <link href="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    <url>/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<h2 id="week3-逻辑回归">Week3 逻辑回归</h2><h3 id="二元分类">1. 二元分类</h3><p>只有两种可能输出的分类问题称为二元分类。</p><h3 id="sigmoid-函数">2. sigmoid 函数</h3><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008173829773.png"></p><figure><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008173915794.png" alt="sigmoid"><figcaption aria-hidden="true">sigmoid</figcaption></figure><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20241113221925070.png"></p><p>输入特征，输出0到1</p><h3 id="决策边界">3. 决策边界</h3><p>线性or非线性</p><h3 id="代价函数">4. 代价函数</h3><p>平方误差成本函数不是逻辑回归的理想成本函数，常用的是对数损失函数。</p><figure><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008205513401.png" alt="squared error cost"><figcaption aria-hidden="true">squared error cost</figcaption></figure><figure><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008205613800.png" alt="凸和非凸"><figcaption aria-hidden="true">凸和非凸</figcaption></figure><figure><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008205638121.png" alt="image-20231008205638121"><figcaption aria-hidden="true">image-20231008205638121</figcaption></figure><figure><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008205807667.png" alt="logistic loss function"><figcaption aria-hidden="true">logistic loss function</figcaption></figure><p>请记住，损失函数衡量的是你在一个训练样例上的表现如何，它是通过总结你随后获得的所有训练样例的损失，成本函数衡量你在整个训练集上的表现。</p><figure><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008210426343.png" alt="image-20231008210426343"><figcaption aria-hidden="true">image-20231008210426343</figcaption></figure><p>整体成本函数为凸函数，可以获得全局最小值</p><p>简化损失函数</p><figure><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008211105952.png" alt="image-20231008211105952"><figcaption aria-hidden="true">image-20231008211105952</figcaption></figure><p>代价函数</p><figure><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008211415275.png" alt="image-20231008211415275"><figcaption aria-hidden="true">image-20231008211415275</figcaption></figure><p>使用最大似然估计推导出来，是凸函数。</p><h3 id="梯度下降">5. 梯度下降</h3><figure><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008211755913.png" alt="image-20231008211755913"><figcaption aria-hidden="true">image-20231008211755913</figcaption></figure><figure><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008211932119.png" alt="image-20231008211932119"><figcaption aria-hidden="true">image-20231008211932119</figcaption></figure><figure><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008211950319.png" alt="image-20231008211950319"><figcaption aria-hidden="true">image-20231008211950319</figcaption></figure><p>Same concepts:</p><ul><li>Monitor gradient descent(learning curve)</li><li>Vectorized implementation</li><li>Feature scaling</li></ul><h3 id="过拟合与欠拟合">6. 过拟合与欠拟合</h3><ul><li><p>欠拟合：高偏差 high bias Does not fit thetraining setwell</p></li><li><p>过拟合：高方差 high variance Fits the training setextremelywell</p></li></ul><h3 id="解决过拟合">7. 解决过拟合</h3><ul><li><p>收集更多的训练样本</p></li><li><p>选择特征 select features to include/exclude</p></li><li><p>正则化 Regularization正则化是一种更温和地减少某些特征影响的方法，而不用像彻底消除它那样严厉。</p></li><li><p>那么正则化的作用是，它可以让你保留所有特征，但它们只是防止特征产生过大的影响，而这有时会导致过度拟合。</p></li></ul><h3 id="正则化-regularization">8. 正则化 Regularization</h3><p>λ正则化参数</p><figure><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008223908932.png" alt="image-20231008223908932"><figcaption aria-hidden="true">image-20231008223908932</figcaption></figure><p>正则化线性回归</p><figure><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008224030737.png" alt="image-20231008224030737"><figcaption aria-hidden="true">image-20231008224030737</figcaption></figure><p>梯度下降</p><figure><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008224109310.png" alt="image-20231008224109310"><figcaption aria-hidden="true">image-20231008224109310</figcaption></figure><p>正则化逻辑回归</p><h1 id="image-20231008225551317"><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008225551317.png" alt="image-20231008225551317"></h1>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>ML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于演员-评论家框架的层次化多智能体协同决策方法</title>
    <link href="/2024/11/12/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E5%9F%BA%E4%BA%8E%E6%BC%94%E5%91%98-%E8%AF%84%E8%AE%BA%E5%AE%B6%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B1%82%E6%AC%A1%E5%8C%96%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%8D%8F%E5%90%8C%E5%86%B3%E7%AD%96%E6%96%B9%E6%B3%95/"/>
    <url>/2024/11/12/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E5%9F%BA%E4%BA%8E%E6%BC%94%E5%91%98-%E8%AF%84%E8%AE%BA%E5%AE%B6%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B1%82%E6%AC%A1%E5%8C%96%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%8D%8F%E5%90%8C%E5%86%B3%E7%AD%96%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="主要内容">主要内容</h1><p>这篇文章的主要内容是提出了一种基于演员-评论家（Actor-Critic，AC）框架的层次化多智能体协同决策方法，旨在解决复杂作战环境下多智能体协同决策中的任务分配不合理和决策一致性较差的问题。该方法通过将决策过程分为不同层次，并使用AC框架来实现智能体之间的信息交流和决策协同，以提高决策效率和战斗力。在高层次，顶层智能体制定任务决策，将总任务分解并分配给底层智能体。在低层次，底层智能体根据子任务进行动作决策，并将结果反馈给高层次。</p><h1 id="研究方法和算法实现">研究方法和算法实现：</h1><div data-align="center"><img src="/2024/11/12/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E5%9F%BA%E4%BA%8E%E6%BC%94%E5%91%98-%E8%AF%84%E8%AE%BA%E5%AE%B6%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B1%82%E6%AC%A1%E5%8C%96%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%8D%8F%E5%90%8C%E5%86%B3%E7%AD%96%E6%96%B9%E6%B3%95/image-20241112210938443.png" alt="image-20241112210938443" style="zoom:40%;" align="center"></div><ol type="1"><li><strong>决策层次划分：</strong><ul><li>高层次（High Level,HL）：顶层智能体负责制定任务决策，将总任务分解并分配给底层智能体。</li><li>低层次（Low Level,LL）：底层智能体根据子任务进行动作决策，并将结果反馈给高层次。</li></ul></li><li><strong>状态空间和动作空间的分割：</strong><ul><li>根据层级关系对状态空间和指令空间进行分割，HL决策针对全局作战态势信息下达宏观作战指令，LL决策对执行宏观作战指令的作战编组进行动作操控。</li></ul></li><li><strong>上层任务分解</strong><ul><li>给定总任务<em>M</em>，拆分成子任务集{𝑀0,𝑀1,⋯,𝑀𝑖}</li><li>每一个子任务有任务类型、任务时间、任务状态和作战单元类型，可用one-hot独热码<ul><li>任务类型：主要分为打击任务和巡逻任务，打击任务包含对空拦截、对陆打击，巡逻任务包含空战巡逻、反地面战巡逻</li><li>任务时间：做离散化处理，用时刻𝑇1和时刻𝑇2来表示</li><li>任务状态：启动、未启动</li><li>作战单元：导弹驱逐舰和轰炸机</li></ul></li><li>在根据想定场景设计出子任务后，HL需要根据任务类型规划出任务启动时间，并进一步确定任务的启动次序。</li></ul></li><li><strong>奖惩函数设计：</strong><ul><li>高层智能体只需要聚焦于子任务选择是否合适，因此高层智能体的奖励函数HL<sub>r</sub>设计为当任务合适时给予正奖励回报，反之则为负奖励回报。本文中根据全局任务是否完成判断子任务选择是否正确。</li></ul></li><li><strong>基于AC框架的层次化多智能体算法框架：</strong><ul><li>离策略修正的层次化学习(Hierarchical reinforcement learning withoff-policy correction,HIRO)[31]算法是一种使用两层策略结构来解决复杂强化学习问题的一种单智能体算法，核心思想是高层策略提出目标，低层策略完成这一目标。</li><li>采用部分可观察马尔可夫决策过程（POMDP）对环境进行建模。</li><li>利用深度确定性策略梯度（Deep Deterministic Policy Gradient,DDPG）算法作为基础，结合多智能体深度强化学习，形成了HierarchicalMulti-Agent Actor-Critic（HMaAC）算法。</li></ul></li><li><strong>HMaAC算法设计：</strong><ul><li>初始化顶层和底层的Critic网络和Actor网络，以及经验回放缓冲池。</li><li>通过采样和最小化损失函数更新Critic网络，通过策略梯度更新Actor网络。</li><li>引入熵约束的概念，最大化策略的熵以学习设置合适的子目标。</li></ul></li><li><strong>仿真环境与仿真结果：</strong><ul><li>使用联合作战仿真推演平台作为实验验证环境，进行了2v2、4v4、6v6等不同规模的作战场景实验。</li><li>实验结果显示，HMaAC算法在多种复杂作战场景下均取得了较好的性能，展现了其在提升军事作战协同决策能力方面的潜力。</li></ul></li><li><strong>网络结构设计和训练参数：</strong><ul><li>设计了上层和下层的神经网络结构，均使用3层全连接层，使用ReLU和Tanh作为激活函数。</li><li>设定了一系列超参数，如最大episode数量、批处理参数、熵正则项系数等。</li></ul></li></ol><p><img src="/2024/11/12/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E5%9F%BA%E4%BA%8E%E6%BC%94%E5%91%98-%E8%AF%84%E8%AE%BA%E5%AE%B6%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B1%82%E6%AC%A1%E5%8C%96%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%8D%8F%E5%90%8C%E5%86%B3%E7%AD%96%E6%96%B9%E6%B3%95/image-20241113205648783.png"></p><ol type="1"><li><strong>训练结果分析：</strong><ul><li>对比了HMaAC算法和MADDPG算法在2v2仿真场景中的表现，HMaAC算法在奖励值和收敛速度上优于MADDPG算法。</li></ul></li></ol><p>文章最后指出，尽管HMaAC算法在实验中表现出色，但仍需在实地测试和实战演练中进一步验证其可行性和有效性，同时探讨在更复杂多样化作战环境中的适应性和鲁棒性。</p><p>[1]傅妍芳,雷凯麟,魏佳宁,等.基于演员-评论家框架的层次化多智能体协同决策方法[J].兵工学报,2024,45(10):3385-3396.</p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
      <category>多智能体强化学习任务分配</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
      <tag>科研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.2 因特网概述</title>
    <link href="/2024/11/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2%E5%9B%A0%E7%89%B9%E7%BD%91%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/11/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2%E5%9B%A0%E7%89%B9%E7%BD%91%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="因特网概述">1.2 因特网概述</h1><h2 id="网络互联网和因特网">1. 网络，互联网和因特网</h2><ul><li>网络是由若干结点和链接这些结点的链路组成</li><li>多个网络通过路由器互连起来，构成一个覆盖范围更大的网路，称为互联网</li><li>因特网是世界上最大的互联网络，连接在因特网上的计算机称为主机</li></ul><h3 id="internet和internet的区别">1.1 internet和Internet的区别</h3><ol type="1"><li>internet(互联网或互连网)是一个通用名词，它泛指由多个计算机网络互连而成的网络。在这些网络之间的通信协议可以是任意的。</li><li>Internet(因特网)则是一个专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定计算机网络，它采用TCPP协议族作为通信的规则，其前身是美国的ARPANET。</li></ol><h2 id="因特网服务提供者ispinternet-service-provider">2.因特网服务提供者ISP(Internet Service Provider)</h2><ul><li>通过向ISP缴纳费用，拿到IP地址和通信线路，路由器等连网设备的使用权</li><li>同时，每个接入因特网的用户，也可以成为ISP，只需购买调制解调器或路由器这样的设备，让其他用户与之相连</li></ul><figure><img src="/2024/11/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2%E5%9B%A0%E7%89%B9%E7%BD%91%E6%A6%82%E8%BF%B0/image-20241115201435974.png" alt="image-20241115201435974"><figcaption aria-hidden="true">image-20241115201435974</figcaption></figure><h3 id="基于isp的三层结构的因特网">2.1 基于ISP的三层结构的因特网</h3><ul><li>第一层：国际性区域</li><li>第二层：区域性或国家性覆盖规模</li><li>第三层：本地ISP</li></ul><figure><img src="/2024/11/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2%E5%9B%A0%E7%89%B9%E7%BD%91%E6%A6%82%E8%BF%B0/image-20241115201638639.png" alt="image-20241115201638639"><figcaption aria-hidden="true">image-20241115201638639</figcaption></figure><h2 id="因特网的标准化工作">3. 因特网的标准化工作</h2><ol type="1"><li><p>因特网的标准化工作对因特网的发展起到了非常重要的作用。</p></li><li><p>因特网在制定其标准上的一个很大的特点是面向公众。</p><ol type="1"><li>因特网所有的<a href="http://www.ietf.org/rfc.html">RFC(Request ForComments)技术文档</a>都可从因特网上免费下载；</li><li>任何人都可以随时用电子邮件发表对某个文档的意见或建议。</li></ol></li><li><p>因特网协会ISOC是一个国际性组织，它负责对因特网进行全面管理，以及在世界范围内促进其发展和使用。</p><ol type="1"><li>因特网体系结构委员会IAB,负责管理因特网有关协议的开发：</li><li>因特网工程部ETF，负责研究中短期工程问题，主要针对协议的开发和标准化</li><li>因特网研究部IRTF,从事理论方面的研究和开发一些需要长期考虑的问题。</li></ol></li><li><p>制订因特网的正式标准要经过以下4个阶段：</p><ol type="1"><li>因特网草案（在这个阶段还不是RFC文档）</li><li>建议标准（从这个阶段开始就成为RFC文档） 因特网体系结构委员会A由</li><li>草案标准</li><li>因特网标准</li></ol><blockquote><p>只有一小部分RFC文档最后才能变成因特网标准</p></blockquote></li></ol><h2 id="因特网的组成">4. 因特网的组成</h2><ol type="1"><li><p>边缘部分</p><blockquote><p>由所有连接在因特网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据，音频或视频)和资源共享。</p></blockquote></li><li><p>核心部分</p><blockquote><p>由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）</p></blockquote><ol type="1"><li><strong>路由器</strong>是实现<strong>分组交换</strong>的关键构件，任务是<strong>转发收到的分组</strong></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>os</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github+hexo 搭建个人网站</title>
    <link href="/2024/11/12/hexo/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/"/>
    <url>/2024/11/12/hexo/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h1 id="配置环境">配置环境</h1><h2 id="安装准备">安装准备</h2><p>Git版本：Git-2.47.0.2-64-bit</p><p>Node.js版本：node-v22.11.0-x64</p><ol type="1"><li>官网下载，一路下一步安装即可。</li></ol><p>安装完成，右键git bash here，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git --version<br>node -v<br>npm -v<br></code></pre></td></tr></table></figure><p>安装成功，可查看版本。</p><ol start="2" type="1"><li>安装hexo:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo -g<br></code></pre></td></tr></table></figure><p>hexo 安装成功，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo -v<br></code></pre></td></tr></table></figure><h2 id="git-配置ssh-key">git 配置SSH key</h2><ol type="1"><li>生成key</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;xxx@qq.com&quot;</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>进入C:.ssh，进入ssh文件夹，复制id_rsa.pub文件里的所有内容</li><li>打开github主页，点击个人设置，点击左侧SSH and GPG keys，点击New SShkey</li><li>标题随便起，将复制的内容粘贴到Key，点击Add SSH key</li><li>测试是否成功，在git bash中输入：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -T git@github.com<br></code></pre></td></tr></table></figure><p><font style="color:rgb(83, 88, 97);">如果遇到选择，输入yes，看到成功即可。</font></p><ol start="6" type="1"><li>配置账号密码</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-comment">#你的github用户名</span><br>git config --global user.email <span class="hljs-string">&quot;xxx@163.com&quot;</span> <span class="hljs-comment">#填写你的github注册邮箱</span><br></code></pre></td></tr></table></figure><ol start="7" type="1"><li>安装部署插件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git -save<br></code></pre></td></tr></table></figure><h1 id="搭建个人博客">搭建个人博客</h1><ol type="1"><li>新建文件夹，初始化个人博客，右键打开git bash，输入</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init <span class="hljs-comment">#初始化</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>生成静态网页并预览</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g <span class="hljs-comment"># 生成静态页面</span><br>hexo s <span class="hljs-comment"># 预览</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li><p>打开网址即可预览</p></li><li><p>打开github创建与用户名同名的仓库：username.github.io，并查看主分支是main ormaster</p></li><li><p>打开博客目录下的_config.ymal，找到对应内容并修改</p></li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">git@github.com:username/username.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br></code></pre></td></tr></table></figure><ol start="6" type="1"><li>发布到github</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo d<br></code></pre></td></tr></table></figure><ol start="7" type="1"><li>新建博客</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new <span class="hljs-string">&#x27;blog-name&#x27;</span><br>hexo new title -p  <span class="hljs-string">&#x27;subdir/title&#x27;</span><br></code></pre></td></tr></table></figure><p>在source/_post目录下可查看新建的md文件。</p><p>注：可在hexo s服务开启的状态下修改问价内容查看预览内容。</p><p>要设置其他主题，可自行查找，博主参考Fluid风格的blog <a href="https://hexo.fluid-dev.com/docs/">Hexo Fluid 用户手册</a>。</p><h1 id="常见问题">常见问题</h1><h2 id="问题一">问题一</h2><p>当数学公式复杂的时候，默认的渲染引擎无法正常渲染，解决办法如下：</p><ol type="1"><li>windows安装pandoc<ol type="1"><li>下载win版本的msi文件，双击安装即可</li><li>本地安装pandoc，安装之后记得重启电脑哦，否则会报错捏！</li></ol></li><li>更换渲染引擎<ol type="1"><li>卸载 hexo-renderer-marked 和 hexo-math</li><li>安装 hexo-renderer-pandoc 和 hexo-filter-mathjax</li></ol></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm uninstall hexo-math --save<br>npm uninstall hexo-renderer-marked --save<br><br>npm install hexo-renderer-pandoc --save<br>npm install hexo-filter-mathjax --save<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>修改配置</li></ol><ul><li>打开 Hexo 根目录的 <code>_config.yml</code>文件，添加下面的代码：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json">mathjax<span class="hljs-punctuation">:</span><br>  tags<span class="hljs-punctuation">:</span> none # or &#x27;ams&#x27; or &#x27;all&#x27;<br>  single_dollars<span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span> # enable single dollar signs as in-line math delimiters<br>  cjk_width<span class="hljs-punctuation">:</span> <span class="hljs-number">0.9</span> # relative CJK char width<br>  normal_width<span class="hljs-punctuation">:</span> <span class="hljs-number">0.6</span> # relative normal (monospace) width<br>  append_css<span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span> # add CSS to pages rendered by MathJax<br>  every_page<span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span> # if <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> every page will be rendered by MathJax regardless the `mathjax` setting in Front-matter<br>  packages<span class="hljs-punctuation">:</span> # extra packages to load<br>  extension_options<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br>    # you can put your extension options here<br>    # see http<span class="hljs-punctuation">:</span><span class="hljs-comment">//docs.mathjax.org/en/latest/options/input/tex.html#tex-extension-options for more detail</span><br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>重新构建</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo clean<br>hexo g<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>在客户端使用 mathjax 渲染数学公式。注意：来包裹行内公式的 $和公式之间不能有空格，否则会渲染失败。如：</li></ol><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-built_in">$</span>a<span class="hljs-built_in">$</span> <span class="hljs-params">#</span>ok<br><span class="hljs-built_in">$</span> a <span class="hljs-built_in">$</span> <span class="hljs-params">#</span>不ok<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>个人博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rust todo</title>
    <link href="/2024/11/12/Rust/rust/"/>
    <url>/2024/11/12/Rust/rust/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu虚拟机磁盘扩容</title>
    <link href="/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/"/>
    <url>/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="ubuntu虚拟机磁盘空间不够如何扩容">Ubuntu虚拟机磁盘空间不够，如何扩容</h1><h2 id="一软件版本">一、软件版本</h2><p>1.vmware 15.5.0</p><p>2.ubuntu 20.04</p><h2 id="二操作步骤">二、操作步骤</h2><p>1.打开虚拟机设置，点击硬盘 <img src="/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/15fc8dc4f12fa5028a9388249f3af272.png" alt="在这里插入图片描述"></p><p>2.点击扩展 <img src="/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/03bf87f8780d1f5f0d7b6c7130f738ca.png" alt="在这里插入图片描述"></p><p>3.此处我由50G增加到70G，点击扩展 <img src="/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/19983adb5563d49266bf294485b59606.png" alt="在这里插入图片描述"></p><p>4.开启虚拟机</p><p>5.点击磁盘 <img src="/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/c8428adcd11dfe842401ab61e80d16f2.png" alt="在这里插入图片描述"></p><p>6.看到有21G的未分配的磁盘空间</p><figure><img src="/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/226cfc5dee27ecee83abb2ac08898792.png" alt="在这里插入图片描述"><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p>7.点击扩展分区</p><figure><img src="/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/e8a7616f83cfd499830719c53a862147.png" alt="在这里插入图片描述"><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p>8.点击设置</p><figure><img src="/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/6b93eb112dfe8bce5b66ddb825349451.png" alt="在这里插入图片描述"><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p>9.调整大小</p><p>10.把按钮拖动到最大，点击调整大小 <img src="/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/64180784c7a86f2bccc1103506efefda.png" alt="在这里插入图片描述"></p><p>11.选择文件系统进行同样的操作</p><p>12.在终端使用命令 df查看</p><figure><img src="/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/c8b5025526882a778881a1c67620328d.png" alt="在这里插入图片描述"><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p>扩容成功！！！！！！！！！</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
