<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>6.7 万维网WWW</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-7-%E4%B8%87%E7%BB%B4%E7%BD%91WWW/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-7-%E4%B8%87%E7%BB%B4%E7%BD%91WWW/</url>
    
    <content type="html"><![CDATA[<h1 id="6-7-万维网WWW"><a href="#6-7-万维网WWW" class="headerlink" title="6.7 万维网WWW"></a>6.7 万维网WWW</h1><blockquote><p>即 World Wide Web，是一个大规模的、联机式的信息储藏所，是运行在因特网上的一个分布式应用。</p></blockquote><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-7-%E4%B8%87%E7%BB%B4%E7%BD%91WWW/image-20241118192932067.png" alt="万维网文档"></p><ol><li><p>统一资源定位符URL</p><blockquote><p>万维网使用统一资源定位符URL来指明因特网上任何种类“资源”的位置。</p><p>其一般形式为：<code>&lt;协议&gt;：/∥&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;</code></p></blockquote></li><li><p>超文本传输协议HTTP</p><blockquote><p>超文本传输协议 HTTP (HyperText Transfer Protocol) 定义了浏览器（即万维网客户进程）<br>怎样向万维网服务器请求万维网文档以及万维网服务器怎样把万维网文档传送给浏览器。</p></blockquote><ol><li><p>HTTP1.0</p><blockquote><p>采用非持续连接方式。每次浏览器要请求一个文件都要与服务器建立TCP连接(80端口)，当收到响应后就立即关闭连接。</p><p>每请求一个文档就要有两倍的TT的开销。若一个网页上有很多引用对象（例如图片等），那么请求每一个对象都需要花费2RTT的时间。<br>为了减小时延，浏览器通常会建立多个并行的TCP连接同时请求多个对象。但是，这会大量占用万维网服务器的资源，特别是万维网服务器往往要同时服务于大量客户的请求，这会使其负担很重。</p></blockquote></li><li><p>HTTP1.1</p><blockquote><ol><li><p>采用持续连接方式。万维网服务器在发送响应后仍然保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。</p></li><li><p>为了进一步提高效率，还可采用流水线方式，即浏览器在收到HTTP的响应报文之前<br>就能够连续发送多个请求报文。</p></li></ol></blockquote></li></ol></li><li><p>HTTP两种报文——请求报文和响应报文</p><blockquote><p>报文中的每一个字段都是一些ASCII码串，并且每个字段的长度都是不确定的。</p></blockquote><ol><li><p>请求报文格式<br><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-7-%E4%B8%87%E7%BB%B4%E7%BD%91WWW/image-20241118222527016.png"></p></li><li><p>响应报文格式<br><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-7-%E4%B8%87%E7%BB%B4%E7%BD%91WWW/1689763996008.png" alt="1689763996008"></p></li></ol></li><li><p>Cookie技术</p><blockquote><p>Cookie提供了一种机制使得万维网服务器能够“记住”用户，而无需用户主动提供用户标识信息。<br>也就是说，Cookie是一种<strong>对无状态的HTTP进行状态化</strong>的技术。</p></blockquote><p><img src="https://raw.githubusercontent.com/Ag-epiphany/typora_Pictures/main/image-20230719184205348.png" alt="image-20230719184205348"></p></li><li><p>万维网缓存（Web缓存）</p><blockquote><p>在万维网中还可以使用缓存机制以提高万维网的效率。<br>可位于客户机，也可位于中间系统上，位于中间系统上的Web缓存又称为代理服务器。</p></blockquote><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-7-%E4%B8%87%E7%BB%B4%E7%BD%91WWW/image-20230719183530450.png" alt="image-20230719183530450"></p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>Last-Modified</td><td>最后修改时间</td></tr><tr><td>Expires</td><td>有效期</td></tr></tbody></table><ol><li>若过了最后有效期，则在客户机发来请求时，代理服务器向原始服务器发送请求得到新的数据<ol><li>若原始服务器的数据也未更改，则发回一个不带实体数据的响应报文，<br>代理服务器收到后更新有效期，将数据发给客户机</li><li>若原始服务器的数据更改，那么发回新数据的响应报文，代理服务器更新数据以及两个字段并将新数据发给客户机</li></ol></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.6 电子邮件</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-6-%E7%94%B5%E5%AD%90%E5%8D%8F%E8%AE%AE/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-6-%E7%94%B5%E5%AD%90%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="6-6-电子邮件"><a href="#6-6-电子邮件" class="headerlink" title="6.6 电子邮件"></a>6.6 电子邮件</h1><h2 id="1-电子邮件系统"><a href="#1-电子邮件系统" class="headerlink" title="1. 电子邮件系统"></a>1. 电子邮件系统</h2><blockquote><p>电子邮件系统采用客户&#x2F;服务器方式。三个主要组成构件：用户代理，邮件服务器以及电子邮件所需的协议</p></blockquote><ol><li>用户代理是用户与电子邮件系统的接口，又称为电子邮件客户端软件</li><li>邮件服务器是电子邮件系统的基础设施。因特网上所有的SP都有邮件服务器，其功能是发送和接收邮件，同时还要负责维护用户的邮箱。</li><li>协议包括邮件发送协议（例如SMTP)和邮件读取协议（例如POP3)。</li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-6-%E7%94%B5%E5%AD%90%E5%8D%8F%E8%AE%AE/image-20241118190659564.png"></p><h2 id="2-简单邮件传送协议SMTP"><a href="#2-简单邮件传送协议SMTP" class="headerlink" title="2. 简单邮件传送协议SMTP"></a>2. 简单邮件传送协议SMTP</h2><ol><li><p>基本工作原理</p><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-6-%E7%94%B5%E5%AD%90%E5%8D%8F%E8%AE%AE/image-20241118191131692.png"></p></li><li><p>SMTP协议只能传送ASCII码文本数据，不能传送可执行文件或其他的二进制对象。</p></li><li><p>SMTP不能满足传送多媒体邮件（例如带有图片、音频或视频数据）的需要。并且许多其他非英语国家的文字(例如中文、俄文、甚至带有重音符号的法文或德文)也无法用SMTP传送。</p></li><li><p>为解决SMTP传送非ASCII码文本的问题，提出了多用途因特网邮件扩展MIME</p><ol><li>增加了5个新的邮件首部字段，这些字段提供了有关邮件主体的信息。</li><li>定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。</li><li>定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变。</li></ol></li><li><p>实际上，MIME不仅仅用于SMTP,也用于后来的同样面向ASCII字符的HTTP。</p></li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-6-%E7%94%B5%E5%AD%90%E5%8D%8F%E8%AE%AE/image-20241118191715497.png"></p><h2 id="3-电子邮件的格式"><a href="#3-电子邮件的格式" class="headerlink" title="3. 电子邮件的格式"></a>3. 电子邮件的格式</h2><ul><li>一个电子邮件有信封和内容两部分。而内容又由首部和主体两部分构成。</li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-6-%E7%94%B5%E5%AD%90%E5%8D%8F%E8%AE%AE/image-20241118191547061.png"></p><ol><li>高亮部分为比较重要的部分，为必填项。</li></ol><h2 id="4-邮件读取协议"><a href="#4-邮件读取协议" class="headerlink" title="4. 邮件读取协议"></a>4. 邮件读取协议</h2><ol><li><p>邮局协议POP3</p><blockquote><p>非常简单、功能有限的邮件读取协议。用户只能以下载并删除方式或下载并保留方式从邮件服务器下载邮件到用户方计算机。不允许用户在邮件服务器上管理自己的邮件。</p></blockquote></li><li><p>因特网邮件访问协议IMAP</p><blockquote><p>功能比POP3强大的邮件读取协议。用户在自己的计算机上就可以操控邮件服务器中的邮箱，就像在本地操控一样，因此IMAP是一个联机协议。</p></blockquote></li><li><p>POP3和IMAP4都采用基于TCP连接的客户&#x2F;服务器方式。</p><ol><li>POP3使用端口110 </li><li>IMAP4使用端口143</li></ol></li></ol><h2 id="5-基于万维网的电子邮件"><a href="#5-基于万维网的电子邮件" class="headerlink" title="5. 基于万维网的电子邮件"></a>5. 基于万维网的电子邮件</h2><ul><li>通过浏览器登录（提供用户名和口令）邮件服务器万维网网站就可以撰写、收发、阅读和管理电子邮件。这种工作模式与IMAP很类似，不同的是用户计算机无需安装专门的用户代理程序，只需要使用通用的万维网浏览器。</li><li>这种工作摸式在用户浏览器与邮件服务器网站之间使用HTTP协议，而邮件服务器之间使用SMTP协议。</li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-6-%E7%94%B5%E5%AD%90%E5%8D%8F%E8%AE%AE/image-20241118192409368.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.5 文件传送协议FTP</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-5-%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AEFTP/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-5-%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AEFTP/</url>
    
    <content type="html"><![CDATA[<h2 id="6-5-文件传送协议FTP"><a href="#6-5-文件传送协议FTP" class="headerlink" title="6.5 文件传送协议FTP"></a>6.5 文件传送协议FTP</h2><ol><li>FTP提供交互式的访问，允许客户指明文件的类型与格式（如指明是否使用ASCII码），并允许文件具有存取权限（如访问文件的用户必须经过授权，并输入有效的口令）</li><li>FTP屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件</li></ol><h2 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1. 基本原理"></a>1. 基本原理</h2><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-5-%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AEFTP/image-20230719151544230.png"></p><ol><li>FTP客户和服务器之间要建立以下两个并行的TCP连接<ol><li>控制连接，在<strong>整个会话期间一直保持打开</strong>，用于传送FTP相关<strong>控制命令</strong></li><li>数据连接，用于文件传输，在<strong>每次文件传输时才建立</strong>，<strong>传输结束就关闭</strong></li></ol></li><li>默认情况下，FTP使用TCP 21端口进行控制连接，TCP 20端口进行数据连接。<br>但是，是否使用TCP20端口建立数据连接与传输模式有关，主动方式使用TCP 20端口<br>被动方式由服务器和客户端自行协商决定。</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.4 域名系统DNS</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-4-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-4-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS/</url>
    
    <content type="html"><![CDATA[<h1 id="6-4-域名系统DNS"><a href="#6-4-域名系统DNS" class="headerlink" title="6.4 域名系统DNS"></a>6.4 域名系统DNS</h1><h2 id="1-DNS介绍"><a href="#1-DNS介绍" class="headerlink" title="1. DNS介绍"></a>1. DNS介绍</h2><ol><li>域名系统DNS是因特网使用的命名系统，用来把便于人们记忆的具有特定含义的主机名（例如<a href="http://www.hust.cn),转换为便于机器处理的ip地址./">www.hust.cn),转换为便于机器处理的IP地址。</a></li><li>因特网是否可以只使用1台DNS服务器？<ol><li>这种做法并不可取。因为因特网的规摸很大，这样的域名服务器肯定会因为超负荷而无法正常工作，而且一旦域名服务器出现故障，整个因特网就会瘫痪。</li><li>早在1983年，因特网就开始采用层次结构的命名树作为主机的名字(即域名)，并使用分布式的域名系统DNS</li><li>DNS使大多数域名都在本地解析，仅少量解折需要在因特网上通信，因此系统效率很高。</li><li>由于DNS是分布式系统，即使单个计算机出了故障，也不会妨碍整个系统的正常运行</li></ol></li><li>域名和IP地址的映射关系必须保存在域名服务器中，供所有其他应用查询。显然不能将所有信息都储存在一台域名服务器中。DNS使用分布在各地的域名服务器来实现域名到IP地址的转换。</li><li>DNS报文使用运输层的UDP协议进行封装，运输层端口号为53</li></ol><h2 id="2-层次树状域名结构"><a href="#2-层次树状域名结构" class="headerlink" title="2. 层次树状域名结构"></a>2. 层次树状域名结构</h2><ol><li>因特网采用层次树状结构的域名结构…三级域名.二级域名.顶级域名<ol><li>每一级的域名都由英文字母和数字组成，不超过63个字符，不区分大小写字母。</li><li>级别最低的域名写在最左边，而级别最高的顶级域名写在最右边。</li><li>完整的域名不超过255个字符。</li></ol></li><li>域名系统既不规定一个域名需要包含多少个下级域名，也不规定每一级的域名代表什么意思。</li><li>各级域名由其上一级的域名管理机构管理，而最高的顶级域名则由因特网名称与数字地址分配机构CANN进行管理。</li></ol><h3 id="2-1-域名层次划分"><a href="#2-1-域名层次划分" class="headerlink" title="2.1 域名层次划分"></a>2.1 域名层次划分</h3><ol><li>顶级域名TLD（Top Level Domain）<ol><li>国家顶级域名nTLD<ol><li>采用IS03166的规定。如cn表示中国，us表示美国，uk表示英国、等等。</li></ol></li><li>通用顶级域名<ol><li>最常见的通用顶级域名有七个，即：com(公司企业)、net(网络服务机构)、org(非营利性组织)、int(国际组织)、edu(美国教育结构)、gov(美国政府部门)、mil(美国军事部门)。</li></ol></li><li>反向域（arpa）<ol><li>用于反向域名解析，即IP地址反向解析为域名。</li></ol></li></ol></li><li>在国家顶级域名下注册的二级域名均由该国家自行确定。例如，顶级域名为j的日本，将其教育和企业机构的二级域名定为ac和co,而不用edu和com。</li><li>我国则将二级域名划分为以下两类：<ol><li>类别域名<ol><li>共七个：ac(科研机构)、com(工、商、金融等企业)、edu(教育机构)、gov(政府部门)、net(提供网络服务的机构)、mil(军事机构)和org(非营利性组织)。</li></ol></li><li>行政区域名<ol><li>共34个，适用于我国的各省、自治区、直辖市。例如：b为北京市、sh为上海市、js为江苏省，等等。</li></ol></li></ol></li><li>顶级域名由ICANN管理，顶级域名以下的二级域名，三级域名等，都由其上一级域名管理机构自行管理。</li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-4-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS/image-20241118165949003.png"></p><h3 id="2-2-域名服务器类型"><a href="#2-2-域名服务器类型" class="headerlink" title="2.2 域名服务器类型"></a>2.2 域名服务器类型</h3><ul><li>域名和IP地址的映射关系必须保存在域名服务器中，供所有其他应用查询。显然不能将所有信息都储存在一台域名服务器中。DNS使用分布在各地的域名服务器来实现域名到IP地址的转换。</li></ul><ol><li>根域名服务器<ol><li>根域名服务器是最高层次的域名服务器。<br>每个根域名服务器都知道所有的顶级域名服务器的域名及其IP地址。<br>因特网上共有13个不同IP地址的根域名服务器。</li><li>尽管我们将这13个根域名服务器中的每一个都视为单个的服务器，但“每台服务器”实际上是由许多分布在世界各地的计算机构成的服务器群集。当本地域名服务器向根域名服务器发出查询请求时，路由器就把查询请求报文转发到离这个DNS客户最近的一个根域名服务器。<br>这就加快了DNS的查询过程，同时也更合理地利用了因特网的资源。</li><li>根域名服务器通常并不直接对域名进行解析，而是返回该域名所属顶级域名的顶级域名服务器的IP地址。</li></ol></li><li>顶级域名服务器<ol><li>这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名。<br>当收到DNS查询请求时就给出相应的回答（可能是最后的结果，也可能是下一级权限域名服务器的P地址)。</li></ol></li><li>权限域名服务器<ol><li>这些域名服务器负责管理某个区的域名。<br>每一个主机的域名都必须在某个权限域名服务器处注册登记。<br>因此权限域名服务器知道其管辖的域名与IP地址的映射关系。</li><li>另外，权限域名服务器还知道其下级域名服务器的地址</li></ol></li><li>本地域名服务器<ol><li>本地域名服务器不属于上述的域名服务器的等级结构。<br>当一个主机发出DNS请求报文时，这个报文就首先被送往该主机的本地域名服务器。</li><li>本地域名服务器起着代理的作用，会将该报文转发到上述的域名服务器的等级结构中。</li><li>每一个因特网服务提供者ISP，一个大学一个大学里的学院，都可以拥有一个本地域名服务器，它有时也称为默认域名服务器。本地域名服务器离用户较近，一般不超过几个路由器<br>的距离，也有可能就在同一个局域网中。</li><li>本地域名服务器的IP地址需要直接配置在需要域名解析的主机中，</li></ol></li></ol><h2 id="3-DNS域名解析两种方式"><a href="#3-DNS域名解析两种方式" class="headerlink" title="3. DNS域名解析两种方式"></a>3. DNS域名解析两种方式</h2><ul><li>递归解析和迭代解析</li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-4-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS/image-20230718233234205.png"></p><ol><li>为了提高DNS的查询效率，并减轻根域名服务器的负荷和减少因特网上的DNS查询报文数量，在域名服务器和主机中广泛地使用了高速缓存。</li><li>DNS报文使用运输层的UDP协议进行封装，运输层端口号为53</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.3 动态主机配置协议DHCP</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-3-%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AEDHCP/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-3-%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AEDHCP/</url>
    
    <content type="html"><![CDATA[<h1 id="6-3-动态主机配置协议DHCP"><a href="#6-3-动态主机配置协议DHCP" class="headerlink" title="6.3 动态主机配置协议DHCP"></a>6.3 动态主机配置协议DHCP</h1><ul><li>动态主机配置协议DHCP(Dynamic Host Configuration Protocol))提供了一种机制，称为即插即用连网。</li><li>这种机制允许一台计算机加入新网络时可自动获取P地址等网络配置信息而不用手工参与。</li></ul><ol><li><p>DHCP报文在运输层使用UDP协议封装</p><ol><li>DHCP客户使用的UDP端口号为68</li><li>DHCP服务器使用的UDP端口号为67</li></ol></li><li><p>客户端向DHCP服务器申请IP的全过程</p></li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-3-%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AEDHCP/image-20241118164104548.png"></p><ul><li><p>使用ARP检测所分配到的IP地址是否已被网络中其他主机占用：</p><ul><li>若被占用：给DHCP服务器发送“DHCP DECLINE”报文敬销IP地址租约，并重新发送“DHCP DISCOVER”报文；</li><li>若未被占用：可以使用租约中的P地址与网络中其他主机通信了。</li></ul></li><li><p>使用ARP确保所选IP地址未被网络中其他主机占用</p></li></ul><table><thead><tr><th>报文</th><th>包含字段</th></tr></thead><tbody><tr><td>DHCP DISCOVER</td><td>事务ID，DHCP的MAC地址</td></tr><tr><td>DHCP OFFER</td><td>事务ID，配置信息：IP地址，子网掩码，地址租期，默认网关，DNS服务器</td></tr><tr><td>DHCP REQUEST</td><td>事务ID，DHCP的MAC地址，接受的租约中的IP地址，提供此租约的DHCP服务器的IP地址</td></tr></tbody></table><ol start="3"><li>DHCP中继代理</li></ol><blockquote><p>路由器不会转发普通的广播分组，并且我们也不希望在每个网络中都配置一台DHCP服务器，所以DHCP中继代理出现了。</p></blockquote><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-3-%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AEDHCP/image-20241118164332043.png"></p><ul><li>DHCP DISCOVER:DHCP发现报文</li><li>DHCP OFFER:DHCP提供报文</li><li>DHCP REQUEST:DHCP请求报文</li><li>DHCP ACK:DHCP确认报文</li><li>DHCP NACK:DHCP否认报文</li><li>DHCP RELEASE:DHCP释放报文</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.2 客户服务器方式和对等方式</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-2-%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%B9%E5%BC%8F%E5%92%8C%E5%AF%B9%E7%AD%89%E6%96%B9%E5%BC%8F/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-2-%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%B9%E5%BC%8F%E5%92%8C%E5%AF%B9%E7%AD%89%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="6-2-客户-服务器方式（C-S）和对等方式（P2P方式）"><a href="#6-2-客户-服务器方式（C-S）和对等方式（P2P方式）" class="headerlink" title="6.2 客户&#x2F;服务器方式（C&#x2F;S）和对等方式（P2P方式）"></a>6.2 客户&#x2F;服务器方式（C&#x2F;S）和对等方式（P2P方式）</h1><ul><li>网络应用程序运行在处于网络边缘的不同的端系统上，通过彼此间的通信来共同完成某项任务。</li><li>开发一种新的网络应用首先要考虑的问题就是网络应用程序在各种端系统上的组织方式和它们之间的关系。目前流行的主要有以下两种：<ul><li>客户&#x2F;服务器(Client&#x2F;Server,C&#x2F;S)方式</li><li>对等(Peer-to-Peer,P2P)方式</li></ul></li></ul><h2 id="1-客户-服务器-Client-Server-C-S-方式"><a href="#1-客户-服务器-Client-Server-C-S-方式" class="headerlink" title="1. 客户&#x2F;服务器(Client&#x2F;Server,C&#x2F;S)方式"></a>1. 客户&#x2F;服务器(Client&#x2F;Server,C&#x2F;S)方式</h2><ul><li><p>C&#x2F;S方式</p><ul><li>客户和服务器是指通信中所涉及的两个应用进程。</li><li>客户&#x2F;服务器方式所描述的是进程之间服务和被服务的关系。</li><li>客户是服务请求方，服务器是服务提供方。</li><li>服务器总是处于运行状态，并等待客户的服务请求。服务器具有固定端口号（例如HTTP服务器的默认端口号为80)，而运行服务器的主机也具有固定的P地址。</li></ul></li><li><p>C&#x2F;S方式是因特网上传统的、同时也是最成熟的方式，很多我们熟悉的网络应用采用的都是C&#x2F;S方式。包括万维网WWW、电子邮件、文件传输FTP等。</p></li><li><p>基于C&#x2F;S方式的应用服务通常是服务集中型的，即应用服务集中在网络中比客户计算机少得多的服务<br>器计算机上。</p><ul><li>由于一台服务器计算机要为多个客户机提供服务，在C&#x2F;S应用中，常会出现服务器计算机跟不上众多客户机请求的情况。</li><li>为此，在C&#x2F;S应用中，常用计算机群集（或服务器场）构建一个强大的虚拟服务器。</li></ul></li></ul><h2 id="2-对等方式（P2P方式）"><a href="#2-对等方式（P2P方式）" class="headerlink" title="2. 对等方式（P2P方式）"></a>2. 对等方式（P2P方式）</h2><ul><li><p>P2P方式</p><ul><li>在P2P方式中，没有固定的服务请求者和服务提供者，分布在网络边缘各端系统中的应用进程是对等的，被称为对等方。</li><li>对等方相互之间直接通信，每个对等方既是服务的请求者，又是服务的提供者。</li></ul></li><li><p>目前，在因特网上流行的P2P应用主要包括P2P文件共享、即时通信、P2P流媒体、分布式存储等。</p></li><li><p>基于P2P的应用是服务分散型的，因为服务不是集中在少数几个服务器计算机中，而是分散在大量对等计算机中，这些计算机并不为服务提供商所有，而是为个人控制的桌面计算机和笔记本电脑，它们通常位于住宅、校园和办公室中。</p></li><li><p>P2P方式的最突出特性之一就是它的可扩展性。因为系统每增加一个对等方，不仅增加的是服务的请求者，同时也增加了服务的提供者，系统性能不会因规摸的增大而降低。</p></li><li><p>P2P方式具有成本上的优势，因为它通常不需要庞大的服务器设施和服务器带宽。为了降低成本，服务提供商对于将P2P方式用于应用的兴趣越来越大。</p></li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-2-%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%B9%E5%BC%8F%E5%92%8C%E5%AF%B9%E7%AD%89%E6%96%B9%E5%BC%8F/image-20241118162748601.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.1 应用层概述</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-1-%E5%BA%94%E7%94%A8%E5%B1%82%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-1-%E5%BA%94%E7%94%A8%E5%B1%82%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="6-1-应用层"><a href="#6-1-应用层" class="headerlink" title="6.1 应用层"></a>6.1 应用层</h1><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-1-%E5%BA%94%E7%94%A8%E5%B1%82%E6%A6%82%E8%BF%B0/image-20241118161627816.png"></p><ul><li>应用层是计算机网络体系结构的最顶层，是设计和建立计算机网络的最终目的，也是计算机网络中发展最快的部分。<ul><li>早期基于文本的应用（电子邮件、远程登绿、文件传输、新闻组）<ul><li>20世纪90年代将因特网带入干家万户的万维网WWW</li></ul></li><li>当今流行的即时通信、P2P文件共享及各种音视频应用计算设备的小型化和“无处不在”，宽带住宅接入和无线接入的日益普及和迅速发展，为未来更多的新型应用提供了广阔的舞台。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.9 TCP报文段的首部格式</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-9-TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-9-TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="5-9-TCP报文段的首部格式"><a href="#5-9-TCP报文段的首部格式" class="headerlink" title="5.9 TCP报文段的首部格式"></a>5.9 TCP报文段的首部格式</h1><ul><li>为了实现可靠传输，TCP采用了面向字节流的方式。</li><li>但TCP在发送数据时，是从发送缓存取出一部分或全部字节并给其添加一个首部使之成为TCP报文段后进行发送。<ul><li>一个TCP报文段由首部和数据载荷两部分构成；</li><li>TCP的全部功能都体现在它首部中各字段的作用。</li></ul></li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-9-TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F/image-20241118153709722.png"></p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>源端口</td><td>占16比特，写入源端口号，用来标识发送该TCP报文段的应用进程</td></tr><tr><td>目的端口</td><td>占16比特，写入目的端口号，用来标识接收该TCP报文段的应用进程</td></tr><tr><td>序号</td><td>占32比特，取值范围[0,2^32^-1]，序号增加到最后一个后，下一个序号就又回到0。<br>指出本TCP报文段数据载荷的第一个字节的序号。</td></tr><tr><td>确认号</td><td>占32比特，取值范围[0,2^32^-1]，确认号增加到最后一个后，下一个确认号就又回到0。<br>指出期望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，同时也是对之前收到的所有数据的确认。</td></tr><tr><td>确认标志位ACK</td><td>取值为1时确认号字段才有效：取值为0时确认号字段无效</td></tr><tr><td>数据偏移</td><td>占4比特，并以4字节为单位。<br>用来指出TCP报文段的数据载荷部分的起始处距离TCP报文段的起始处有多远。</td></tr><tr><td>保留</td><td>占6比特，保留为今后使用，但目前应置为0。</td></tr><tr><td>窗口</td><td>占16比特，以字节为单位。指出发送本报文段的一方的接收窗口。<br>窗口值作为接收方让发送方设置其发送窗口的依据。<br>这是以接收方的接收能力来控制发送方的发送能力，称为流量控制。</td></tr><tr><td>校验和</td><td>占16比特，检查范围包括TCP报文段的首部和数据载荷两部分。<br>在计算校验和时，要在TCP报文段的前面加上12字节的伪首部。</td></tr><tr><td>同步标志位SYN</td><td>在TCP连接建立时用来同步序号</td></tr><tr><td>终止标志位FIN</td><td>用来释放TCP连接。</td></tr><tr><td>复位标志位RST</td><td>用来复位TCP连接。<br>当RST&#x3D;1时，表明TCP连接出现了异常，必须释放连接，然后再重新建立连接。<br>RST置1还用来拒绝一个非法的报文段或拒绝打开一个TCP连接。</td></tr><tr><td>推送标志位PSH</td><td>接收方的TCP收到该标志位为1的报文段会尽快上交应用进程。<br>而不必等到接收缓存都填满后再向上交付。</td></tr><tr><td>紧急标志位URG</td><td>取值为1时紧急指针字段有效：取值为0时紧急指针字段无效。</td></tr><tr><td>紧急指针</td><td>占16比特，以字节为单位，用来指明紧急数据的长度。</td></tr><tr><td>选项</td><td>1. 最大报文段长度MSS选项：TCP报文段数据载荷部分的最大长度。<br>2. 窗口扩大选项：为了扩大窗口（提高吞吐率）<br>3. 时间戳选项：<br>     a. 用来计算往返时间RTT<br>     b. 用于处理序号超范围的情况，又称为防止序号绕回PAWS。<br>4. 选择确认选项<br>选项的作用是为了扩展TCP报文段首部的功能</td></tr><tr><td>填充</td><td>由于选项的长度可变，因此使用填充来确保报文段首部能被4整除<br>(因为数据偏移字段，也就是首部长度字段，是以4字节为单位的)</td></tr></tbody></table><ul><li>紧急数据：<ul><li>当发送方有紧急数据时，可将紧急数据插队到发送缓存的最前面，并立刻封装到一个TCP报文段中进行发送。</li><li>紧急指针会指出本报文段数据载荷部分包含了多长的紧急数据，紧急数据之后是普通数据。</li><li>接收方将紧急数据部分取出，并直接上交应用程序，而不必在接受缓存中排队。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.8 TCP的运输连接管理</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-8-TCP%E7%9A%84%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-8-TCP%E7%9A%84%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="5-8-TCP的运输连接管理"><a href="#5-8-TCP的运输连接管理" class="headerlink" title="5.8 TCP的运输连接管理"></a>5.8 TCP的运输连接管理</h1><ul><li>TCP是面向连接的协议，它基于运输连接来传送TCP报文段。</li><li>TCP运输连接的建立和释放是每一次面向连接的通信中必不可少的过程。</li><li>TCP运输连接有以下三个阶段：<ul><li>建立TCP连接</li><li>数据传送</li><li>释放TCP连接</li></ul></li><li>TCP的运输连接管理就是使运输连接的建立和释放都能正常地进行。</li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-8-TCP%E7%9A%84%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/image-20241118150137225.png"></p><h2 id="1-TCP的连接建立（三次握手）"><a href="#1-TCP的连接建立（三次握手）" class="headerlink" title="1. TCP的连接建立（三次握手）"></a>1. TCP的连接建立（三次握手）</h2><blockquote><p>TCP的连接建立要解决以下三个问题：</p><ol><li>使TCP双方能够确知对方的存在</li><li>使TCP双方能够协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）</li><li>使TCP双方能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。</li></ol></blockquote><ol><li><p>三次握手建立连接的过程</p><blockquote><p>也就是使用三个TCP报文建立连接</p><ul><li>传输控制块<ul><li>TCP连接表</li><li>指向发送和接收缓存的指针</li><li>指向重传队列的指针</li><li>当前的发送和接收序号</li></ul></li></ul></blockquote><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-8-TCP%E7%9A%84%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/image-20230718175005023.png" alt="image-20230718175005023"></p></li><li><p>两报文建立连接会发生以下问题<br><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-8-TCP%E7%9A%84%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/image-20230718175045894.png" alt="image-20230718175045894"></p></li><li><p>注意<br>(1)TCP的标准规定，SYN&#x3D;1的报文段不能携带数据，但要消耗掉一个序号。<br>(2)TCP的标准规定，普通的确认报文段如果不携带数据，则不消耗序号。</p></li></ol><h2 id="2-TCP的连接释放（四次挥手）"><a href="#2-TCP的连接释放（四次挥手）" class="headerlink" title="2. TCP的连接释放（四次挥手）"></a>2. TCP的连接释放（四次挥手）</h2><ol><li><p>四报文挥手过程<br><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-8-TCP%E7%9A%84%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/image-20230718182458129.png" alt="image-20230718182458129"></p></li><li><p>若不等待2MSL则有可能发生以下情况</p><blockquote><p>最后一个确认报文丢失，导致服务器进程陷入最后确定状态，无法进入关闭状态</p></blockquote><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-8-TCP%E7%9A%84%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/image-20230718182524772.png" alt="image-20230718182524772"></p></li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-8-TCP%E7%9A%84%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/image-20241118153322909.png"></p><ul><li>TCP服务器进程每收到一次TCP客户进程的数据，就重新设置并启动保活计时器(2小时定时)</li><li>若保活计时器定时周期内未收到TCP客户进程发来的数据，则当保活计时器到时后，TCP服务器进程就向TP客户进程发送一个探测报文段，以后则每隔75秒钟发送一次。若一连发送10个探测报文段后仍无TCP客户进程的响应，TCP服务器进程就认为TCP客户进程所在主机出了故障，接着就关闭这个连接。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.7 TCP可靠传输的实现</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-7-TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-7-TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="5-7-TCP可靠传输的实现"><a href="#5-7-TCP可靠传输的实现" class="headerlink" title="5.7 TCP可靠传输的实现"></a>5.7 TCP可靠传输的实现</h1><ol><li><p>TCP基于以<strong>字节为单位的滑动窗口</strong>来实现可靠传输。</p><ol><li><p>发送方在未收到接收方的确认时，可将发送窗口内还未发送的数据全部发送出去</p></li><li><p>接收方只接收序号落入发送窗口内的数据</p><blockquote><p>虽然发送方的发送窗口是根据接收方的接收窗口设置的，<br>但在同一时刻，发送方的发送窗口并不总是和接收方的接收窗口一样大。</p></blockquote></li><li><p>网络传送窗口值需要经历一定的时间滞后，井且这个时间还是不确定的。</p></li><li><p>发送方还可能根据网络当时的拥塞情况适当减小自己的发送窗口尺寸</p></li></ol></li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-7-TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20241118144647353.png"></p><ol start="2"><li><p>对于不按序到达的数据应如何处理，TCP并无明确规定</p><ol><li>如果接收方把不按序到达的数据一律丢弃，那么接收窗口的管理将会比较简单，<br>但这样做对网络资源的利用不利，因为发送方会重复传送较多的数据。</li><li>TCP通常对不按序到达的数据是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程</li><li>TCP要求接收方必须有累积确认和捎带确认机制，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。<ol><li>接收方不应过分推迟发送确认，否则会导致发送方不必要的超时重传，这反而浪费了网络的资源。</li><li>TCP标准规定，确认推迟的时间不应超过0.5秒。若收到一连串具有最大长度的报文段，则必须每隔一个报文段就发送一个确认</li><li>梢带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。</li></ol></li></ol></li><li><p>TCP的通信是全双工通信。</p><blockquote><p>通信中的每一方都在发送和接收报文段。<br>因此，每一方都有自己的发送窗口和接收窗口。在谈到这些窗口时，一定要弄清楚是哪一方的窗口。</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.6 TCP超时重传时间的选择</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-6-TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4%E7%9A%84%E9%87%8D%E4%BC%A0/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-6-TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4%E7%9A%84%E9%87%8D%E4%BC%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="5-6-TCP超时重传的时间的选择（RTO）"><a href="#5-6-TCP超时重传的时间的选择（RTO）" class="headerlink" title="5.6 TCP超时重传的时间的选择（RTO）"></a>5.6 TCP超时重传的时间的选择（RTO）</h1><ul><li>利用每次测量得到的RTT样本，计算加权平均往返时间RTTs(又称为平滑的往返时间)。</li><li>超时重传的时间应略大于RTTs的值。</li></ul><ol><li><p>计算RTT<del>S</del><br>$$<br>初始RTT_S &#x3D; 测得的第一个RTT<br>$$<br>$$<br> RTTs &#x3D; (1-\alpha)\times 旧的RTTs + \alpha \times 新的RTT样本<br>$$<br>建议 $\alpha$ &#x3D; 0.125</p></li><li><p>计算RTT<del>D</del><br>$$<br>初始RTT_D &#x3D; \frac{RTT_1}{2}\<br>RTT_D &#x3D; (1 - \beta) \times 旧的RTT_D + \beta \times \vert RTT_S - 新的RTT样本 \vert<br>$$<br>建议$\beta$ &#x3D; 0.25</p></li><li><p>针对出现超时重传时无法测准往返时间RTT的问题，Kan提出了一个算法：在计算<br>加权平均往返时间RTTs时，只要报文段重传了，就不采用其往返时间RTT样本。也<br>就是出现重传时，不重新计算RTTs,进而超时重传时间RTO也不会重新计算。</p></li><li><p>这又引起了新的问题。设想出现这样的情况：报文段的时延突然增大了很多，并目<br>之后很长一段时间都会保持这种时延。因此在原来得出的重传时间内，不会收到确<br>认报文段。于是就重传报文段。但根据Kar算法，不考虑重传的报文段的往返时间<br>样本。这样，超时重传时间就无法更新。这会导致报文段反复被重传。</p></li><li><p>因此，要对Kan算法进行修正。方法是：报文段每重传一次，就把超时重传时间<br>RTO增大一些。典型的做法是将新RTO的值取为旧RTO值的2倍。</p></li><li><p>计算超时重传时间<br>$$<br>RTO &#x3D; RTT_S + 4 \times RTT_D<br>$$<br>只要某报文段超时重传，就将RTO设为原来的两倍，而不是按照上述公式计算</p></li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-6-TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4%E7%9A%84%E9%87%8D%E4%BC%A0/image-20241118125512601.png"></p><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-6-TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4%E7%9A%84%E9%87%8D%E4%BC%A0/image-20241118125933926.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.5 TCP的拥塞控制</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-5-TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-5-TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="5-5-TCP拥塞控制"><a href="#5-5-TCP拥塞控制" class="headerlink" title="5.5 TCP拥塞控制"></a>5.5 TCP拥塞控制</h1><ol><li>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏。这种情况就叫做拥塞(congestion)。</li><li>在计算机网络中的链路容量（即带宽）、交换结点中的缓存和处理机等，都是网络的资源。</li><li>若出现拥塞而不进行控制，整个网络的吞吐量将随输入负荷的增大而下降。</li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-5-TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/image-20241118122339061.png"></p><h2 id="1-拥塞避免算法"><a href="#1-拥塞避免算法" class="headerlink" title="1. 拥塞避免算法"></a>1. 拥塞避免算法</h2><ul><li>下面介绍这四种拥塞控制算法的基本原理，假定如下条件：<ul><li>数据是单方向传送，而另一个方向只传送确认。</li><li>接收方总是有足够大的缓存空间，因而发送方发送窗口的大小由网络的拥塞程度来决定。</li><li>以最大报文段MSS的个数为讨论问题的单位，而不是以字节为单位。</li></ul></li></ul><h3 id="1-1-慢开始与拥塞避免算法"><a href="#1-1-慢开始与拥塞避免算法" class="headerlink" title="1.1 慢开始与拥塞避免算法"></a>1.1 慢开始与拥塞避免算法</h3><ol><li><p>发送方维护一个叫做拥塞窗口cwd的状态变量，其值取决于网络的拥塞程度，并且动态变化。</p><ol><li><p>拥塞窗口cwd的维护原则</p><ol><li>只要网络没有出现拥塞，拥塞窗口就再增大一些；</li><li>但只要网络出现拥塞，拥塞窗口就减少一些。</li><li>具体做法<ol><li>发生超时重传后，将门限ssthresh设为拥塞窗口的一半，并将当前拥塞窗口设为1</li><li>重新运行开始慢开始算法</li></ol></li></ol></li><li><p>判断出现网络拥塞的依据</p><blockquote><p>没有按时收到应当到达的确认报文（即发生超时重传）。</p></blockquote></li></ol></li><li><p>发送方将拥塞窗口作为发送窗口swnd,即 swnd&#x3D;cwnd。</p></li><li><p>维护一个慢开始门限ssthresh状态变量</p><ol><li>当cwnd&lt;ssthresh时，使用慢开始算法</li><li>当cwnd&gt;ssthresh时，停止使用慢开始算法而改用拥塞避免算法：</li><li>当cwnd&#x3D;ssthresh时，既可使用慢开始算法，也可使用拥塞避免算法。</li></ol></li><li><p>慢开始指数增长，从1开始，每次×2</p></li><li><p>拥塞避免，拥塞窗口每次加1</p></li><li><p>出现拥塞，ssthresh值更新为cwnd的一半</p></li><li><p>cwnd值置为1，再重新开始慢开始算法</p></li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-5-TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/image-20241118123625970.png"></p><ul><li><p>“慢开始”是指一开始向网络注入的报文段少，并不是指拥塞窗口cwd增长速度慢；</p></li><li><p>“拥塞避免”并非指完全能够避免拥塞，而是指在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞</p></li><li><p>慢开始和拥塞避免算法是1988年提出的TCP拥塞控制算法(TCP Tahoe版本)</p></li><li><p>1990年又增加了两个新的拥塞控制算法（改进TCP的性能），这就是快重传和快恢复(TCP Reno.版本)。</p><ul><li>有时，个别报文段会在网络中丢失，但实际上网络并未发生拥塞。<ul><li>这将导致发送方超时重传，并误认为网络发生了拥塞；</li><li>发送方把拥塞窗口cwd又设置为最小值1，并错误地启动慢开始算法，因而降低了传输效率</li></ul></li></ul></li><li><p>采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。</p></li><li><p>所谓快重传，就是使发送方尽快进行重传，而不是等超时重传计时器超时再重传。</p></li></ul><h3 id="1-2-快重传与快恢复"><a href="#1-2-快重传与快恢复" class="headerlink" title="1.2 快重传与快恢复"></a>1.2 快重传与快恢复</h3><ol><li>要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认</li><li>即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。</li><li>发送方一旦<strong>收到3个连续的重复确认</strong>，就将相应的报文段立即重传，<br>而不是等该报文段的超时重传计时器超时再重传。</li><li>对于个别丢失的报文段，发送方不会出现超时重传，也就不会误认为出现了拥塞（进而降低拥塞窗口cwd为1）。使用快重传可以使整个网络的吞吐量提高约20%。</li><li>发送方一旦收到3个重复确认，就知道现在只是丢失了个别的报文段。<br>于是不启动慢开始算法，而执行<strong>快恢复算法</strong><ol><li>发送方将慢开始<strong>门限ssthresh值</strong>和<strong>拥塞窗口cwnd值</strong>调整为<strong>当前窗口的一半</strong></li><li>开始执行拥塞避免算法。</li><li>也有的快恢复实现是把快恢复开始时的拥塞窗口cwnd值再增大一些，即等于新的ssthresh+3。<ol><li>既然发送方收到3个重复的确认，就表明有3个数据报文段已经离开了网络，这3个报文段不再消耗网络资源而是停留在接收方的接收缓存中，可见现在网络中不是堆积了报文段而是减少了3个报文段。因此可以适当把拥塞窗口扩大些。</li></ol></li></ol></li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-5-TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/image-20241118124545558.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.4 TCP的流量控制</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-4-TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-4-TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><ul><li><p>所谓流量控制 ( flow control )就是让发送方的发送速率不要太快，要让接收方来得及接收。</p></li><li><p>TCP接收方利用自己的接收窗口的大小来限制发送方发送窗口的大小。</p></li></ul><p>$$<br>发送窗口 &#x3D; Min(发送方拥塞窗口，接受方接收窗口)<br>$$</p><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-4-TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/image-20241118120929780.png" alt="image-20241118120929780"></p><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-4-TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/image-20241118121512615.png"></p><p>注意</p><ol><li>TCP发送方收到接收方的零窗口通知后，应启动持续计时器。持续计时器超时后，向接收方发送零窗口探测报文。</li></ol><blockquote><p>若是零窗口探测报文传输过程中丢失，则在其重发计数器超时后重发该报文</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.3 UDP和TCP的对比</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-3-UDP%E5%92%8CTCP%E7%9A%84%E5%AF%B9%E6%AF%94/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-3-UDP%E5%92%8CTCP%E7%9A%84%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<h1 id="5-3-UDP和TCP的对比"><a href="#5-3-UDP和TCP的对比" class="headerlink" title="5.3 UDP和TCP的对比"></a>5.3 UDP和TCP的对比</h1><ul><li>用户数据报协议UDP:(User Datagram Protocol)<ul><li>无连接</li></ul></li><li>传输控制协议TCP：Transmission Control Protocol<ul><li>面向连接</li></ul></li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-3-UDP%E5%92%8CTCP%E7%9A%84%E5%AF%B9%E6%AF%94/image-20241118111939771.png"></p><ul><li>UDP支持单播、多播以及广播</li><li>TCP仅支持单播</li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-3-UDP%E5%92%8CTCP%E7%9A%84%E5%AF%B9%E6%AF%94/image-20241118112226603.png"></p><ul><li>UDP是面向应用报文的</li><li>TCP是面向字节流的</li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-3-UDP%E5%92%8CTCP%E7%9A%84%E5%AF%B9%E6%AF%94/image-20241118112458492.png"></p><ul><li>UDP向上层提供无连接不可靠传输服务(适用于IP电话、视频会议等实时应用)</li><li>TCP向上层提供面向连接的可靠传输服务(适用于要求可靠传输的应用，例如文件传输)</li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-3-UDP%E5%92%8CTCP%E7%9A%84%E5%AF%B9%E6%AF%94/image-20241118112750466.png"></p><ul><li>UDP用户数据报首部仅8字节</li><li>TCP报文段首部最小20字节，最大60字节</li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-3-UDP%E5%92%8CTCP%E7%9A%84%E5%AF%B9%E6%AF%94/image-20241118112843761.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.2 运输层端口号、复用与分用的概念</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-2-%E8%BF%90%E8%BE%93%E5%B1%82%E7%AB%AF%E5%8F%A3%E5%8F%B7-%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%88%86%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-2-%E8%BF%90%E8%BE%93%E5%B1%82%E7%AB%AF%E5%8F%A3%E5%8F%B7-%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%88%86%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="5-2-运输层端口号，复用，分用"><a href="#5-2-运输层端口号，复用，分用" class="headerlink" title="5.2 运输层端口号，复用，分用"></a>5.2 运输层端口号，复用，分用</h1><h2 id="1-端口号"><a href="#1-端口号" class="headerlink" title="1. 端口号"></a>1. 端口号</h2><ol><li><p>因为因特网上的计算机并不是使用统一的操作系统，不同的操作系统又使用不同格式的进程标识符，为了使运行不同操作系统的计算机的应用进程之间能够进行网络通信，就必须使用统一的方法对TCP&#x2F;IP体系的应用进程进行标识。</p></li><li><p>TCP&#x2F;IP体系的运输层使用端口号来区分应用层的不同应用进程，端口号使用16比特表示，取值范围 [0,65535]。</p></li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-2-%E8%BF%90%E8%BE%93%E5%B1%82%E7%AB%AF%E5%8F%A3%E5%8F%B7-%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%88%86%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5/image-20241118110803598.png" alt="端口号的划分"></p><ol start="3"><li>端口号只具有本地意义，即端口号只是为了标识本计算机应用层中的各进程，在因特网中，不同计算机中的相同端口号是没有联系的。</li></ol><h2 id="2-发送方的复用和接收方的分用"><a href="#2-发送方的复用和接收方的分用" class="headerlink" title="2. 发送方的复用和接收方的分用"></a>2. 发送方的复用和接收方的分用</h2><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-2-%E8%BF%90%E8%BE%93%E5%B1%82%E7%AB%AF%E5%8F%A3%E5%8F%B7-%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%88%86%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5/image-20241118111045703.png"></p><ol><li>TCP&#x2F;IP体系的应用层常用协议所使用运输层的熟知端口号</li></ol><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-2-%E8%BF%90%E8%BE%93%E5%B1%82%E7%AB%AF%E5%8F%A3%E5%8F%B7-%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%88%86%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5/image-20241118111132310.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.1 运输层概述</title>
    <link href="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-1-%E8%BF%90%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-1-%E8%BF%90%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="5-1-运输层概述"><a href="#5-1-运输层概述" class="headerlink" title="5.1 运输层概述"></a>5.1 运输层概述</h1><ul><li><p>实际上在计算机网络中进行通信的真正实体是位于通信两端主机中的进程</p></li><li><p>如何为运行在不同主机上的应用进程提供直接的通信服务是运输层的任务，运输层协议又称为端到端协议。</p></li><li><p>运输层向高层用户屏蔽了下面网络核心的细节（如网络拓扑、所采用的路由选择协议等)，它使应用进程看见的就好像是在两个运输层实体之间有一条端到端的逻辑通信信道。</p></li><li><p>根据应用需求的不同，因特网的运输层为应用层提供了两种不同的运输协议，即面向连接的TCP和无连接的UDP,这两种协议就是本章要讨论的主要内容。</p></li></ul><p><img src="/2024/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-1-%E8%BF%90%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0/image-20241118110058782.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.9 虚拟专用网VPN与网络地址转换NAT</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-9-%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91VPN%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2NAT/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-9-%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91VPN%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2NAT/</url>
    
    <content type="html"><![CDATA[<h1 id="4-9-虚拟专用网络VPN与网络地址转换NAT"><a href="#4-9-虚拟专用网络VPN与网络地址转换NAT" class="headerlink" title="4.9 虚拟专用网络VPN与网络地址转换NAT"></a>4.9 虚拟专用网络VPN与网络地址转换NAT</h1><h2 id="1-VPN"><a href="#1-VPN" class="headerlink" title="1. VPN"></a>1. VPN</h2><ul><li>利用公用的因特网作为本机构各专用网之间的通信载体，这样的专用网又称为虚拟专用网。</li><li>VPN要保证传输数据的安全性，会将原始的内部数据报进行加密，然后再将其封装成为在因特网上发送到的外部数据报。</li></ul><ol><li>VPN类型<ol><li>同一机构内不同部门的内部网络所构成的虚拟专用网VPN又称为内联网VPN</li><li>有时一个机构的VPN需要有某些外部机构（通常就是合作伙伴）参加进来。这样的VPN就称为外联网VPN</li><li>在外地工作的员工需要访问公司内部的专用网络时，只要在任何地点接入到因特网，运行驻留在员工PC中的VPN软件，在员工的PC和公司的主机之间建立VPN隧道，即可访问专用网络中的资源。这种VPN称为远程接入VPN。</li></ol></li></ol><h2 id="2-NAT"><a href="#2-NAT" class="headerlink" title="2. NAT"></a>2. NAT</h2><ul><li>NAT能使大量使用内部专用地址的专用网络用户共享少量外部全球地址来访问因特网上的主机和资源。</li><li>传统NAT是将每个本地IP转换为一个公有IP，意味着路由器中NAT映射表记录N个全球IP，则对应的子网最多只能有N台主机，这不符预期。</li></ul><ol><li>由于绝大多数的网络应用都是使用运输层协议TCP或UDP来传送数据，因此可以利用运输层的端口号和IP地址一起进行转换。<ol><li>这样用一个全球P地址就可以使多个拥有本地地址的主机同时和因特网上的主机进行通信。这种将端口号和P地址一起进行转换的技术叫作网络地址与端口号转换NAPT (Network Address and Port Translation)。</li></ol></li><li>收到来自外网的IP数据报后，在NAPT转换表中找不到相应的记录！</li><li>对于一些P2P网络应用，需要外网主机主动与内网主机进行通信，在通过NAT时会遇到问题，需要网络应用自己使用一些特殊的NAT穿越技术来解决问题。</li><li>由于NAT对外网屏蔽了内网主机的网络地址，能为内网的主机提供一定的安全保护。</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-9-%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91VPN%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2NAT/image-20241118104142578.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.8 网际控制报文协议</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-8-%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-8-%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="4-8-网际控制报文协议ICMP"><a href="#4-8-网际控制报文协议ICMP" class="headerlink" title="4.8 网际控制报文协议ICMP"></a>4.8 网际控制报文协议ICMP</h1><ul><li>为了更有效地转发P数据报和提高交付成功的机会，在网际层使用了网际控制报文协议<ul><li>主机或路由器使用ICMP来发送差错报告报文和询问报文</li><li>ICMP报文被封装在IP数据报中发送</li></ul></li></ul><h2 id="1-五种差错报告报文"><a href="#1-五种差错报告报文" class="headerlink" title="1. 五种差错报告报文"></a>1. 五种差错报告报文</h2><h3 id="1-1-终点不可达"><a href="#1-1-终点不可达" class="headerlink" title="1.1 终点不可达"></a>1.1 终点不可达</h3><ol><li>当路由器或主机不能交付数据报时，就向源点发送终点不可达报文。</li><li>具体可再根据ICMP的代码字段细分为目的网络不可达、目的主机不可达、目的协议不可达、目的端口不可达、目的网络未知、目的主机未知等13种错误。</li></ol><h3 id="1-2-源点抑制"><a href="#1-2-源点抑制" class="headerlink" title="1.2 源点抑制"></a>1.2 源点抑制</h3><ol><li>当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢。</li></ol><h3 id="1-3-时间超过"><a href="#1-3-时间超过" class="headerlink" title="1.3 时间超过"></a>1.3 时间超过</h3><ol><li>当路由器收到一个目的1P地址不是自己的P数据报，会将其生存时间TTL字段的值减1。</li><li>若结果不为0，则将该P数据报转发出去；若结果为0，除丢弃该P数据报外，还要向源点发送时间超过报文。</li></ol><h3 id="1-4-参数问题"><a href="#1-4-参数问题" class="headerlink" title="1.4 参数问题"></a>1.4 参数问题</h3><ol><li>当路由器或目的主机收到P数据报后，根据其首部中的检验和字段发现首部在传输过程中出现了误码，就丢弃该数据报，并向源点发送参数问题报文。</li></ol><h3 id="1-5-改变路由-重定向"><a href="#1-5-改变路由-重定向" class="headerlink" title="1.5 改变路由(重定向)"></a>1.5 改变路由(重定向)</h3><ol><li>路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）。</li></ol><h2 id="2-当发生以下情况时不应该发送IMCP差错报告报文"><a href="#2-当发生以下情况时不应该发送IMCP差错报告报文" class="headerlink" title="2. 当发生以下情况时不应该发送IMCP差错报告报文"></a>2. 当发生以下情况时不应该发送IMCP差错报告报文</h2><ol><li>对ICMP差错报告报文不再发送ICMP差错报告报文</li><li>对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文</li><li>对具有多播地址的数据报都不发送ICMP差错报告报文</li><li>对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送ICMP差错报告报文</li></ol><h2 id="3-常用的ICMP询问报文"><a href="#3-常用的ICMP询问报文" class="headerlink" title="3. 常用的ICMP询问报文"></a>3. 常用的ICMP询问报文</h2><ol><li>回送请求和回答</li><li>ICMP回送请求报文是由主机回或路由器向一个特定的目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。<ol start="2"><li>这种询问报文用来测试目的站是否可达及了解其有关状态。</li></ol></li><li>时间戳请求和回答<ol><li>ICMP时间戳请求报文是请某个主机或路由器回答当前的日期和时间。</li><li>在ICMP时间戳回答报文中有一个32位的字段，其中写入的整数代表从1900年1月1日起到当前时刻一共有多少秒。</li><li>这种询问报文用来进行时钟同步和测量时间</li></ol></li></ol><h2 id="4-ICMP应用"><a href="#4-ICMP应用" class="headerlink" title="4. ICMP应用"></a>4. ICMP应用</h2><h3 id="4-1-分组网间探测（PING）"><a href="#4-1-分组网间探测（PING）" class="headerlink" title="4.1 分组网间探测（PING）"></a>4.1 分组网间探测（PING）</h3><blockquote><p>Packet Internet Groper</p></blockquote><ol><li>用来测试主机或路由器间的连通性</li><li>应用层直接使用网际层的ICMP(没有通过运输层的TCP或UDP)</li><li>使用ICMP回送请求和回答报文</li></ol><h3 id="4-2-跟踪路由"><a href="#4-2-跟踪路由" class="headerlink" title="4.2 跟踪路由"></a>4.2 跟踪路由</h3><blockquote><p>traceroute</p><p>用来测试P数据报从源主机到达目的主机要经过哪些路由器</p></blockquote><ol><li><p>Windows版本</p><blockquote><p>tracert命令<br>应用层直接使用网际层ICMP<br>使用了ICMP回送请求和回答报文以及差错报告报文</p></blockquote></li><li><p>Unix版本</p><blockquote><p>traceroute命令<br>在运输层使用UDP协议<br>仅使用ICMP差错报告报文</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.7 IPv4数据报的首部格式</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-7-IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-7-IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="4-7-IP数据报的首部格式"><a href="#4-7-IP数据报的首部格式" class="headerlink" title="4.7 IP数据报的首部格式"></a>4.7 IP数据报的首部格式</h1><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-7-IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F/image-20230717175105117.png"></p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>版本</td><td>占4比特，表示IP协议的版本。<br>通信双方使用的P协议的版本必须一致。<br>目前广泛使用的IP协议版本号为4（即IPv4)<br></td></tr><tr><td>首部长度<br></td><td>占4比特，表示IP数据报首部的长度。<br>该字段的取值以4字节为单位。<br>最小十进制取值为5，表示P数据报首部只有20字节固定部分；<br>量大十进制取值为15，表示1P数据报首部包含20字节固定部分和最大40字节可变部分。<br></td></tr><tr><td>区分服务</td><td>占8比特，用来获得更好的服务。利用该字段的不同数值可提供不同等级的服务质量。<br>只有在使用区分服务时，该字段才起作用。一般情况下都不使用该字段。</td></tr><tr><td>总长度</td><td>占16比特，表示IP数据报的总长度（首部+数据载荷），最大取值为十进制的65535，以字节为单位。</td></tr><tr><td>标识</td><td>占16比特，属于同一个数据报的各分片数据报应该具有相同的标识。<br>IP软件维持一个计数器，每产生一个数据报，计数器值加1，并将此值赋给标识字段。</td></tr><tr><td>标志</td><td>占3比特，各比特含义如下：<br>DF位：1表示不允许分片：0表示允许分片；<br>MF位：1表示 后面还有分片：0表示 这是最后一个分片；<br>保留位：必须为0</td></tr><tr><td>片偏移</td><td>占13比特，指出分片数据报的数据载荷部分偏移其在原数据报的位置有多少个单位。<br>片偏移以8个字节为单位。</td></tr><tr><td>生存时间TTL</td><td>占8比特，表示P数据报的生存时间。<br>现在以“跳数”为单位，路由器转发P数据报时，将1P数据报首部中的该字段的值减1，若不为0就转发。否则就丢弃</td></tr><tr><td>首部校验和</td><td>1P数据报每经过一个路由器，路由器都要重新计算首部检验和，因为某些字段<br>（生存时间，标志，片偏移等）的取值可能发生变化</td></tr><tr><td>源IP地址和目的IP地址</td><td>略</td></tr><tr><td>填充</td><td>IP数据报首部大小必须为4字节的整数倍</td></tr><tr><td>可选字段长度</td><td>从1个字节到40个字节不等。用来支持排错、测量及安全等措施<br>但一般不使用</td></tr><tr><td>协议</td><td>占8比特，指明IPV4数据报的数据部分是何种协议数据单元。<br>常用的一些协议和相应的协议字段值如下。<br><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-7-IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F/image-20241117220627692.png" alt="image-20241117220627692"></td></tr></tbody></table><h2 id="1-IPV4分片"><a href="#1-IPV4分片" class="headerlink" title="1. IPV4分片"></a>1. IPV4分片</h2><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-7-IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F/image-20241117215341102.png"></p><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-7-IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F/image-20241117220158751.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.6 路由选择协议</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="4-6-路由选择协议"><a href="#4-6-路由选择协议" class="headerlink" title="4.6 路由选择协议"></a>4.6 路由选择协议</h1><h2 id="1-路由选择协议"><a href="#1-路由选择协议" class="headerlink" title="1. 路由选择协议"></a>1. 路由选择协议</h2><blockquote><p>早期RFC文档中，使用“网关”这个词指代路由器，现代使用“路由器”指代路由器，两者为同一设备的不同名称</p></blockquote><h3 id="1-1-静态路由选择"><a href="#1-1-静态路由选择" class="headerlink" title="1.1 静态路由选择"></a>1.1 静态路由选择</h3><ol><li>由人工配置的网络路由、默认路由、特定主机路由，黑洞路由等都属于静态路由。</li><li>这种人工配置方式简单、开销小，但不能及时适应网络状态（流量、拓扑等）的变化</li><li>一般只在小规模网络中采用。</li></ol><h3 id="1-2-动态路由选择"><a href="#1-2-动态路由选择" class="headerlink" title="1.2 动态路由选择"></a>1.2 动态路由选择</h3><ol><li>路由器通过路由选择协议自动获取路由信息比较复杂、开销比较大，</li><li>能较好地适应网络状态的变化</li><li>适用于大规模网络</li></ol><h3 id="1-3-因特网所采用的路由选择协议的主要特点"><a href="#1-3-因特网所采用的路由选择协议的主要特点" class="headerlink" title="1.3 因特网所采用的路由选择协议的主要特点"></a>1.3 因特网所采用的路由选择协议的主要特点</h3><ol><li>自适应<ol><li>动态路由选择，能较好地适应网络状态的变化</li></ol></li><li>分布式<ol><li>路由器之间交换路由信息</li></ol></li><li>分层次<ol><li>将整个因特网划分为许多较小的自治系统AS(Autonomous System）</li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117204127866.png"></p><h3 id="1-4-因特网采用分层次的路由选择协议"><a href="#1-4-因特网采用分层次的路由选择协议" class="headerlink" title="1.4 因特网采用分层次的路由选择协议"></a>1.4 因特网采用分层次的路由选择协议</h3><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117204721689.png"></p><ol><li><p>一般一个ISP负责的所有网络作为一个自治系统</p><ol><li>内部网关协议（IGP）和外部网关协议（EGP）是协议分类的总称，不是具体的协议名</li></ol></li><li><p>路由选择协议</p></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117204849446.png"></p><ol start="3"><li>路由器的基本结构</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117204931573.png"></p><ol start="4"><li>路由表一般仅包含从目的网络到下一跳的映射</li><li>路由表需要对网络拓扑变化的计算最优化<ol><li>转发表是从路由表得出的</li><li>转发表的结构应当使查找过程最优化</li></ol></li></ol><h2 id="2-路由信息RIP协议工作原理"><a href="#2-路由信息RIP协议工作原理" class="headerlink" title="2. 路由信息RIP协议工作原理"></a>2. 路由信息RIP协议工作原理</h2><ol><li>路由信息协议RIP(Routing Information Protocol)是内部网关协议IGP中最先得到广泛使用的协议之一，其相关标准文档为RFC1058。</li><li>RIP要求自治系统AS内的每一个路由器都要维护从它自己到AS内其他每一个网络的距离记录。这是一组距离，称为“距离向量”。</li><li>RIP使用跳数(Hop Count)作为度量(Metric)来衡量到达目的网络的距离。<ol><li>路由器到直连网络的距离定义为1。路由器到非直连网络的距离定义为所经过的路由器数加1。</li><li>允许一条路径最多只能包含15个路由器。“距离”等于16时相当于不可达。因此，RIP只适用于小型互联网。</li></ol></li><li>RIP认为好的路由就是“距离短”的路由，也就是所通过路由器数量最少的路由</li><li>当到达同一目的网络有多条“距离相等”的路由时，可以进行等价负载均衡</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117205628647.png"></p><h3 id="2-1-特点"><a href="#2-1-特点" class="headerlink" title="2.1 特点"></a>2.1 特点</h3><ol><li>仅和相邻路由器交换信息</li><li>交换的信息是自己的路由表</li><li>周期性交换该信息</li></ol><h3 id="2-2-RP的基本工作流程"><a href="#2-2-RP的基本工作流程" class="headerlink" title="2.2 RP的基本工作流程"></a>2.2 RP的基本工作流程</h3><ol><li>路由器刚开始工作时，只知道自己到直连网络的距离为1。</li><li>每个路由器仅和相邻路由器周期性地交换并更新路由信息。</li><li>若干次交换和更新后，每个路由器都知道到达本AS内各网络的最短距离和下一跳地址，称为收敛。</li></ol><h3 id="2-3-更新规则"><a href="#2-3-更新规则" class="headerlink" title="2.3 更新规则"></a>2.3 更新规则</h3><ol><li>发现了新的网络，添加</li><li>到达目的网络，相同下一跳，最新消息，更新</li><li>到达目的网络，不同下一跳，新路由优势，更新</li><li>到达目的网络，不同下一跳，新路由劣势，不更新</li><li>到达目的网络，不同下一跳，等价负载均衡</li></ol><ul><li>RIP存在“坏消息传播得慢”的问题</li></ul><blockquote><p>坏消息传播得慢”又称为路由环路或距离无穷计数问题，这是距离向量算法的一个固有问题。</p></blockquote><ul><li>可以采取多种措施减少出现该问题的概率或减小该问题带来的危害。<ul><li>限制最大路径距离为15(16表示不可达)</li><li>当路由表发生变化时就立即发送更新报文（即“触发更新”），而不仅是周期性发送</li><li>让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向传送（即“水平分割”）</li></ul></li></ul><h2 id="3-开放最短路径OSPF协议的工作原理"><a href="#3-开放最短路径OSPF协议的工作原理" class="headerlink" title="3. 开放最短路径OSPF协议的工作原理"></a>3. 开放最短路径OSPF协议的工作原理</h2><h3 id="3-1-OSPF协议"><a href="#3-1-OSPF协议" class="headerlink" title="3.1 OSPF协议"></a>3.1 OSPF协议</h3><ol><li>开放最短路径优先OSPF(Open Shortest Path First),是为克服RIP的缺点在1989年开发出来的。</li><li>“开放”表明OSPF协议不是受某一家厂商控制，而是公开发表的。</li><li>“最短路径优先”是因为使用了Dijkstra提出的最短路径算法SPF。</li><li>OSPF是基于链路状态的，而不像RIP那样是基于距离向量的。</li><li>OSPF采用SPF算法计算路由，从算法上保证了不会产生路由环路。</li><li>OSPF不限制网络规模，更新效率高，收敛速度快。</li></ol><h3 id="3-2-链路"><a href="#3-2-链路" class="headerlink" title="3.2 链路"></a>3.2 链路</h3><ol><li>链路状态是指本路由器都和哪些路由器相邻，以及相应链路的“代价”(cost)。</li><li>“代价”用来表示费用、距离、时延、带宽，等等。这些都由网络管理人员来决定。</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117211227799.png"></p><ol><li>OSPF相邻路由器之间通过交互问候(Hllo)分组，建立和维护邻居关系。<ol><li>Hello分组封装在IP数据报中，发往组播地址224.0.0.5；</li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117211306170.png"></p><ol start="2"><li>发送周期为10秒<ol><li>40秒未收到来自邻居路由器的Hlo分组，则认为该邻居路由器不可达。</li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117211527755.png"></p><h3 id="3-3-链路状态通告"><a href="#3-3-链路状态通告" class="headerlink" title="3.3 链路状态通告"></a>3.3 链路状态通告</h3><blockquote><p>使用OSPF的每个路由器都会产生链路状态通告 LSA  (Link State Advertisement)。</p></blockquote><ol><li>LSA中包含以下内容：<ol><li>直连网络的链路状态信息</li><li>邻居路由器的链路状态信息</li></ol></li><li>LSA被封装在链路状态更新分组LSU中，采用洪泛法发送。<br>使用OSPF的每个路由器都有一个链路状态数据库LSDB，用于存储LSA。</li><li>通过各路由器洪泛发送封装有自己LSA的LSU分组，各路由器的LSDB最终将达到一致。</li><li>使用OSPF的各路由器基于LSDB进行最短路径优先SPF计算，构建出各自到达其他各路由器的最短路径，即构建各自的路由表。</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117211848406.png"></p><h3 id="3-4-OSPF共有五种分组类型"><a href="#3-4-OSPF共有五种分组类型" class="headerlink" title="3.4 OSPF共有五种分组类型"></a>3.4 OSPF共有五种分组类型</h3><ol><li>问候分组（Hello）<ol><li>用来发现和维护邻居路由器的可达性。</li></ol></li><li>数据库描述分组（DD）<ol><li>向邻居路由器给出自己的链路状态数据库中的所有链路状态项目的摘要信息</li></ol></li><li>链路状态请求分组（LSR）<ol><li>向邻居路由器请求发送某些链路状态项目的详细信息。</li></ol></li><li>链路状态更新分组（LSU）<ol><li>路由器使用这种分组将其链路状态进行洪泛发送，即用洪泛法对全网更新链路状态。</li></ol></li><li>链路确认分组（LSA）<ol><li>这是对链路状态更新分组的确认分组。</li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20230717155343654.png"></p><h3 id="3-5-OSPF的基本工作过程"><a href="#3-5-OSPF的基本工作过程" class="headerlink" title="3.5 OSPF的基本工作过程"></a>3.5 OSPF的基本工作过程</h3><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20230717155522453.png"></p><ol><li>OSPF在多点接入的网络中路由器邻里关系的建立<ol><li>选举指定路由器DR(designated router)和备用的指定路由器BDR(backup designated router)</li><li>所有的非DR&#x2F;BDR只与DR&#x2F;BDR建立邻居关系，即非DR&#x2F;BDR之间通过DR&#x2F;BDR交换信息</li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20230717155708575.png"></p><ol start="2"><li>为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统再划分为若干个更小的范围，叫做区域(Area)<ol><li>划分区域的好处就是把利用洪泛法交换链路状体信息的范围局限于每一个区域而不是整个自治系统，这就减少了整个网络上的通信量。</li><li>每个区域不大于200个路由器</li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117213232150.png"></p><h2 id="4-边界网关协议BGP的基本工作原理"><a href="#4-边界网关协议BGP的基本工作原理" class="headerlink" title="4. 边界网关协议BGP的基本工作原理"></a>4. 边界网关协议BGP的基本工作原理</h2><h3 id="4-1-BGP原理"><a href="#4-1-BGP原理" class="headerlink" title="4.1 BGP原理"></a>4.1 BGP原理</h3><ol><li>BGP只能是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由</li><li>BGP要解决的问题<ol><li>在不同自治系统内，度量路由的“代价”（距离，带宽，费用等)可能不同。因此，对于自治系统之间的路由选择，使用“代价”作为度量来寻找最佳路由是不行的。</li><li>自治系统之间的路由选择必须考虑相关策略（政治，经济，安全等）</li></ol></li></ol><h3 id="4-2-交换路由的过程"><a href="#4-2-交换路由的过程" class="headerlink" title="4.2 交换路由的过程"></a>4.2 交换路由的过程</h3><ol><li><p>在配置BGP时，每个自治系统的管理员要选择至少一个路由器作为该自治系统的“BGP发言人”，不同自治系统的BGP发言人要交换路由信息，首先必须建立TCP连接，端口号为179</p></li><li><p>在此TCP连接上交换BGP报文以建立BGP会话</p></li><li><p>利用BGP会话交换路由信息（例如，增加新的路由，或撤销过时的路由，以及报告出错的情况等）</p><blockquote><p>使用TCP连接交换路由信息的两个BGP发言人，彼此称为对方的邻站(neighbor)或对等站(peer)</p></blockquote></li><li><p>BGP发言人除了运行BGP外，还必须运行自己所在自治系统所使用的内部网关协议IGP,例如OSPF或RIP。</p></li><li><p>当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各自治系统的较好的路由。也就是构造出树形结构、不存在回路的自治系统连通图。</p></li></ol><h3 id="4-3-BGP适用于多级结构的因特网"><a href="#4-3-BGP适用于多级结构的因特网" class="headerlink" title="4.3 BGP适用于多级结构的因特网"></a>4.3 BGP适用于多级结构的因特网</h3><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117214100280.png"></p><h3 id="4-4-BGP-4四种报文类型"><a href="#4-4-BGP-4四种报文类型" class="headerlink" title="4.4 BGP-4四种报文类型"></a>4.4 BGP-4四种报文类型</h3><table><thead><tr><th align="center">报文</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">OPEN(打开)报文</td><td align="left">用来与相邻的另一个BGP发言人建立关系，使通信初始化</td></tr><tr><td align="center">UPDATE(更新)报文</td><td align="left">用来通告某一路由的信息，以及列出要撤销的多条路由</td></tr><tr><td align="center">KEEPALIVE(保活)报文</td><td align="left">用来周期性地证实邻站的连通性。</td></tr><tr><td align="center">NOTIFICATION(通知)报文</td><td align="left">用来发送检测到的差错。</td></tr></tbody></table><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-6-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/image-20241117214318616.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.5 静态路由配置及其可能产生的路由环路问题</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-5-%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%B6%E5%8F%AF%E8%83%BD%E4%BA%A7%E7%94%9F%E7%9A%84%E8%B7%AF%E7%94%B1%E7%8E%AF%E8%B7%AF%E9%97%AE%E9%A2%98/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-5-%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%B6%E5%8F%AF%E8%83%BD%E4%BA%A7%E7%94%9F%E7%9A%84%E8%B7%AF%E7%94%B1%E7%8E%AF%E8%B7%AF%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="4-5-静态路由配置及其可能产生的路由环路问题"><a href="#4-5-静态路由配置及其可能产生的路由环路问题" class="headerlink" title="4.5 静态路由配置及其可能产生的路由环路问题"></a>4.5 静态路由配置及其可能产生的路由环路问题</h1><ul><li>静态路由配置是指用户或网络管理员使用路由器的相关命令给路由器人工配置路由表。<ul><li>这种人工配置方式简单、开销小。但不能及时适应网络状态（流量、拓扑等）的变化。</li><li>一般只在小规模网络中采用。</li></ul></li></ul><h2 id="1-使用静态路由配置可能出现以下导致产生路由环路的错误"><a href="#1-使用静态路由配置可能出现以下导致产生路由环路的错误" class="headerlink" title="1. 使用静态路由配置可能出现以下导致产生路由环路的错误"></a>1. 使用静态路由配置可能出现以下导致产生路由环路的错误</h2><h3 id="1-1-配置错误"><a href="#1-1-配置错误" class="headerlink" title="1.1 配置错误"></a>1.1 配置错误</h3><ul><li>解决方法：<ul><li>IP数据报头部设置一个生存期，每经过一次路由转发，其值减一，当其值小于等于0时被丢弃</li><li>为了防止P数据报在路由环路中永久兜圈，在IP数据报首部设有生存时间TTL字段。</li><li>IP数据报进入路由器后，TTL字段的值减1。若TTL的值不等于0，则被路由器转发，否则被丢弃。</li></ul></li></ul><h3 id="1-2-聚合了不存在的网络"><a href="#1-2-聚合了不存在的网络" class="headerlink" title="1.2 聚合了不存在的网络"></a>1.2 聚合了不存在的网络</h3><ul><li>静态配置不存在的IP网络为黑洞路由</li></ul><h3 id="1-3-网络故障"><a href="#1-3-网络故障" class="headerlink" title="1.3 网络故障"></a>1.3 网络故障</h3><ul><li>静态配置故障的IP网络为黑洞路由，当其故障修复后，再自动添加回来并设置黑洞路由无效，若再故障，则删除并设置之前的黑洞路由有效</li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-5-%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%B6%E5%8F%AF%E8%83%BD%E4%BA%A7%E7%94%9F%E7%9A%84%E8%B7%AF%E7%94%B1%E7%8E%AF%E8%B7%AF%E9%97%AE%E9%A2%98/image-20241117203152226.png"></p><h2 id="2-路由条目的类型"><a href="#2-路由条目的类型" class="headerlink" title="2. 路由条目的类型"></a>2. 路由条目的类型</h2><ol><li>直连网络</li><li>静态路由（人工配置）</li><li>动态路由（路由选择协议）</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-5-%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%B6%E5%8F%AF%E8%83%BD%E4%BA%A7%E7%94%9F%E7%9A%84%E8%B7%AF%E7%94%B1%E7%8E%AF%E8%B7%AF%E9%97%AE%E9%A2%98/image-20241117202703876.png"></p><ol start="4"><li>特定主机路由<ol><li><p>特殊的静态路由条目</p></li><li><p>默认路由（目的网络为0.0.0.0，地址掩码为0.0.0.0）</p><blockquote><p>当路由表查找不到目标网络时，使用该路由</p></blockquote></li><li><p>特定主机路由（目的网络为特定主机的1P地址，地址掩码为255.255.255.255）</p></li><li><p>黑洞路由（下一跳为null0)</p></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.4 IP数据包的发送和转发过程</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-4-IP%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E5%8F%91%E9%80%81%E5%92%8C%E8%BD%AC%E5%8F%91%E8%BF%87%E7%A8%8B/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-4-IP%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E5%8F%91%E9%80%81%E5%92%8C%E8%BD%AC%E5%8F%91%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="4-4-IP数据报发送和转发过程"><a href="#4-4-IP数据报发送和转发过程" class="headerlink" title="4.4 IP数据报发送和转发过程"></a>4.4 IP数据报发送和转发过程</h1><ul><li>分为两部分<ul><li>主机发送IP数据报</li><li>路由器发送IP数据报</li></ul></li></ul><h2 id="1-主机发送数据报"><a href="#1-主机发送数据报" class="headerlink" title="1. 主机发送数据报"></a>1. 主机发送数据报</h2><ul><li>判断目的主机是否与自己在同一个网络（判断方法请参看本节课相关示例）<ul><li>若在同一个网络，则属于直接交付：</li><li>若不在同一个网络，则属于间接交付，传输给主机所在网络的默认网关(路由器)，由默认网关帮忙转发；</li></ul></li></ul><h2 id="2-路由器转发数据报"><a href="#2-路由器转发数据报" class="headerlink" title="2. 路由器转发数据报"></a>2. 路由器转发数据报</h2><ul><li>检查IP数据报首部是否出错：<ul><li>若出错，则直接丢弃该P数据报并通告源主机；</li><li>若没有出错，则进行转发；</li></ul></li><li>根据IP数据报的目的地址在路由表中查找匹配的条目(查找方法请参看本节课相关示例)：<ul><li>若找到匹配的条目，则转发给条目中指示的下一跳；</li><li>若找不到，则丢弃该P数据报并通告源主机；</li></ul></li></ul><h2 id="3-隔离"><a href="#3-隔离" class="headerlink" title="3. 隔离"></a>3. 隔离</h2><ul><li>中继器和集线器工作在物理层，既不隔离冲突域也不隔离广播域。</li><li>网桥和交换机（多端口网桥）工作在数据链路层，可以隔离冲突域，不能隔离广播域。</li><li>路由器工作在网络层，既隔离冲突域，也隔离广播域。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.3 IPv4</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/</url>
    
    <content type="html"><![CDATA[<h1 id="4-3-IPv4"><a href="#4-3-IPv4" class="headerlink" title="4.3 IPv4"></a>4.3 IPv4</h1><h2 id="1-IPv4地址概述"><a href="#1-IPv4地址概述" class="headerlink" title="1. IPv4地址概述"></a>1. IPv4地址概述</h2><blockquote><p>给因特网上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的32比特的标识符。</p></blockquote><ol><li>在TCP&#x2F;IP体系中，IP地址是一个最基本的概念，我们必须把它弄清楚。</li><li>IPv4地址就是给因特网(Internet)上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的32比特的标识符。</li><li>IP地址由因特网名字和数字分配机构ICANN(Internet Corporation for Assigned Names and Numbers)进行分配.</li><li>我国用户可向亚太网络信息中心APNIC(Asia Pacific Network Information Center)申请IP地址，需要缴费。</li><li>2011年2月3日，互联网号码分配管理局IANA(由ICANN行使职能)宣布，IPV4地址已经分配完毕。</li><li>我国在2014至2015年也逐步停止了向新用户和应用分配IPv4地址。同时全面开展商用部署IPv6。</li></ol><h3 id="1-1-十进制表示"><a href="#1-1-十进制表示" class="headerlink" title="1.1 十进制表示"></a>1.1 十进制表示</h3><blockquote><p> 32比特的1Pv4地址不方便阅读、记录以及输入等，因此IPv4地址采用点分十进制表示方法以方便用户使用。</p><p> 八位一组，中间用  <code>. </code> 隔开</p></blockquote><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/image-20230716135419296.png"></p><h2 id="2-分类编址的IPv4地址"><a href="#2-分类编址的IPv4地址" class="headerlink" title="2. 分类编址的IPv4地址"></a>2. 分类编址的IPv4地址</h2><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/image-20230716142505440.png"></p><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/image-20230716142540603.png"></p><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/image-20241117190912535.png"></p><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/image-20230716142559662.png"></p><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/image-20230716141719165.png"></p><h2 id="3-划分子网的IPv4地址"><a href="#3-划分子网的IPv4地址" class="headerlink" title="3. 划分子网的IPv4地址"></a>3. 划分子网的IPv4地址</h2><ol><li>从主机号中借用一部分比特来作为子网号</li><li>子网掩码<ol><li>子网掩码使用连续的比特1来对应网络号和子网号</li><li>子网掩码使用连续的比特0来对应主机号</li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/image-20230716165915602.png"></p><ol start="3"><li><p>为新增网络申请新的网络号会带来以下弊端：</p><ol><li>需要等待时间和花费更多的费用</li><li>会增加其他路由器中路由表记录的数量</li><li>浪费原有网络号中剩余的大量IP地址</li></ol></li><li><p>默认子网掩码</p></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/image-20230716170001375.png" alt="默认子网掩码"></p><h2 id="4-无分类编址的IPv4地址"><a href="#4-无分类编址的IPv4地址" class="headerlink" title="4. 无分类编址的IPv4地址"></a>4. 无分类编址的IPv4地址</h2><ol><li>无分类域间路由选择（CIDR）消除了传统的A类、B类和C类地址，以及划分子网的概念。</li><li>为此，因特网工程任务组ETF又提出了采用无分类编址的方法来解决P地址紧张的问题，同时还专门成立Pv6工作组负责研究新版本P以彻底解决P地址耗尽问题。</li><li>1993年，IETF发布了无分类域间路由选择CIDR(Classless Inter-Domain Routing)的RFC文档：RFC1517~1519和1520。</li><li>CIDR消除了传统的A类、B类和C类地址，以及划分子网的概念：</li><li>CIDR可以更加有效地分配IPv4的地址空间，并且可以在新的PV6使用之前允许因特网的规模继续增长。</li><li>CIDR可以更加有效地分配IPV4的地址空间，并且可以在新的PV6使用之前允许因特网的规模继续增长。如：192.8.32.3&#x2F; 20</li><li>CIDR实际上是将网络前缀都相同的连续的1P地址组成一个“CIDR地址块”。</li></ol><h2 id="4-1-路由聚合"><a href="#4-1-路由聚合" class="headerlink" title="4.1 路由聚合"></a>4.1 路由聚合</h2><ul><li>构造超网，找到相同接口的多个地址的最长公共前缀，其余位归0，将该地址记录下来，那些地址删除即将它们合并成一个地址</li><li>网络前缀越长，地址块越小，路由越具体</li><li>若路由器查表转发分组时发现有多条路由可选，则选择网络前缀最长的那条，这称为最长前缀匹配。因为这样的路由更具体</li></ul><h2 id="5-IPv4地址的应用规划"><a href="#5-IPv4地址的应用规划" class="headerlink" title="5. IPv4地址的应用规划"></a>5. IPv4地址的应用规划</h2><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-3-Pv4/image-20230716214234227.png"></p><ul><li>变长的子网掩码是CIDR技术的应用</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.2 网络层提供的两种服务</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-2-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-2-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="4-2-网络层提供的两种服务"><a href="#4-2-网络层提供的两种服务" class="headerlink" title="4.2 网络层提供的两种服务"></a>4.2 网络层提供的两种服务</h1><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-2-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1/image-20230716133452655.png"></p><h2 id="1-虚电路服务"><a href="#1-虚电路服务" class="headerlink" title="1. 虚电路服务"></a>1. 虚电路服务</h2><ol><li>可靠通信由网络来保证</li><li>必须建立网络层的连接</li><li>虚电路VC(Virtual Circuit) 通信双方沿着已建立的虚电路发送分组，目的主机的地址仅在连接建立阶段使用，之后每个分组的首部只需携带一条虚电路的编号（构成虚电路的每一段链路都有一个虚电路编号)。这种通信方式如果再使用可靠传输的网络协议，就可使所发送的分组最终正确到达接收方（无差错按序到达、不丢失、不重复)。</li><li>通信结束后，需要释放之前所建立的虚电路。</li><li>很多广域分组交换网都使用面向连接的虚电路服务。<ol><li>例如，曾经的X.25和逐渐过时的帧中继FR、异步传输模式ATM等。</li></ol></li></ol><h2 id="2-数据报服务"><a href="#2-数据报服务" class="headerlink" title="2. 数据报服务"></a>2. 数据报服务</h2><ol><li>无连接的数据报服务</li><li>可靠通信应当由用户主机来保证</li><li>不需要建立网络层连接</li><li>每个分组可走不同的路径</li><li>每个分组的首部必须携带目的主机的完整地址这种通信方式所传送的分组可能误码、丢失、重复和失序。</li><li>由于网络本身不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价格低廉（与电信网的交换机相比较）。</li><li>因特网采用了这种设计思想，也就是将复杂的网络处理功能置于因特网的边缘（用户主机和其内部的运输层)，而将相对简单的尽最大努力的分组交付功能置于因特网核心。</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.1 网络层概述</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-1-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-1-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="4-1-网络层"><a href="#4-1-网络层" class="headerlink" title="4.1 网络层"></a>4.1 网络层</h1><h2 id="1-网络层"><a href="#1-网络层" class="headerlink" title="1. 网络层"></a>1. 网络层</h2><ol><li><p>网络层的主要任务是实现网络互连，进而实现数据包在各网络之间的传输</p></li><li><p>要实现网络层任务，需要解决以下主要问题：</p><ol><li>网络层向运输层提供怎样的服务（可靠传输 还是 不可靠传输）<ol><li>如果网络层对传输错误（分组丢失，分组失序等）不采取任何措施，那么就是不可靠服务</li><li>TCP&#x2F;IP网络体系结构提供的就是无连接，不可靠的传输服务（IP协议）</li></ol></li><li>网络层寻址问题</li><li>路由选择问题</li></ol></li><li><p>因特网(Internet)是目前全世界用户数量最多的互联网，它使用TCP&#x2F;IP协议栈。</p></li><li><p>由于TCP&#x2F;IP协议栈的网络层使用网际协议IP,它是整个协议栈的核心协议，因此在TCP&#x2F;IP协议栈中网络层常称为网际层。</p></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-1-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0/image-20241117185613994.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.11 虚拟局域网VLAN</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-11-%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91VLAN%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-11-%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91VLAN%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="3-11-虚拟局域网（VLAN）"><a href="#3-11-虚拟局域网（VLAN）" class="headerlink" title="3.11 虚拟局域网（VLAN）"></a>3.11 虚拟局域网（VLAN）</h1><ol><li><p>以太网交换机工作在数据链路层（也包括物理层）</p></li><li><p>使用一个或多个以太网交换机互连起来的交换式以太网，其所有站点都属于同一个广播域。随着交换式以太网规模的扩大，广播域相应扩大。</p></li><li><p>巨大的广播域会带来很多弊端：</p><ol><li>广播风暴</li><li>难以管理和维护</li><li>潜在的安全问题</li></ol></li><li><p>广播风暴会浪费网络资源和各主机的CPU资源！网络中会频繁出现广播信息</p><ol><li>TCP&#x2F;IP协议栈中的很多协议都会使用广播：<ol><li>地址解析协议ARP(已知IP地址，找出其相应的MAC地址)</li><li>路由信息协议RIP(一种小型的内部路由协议)</li><li>动态主机配置协议DHCP(用于自动配置IP地址)</li><li>NetBEUI: Windows下使用的广播型协议</li><li>IPX&#x2F;SPX: Novell网络的协议栈</li><li>Apple Talk: Apple公司的网络协议栈</li></ol></li></ol></li></ol><h2 id="1-分割广播域的方法"><a href="#1-分割广播域的方法" class="headerlink" title="1. 分割广播域的方法"></a>1. 分割广播域的方法</h2><ul><li><p>使用路由器可以隔离广播域</p></li><li><p>虚拟局域网VLAN(Virtual Local Area Network)是一种将局域网内的设备划分成与物理位置无关的逻辑组的技术，这些逻辑组具有某些共同的需求。</p></li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-11-%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91VLAN%E6%A6%82%E8%BF%B0/image-20241117181858889.png"></p><blockquote><p>虚拟局域网是一种将局域网内的设备划分成与物理位置无关的逻辑组的技术，这些逻辑组具有某些共同的需求。即作用是像路由器一样分割广播域。</p></blockquote><ol><li><p>802.1Q帧对以太网帧进行了扩展，插入了4字节的VLAN标记<br><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-11-%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91VLAN%E6%A6%82%E8%BF%B0/image-20241117182055735.png"></p></li><li><p>VLAN标记的最后12比特称为VLAN标识符VID,它唯一地标志了以太网帧属于哪一个VLAN.</p><ol><li>V1D的取值范围是0~4095 ( 0 ~ 2^12^-1 )</li><li>0和4095都不用来表示VLAN，因此用于表示VLAN的V1D的有效取值范围是1~4094</li></ol></li><li><p>802.1Q帧是由交换机来处理的，而不是用户主机来处理的。</p><ol><li>当交换机收到普通的以太网帧时，会将其<strong>插入4字节的VLAN标记</strong>转变为802.1Q帧，简称“打标签”</li><li>当交换机转发802.1Q帧时，可能会<strong>删除其4字节VLAN标记</strong>转变为普通以太网帧，简称“去标签”</li></ol></li></ol><h2 id="2-交换机端口类型"><a href="#2-交换机端口类型" class="headerlink" title="2. 交换机端口类型"></a>2. 交换机端口类型</h2><ol><li><p>交换机有三种端口类型</p><ol><li>Access</li><li>Trunk</li><li>Hybrid</li></ol></li><li><p>Access端口一般用于连接用户计算机</p><ol><li>Access端口只能属于一个VLAN</li><li>Access端口的PVID值与端口所属VLAN的ID相同（默认为1）</li><li>Access端口接收处理方法：<ol><li>一般只接受“未打标签”的普通以太网MAC帧。</li><li>根据接收帧的端口的PVID给帧“打标签”，即插入4字节VLAN标记字段，字段中的VID取值与端口的PVID取值相等。</li></ol></li></ol></li><li><p>Trunk端口一般用于交换机之间或交换机与路由器之间的互连</p><ol><li>Trunk端口可以属于多个VLAN</li><li>用户可以设置Trunk端口的PVID值。默认情况下，Trunki端口的PVID值为1。</li><li>Trunk端口发送处理方法：<ol><li>对VID等于PVID的帧，“去标签”再转发；</li><li>Trunk端口接收处理方法：接收“未打标签”的帧，根据接收帧的端口的PVID给帧“打标签”，即插入4字节</li><li>VLAN标记字段，字段中的VID取值与端口的PVID取值相等。</li></ol></li></ol></li><li><p>Hybrid端口</p><ol><li>既可用于交换机之间或交换机，与路由器之间的互连（同Trunk端口），也可用于交换机与用户计算机之间的互连（同Access端口）</li><li>Hybrid端口可以属于多个VLAN(同Trunk端口)</li><li>用户可以设置Hybrid端口的PVID值。默认情况下，Hybrid端口的PVID值为1（同Trunk端口）</li><li>Hybrid端口发送处理方法（与Trunk端口不同）<ol><li>查看帧的VID是否在端口的“去标签”列表中：</li><li>若存在，则“去标签”后再转发；</li><li>若不存在，则直接转发；</li></ol></li><li>Hybrid端口接收处理方法（同Trunk端口）<ol><li>接收“未打标签”的帧，根据接收帧的端口的PVID给帧”打标签”，即插入4字节VLAN标记字段，字段中的VID取值与端口的PVID取值相等。</li><li>接收“已打标签的帧”：</li></ol></li></ol></li></ol><ul><li>交换机各端口的缺省VLAN ID,在思科交换机上称为Native VLAN,即本征VLAN。</li><li>在华为交换机上称为Port VLAN ID,即端口VLAN ID,简记为PVID。</li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-11-%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91VLAN%E6%A6%82%E8%BF%B0/image-20241117184056860.png" alt="image-20241117184056860"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.10 以太网交换机的生成树协议STP</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-10-%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AESTP/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-10-%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AESTP/</url>
    
    <content type="html"><![CDATA[<h2 id="3-10-以太网交换机的生成树协议STP"><a href="#3-10-以太网交换机的生成树协议STP" class="headerlink" title="3.10 以太网交换机的生成树协议STP"></a>3.10 以太网交换机的生成树协议STP</h2><ul><li>为提高以太网的可靠性，需要添加冗余链路，但添加冗余链路会形成网络环路，网络环路会造成很多问题：<ul><li>广播风暴<ul><li>大量消耗网络资源，使得网络无法正常转发其他数据帧：</li></ul></li><li>主机收到重复的广播帧<ul><li>大量消耗主机资源</li></ul></li><li>交换机的帧交换表震荡（漂移）<ul><li>某记录在错误的记录之间来回震荡</li></ul></li></ul></li><li>STP正是为了解决这一问题而出现。<ul><li>不论交换机之间采用怎样的物理连接，交换机都能够自动计算并构建一个逻辑上没有环路的网络，其逻辑拓扑结构必须是树型的（无逻辑环路）</li><li>最终生成的树型逻辑拓扑要确保连通整个网络。</li><li>当首次连接交换机或网络物理拓扑发生变化时（有可能是人为改变或故障），交换机都将进行生成树的重新计算。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.9 以太网交换机自学习和转发帧的流程</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-9-%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA%E8%87%AA%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%BD%AC%E5%8F%91%E5%B8%A7%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-9-%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA%E8%87%AA%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%BD%AC%E5%8F%91%E5%B8%A7%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="3-9-以太网自学习和转发帧"><a href="#3-9-以太网自学习和转发帧" class="headerlink" title="3.9 以太网自学习和转发帧"></a>3.9 以太网自学习和转发帧</h1><ul><li>以太网交换机工作在数据链路层（也包括物理层）<ul><li>以太网交换机收到帧后，在帧交换表中查找帧的目的MAC地址所对应的接口号，然后通过该接口转发帧。</li></ul></li><li>以太网交换机是一种即插即用设备，刚上电启动时其内部的帧交换表是空的。随着网络中各主机间的通信，<ul><li>以太网交换机通过自学习算法自动逐渐建立起帧交换表。</li></ul></li></ul><ol><li>收到帧后进行登记。登记的内容为帧的源MAC地址及进入交换机的接口号</li><li>根据帧的目的MAC地址和交换机的帧交换表对帧进行转发，有以下三种情况：<ol><li>明确转发：交换机知道应当从哪个（回或哪些）接口转发该帧（单播，多播，广播）</li><li>盲目转发：交换机不知道应当从哪个端口转发帧，只能将其通过除进入交换机的接口外的其他所有接口转发（也称为泛洪）</li><li>明确丢弃：交换机知道不应该转发该帧，将其丢弃。比如：源MAC地址和目的MAC地址在表中记录为同一个端口</li></ol></li><li>帧交换表中的每条记录都有自己的有效时间，到期删除。原因如下：<ol><li>交换机的接口改接了另一台主机</li><li>主机更换了网卡</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.8 集线器与交换机的区别</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-8-%E9%9B%86%E7%BA%BF%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-8-%E9%9B%86%E7%BA%BF%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="3-8-集线器（HUB）和交换机（SWITCH）的区别"><a href="#3-8-集线器（HUB）和交换机（SWITCH）的区别" class="headerlink" title="3.8 集线器（HUB）和交换机（SWITCH）的区别"></a>3.8 集线器（HUB）和交换机（SWITCH）的区别</h1><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-8-%E9%9B%86%E7%BA%BF%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB/image-20241117174351414.png"></p><h2 id="1-集线器HUB"><a href="#1-集线器HUB" class="headerlink" title="1. 集线器HUB"></a>1. 集线器HUB</h2><ol><li>使用集线器的以太网在逻辑上仍是一个总线网，各站共享总线资源，使用的还是CSMA&#x2F;CD协议：</li><li>集线器只工作在物理层，它的每个接口仅简单地转发比特，不进行碰撞检测（由各站的网卡检测）：<ol><li>集线器一般都有少量的容错能力和网络管理功能。例如，若网络中某个网卡出了故障，不停地发送帧。此时，集线器可以检测到这个问题，在内部断开与出故障网卡的连线，使整个以太网仍然能正常工作。</li></ol></li><li>使用集线器HUB在物理层扩展以太网</li></ol><h2 id="2-交换机"><a href="#2-交换机" class="headerlink" title="2. 交换机"></a>2. 交换机</h2><blockquote><p>前提：交换机已完成自学习</p></blockquote><ol><li>以太网交换机通常都有多个接口。每个接口都可以直接与一台主机回或另一个以太网交换机相连。一般都工作在全双工方式。</li><li>以太网交换机具有并行性，能同时连通多对接口，使多对主机能同时通信，无碰撞（不使用CSMA&#x2F;CD协议）。</li><li>以太网交换机一般都具有多种速率的接口，例如：10Mb&#x2F;s、100Mb&#x2F;s、1Gb&#x2F;s、10Gb&#x2F;s接口的多种组合。<ol><li>以太网交换机工作在数据链路层（也包括物理层），它收到帧后，在帧交换表中查找帧的目的MAC地址所对应的接口号，然后通过该接口转发帧。</li><li>以太网交换机是一种即插即用设备，其内部的帧交换表是通过自学习算法自动地逐渐建立起来的。</li></ol></li><li>帧的两种转发方式：<ol><li>存储转发</li><li>直通交换：采用基于硬件的交叉矩阵（交换时延非常小，但不检查帧是否右差错)</li></ol></li></ol><h2 id="3-比较"><a href="#3-比较" class="headerlink" title="3. 比较"></a>3. 比较</h2><ol><li>交换机性能远超集线器，而且价格不高，所以市场上集线器已被淘汰</li><li>交换机不会改变源目MAC地址</li><li>交换机全双工传输</li><li>交换机即插即用</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-8-%E9%9B%86%E7%BA%BF%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB/image-20241117175352287.png"></p><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-8-%E9%9B%86%E7%BA%BF%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB/image-20241117175440399.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.7 MAC地址 IP地址以及ARP协议</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-7-MAC%E5%9C%B0%E5%9D%80-IP%E5%9C%B0%E5%9D%80-ARP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-7-MAC%E5%9C%B0%E5%9D%80-IP%E5%9C%B0%E5%9D%80-ARP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="3-7-MAC地址，IP地址，ARP地址"><a href="#3-7-MAC地址，IP地址，ARP地址" class="headerlink" title="3.7 MAC地址，IP地址，ARP地址"></a>3.7 MAC地址，IP地址，ARP地址</h1><ul><li>MAC地址是以太网的MAC子层所使用的地址</li><li>IP地址是TCP&#x2F;小P体系结构网际层所使用的地址</li><li>ARP协议属于TCP&#x2F;IP体系结构的网际层，其作用是已知设备所分配到的1P地址，使用ARP协议可以通过该P地址获取到设备的MAC地址；</li><li>尽管IP地址和ARP协议属于TCP&#x2F;IP体系结构的网际层（而不属于数据链路层)，但是它们与MAC地址存在一定的关系，并且我们日常的网络应用都离不开MAC地址、IP地址以及ARP协议。</li></ul><h2 id="1-MAC地址"><a href="#1-MAC地址" class="headerlink" title="1. MAC地址"></a>1. MAC地址</h2><ul><li>又称硬件地址，物理地址，属于数据链路层范畴</li><li>当多个主机连接在同一个广播信道上，要想实现两个主机之间的通信，则每个主机都必须有一个唯一的标识，即一个数据链路层地址</li></ul><ol><li>一般情况下，用户主机会包含两个网络适配器：有线局域网适配器（有线网卡）和无线局域网适配器（无线网卡)。</li><li>每个网络适配器都有一个全球唯一的MAC地址。而交换机和路由器往往拥有更多的网络接口，所以会拥有更多的MAC地址。综上所述，严格来说，MAC地址是对网络上各接口的唯一标识，而不是对网络上各设备的唯一标识。</li><li>在每个主机发送的帧中必须携带标识发送主机和接收主机的地址。由于这类地址是用于媒体接入控制MAC(Media Access Control),因此这类地址被称为MAC地址：<ol><li>MAC地址一般被固化在网卡（网络适配器）的电可擦可编程只读存储器EEPROM中，因此MAC地址也被称为硬件地址；</li><li>MAC地址有时也被称为物理地址。请注意：这并不意味着MAC地址属于网络体系结构中的物理层！</li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-7-MAC%E5%9C%B0%E5%9D%80-IP%E5%9C%B0%E5%9D%80-ARP%E5%8D%8F%E8%AE%AE/image-20241117152902875.png"></p><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-7-MAC%E5%9C%B0%E5%9D%80-IP%E5%9C%B0%E5%9D%80-ARP%E5%8D%8F%E8%AE%AE/image-20241117153926503.png"></p><h2 id="2-IP地址"><a href="#2-IP地址" class="headerlink" title="2. IP地址"></a>2. IP地址</h2><blockquote><p>IP地址是因特网(Internet)上的主机和路由器所使用的地址，属于网络层范畴</p><p>用于标识两部分信息：</p><ol><li>网络编号：标识因特网上数以百万计的网络</li><li>主机编号：标识同一网络上不同主机（或路由器各接口）</li></ol></blockquote><ol><li>数据包转发过程中，源IP地址和目的IP地址不变源MAC地址和目的MAC地址逐个链路改变</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-7-MAC%E5%9C%B0%E5%9D%80-IP%E5%9C%B0%E5%9D%80-ARP%E5%8D%8F%E8%AE%AE/image-20241117154839729.png"></p><h2 id="3-ARP协议"><a href="#3-ARP协议" class="headerlink" title="3. ARP协议"></a>3. ARP协议</h2><blockquote><p>解析IP地址 得到相应的MAC地址，属于网络层范畴</p></blockquote><ul><li><p>内容步骤</p><ol><li>源主机在自己的ARP高速缓存表中查找目的主机的1P地址所对应的MAC地址，若找到了，则可以封装MAC帧进行发送；若找不到，则发送ARP请求（封装在广播MAC帧中）</li><li>目的主机收到ARP请求后，将源主机的IP地址与MAC地址记录到自己的ARP高速缓存表中，然后给源主机发送ARP响应（封装在单播MAC帧中)，ARP响应中包含有目的主机的IP地址和MAC地址</li></ol></li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-7-MAC%E5%9C%B0%E5%9D%80-IP%E5%9C%B0%E5%9D%80-ARP%E5%8D%8F%E8%AE%AE/image-20241117173649451.png"></p><ol><li><p>作用范围</p></li><li><p>逐段链路或逐段网络使用</p></li><li><p>ARP高速缓存表中记录了每个IP地址对应的MAC地址，以及这个地址对的类型类型分为静态类型和动态类型</p><ol><li>静态类型手动配置，可设置系统重启后这些静态类型的地址对是否仍然有效</li><li>动态类型是通过上述ARP请求以及ARP相应得到的，有效时间很短，2分钟左右</li></ol></li><li><p>ARP协议不能跨网络使用</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.6 媒体接入控制</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="3-6-媒体接入控制（MAC）"><a href="#3-6-媒体接入控制（MAC）" class="headerlink" title="3.6 媒体接入控制（MAC）"></a>3.6 媒体接入控制（MAC）</h1><ul><li>共享信道要着重考虑的一个问题就是如何协调多个发送和接收站点对一个共享传输媒体的占用，即媒体接入控制MAC(Medium Access Control)。</li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117135016262.png"></p><ul><li>随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局<br>域网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术。</li></ul><h2 id="1-静态划分信道"><a href="#1-静态划分信道" class="headerlink" title="1. 静态划分信道"></a>1. 静态划分信道</h2><ul><li>信道复用技术<ul><li>复用(Multiplexing)是通信技术中的一个重要概念。复用就是通过一条物理线路同时传输多路用户的信号。</li><li>当网络中传输媒体的传输容量大于多条单一信道传输的总通信量时，可利用复用技术在一条物理线路上建立多条通信信道来充分利用传输媒体的带宽。</li></ul></li></ul><h3 id="1-1-频分复用（FDM）"><a href="#1-1-频分复用（FDM）" class="headerlink" title="1.1 频分复用（FDM）"></a>1.1 频分复用（FDM）</h3><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117135153544.png"></p><ul><li>频分复用的所有用户同时占用不同的频带资源并行通信。</li></ul><h3 id="1-2-时分复用（TDM）"><a href="#1-2-时分复用（TDM）" class="headerlink" title="1.2 时分复用（TDM）"></a>1.2 时分复用（TDM）</h3><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117135256698.png"></p><ul><li>时分复用的所有用户在不同的时间占用同样的频带宽度。</li></ul><h3 id="1-3-波分复用（WDM）"><a href="#1-3-波分复用（WDM）" class="headerlink" title="1.3 波分复用（WDM）"></a>1.3 波分复用（WDM）</h3><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117135344436.png"></p><h3 id="1-4-码分复用"><a href="#1-4-码分复用" class="headerlink" title="1.4 码分复用"></a>1.4 码分复用</h3><ol><li>CDM的每一个用户可以在同样的时间使用同样的频带进行通信。</li><li>由于各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。</li><li>CDM最初是用于军事通信的，因为这种系统所发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li><li>在CDMA中，每一个比特时间再划分为m个短的间隔，称为码片(Chip)。通常m的值是64或128</li><li>使用CDMA的每一个站被指派一个唯一的码片码片序列<ol><li>一个站如果要发送比特1，则发送它自己的码片码片序列；</li><li>一个站如果要发送比特0，则发送它自己的码片序列的二进制反码</li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117140108915.png"></p><ol start="6"><li>码片序列挑选原则</li></ol><ul><li>分配给每个站的码片序列必须各不相同，实际常采用伪随机码序列。</li><li>分配给每个站的码片序列必须相互正交（规格化内积为0）</li></ul><p>$$<br>A \bullet B &#x3D; \frac{1}{m} \times \sum_{i&#x3D;1}^{m}A_i \times B_i<br>$$</p><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117140433653.png"></p><h2 id="2-动态接入控制——随机接入"><a href="#2-动态接入控制——随机接入" class="headerlink" title="2. 动态接入控制——随机接入"></a>2. 动态接入控制——随机接入</h2><h3 id="2-1-CSMA-CD协议"><a href="#2-1-CSMA-CD协议" class="headerlink" title="2.1 CSMA&#x2F;CD协议"></a>2.1 CSMA&#x2F;CD协议</h3><ul><li>载波监听 多址接入 &#x2F; 碰撞检测</li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117142251276.png"></p><ul><li>以太网还采取一种叫做强化碰撞的措施。这就是当发送帧的站点一旦检测到碰撞，除了立即停止发送帧外，还要再继续发送32比特或48比特的人为干扰信号(Jamming Signal),以便有足够多的碰撞信号使所有站点都能检测出碰撞。</li></ul><h3 id="2-2-工作原理"><a href="#2-2-工作原理" class="headerlink" title="2.2 工作原理"></a>2.2 工作原理</h3><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117142509113.png"></p><ol start="2"><li><p>争用期（碰撞窗口）</p><ol><li>发送帧的主机最多经过以太网端到端往返传播时延2τ这么长时间，就可检测到本次传输是否发生了碰撞，2τ称为争用期：</li><li>经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</li><li>以太网规定2τ的取值为512比特时间（即发送512比特所耗费的时间），对于10Mbps的以太网，2τ 即为51.2 μs。</li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117142629341.png"></p><ol start="3"><li>最小帧长</li></ol><p>$$<br>最小帧长 &#x3D; 争用期 \times 数据传输速率（带宽）<br>$$</p><ul><li>最小帧长的设置是因为源主机将帧发送完毕以后，便不会再管这个帧，此时发生碰撞导致目标主机丢弃该帧，不会重发。</li><li>以太网规定最小帧长为64字节，即512比特(512比特时间即为争用期)：<ul><li>如果要发送的数据非常少，那么必须加入一些填充字节，使帧长不小于64字节。</li><li>以太网的最小帧长确保了主机可在帧发送完成之前就检测到该帧的发送过程中是否遭遇了碰撞：</li><li>如果在争用期（共发送64字节）没有检测到碰撞，那么后续发送的数据就一定不会发生碰撞；</li><li>如果在争用期内检测到碰撞，就立即中止发送，这时已经发送出去的数据一定小于64字节，因此凡长度小于64字节的帧都是由于碰撞而异常中止的无效帧。</li></ul></li></ul><ol start="4"><li>最大帧长</li></ol><ul><li>最大帧长的设置是因为不能使某个主机长时间独占共享媒介，否则过于影响其它主机的数据发送</li></ul><ol start="5"><li>截断二进制指数退避算法</li></ol><p>$$<br>随机退避时间&#x3D;争用期\times 随机数r,\其中r从离散的整数集合0,1，…，(2k.1)中随机取出一个，<br>$$</p><p>$$<br>k &#x3D; Min(重传次数，10)<br>$$</p><ul><li>若连续多次发生碰撞，就表明可能有较多的主机参与竞争信道。但使用上述退避算法可使重传需要推迟的平均时间随重传次数而增大（这也称为动态退避），因而减)小发生碰撞的概率，有利于整个系统的稳定。</li><li>当重传达16次仍不能成功时，这表明同时打算发送数据的主机太多以至于连续发生碰撞，则丢弃该帧并向高层报告。</li></ul><ol start="6"><li>以太网信道利用率</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117143437511.png"></p><ol start="7"><li>考虑以下这种理想情况：<ol><li>各主机发送帧都不会产生碰撞，总线一旦空闲就有某个主机立即发送帧：</li><li>发送一帧占用总线的时间为T0+T，而帧本身的发送时间是T0,</li><li>理想情况公式：</li></ol></li></ol><p>$$<br>S_{max} &#x3D; \frac{T_0}{T_0 + \tau} &#x3D; \frac{1}{1+\frac{\tau}{T_0}}<br>$$</p><ul><li>信道利用率受传播时延限制，所以以太网端到端的距离收到限制，以太网帧的长度最好尽量长些</li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117143601933.png"></p><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117143649489.png"></p><h2 id="3-CSMA-CA协议"><a href="#3-CSMA-CA协议" class="headerlink" title="3. CSMA&#x2F;CA协议"></a>3. CSMA&#x2F;CA协议</h2><ul><li><p>载波监听 多址接入  &#x2F; 碰撞避免 </p></li><li><p>载波监听多址接入&#x2F;碰撞避免CSMA&#x2F;CA(Carrier Sense Multiple Access&#x2F;Collision Avoidance)</p></li></ul><ol><li><p>既然CSMA&#x2F;CD协议已经成功地应用于使用广播信道的有线局域网，那么同样使用广播信道的无线局域网能不能也使用CSMA&#x2F;CD协议呢？</p></li><li><p>在无线局域网中，仍然可以使用载波监听多址接入CSMA,即在发送帧之前先对传输媒体进行载波监听。若发现有其他站在发送帧，就推迟发送以免发生碰撞。</p></li><li><p>在无线局域网中，不能使用碰撞检测CD,原因如下：</p><ol><li>由于无线信道的传输条件特殊，其信号强度的动态范围非常大，无线网卡上接收到的信号强度往往会远远小于发送信号的强度（可能相差百万倍）。如果要在无线网卡上实现碰撞检测CD,对硬件的要求非常高。</li><li>即使能够在硬件上实现无线局域网的碰撞检测功能，但由于无线电波传播的特殊性（存在隐蔽站问题)，进行碰撞检测的意义也不大。</li></ol></li><li><p>802.11无线局域网使用CSMA&#x2F;CA协议，在CSMA的基础上增加了一个碰撞避免CA功能，而不再实现碰撞检测功能。</p></li><li><p>由于不可能避免所有的碰撞，并且无线信道误码率较高，802.11标准还使用了数据链路层确认机制（停止-等待协议）来保证数据被正确接收。</p></li><li><p>802.11的MAC层标准定义了两种不同的媒体接入控制方式：</p><ol><li>分布式协调功能DCF(Distributed Coordination Function)。在DCF方式下，没有中心控制站点，每个站点使用CSMA&#x2F;CA协议通过争用信道来获取发送权，这是802.11定义的默认方式。</li><li>点协调功能PCF(Point Coordination Function)。PCF方式使用集中控制的接入算法 (一般在接入点AP实现集中控制)，是802.11定义的可选方式，在实际中较少使用。</li></ol></li></ol><h3 id="3-1-帧间间隔IFS-InterFrame-Space"><a href="#3-1-帧间间隔IFS-InterFrame-Space" class="headerlink" title="3.1 帧间间隔IFS(InterFrame Space)"></a>3.1 帧间间隔IFS(InterFrame Space)</h3><ol><li><p>802.11标准规定，所有的站点必须在持续检测到信道空闲一段指定时间后才能发送帧，这段时间称为帧间间隔FS。</p></li><li><p>帧间间隔的长短取决于该站点要发送的帧的类型：</p><ol><li>高优先级帧需要等待的时间较短，因此可优先获得发送权：</li><li>低优先级帧需要等待的时间较长。若某个站的低优先级帧还没来得及发送，而其他站的高优先级帧已发送到信道上，则信道变为忙态，因而低优先级帧就只能再推迟发送了。这样就减少了发生碰撞的机会。</li></ol><blockquote><p>无法在无线局域网中使用碰撞检测，所以还使用了停止-等待协议来实现可靠传输</p></blockquote></li><li><p>短帧间间隔（SIFS）和 长时间间隔（DIFS），常用的两种帧间间隔如下：</p><ol><li>短帧间间隔SIFS(28μs),是最短的帧间间隔，用来分隔开属于一次对话的各帧。一个站点应当能够在这段时间内从发送方式切换到接收方式。使用SIFS的帧类型有ACK帧、CTS帧、由过长的MAC帧分片后的数据帧、以及所有回答AP探询的帧和在PCF方式中接入点AP发送出的任何帧。</li><li>DCF帧间间隔DIFS(128μS),它比短帧间间隔SIFS要长得多，在DCF方式中用来发送数据帧和管理帧。</li></ol></li></ol><h3 id="3-2-退避算法"><a href="#3-2-退避算法" class="headerlink" title="3.2 退避算法"></a>3.2 退避算法</h3><ol><li>在执行退避算法时，站点为退避计时器设置一个随机的退避时间<ol><li>当退避计时器的时间减小到零时，就开始发送数据；</li><li>当退避计时器的时间还未减小到零时而信道又转变为忙状态，这时就冻结退避计时器的数值，重新等待信道变为空闲，再经过时间DIFS后，继续启动退避计时器。</li></ol></li><li>在进行第i次退避时，退避时间在时隙编号0,1,……,2^i+2^ -1中随机选择一个，然后乘以基本退避时间（也就是一个时隙的长度）就可以得到随机的退避时间。这样做是为了使不同站点选择相同退避时间的概率减少。当时隙编号达到255时（对应于第6次退避)就不再增加了。</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117150202751.png"></p><ol start="3"><li><p>何时执行退避算法</p><ol><li>在发送数据帧之前检测到信道处于忙状态时</li><li>在每一次重传一个数据帧时</li><li>在每一次成功发送后要连续发送下一个帧时（这是为了避免一个站点长时间占用信道）</li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117145612604.png" alt="image-20241117145612604"></p><ol start="4"><li><p>信道预约</p><ol><li>为了尽可能减少碰撞的概率和降低碰撞的影响，802.11标准允许要发送数据的站点对信道进行预约。</li><li>802.11标准允许要发送数据的站点对信道进行预约，即在发送数据帧之前先发送请求发送RTS帧。在收到响应允许发送CTS帧后，就可发送数据帧。<ol><li>源站在发送数据帧之前先发送一个短的控制帧，称为请求发送RTS(Request To Send),它包括源地址、目的地址以及这次通信（包括相应的确认帧)所需的持续时间。</li><li>若目的站正确收到源站发来的RTS顿，且媒体空闲，就发送一个响应控制帧，称为允许发送CTS(Clear To Send),它也包括这次通信所需的持续时间（从RTS帧中将此持续时间复制到CTS帧中）。</li><li>源站收到CTS帧后，再等待一段时间S1FS后，就可发送其数据帧。</li><li>若目的站正确收到了源站发来的数据帧，在等待时间SFS后，就向源站发送确认帧ACK。</li></ol></li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117150514559.png"></p><ul><li>除源站和目的站以外的其他各站，在收到CTS帧（或数据帧）后就推迟接入到无线局域网中。这样就保证了源站和目的站之间的通信不会受到其他站的干扰。</li><li>如果RTS帧发生碰撞，源站就收不到CTS帧，<strong>需执行退避算法重传RTS帧。</strong></li><li>由于RTS帧和CTS帧很短，发送碰撞的概率、碰撞产生的开销及本身的开销都很小。而对于一般的数据帧，其<strong>发送时延往往大于传播时延</strong>（因为是局域网），碰撞的概率很大，且一旦发生碰撞而导致数据帧重发，则浪费的时间就很多，因此用很小的代价对信道进行预约往往是值得的。802.11标准规定了3种情况供用户选择：<ol><li>使用RTS帧和CTS帧</li><li>不使用RTS帧和CTS帧</li><li>只有当数据帧的长度超过某一数值时才使用RTS帧和CTS帧</li></ol></li></ul><ol start="5"><li>虚拟载波监听<ol><li>除RTS帧和CTS帧会携带通信需要持续的时间，数据帧也能携带通信需要持续的时间，这称为802.11的虚拟载波监听机制。</li></ol></li><li>由于利用虚拟载波监听机制，站点只要监听到RTS帧、CTS帧或数据帧中的任何一个，就能知道信道被占用的持续时间，而不需要真正监听到信道上的信号，因此虚拟载波监听机制能减少隐蔽站带来的碰撞问题。</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-6-%E5%AA%92%E4%BD%93%E4%BB%8B%E5%85%A5%E6%8E%A7%E5%88%B6/image-20241117150646126.png" alt="image-20241117150646126"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.5 点对点协议PPP</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-5-%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-5-%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/</url>
    
    <content type="html"><![CDATA[<h1 id="3-5-点对点协议（PPP）"><a href="#3-5-点对点协议（PPP）" class="headerlink" title="3.5 点对点协议（PPP）"></a>3.5 点对点协议（PPP）</h1><h2 id="1-PPP"><a href="#1-PPP" class="headerlink" title="1. PPP"></a>1. PPP</h2><ol><li>点对点协议PPP(Point-to-Point Protocol)是目前使用最广泛的点对点数据链路层协议。</li><li>PPP协议是因特网工程任务组IETF在1992年制定的。经过1993年和1994年的修订，现在的PPP协议已成为因特网的正式标准[RFC1661,RFC1662]。</li><li>PPP协议为在点对点链路传输各种协议数据报提供了一个标准方法，主要由以下三部分构成：<ol><li>对各种协议数据报的封装方法（封装成帧）</li><li>链路控制协议LCP<ol><li>用于建立、配置以及测试数据链路的连接</li></ol></li><li>一套网络控制协议NCPs<ol><li>其中的每一个协议支持不同的网络层协议</li></ol></li></ol></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-5-%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/image-20241117132354632.png" alt="image-20241117132354632"></p><h2 id="2-帧格式"><a href="#2-帧格式" class="headerlink" title="2. 帧格式"></a>2. 帧格式</h2><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-5-%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/image-20241117132538280.png"></p><h2 id="3-透明传输"><a href="#3-透明传输" class="headerlink" title="3. 透明传输"></a>3. 透明传输</h2><h3 id="3-1-面向字节的异步链路采用插入转义字符的字节填充法"><a href="#3-1-面向字节的异步链路采用插入转义字符的字节填充法" class="headerlink" title="3.1 面向字节的异步链路采用插入转义字符的字节填充法"></a>3.1 面向字节的异步链路采用插入转义字符的字节填充法</h3><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-5-%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/image-20241117132827308.png"></p><h3 id="3-2-面向比特的同步链路采用插入比特0的比特填充法"><a href="#3-2-面向比特的同步链路采用插入比特0的比特填充法" class="headerlink" title="3.2 面向比特的同步链路采用插入比特0的比特填充法"></a>3.2 面向比特的同步链路采用插入比特0的比特填充法</h3><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-5-%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/image-20241117132942711.png"></p><h2 id="4-差错检测"><a href="#4-差错检测" class="headerlink" title="4. 差错检测"></a>4. 差错检测</h2><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-5-%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/image-20241117133033065.png"></p><h2 id="5-工作状态"><a href="#5-工作状态" class="headerlink" title="5. 工作状态"></a>5. 工作状态</h2><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-5-%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/image-20241117133237492.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.4 可靠传输</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-4-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-4-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/</url>
    
    <content type="html"><![CDATA[<h1 id="3-4-可靠传输"><a href="#3-4-可靠传输" class="headerlink" title="3.4 可靠传输"></a>3.4 可靠传输</h1><h2 id="1-可靠传输的基本概念"><a href="#1-可靠传输的基本概念" class="headerlink" title="1. 可靠传输的基本概念"></a>1. 可靠传输的基本概念</h2><ol><li>使用差错检测技术（例如循环冗余校验CRC)，接收方的数据链路层就可检测出帧在传输过程中是否产生了误码（比特错误）。</li></ol><h3 id="1-1-数据链路层向上层提供的服务类型"><a href="#1-1-数据链路层向上层提供的服务类型" class="headerlink" title="1.1 数据链路层向上层提供的服务类型"></a>1.1 数据链路层向上层提供的服务类型</h3><ol><li><p>不可靠传输服务：</p><ul><li>仅仅丢弃有误码的帧，其他什么也不做</li></ul></li><li><p>可靠传输服务：</p><ul><li>想办法实现发送端发送什么，接收端就收到什么。</li></ul></li><li><p>一般情况下，有线链路的误码率比较低，为了减小开销，并不要求数据链路层向上提供可靠传输服务。即使出现了误码，可靠传输的问题由其上层处理。</p></li><li><p>无线链路易受干扰，误码率比较高，因此要求数据链路层必须向上层提供可靠传输服务。</p></li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-4-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/image-20241117101000494.png"></p><h3 id="1-2-传输差错"><a href="#1-2-传输差错" class="headerlink" title="1.2 传输差错"></a>1.2 传输差错</h3><ul><li>比特差错只是传输差错中的一种。</li><li>从整个计算机网络体系结构来看，传输差错还包括分组丢失、分组失序以及分组重复。</li><li>分组丢失、分组失序以及分组重复这些传输差错，一般不会出现在数据链路层，而会出现在其上层。</li><li>可靠传输服务并不仅局限于数据链路层，其他各层均可选择实现可靠传输。</li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-4-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/image-20241117101226369.png"></p><h2 id="2-可靠传输的实现机制"><a href="#2-可靠传输的实现机制" class="headerlink" title="2. 可靠传输的实现机制"></a>2. 可靠传输的实现机制</h2><h3 id="2-1-停止-等待协议（SW）"><a href="#2-1-停止-等待协议（SW）" class="headerlink" title="2.1 停止-等待协议（SW）"></a>2.1 停止-等待协议（SW）</h3><ul><li>属于自动请求重传协议（ARQ）</li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-4-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/image-20230714151117181.png"></p><ol><li><p>接收端检测到数据分组有误码时，将其丢弃并等待发送方的超时重传。但对于误码率较高的点对点链路，为使发送方尽早重传，也可给发送方发送NAK分组。</p></li><li><p>为了让接收方能够判断所收到的数据分组是否是重复的，需要给数据分组编号。由于停止-等待协议的停等特性，只需1个比特编号就够了，即编号0和1</p></li><li><p>为了让发送方能够判断所收到的ACK分组是否是重复的，需要给ACK分组编号，所用比特数量与数据分组编号所用比特数量一样。数据链路层一般不会出现ACK分组迟到的情况，因此在数据链路层实现停止-等待协议可以不用给ACK分组编号。</p></li><li><p>超时计时器设置的重传时间应仔细选择。一般可将重传时间选为略大于“从发送方到接收方的平均往返时间”</p><ol><li>在数据链路层点对点的往返时间比较确定，重传时间比较好设定。</li><li>然而在运输层，由于端到端往返时间非常不确定，设置合适的重传时间有时并不容易。</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-4-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/image-20241117102422301.png"></p></li><li><p>当往返时延RTT远大于数据帧发送时延TD时（例如使用卫星链路），信道利用率非常低。若出现重传，则对于传送有用的数据信息来说，信道利用率还要降低。</p></li><li><p>为了克服停止-等待协议信道利用率很低的缺点，就产生了另外两种协议，即后退N帧协议GBN和选择重传协议SR。</p></li></ol><h3 id="2-2-回退N帧协议（GBN）"><a href="#2-2-回退N帧协议（GBN）" class="headerlink" title="2.2 回退N帧协议（GBN）"></a>2.2 回退N帧协议（GBN）</h3><ul><li>是一种滑动窗口协议</li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-4-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/image-20230714153916944.png"></p><ol><li>可退N帧协议在流水线传输的基础上利用发送窗回来限制发送方连续发送数据分组的数量，是一种连续ARQ协议。</li><li>在协议的工作过程中发送窗口和接收窗口不断向前滑动，因此这类协议又称为滑动窗回协议。</li><li>由于回退N帧协议的特性，当通信线路质量不好时。其信道利用率并不比停止等待协议高，</li></ol><h3 id="2-3-选择重传协议SR"><a href="#2-3-选择重传协议SR" class="headerlink" title="2.3 选择重传协议SR"></a>2.3 选择重传协议SR</h3><ol><li>回退N帧协议的接收窗口尺寸W只能等于1，因此接收方只能按序接收正确到达的数据分组。</li><li>一个数据分组的误码就会导致其后续多个数据分组不能被接收方按序接收而丢弃（尽管它们无乱序和误码)。这必然会造成发送方对这些数据分组的超时重传，显然这是对通信资源的极大浪费。</li><li>为了进一步提高性能，可设法只重传出现误码的数据分组。因此，接收窗口的尺寸W不应再等于1（而应大于1），以便接收方先收下失序到达但无误码并且序号落在接收窗口内的那些数据分组，等到所缺分组收齐后再一并送交上层。这就是选择重传协议。</li></ol><ul><li>注意：<ul><li>选择重传协议为了使发送方仅重传出现差错的分组，接收方不能再采用累积确认，而需要对每个正确接收到的数据分组进行逐一确认！</li></ul></li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-4-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/image-20230714174218114.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.3 差错检测</title>
    <link href="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-3-%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B/"/>
    <url>/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-3-%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="3-3-差错检测"><a href="#3-3-差错检测" class="headerlink" title="3.3 差错检测"></a>3.3 差错检测</h1><ul><li>实际的通信链路都不是理想的，比特在传输过程中可能会产生差错；1可能会变成0，而0也可能变成1。这称为比特差错。</li></ul><h2 id="1-误码率"><a href="#1-误码率" class="headerlink" title="1. 误码率"></a>1. 误码率</h2><ul><li><p>在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率BER(Bit Error Rate)。</p></li><li><p>使用<strong>差错检测码</strong>来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一。</p></li></ul><h2 id="2-奇偶校验"><a href="#2-奇偶校验" class="headerlink" title="2. 奇偶校验"></a>2. 奇偶校验</h2><ul><li>在待发送的数据后面添加1位奇偶校验位，使整个数据（包括所添加的校验位在内）中”1”的个数为奇数（奇校验）或偶数（偶校验）。</li></ul><ol><li>如果有奇数个位发生误码，则奇偶性发生变化，可以检查出误码；</li><li>如果有偶数个位发生误码，则奇偶性不发生变化，不能检查出误码</li></ol><ul><li>缺陷：漏检率较高</li></ul><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-3-%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B/image-20241117100050296.png"></p><h2 id="3-循环冗余校验CRC-Cyclic-Redundancy-Check"><a href="#3-循环冗余校验CRC-Cyclic-Redundancy-Check" class="headerlink" title="3. 循环冗余校验CRC(Cyclic Redundancy Check)"></a>3. 循环冗余校验CRC(Cyclic Redundancy Check)</h2><ol><li>收发双方约定好一个生成多项式G(x)</li><li>发送方基于待发送的数据和生成多项式计算出差错检测码（冗余码），将其添加到待传输数据的后面一起传输</li><li>接收方通过生成多项式来计算收到的数据是否产生了误码</li></ol><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-3-%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B/image-20241117100258487.png" alt="CRC"></p><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-3-%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B/image-20241117100334787.png" alt="生成多项式"></p><p><img src="/2024/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-3-%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B/image-20241117100543010.png"></p><ul><li><strong>做除法的意思是，做异或运算</strong></li></ul><ol><li>检错码只能检测出帧在传输过程中出现了差错，但并不能定位错误，因此无法纠正错误。</li><li>要想纠正传输中的差错，可以使用冗余信息更多的纠错码进行前向纠错。但纠错码的开销比较大，在计算机网络中较少使用。</li><li>循环冗余校验CRC有很好的检错能力（漏检率非常低），虽然计算比较复杂，但非常易于用硬件实现，因此被广泛应用于数据链路层。</li><li>在计算机网络中通常采用我们后续课程中将要讨论的检错重传方式来纠正传输中的差错，或者仅仅是丢弃检测到差错的帧，这取决于数据链路层向其上层提供的是可靠传输服务还是不可靠传输服务。</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.2 封装成帧</title>
    <link href="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-2-%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7/"/>
    <url>/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-2-%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="3-2-封装成帧"><a href="#3-2-封装成帧" class="headerlink" title="3.2 封装成帧"></a>3.2 封装成帧</h1><h2 id="1-帧"><a href="#1-帧" class="headerlink" title="1. 帧"></a>1. 帧</h2><ul><li><p>封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧。</p></li><li><p>帧头和帧尾的作用之一就是帧定界.</p></li></ul><p><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-2-%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7/image-20241117092740511.png" alt="帧"></p><h2 id="2-透明传输"><a href="#2-透明传输" class="headerlink" title="2. 透明传输"></a>2. 透明传输</h2><ul><li>数据链路层对上层交付的传输数据没有任何限制，就好像数据链路层不存在一样。</li></ul><ol><li>面向字节的物理链路使用字节填充（或称字符填充）的方法实现透明传输</li><li>面向比特的物理链路使用比特填充的方法实现透明传输。</li><li>为了提高帧的传输效率，应当使帧的数据部分的长度尽可能大些。</li></ol><p><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-2-%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7/image-20241117093119688.png" alt="透明传输"></p><ul><li>考虑到差错控制等多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即最大传送单元MTU (Maximum Transfer Unit)</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.1 数据链路层概述</title>
    <link href="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-1-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-1-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="3-1-数据链路层概述"><a href="#3-1-数据链路层概述" class="headerlink" title="3.1 数据链路层概述"></a>3.1 数据链路层概述</h1><ul><li>数据链路层以帧为单位传输和处理数据。</li></ul><ol><li>链路 (Link)</li></ol><ul><li>就是从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换结点。</li></ul><ol start="2"><li>数据链路(Data Link)</li></ol><ul><li>是指把实现通信协议的硬件和软件加到链路上，就构成了数据链路。</li></ul><h2 id="1-使用点对点信道的数据链路层三个重要问题"><a href="#1-使用点对点信道的数据链路层三个重要问题" class="headerlink" title="1. 使用点对点信道的数据链路层三个重要问题"></a>1. 使用点对点信道的数据链路层三个重要问题</h2><ol><li>封装成帧</li><li>差错检测</li><li>可靠传输<ol><li>尽管误码是不能完全避免的，但若能实现发送方发送什么接收方就能收到什么，就称为可靠传输。</li></ol></li></ol><h2 id="2-使用广播信道的数据链路层"><a href="#2-使用广播信道的数据链路层" class="headerlink" title="2. 使用广播信道的数据链路层"></a>2. 使用广播信道的数据链路层</h2><ol><li>共享式以太网的媒体接入控制协议CSMA&#x2F;CD</li><li>802.11局域网的媒体接入控制协议CSMA&#x2F;CA</li></ol><h2 id="3-数据链路层的互连设备"><a href="#3-数据链路层的互连设备" class="headerlink" title="3. 数据链路层的互连设备"></a>3. 数据链路层的互连设备</h2><ol><li>网桥和交换机的工作原理</li><li>集线器(物理连接设备)与交换机的区别</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.5 信道的极限容量</title>
    <link href="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-5-%E4%BF%A1%E9%81%93%E7%9A%84%E6%9E%81%E9%99%90%E5%AE%B9%E9%87%8F/"/>
    <url>/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-5-%E4%BF%A1%E9%81%93%E7%9A%84%E6%9E%81%E9%99%90%E5%AE%B9%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="2-5-信道极限容量"><a href="#2-5-信道极限容量" class="headerlink" title="2.5 信道极限容量"></a>2.5 信道极限容量</h1><ul><li>在信道带宽一定的情况下，根据奈氏准则和香农公式，要想提高信息的传输速率就必须采用多元制（更好的调制方法）和努力提高信道中的信噪比。</li></ul><h2 id="1-奈式准则"><a href="#1-奈式准则" class="headerlink" title="1. 奈式准则"></a>1. 奈式准则</h2><ul><li>理想低通信道的最高码元传输速率&#x3D;2W Baud&#x3D;2W(单位：码元&#x2F;秒)</li><li>理想带通信道的最高码元传输速率&#x3D;W Baud&#x3D;W(单位：码元&#x2F;秒)</li></ul><h2 id="2-香农公式-单位-bit-s"><a href="#2-香农公式-单位-bit-s" class="headerlink" title="2. 香农公式 单位:bit&#x2F;s"></a>2. 香农公式 单位:bit&#x2F;s</h2><p>$$<br>c &#x3D; W \times log_2(1 + \frac{S}{N})\<br>$$</p><p><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-5-%E4%BF%A1%E9%81%93%E7%9A%84%E6%9E%81%E9%99%90%E5%AE%B9%E9%87%8F/image-20241116162248949.png"></p><p><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-5-%E4%BF%A1%E9%81%93%E7%9A%84%E6%9E%81%E9%99%90%E5%AE%B9%E9%87%8F/image-20241116162436085.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.4 编码与调制</title>
    <link href="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-4-%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6/"/>
    <url>/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-4-%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="2-4-编码与调制"><a href="#2-4-编码与调制" class="headerlink" title="2.4 编码与调制"></a>2.4 编码与调制</h1><p><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-4-%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6/image-20241116160902949.png"></p><h2 id="1-常用编码"><a href="#1-常用编码" class="headerlink" title="1. 常用编码"></a>1. 常用编码</h2><ul><li>码元：在使用时间域的波形表示数字信号时代表不同离散数值的基本波形。</li></ul><ol><li><p>不归零编码（存在同步问题）</p><ul><li>需要额外一根传输线来传输时钟信号使发送方和接收方同步</li></ul></li><li><p>归零编码（自同步，编码效率低）</p></li><li><p>曼彻斯特编码（传统以太网）</p></li></ol><p><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-4-%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6/image-20241116161158338.png"></p><h2 id="2-编码与调制"><a href="#2-编码与调制" class="headerlink" title="2. 编码与调制"></a>2. 编码与调制</h2><h3 id="2-1-基本调制方法"><a href="#2-1-基本调制方法" class="headerlink" title="2.1 基本调制方法"></a>2.1 基本调制方法</h3><p><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-4-%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6/image-20241116161357102.png"></p><ol><li>调幅、调频、调相</li><li>混合调制</li></ol><p><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-4-%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6/image-20241116161941515.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.3 传输方式</title>
    <link href="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-3-%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F/"/>
    <url>/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-3-%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="2-3-传输方式"><a href="#2-3-传输方式" class="headerlink" title="2.3 传输方式"></a>2.3 传输方式</h1><h2 id="1-串并行"><a href="#1-串并行" class="headerlink" title="1. 串并行"></a>1. 串并行</h2><ol><li><p>串行传输</p></li><li><p>并行传输</p></li></ol><h2 id="2-同步异步"><a href="#2-同步异步" class="headerlink" title="2. 同步异步"></a>2. 同步异步</h2><ol><li><p>同步传输</p></li><li><p>异步传输</p></li><li><p>收发双方时钟同步的方法</p></li></ol><p></p><ul><li>外同步：在收发双方之间添加一条单独的时钟信号线</li><li>内同步：发送端将时钟同步信号编码到发送数据中一起传输 (例如曼彻斯特编码)</li></ul><p><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-3-%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F/image-20241116160018725.png" alt="image-20241116160018725"></p><h2 id="3-单双工"><a href="#3-单双工" class="headerlink" title="3.  单双工"></a>3.  单双工</h2><ul><li>单向通信（单工）广播</li><li>双向交替通信（半双工） 对讲机</li><li>双向同时通信（全双工）电话</li></ul><p><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-3-%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F/image-20241116160356202.png" alt="image-20241116160356202"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.2 物理层下面的传输媒体</title>
    <link href="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-2-%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93/"/>
    <url>/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-2-%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<h1 id="2-2-物理层下面的传输媒体"><a href="#2-2-物理层下面的传输媒体" class="headerlink" title="2.2 物理层下面的传输媒体"></a>2.2 物理层下面的传输媒体</h1><h2 id="1-传输媒体"><a href="#1-传输媒体" class="headerlink" title="1. 传输媒体"></a>1. 传输媒体</h2><h3 id="1-1-导引型传输媒体"><a href="#1-1-导引型传输媒体" class="headerlink" title="1.1 导引型传输媒体"></a>1.1 导引型传输媒体</h3><ol><li><p>双绞线</p><ol><li>绞合的作用<ul><li>抵御部分来自外界的电磁波干扰</li><li>减少相邻导线的电磁干扰</li></ul></li><li><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-2-%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93/image-20241116144027376.png" alt="image-20241116144027376"></li></ol></li><li><p>同轴电缆</p><ul><li>基带同轴电缆(50Ω) 数字传输，过去用于局域网</li></ul></li></ol><ul><li>宽带同轴电缆(75Ω)，模拟传输，目前主要用于有线电视<ul><li>同轴电缆价格较贵且布线不够灵活和方便，随着集线器的出现，在局域网领域基本上都是采用双绞线作为传输媒体。</li></ul></li></ul><ol start="3"><li><p>光纤</p><ol><li><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-2-%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93/image-20241116144053439.png" alt="image-20241116144053439"></li><li>纤芯直径<ul><li>多模光纤：50微米，62.5微米</li><li>单模光纤：9微米，包层直径125微米</li></ul></li><li>工作波长<ul><li>0.85微米（衰减较大）</li><li>1.30微米（衰减较小）</li><li>1.55微米（衰减较小）</li></ul></li><li>光纤的优点<ul><li>通信容量大 (25000~30000GHz的带宽)</li><li>传输损耗小，远距离传输时更加经济。</li><li>抗雷电和电磁干扰性能好。这在大电流脉冲干扰的环境下尤为重要</li><li>无串音干扰，保密性好，不易被窃听。</li><li>体积小，重量轻。</li></ul></li><li>光纤的缺点<ul><li>割接需要专用设备</li><li>光电接口价格较贵</li></ul></li><li><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-2-%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93/image-20241116144351388.png" alt="image-20241116144351388"></li><li><img src="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-2-%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93/image-20241116144534158.png" alt="image-20241116144534158"></li></ol></li><li><p>电力线</p></li></ol><h3 id="1-2-非导引型传输媒体"><a href="#1-2-非导引型传输媒体" class="headerlink" title="1.2 非导引型传输媒体"></a>1.2 非导引型传输媒体</h3><ol><li>微波通信（2~40GHz）</li><li>红外线</li><li>可见光</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.1 物理层的基本概念</title>
    <link href="/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-1-%E7%89%A9%E7%90%86%E5%B1%82%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2024/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-1-%E7%89%A9%E7%90%86%E5%B1%82%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="2-1-物理层的基本概念"><a href="#2-1-物理层的基本概念" class="headerlink" title="2.1 物理层的基本概念"></a>2.1 物理层的基本概念</h1><h2 id="1-传输媒体"><a href="#1-传输媒体" class="headerlink" title="1. 传输媒体"></a>1. 传输媒体</h2><ol><li>导引型传输媒体<ul><li>双绞线</li><li>同轴电缆</li><li>光纤</li><li>电力线</li></ul></li><li>非导引型传输媒体<ul><li>微波通信（2~40GHz）</li><li>红外线</li><li>可见光</li></ul></li></ol><h2 id="2-主要任务"><a href="#2-主要任务" class="headerlink" title="2. 主要任务"></a>2. 主要任务</h2><blockquote><ol><li>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流。</li><li>物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体是什么。</li></ol></blockquote><ol><li><p>机械特性</p><blockquote><p> 指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置</p></blockquote></li><li><p>电气特性</p><blockquote><p>指明在接口电缆的各条 线上出现的电压的范围。</p></blockquote></li><li><p>功能特性</p><blockquote><p>指明某条线上出现的某一电平的电压表示何种意义。</p></blockquote></li><li><p>过程特性</p><blockquote><p>指明对于不同功能的各种可能事件的出现顺序。</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.6 计算机体系结构</title>
    <link href="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <url>/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="1-6-计算机网络体系结构"><a href="#1-6-计算机网络体系结构" class="headerlink" title="1.6 计算机网络体系结构"></a>1.6 计算机网络体系结构</h1><h2 id="1-常见的计算机网络体系结构"><a href="#1-常见的计算机网络体系结构" class="headerlink" title="1. 常见的计算机网络体系结构"></a>1. 常见的计算机网络体系结构</h2><ol><li><p>OSI体系结构（开放系统互连参考模型）</p></li><li><p>TCP&#x2F;IP体系结构</p></li></ol><p><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20241115214722039.png"></p><p><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20241115214533994.png"></p><ul><li>IP协议可以为各种网络应用提供服务 (Everything over IP)</li><li>使用IP协议互连不同的网络接口 (IP over everything)</li></ul><h2 id="2-计算机网络体系结构分层的必要性"><a href="#2-计算机网络体系结构分层的必要性" class="headerlink" title="2. 计算机网络体系结构分层的必要性"></a>2. 计算机网络体系结构分层的必要性</h2><p>总线型网络</p><ul><li>如何标识网络中的各主机（主机编址问题，例如MAC地址）</li><li>如何从信号所表示的一连串比特流中区分出地址和数据</li><li>如何协调各主机争用总线</li></ul><blockquote><p>“分层“可将庞大而复杂的问题，转化为若干较小的局部问题，而这些较小的局部问题就比较易于研究和处理。</p></blockquote><table><thead><tr><th align="center">体系结构</th><th align="center">解决问题</th></tr></thead><tbody><tr><td align="center">应用层</td><td align="center">解决通过应用进程的交互来实现特定网络应用的问题</td></tr><tr><td align="center">表示层</td><td align="center">解决通信双方交换信息的表示问题</td></tr><tr><td align="center">会话层</td><td align="center">解决进程之间进行会话问题</td></tr><tr><td align="center">运输层</td><td align="center">解决进程之间基于网络的通信问题</td></tr><tr><td align="center">网络层</td><td align="center">解决分组在多个网络上传输（路由）问题</td></tr><tr><td align="center">数据链路层</td><td align="center">解决分组在一个网络（或一段链路）上传输的问题</td></tr><tr><td align="center">物理层</td><td align="center">解决使用何种信号来传输比特的问题</td></tr></tbody></table><ul><li>表示层的任务是实现与数据表示相关的功能，主要包括数据字符集的转换、数据格式化、文本压缩、数据加密以及解密等工作。</li></ul><h2 id="3-计算机网络体系结构中的专用术语"><a href="#3-计算机网络体系结构中的专用术语" class="headerlink" title="3. 计算机网络体系结构中的专用术语"></a>3. 计算机网络体系结构中的专用术语</h2><table><thead><tr><th align="center">术语</th><th align="left">解释</th></tr></thead><tbody><tr><td align="center">实体</td><td align="left">任何可发送或接收信息的硬件或软件进程</td></tr><tr><td align="center">对等实体</td><td align="left">收发双方相同层次中的实体</td></tr><tr><td align="center">协议</td><td align="left">控制两个对等实体进行逻辑通信的规则的集合</td></tr><tr><td align="center">协议三要素</td><td align="left">语法，语义，同步</td></tr><tr><td align="center">语法</td><td align="left">定义所交换信息的格式</td></tr><tr><td align="center">语义</td><td align="left">定义收发双方所要完成的操作</td></tr><tr><td align="center">同步</td><td align="left">定义收发双方的时序关系<br><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20241115225450275.png" alt="image-20241115225450275"></td></tr><tr><td align="center">服务</td><td align="left">在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务<br><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20241115225634091.png" alt="image-20241115225634091"></td></tr><tr><td align="center">服务访问点</td><td align="left">在同一系统中相邻两层的实体交换信息的逻辑接口，用于区分不同的服务类型<br>1. 数据链路层的服务访问点为帧的“类型”字段。<br>2. 网络层的服务访问点为IP数据报首部中的“协议字段”。<br>3. 运输层的服务访问点为“端口号”</td></tr><tr><td align="center">服务原语</td><td align="left">上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令称为服务原语</td></tr><tr><td align="center">协议数据单元PDU</td><td align="left">对等层次之间传送的数据包称为该层的协议数据单元</td></tr><tr><td align="center">服务数据单元SDU</td><td align="left">同一系统内，层与层之间交换的数据包称为服务数据单元<br>多个SDU可以合成为一个PDU；一个SDU也可划分为几个PDU</td></tr></tbody></table><p><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20241115225112571.png" alt="实体"></p><p><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20241115225152230.png" alt="协议"></p><ol><li>协议是“水平的”，服务是“垂直的</li><li>实体看得见相邻下层所提供的服务，但并不知道实现该服务的具体协议。也就是说，下面的协议对上面的实体是”透明”的。</li></ol><p><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20241115225809482.png" alt="SDU PDU"></p><h2 id="练习题："><a href="#练习题：" class="headerlink" title="练习题："></a>练习题：</h2><ol><li><p>在OSI参考模型中，自下而上第一个提供端到端服务的层次是：（B）<br>A.数据链路层 B.传输层 C.会话层 D.应用层</p><ul><li><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20241115230545942.png" alt="image-20241115230545942"></li></ul></li><li><p>下列选项中，不属于网络体系结构所描述的内容是 C<br>A.网络的层次 B.每一层使用的协议 C.协议的内部实现细节 D.每一层必须完成的功能</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.5 计算机网络的性能指标</title>
    <link href="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-5-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/"/>
    <url>/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-5-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<h1 id="1-5-计算机网络的性能指标"><a href="#1-5-计算机网络的性能指标" class="headerlink" title="1.5 计算机网络的性能指标"></a>1.5 计算机网络的性能指标</h1><table><thead><tr><th align="center">指标</th><th align="left">评测</th></tr></thead><tbody><tr><td align="center">速率</td><td align="left">连接在计算机网络上的主机在数字信道上传送比特的速率，也称为比特率或数据率<br>bit&#x2F;s（b&#x2F;s，bps)，kb&#x2F;s，Mb&#x2F;s，Gb&#x2F;s</td></tr><tr><td align="center">带宽</td><td align="left">用来表示网络的通信线路所能传送数据的能力，单位为Hz<br>因此网络带宽表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据量”<br>与速率指标相同</td></tr><tr><td align="center">吞吐量</td><td align="left">吞吐量表示在单位时间内通过某个网络（或信道、接口）的数据量。<br>吞吐量被经常用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。<br>吞吐量受网络的带宽或额定速率的限制。</td></tr><tr><td align="center">时延</td><td align="left">网络时延由三部分组成，分别为发送时延，传播时延，处理时延<br>网卡的发送速率，信道带宽，交换机的接口速率共同决定了发送时延<br><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-5-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/image-20241115211453147.png"></td></tr><tr><td align="center">时延带宽积</td><td align="left">1. 若发送端连续发送数据，则在所发送的第一个比特即将到达终点时，<br>     发送端就已经发送了时延带宽积个比特。<br>2. 链路的时延带宽积又称为以比特为单位的链路长度。</td></tr><tr><td align="center">往返时间（RTT）</td><td align="left">双向交互一次所需的时间<br>从源主机发送分组开始，直到源主机收到来自目的主机的确认分组为止</td></tr><tr><td align="center">利用率</td><td align="left">分为信道利用率，网络利用率<br>信道利用率：表示某信道有百分之几的时间是被利用的<br>网络利用率：全网络的信道利用率加权平均<br>信道利用率并非越高越好，高利用率会引发高时延</td></tr><tr><td align="center">丢包率</td><td align="left">丢包率即分组丢失率，是指在一定的时间范围内，传输过程中丢失的分组数量与总分组数量的比率。<br>丢包率具体可分为接口丢包率、结点丢包率、链路丢包率、路径丢包率、网络丢包率等<br></td></tr></tbody></table><ol><li><p>补充</p><ol><li>时延计算公式</li></ol></li></ol><p>$$<br>发送时延 &#x3D; \frac{分组长度}{发送速率}\\<br>$$</p><p>$$<br>发送时延 &#x3D; \frac{信道长度}{电磁波传播速率}<br>$$</p><ol start="2"><li>时延带宽积</li></ol><p>$$<br>时延带宽积 &#x3D; 传播时延 \times 带宽<br>$$</p><ul><li>处理时延一般不计算</li></ul><ol start="3"><li><p>网络当前时延与信道利用率之间的关系<br>$$<br>D为网络当前时延，D_0为网络空闲时的时延，U为信道利用率\<br>$$</p></li><li><p>丢包率计算公式<br>$$<br>丢包率 &#x3D; \frac{一定时间范围内丢失的分组数量}{总分组数量}<br>$$</p><p>$$<br>D &#x3D; \frac{D_0}{1-U}<br>$$</p></li><li><p>分组丢失的两种情况</p><ol><li>分组在传输过程中出现误码，被结点丢弃</li><li>分组到达一台队列已满的分组交换机时被丢弃，在通信量较大时就可能造成网络拥塞。</li></ol></li><li><p>丢包率反映了网络的拥塞情况</p><ol><li>无拥塞时路径丢包率为0</li><li>轻度拥塞时路径丢包率为1%~4%</li><li>严重拥塞时路径丢包率为5%~15%</li></ol></li><li><p>n个分组，m段链路，忽略处理时延，总时延的计算（假设分组等长，各链路长度相同，带宽相同）<br>$$<br>总时延 &#x3D; n个分组的发送时延 + 1个分组的发送时延 \times (m-1) + 1段链路的传播时延 \times m<br>$$</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.4 计算机网络的定义和分类</title>
    <link href="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%86%E7%B1%BB/"/>
    <url>/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-4-计算机网络的定义和分类"><a href="#1-4-计算机网络的定义和分类" class="headerlink" title="1.4 计算机网络的定义和分类"></a>1.4 计算机网络的定义和分类</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><ol><li><p>简单定义：一些<strong>互相连接</strong>的，<strong>自治</strong>的计算机的<strong>集合</strong></p><blockquote><p>互连：是指计算机之间可以通过有线或无线的方式进行数据通信；<br>自治：是指独立的计算机，它有自己的硬件和软件，可以单独运行使用；<br>集合：是指至少需要两台计算机。</p></blockquote></li><li><p>计算机网络的较好的定义</p><blockquote><p>计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号)。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</p></blockquote><ol><li>计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机等智能硬件</li><li>计算机网络并非专门用来传送数据，而是能够支持很多种的应用（包括今后可能出现的名种应用)</li></ol></li></ol><h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h2><h3 id="2-1-按交换技术分类"><a href="#2-1-按交换技术分类" class="headerlink" title="2.1 按交换技术分类"></a>2.1 按交换技术分类</h3><ol><li>电路交换网路</li><li>报文交换网络</li><li>分组交换网络</li></ol><h3 id="2-2-按使用者分类"><a href="#2-2-按使用者分类" class="headerlink" title="2.2 按使用者分类"></a>2.2 按使用者分类</h3><ol><li><p>公用网</p><blockquote><p>电信公司出资建造,给电信公司缴纳费用即可使用</p></blockquote></li><li><p>专用网</p><blockquote><p>不向外人提供服务</p></blockquote></li></ol><h3 id="2-3-按传输介质分类"><a href="#2-3-按传输介质分类" class="headerlink" title="2.3 按传输介质分类"></a>2.3 按传输介质分类</h3><ol><li><p>有线网路</p><blockquote><p>包括双绞线网络,光纤网络等</p></blockquote></li><li><p>无线网络</p><blockquote><p>WIFI应用普遍</p></blockquote></li></ol><h3 id="2-4-按覆盖范围分类"><a href="#2-4-按覆盖范围分类" class="headerlink" title="2.4 按覆盖范围分类"></a>2.4 按覆盖范围分类</h3><ol><li><p>广域网(WAN)</p><blockquote><p>可以覆盖一个国家,地区甚至几个洲</p><p>WAN是因特网的核心部分,为核心路由器提供远距离高速连接</p></blockquote></li><li><p>城域网(MAN)</p><blockquote><p>覆盖一个街区,或几个城市</p><p>通常作为城市骨干网,互连学校,企业,机构的局域网</p></blockquote></li><li><p>局域网(LAN)</p><blockquote><p>覆盖一个实验室,一幢楼,一个校园等</p></blockquote></li><li><p>个域网(PAN)</p><blockquote><p>即无线个人区域网(WPAN),在各人工作的地方,将属于个人使用的电子设备用无线技术连接起来的网络</p></blockquote></li></ol><h3 id="2-5-按拓扑结构分类"><a href="#2-5-按拓扑结构分类" class="headerlink" title="2.5 按拓扑结构分类"></a>2.5 按拓扑结构分类</h3><ol><li>总线型网络</li></ol><p><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%86%E7%B1%BB/image-20230712140101315.png"></p><ol start="2"><li>星型网络</li></ol><p><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%86%E7%B1%BB/image-20230712140145867.png"></p><ol start="3"><li>环型网络</li></ol><p><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%86%E7%B1%BB/image-20230712140251758.png"></p><ol start="4"><li>网状型网络</li></ol><p><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%86%E7%B1%BB/image-20230712140454142.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.3 三种交换方式</title>
    <link href="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-3-%E4%B8%89%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F/"/>
    <url>/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-3-%E4%B8%89%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-3-三种交换方式"><a href="#1-3-三种交换方式" class="headerlink" title="1.3 三种交换方式"></a>1.3 三种交换方式</h1><h2 id="1-电路交换-Circuit-Switching"><a href="#1-电路交换-Circuit-Switching" class="headerlink" title="1. 电路交换(Circuit Switching)"></a>1. 电路交换(Circuit Switching)</h2><ul><li>电话交换机接通电话线的方式称为电路交换，中间设备是电话交换机</li><li>从通信资源的分配角度来看，交换(Switching)就是按照某种方式动态地分配传输线路的资源；</li><li>当使用电路交换来传送计算机数据时，其线路的传输效率往往很低。</li><li>不适合计算机传输数据，因为占用通信资源，却迟迟不使用，造成通信资源的浪费</li></ul><p><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-3-%E4%B8%89%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F/image-20241115203653573.png" alt="电话交换机"></p><ol><li>电话交换的三个步骤<ol><li>建立连接（分配通信资源）</li><li>通话（一直占用通信资源）</li><li>释放连接（归还通信资源）</li></ol></li><li>优点<ol><li>通信时延小</li><li>有序传输</li><li>没有冲突</li><li>适用范围广</li><li>实时性强</li><li>控制简单</li></ol></li><li>缺点<ol><li>建立连接时间长</li><li>线路独占，使用效率低</li><li>灵活性差</li><li>难以规格化</li></ol></li></ol><h2 id="2-分组交换-Packet-Switching-※"><a href="#2-分组交换-Packet-Switching-※" class="headerlink" title="2. 分组交换(Packet Switching)※"></a>2. 分组交换(Packet Switching)※</h2><p><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-3-%E4%B8%89%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F/image-20241115204514266.png"></p><blockquote><p>通常把表示消息的整块数据称为一个报文</p></blockquote><ol><li><p>步骤</p><ol><li><p>发送方：构造分组，发送分组</p></li><li><p>路由器：缓存分组，转发分组</p></li><li><p>接收方：接收分组，还原报文</p></li></ol></li><li><p>优点</p><ol><li>无需建立连接</li><li>线路利用率高</li><li>简化了存储管理</li><li>加速传输</li><li>减少出错概率和重发数据量</li></ol></li><li><p>缺点</p><ol><li><p>引起了转发时延</p></li><li><p>需要传输额外的信息量</p></li><li><p>对于数据报服务，存在失序、丢失或重复分组的问题;</p><p>对于虚电路服务存在呼叫建立、数据传输和虚电路释放三个过程</p></li></ol></li></ol><h2 id="3-报文交换-Message-Switching"><a href="#3-报文交换-Message-Switching" class="headerlink" title="3. 报文交换(Message Switching)"></a>3. 报文交换(Message Switching)</h2><blockquote><p>与分组交换类似，但对报文大小没有限制，也不分组，现代已很少使用该方法</p></blockquote><ol><li><p>优点</p><ol><li>无需建立连接</li><li>动态分配线路</li><li>提高线路可靠性</li><li>提高线路利用率</li><li>提供多目标服务</li></ol></li><li><p>缺点</p><ol><li>引起了转发时延</li><li>需要较大存储缓存空间</li><li>需要传输额外的信息量</li></ol></li></ol><p><img src="/2024/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-3-%E4%B8%89%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F/image-20241115204815895.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HCTA：多智能体强化学习中的分层合作任务分配</title>
    <link href="/2024/11/15/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/HCTA%EF%BC%9A%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%88%86%E5%B1%82%E5%90%88%E4%BD%9C%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/"/>
    <url>/2024/11/15/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/HCTA%EF%BC%9A%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%88%86%E5%B1%82%E5%90%88%E4%BD%9C%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="HCTA-Hierarchical-Cooperative-Task-Allocation-in-Multi-Agent-Reinforcement-Learning"><a href="#HCTA-Hierarchical-Cooperative-Task-Allocation-in-Multi-Agent-Reinforcement-Learning" class="headerlink" title="HCTA:Hierarchical Cooperative Task Allocation in Multi-Agent Reinforcement Learning"></a>HCTA:Hierarchical Cooperative Task Allocation in Multi-Agent Reinforcement Learning</h1><h2 id="1-主要内容"><a href="#1-主要内容" class="headerlink" title="1. 主要内容"></a>1. 主要内容</h2><ol><li><strong>子任务选择</strong>：</li></ol><ul><li>基于行动链的长期行为特征动态选择每个智能体适合的子任务。</li></ul><ol start="2"><li><strong>层次化策略学习</strong>：</li></ol><ul><li>结合上述子任务分解和选择，形成层次化合作策略学习框架。在上层动态选择子任务，并在下层根据上层的任务分配结果指导具体决策策略的学习。</li></ul><ol start="3"><li><strong>双时序分辨率框架</strong>：</li></ol><ul><li>HCTA使用双时序分辨率框架，在低时序分辨率的时标上进行任务选择，然后在高时序分辨率的时标上进行策略学习。</li></ul><ol start="4"><li><strong>实验验证</strong>：</li></ol><ul><li>在StarCraft II环境中进行广泛的实验，以评估HCTA框架在不同难度级别上的表现，并与其他基线算法进行比较。</li></ul><p>这些方法共同构成了文章提出的HCTA框架，旨在通过层次化和动态的任务分配来提高多智能体系统在复杂任务中的合作效率和学习效果。</p><ul><li>在本文中，我们的目标是使<strong>个体的子组能够通过人类在处理复杂任务时使用的分解思想来学习解决不同的子任务。</strong></li></ul><h2 id="2-子任务分解"><a href="#2-子任务分解" class="headerlink" title="2. 子任务分解"></a>2. 子任务分解</h2><p>在文章中提到的HCTA（Hierarchical Cooperative Task Allocation）框架中，子任务的分解是通过以下步骤实现的：</p><ol><li><strong>行动表示学习（Action Representation Learning）</strong>：</li></ol><ul><li>首先，框架通过行动表示学习来实现子任务的分解。这是通过创建一个能够反映行动对环境和其他智能体影响的表示（即<code>za = fθ(a; θe)</code>）来完成的，其中<code>za</code>是行动的表示，<code>a</code>是行动本身，<code>θ</code>是学习到的参数。</li></ul><ol start="2"><li><strong>行动空间聚类（Action Space Clustering）</strong>：</li></ol><ul><li>基于行动表示的结果，整个行动空间被聚类分解为多个子行动空间，每个子行动空间对应一个子任务。这样的分解减少了每个子任务的行动空间维度，使得相应的智能体在具有相似效果的行动空间中搜索。</li></ul><ol start="3"><li><strong>行动链模型（Action Chain Model）</strong>：</li></ol><ul><li>使用行动链模型来学习行动编码器。每个智能体选择多个时间步的行动表示作为行动链编码器的输入。通过自注意力机制，智能体学习与自身属性相关的多步行动的累积效应。</li></ul><ol start="4"><li><strong>子任务定义（Subtask Definition）</strong>：</li></ol><ul><li>文章中对子任务的定义是：对于一个给定的合作多智能体任务<code>G</code>，一个角色<code>ρi</code>是一个包含子任务<code>ϕi</code>的元组，<code>ϕi</code>由<code>⟨Ai, Ii, S, P, R, Ωi, O, γ⟩</code>组成，其中<code>Ai</code>是子任务的行动空间，<code>Ii</code>是智能体的子集，且满足<code>Ii ⊂ I</code>，<code>∪iIi = I</code>，<code>Ii ∩ Ij = ∅</code>（对于<code>i ≠ j</code>）。</li></ul><ol start="5"><li><strong>长期行为链（Long-term Behavior Chain）</strong>：</li></ol><ul><li>基于行动链的结果，生成反映智能体行为特征的长期行动链。这个长期行为链用于动态选择适合每个智能体的子任务。</li></ul><p>通过这些步骤，HCTA框架能够将复杂的多智能体任务分解为更小、更易于管理的子任务，每个子任务都涉及一个较小的行动观察空间，从而使智能体能够更有效地专注于特定的子任务。这种分解方法不仅提高了任务分配的效率，还降低了计算复杂度，并使得智能体能够更好地协作以完成复杂的任务。</p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
      <category>多智能体强化学习任务分配</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
      <tag>科研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向兵棋推演的强化学习分层任务优化技术研究</title>
    <link href="/2024/11/15/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E9%9D%A2%E5%90%91%E5%85%B5%E6%A3%8B%E6%8E%A8%E6%BC%94%E7%9A%84%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%88%86%E5%B1%82%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    <url>/2024/11/15/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E9%9D%A2%E5%90%91%E5%85%B5%E6%A3%8B%E6%8E%A8%E6%BC%94%E7%9A%84%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%88%86%E5%B1%82%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="1-主要内容"><a href="#1-主要内容" class="headerlink" title="1. 主要内容"></a>1. 主要内容</h2><p>论文深入探讨了分层控制结构的多智能体强化学习算法在兵棋推演环境中的应用，旨在优化复杂和不确定环境下的任务分配和多智能体任务的执行过程。主要研究内容包括：</p><ol><li>针对实时兵棋推演环境，设计了兵棋AI的状态空间和动作空间，并生成了敌我对抗态势的关键特征信息。通过离散化连续动作的操作优化了原始动作空间，简化了多智能体的交互过程，加快了网络学习速度。</li><li>提出了一种融合注意力机制的DQN算法（ADQN），通过嵌入网络和注意力对输入进行向量化处理后输入DQN网络，将环境分解为独立的子环境，并重新定义特定于子任务的动作-价值函数，有效提高了在复杂环境中进行任务分配的质量和效率。</li><li>基于深度强化学习的多级控制结构，提出了多智能体分层自主决策算法（ADQN-MAPPO），结合了多智能体近端策略优化算法与ADQN算法，通过将复杂任务划分成子任务进行分配后再执行，增强了智能体自主决策的能力，提高了算法模型的训练速度和决策能力。</li></ol><p>论文通过在山地3v3和水田3v3的兵棋推演环境中的实验，验证了ADQN-MAPPO算法在得分能力、胜率、步均推理时间以及模型的泛化能力等方面的优越性能。研究结果对进一步提升分层控制结构的多智能体强化学习算法在兵棋推演以及其他复杂应用环境中的性能和应用范围提供了参考意义。</p><h2 id="2-分层决策框架"><a href="#2-分层决策框架" class="headerlink" title="2. 分层决策框架"></a>2. 分层决策框架</h2><p>这篇论文中提出的分层决策框架是为了解决兵棋推演环境中的多智能体任务分配和执行问题。分层决策框架包括两个主要层次：任务分配层和智能体决策层。以下是这两个层次的详细介绍：</p><h3 id="2-1-任务分配层"><a href="#2-1-任务分配层" class="headerlink" title="2.1 任务分配层"></a>2.1 任务分配层</h3><p>任务分配层的目的是将全局任务分解为多个子任务，并将这些子任务分配给不同的智能体。这一层主要关注如何在多智能体系统中高效地分配任务，以便每个智能体可以专注于自己的子任务，从而提高整体任务执行的效率和效果。</p><ul><li><strong>状态空间和动作空间设计</strong>：在这一层中，状态空间包括了整个环境的总体状态，如战场上的地形、敌我双方的兵力部署等。动作空间则由子任务的编号集合构成，意味着每个智能体的动作是选择一个子任务来执行。</li><li><strong>子任务设计</strong>：根据兵棋推演游戏的特性，将总体任务细分为行军、进攻、防御、支援、夺控等子任务。每个子任务由任务名称、编号、类型、关系、目标等元素组成。</li><li><strong>ADQN算法</strong>：提出了一种融合注意力机制的DQN算法（ADQN），用于处理任务分配问题。ADQN算法通过智能体对子任务的执行，将环境分解为独立的子环境，并重新定义特定于子任务的动作-价值函数。</li></ul><h3 id="2-2-智能体决策层"><a href="#2-2-智能体决策层" class="headerlink" title="2.2 智能体决策层"></a>2.2 智能体决策层</h3><p>智能体决策层根据任务分配层分配的子任务，每个智能体需要做出具体的行动决策来完成任务。这一层主要关注智能体如何在局部环境中做出最优决策。</p><ul><li><strong>MAPPO算法</strong>：在这一层中，使用了多智能体近端策略优化算法（MAPPO），它是一种适用于多智能体环境的强化学习算法，可以处理分布式部分可观察马尔可夫决策过程（DEC-POMDP）。</li><li><strong>策略网络和评价网络</strong>：每个智能体都有自己的策略网络，根据局部观测信息产生动作。同时，有一个全局评价网络根据全局环境信息生成状态价值，用于指导策略网络的更新。</li><li><strong>分层架构的优势</strong>：通过分层架构，上层任务分配网络可以在更大的时间尺度上运行，而下层智能体策略网络则在更细的尺度上做出决策。这种分层方法有助于提高智能体在兵棋推演环境中的决策效率和效果。</li></ul><h3 id="2-3-ADQN-MAPPO算法"><a href="#2-3-ADQN-MAPPO算法" class="headerlink" title="2.3 ADQN-MAPPO算法"></a>2.3 ADQN-MAPPO算法</h3><p>ADQN-MAPPO算法是将ADQN算法和MAPPO算法结合的分层决策框架。这种框架通过将复杂任务分解为子任务，并在不同的抽象层次上学习策略，解决了大规模复杂环境下的决策问题。ADQN-MAPPO算法在实验中表现出了优越的性能，包括更高的得分能力、胜率以及更快的收敛速度。</p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
      <category>多智能体强化学习任务分配</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
      <tag>科研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于分层强化学习的多智能体博弈对抗策略</title>
    <link href="/2024/11/15/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E5%9F%BA%E4%BA%8E%E5%88%86%E5%B1%82%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%8D%9A%E5%BC%88%E5%AF%B9%E6%8A%97%E7%AD%96%E7%95%A5/"/>
    <url>/2024/11/15/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E5%9F%BA%E4%BA%8E%E5%88%86%E5%B1%82%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%8D%9A%E5%BC%88%E5%AF%B9%E6%8A%97%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="1-主要内容"><a href="#1-主要内容" class="headerlink" title="1. 主要内容"></a>1. 主要内容</h2><h3 id="1-1-研究内容"><a href="#1-1-研究内容" class="headerlink" title="1.1 研究内容"></a>1.1 研究内容</h3><ul><li>提出了一种结合任务可解释性的指挥官-集群多智能体分层强化学习算法，提高算法在复杂博弈场景中的收敛速度。</li><li>设计了一种结合软决策树的多智能体分层强化学习算法，增强了策略的解释性。</li><li>基于模糊决策树建立了博弈对抗策略，通过挖掘战法规则，模拟人的决策过程。</li><li>在联合作战实验平台上设计了空战博弈场景和海空联合作战场景，验证了所提算法的有效性。</li></ul><h3 id="1-2-算法设计与实验验证"><a href="#1-2-算法设计与实验验证" class="headerlink" title="1.2 算法设计与实验验证"></a>1.2 算法设计与实验验证</h3><ul><li>设计了指挥官-集群分层强化学习算法，并通过实验验证了其在收敛性、解释性与作战效能方面的优势。</li><li>设计了结合软决策树的分层强化学习算法，验证了其在策略解释性和算法收敛性方面的优势。</li><li>提出了基于模糊决策树的博弈对抗策略，并通过实验验证了其分类效果和战法规则提取效果。</li></ul><h3 id="1-3-实验环境与设置"><a href="#1-3-实验环境与设置" class="headerlink" title="1.3 实验环境与设置"></a>1.3 实验环境与设置</h3><ul><li>使用了“StarCraft2”作为实验平台，设计了多种博弈场景，包括简单同构智能体控制场景、复杂同构智能体控制场景和复杂异构智能体控制场景。</li></ul><h3 id="1-4-结论与展望"><a href="#1-4-结论与展望" class="headerlink" title="1.4 结论与展望"></a>1.4 结论与展望</h3><ul><li>论文提出的分层强化学习算法在多智能体博弈对抗中具有实际应用价值和潜力，尤其在提高指挥部快速决策能力和军队快速反应打击能力上。</li><li>论文还指出了研究的局限性，并对未来的研究方向提出了展望，包括消除上层智能体学习训练结果对模型性能的负面影响，以及针对模糊环境下多层次、多目标的决策问题开展研究。</li></ul><h2 id="2-研究方法"><a href="#2-研究方法" class="headerlink" title="2. 研究方法"></a>2. 研究方法</h2><ul><li><strong>分层强化学习（HRL）</strong>：文章采用分层强化学习方法来处理多智能体复杂博弈场景中的策略优化问题。这种方法通过将复杂的决策问题分解为多个层次，使得学习过程更加高效和可解释。</li><li><strong>结合任务可解释性</strong>：文章提出了结合任务可解释性的指挥官-集群分层强化学习算法，通过模仿学习设计可解释的子任务，引入专家经验，提高算法的收敛速度。</li><li><strong>软决策树</strong>：为了增强策略的解释性，文章设计了结合软决策树的分层强化学习算法，通过引入线性权重表示状态特征与决策结果之间的因果逻辑。</li><li><strong>模糊决策树</strong>：文章进一步挖掘战法规则，建立基于模糊决策树的博弈对抗策略，模拟人的决策过程，并提取模糊决策树中隐藏的战术规则。</li></ul><h2 id="3-算法实现"><a href="#3-算法实现" class="headerlink" title="3. 算法实现"></a>3. 算法实现</h2><ul><li><strong>指挥官-集群分层强化学习算法（HES）</strong>：文章实现了一种指挥官-集群分层强化学习算法，该算法包含上层指挥官决策模型和下层集群作战模型，通过可解释子任务实现信息传递。</li><li><strong>结合软决策树的分层强化学习算法（HEE）</strong>：文章实现了一种结合软决策树的分层强化学习算法，该算法在HES算法框架基础上，将软决策树结构融入宏观决策过程中。</li><li><strong>基于模糊决策树的博弈对抗策略（FDTGAS）</strong>：文章实现了一种基于模糊决策树的博弈对抗策略，通过预处理对抗数据，构建模糊决策树，并从中提取战法规则。</li></ul><h2 id="4-上层决策模型的主要特点和实现细节："><a href="#4-上层决策模型的主要特点和实现细节：" class="headerlink" title="4. 上层决策模型的主要特点和实现细节："></a>4. 上层决策模型的主要特点和实现细节：</h2><h3 id="4-1-指挥官-集群分层强化学习算法（HES）中的上层决策模型"><a href="#4-1-指挥官-集群分层强化学习算法（HES）中的上层决策模型" class="headerlink" title="4.1 指挥官-集群分层强化学习算法（HES）中的上层决策模型"></a>4.1 指挥官-集群分层强化学习算法（HES）中的上层决策模型</h3><ul><li><strong>指挥官决策模型</strong>：模拟战争中高级指挥官的决策过程，基于战争总体形势的变化制定总体作战规划，并将战斗子任务分配给下层战斗单位。</li><li><strong>任务可解释性</strong>：结合任务可解释性思想，设计可解释的子任务，将专家经验引入到分层框架中，引导智能体进行定向学习，提高算法的收敛速度。</li></ul><h3 id="4-2-结合软决策树的分层强化学习算法（HEE）中的上层决策模型"><a href="#4-2-结合软决策树的分层强化学习算法（HEE）中的上层决策模型" class="headerlink" title="4.2 结合软决策树的分层强化学习算法（HEE）中的上层决策模型"></a>4.2 结合软决策树的分层强化学习算法（HEE）中的上层决策模型</h3><ul><li><strong>软决策树（SDT）</strong>：引入软决策树结构，改进传统的决策树模型，使其可以替代神经网络拟合动作价值函数，增强模型的可解释性。</li><li><strong>线性权重</strong>：在软决策树的叶子节点引入线性模型，通过线性权重表示状态特征与决策结果之间的因果逻辑，增强策略的解释性。</li></ul><h3 id="4-3-基于模糊决策树的博弈对抗策略中的上层决策模型"><a href="#4-3-基于模糊决策树的博弈对抗策略中的上层决策模型" class="headerlink" title="4.3 基于模糊决策树的博弈对抗策略中的上层决策模型"></a>4.3 基于模糊决策树的博弈对抗策略中的上层决策模型</h3><ul><li><strong>模糊决策树</strong>：构建模糊决策树模拟人的决策过程，处理高维度数据集中的模糊性和不确定性，提高分类的准确率和模型的泛化能力。</li><li><strong>战法规则提取</strong>：从模糊决策树中提取隐含的战法规则，建立以IF-THEN规则形式表示的博弈对抗策略。</li></ul><h3 id="4-4-实现细节"><a href="#4-4-实现细节" class="headerlink" title="4.4 实现细节"></a>4.4 实现细节</h3><ul><li><strong>神经网络建模</strong>：上层决策模型通常采用神经网络进行建模，使用深度学习技术来处理高维数据和复杂的决策问题。</li><li><strong>参数更新</strong>：上层决策模型的参数通过梯度下降法进行更新，利用经验回放机制和策略梯度方法来优化模型性能。</li><li><strong>目标分解</strong>：上层智能体学习目标的分解策略，将复杂的任务分解为多个子目标，通过子目标的实现逐步达成最终目标。</li></ul><h3 id="4-5-应用场景"><a href="#4-5-应用场景" class="headerlink" title="4.5 应用场景"></a>4.5 应用场景</h3><ul><li><strong>联合作战实验平台</strong>：在空战博弈场景和海空联合作战场景中，上层决策模型负责制定整体作战策略，指导下层作战单元执行具体的作战任务。</li></ul><h2 id="5-上层决策模型的具体实现细节"><a href="#5-上层决策模型的具体实现细节" class="headerlink" title="5. 上层决策模型的具体实现细节"></a>5. 上层决策模型的具体实现细节</h2><h3 id="5-1-指挥官-集群分层强化学习算法（HES）的上层决策模型"><a href="#5-1-指挥官-集群分层强化学习算法（HES）的上层决策模型" class="headerlink" title="5.1 指挥官-集群分层强化学习算法（HES）的上层决策模型"></a>5.1 指挥官-集群分层强化学习算法（HES）的上层决策模型</h3><h4 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h4><ul><li><strong>指挥官角色</strong>：模拟高级指挥官的决策过程，负责在战争或博弈的宏观层面上制定战略。</li><li><strong>任务分解</strong>：将复杂的任务分解为可解释的子任务，这些子任务对下层集群作战模型来说是具体的战术目标。</li></ul><h4 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h4><ul><li><strong>神经网络架构</strong>：使用神经网络来拟合指挥官的决策策略，该网络输入全局观测状态，输出子任务或战术目标。</li><li><strong>模仿学习</strong>：基于专家经验设计可解释的子任务，通过模仿学习将专家知识整合到神经网络的训练过程中。</li><li><strong>参数更新</strong>：利用梯度下降方法更新神经网络参数，以最小化损失函数，提高决策质量。</li></ul><h3 id="5-2-结合软决策树的分层强化学习算法（HEE）的上层决策模型"><a href="#5-2-结合软决策树的分层强化学习算法（HEE）的上层决策模型" class="headerlink" title="5.2 结合软决策树的分层强化学习算法（HEE）的上层决策模型"></a>5.2 结合软决策树的分层强化学习算法（HEE）的上层决策模型</h3><h4 id="设计理念-1"><a href="#设计理念-1" class="headerlink" title="设计理念"></a>设计理念</h4><ul><li><strong>软决策树（SDT）</strong>：引入软决策树来增强策略的解释性，SDT 结合了神经网络的非线性建模能力和决策树的可解释性。</li></ul><h4 id="实现细节-1"><a href="#实现细节-1" class="headerlink" title="实现细节"></a>实现细节</h4><ul><li><strong>树结构优化</strong>：对传统的软决策树结构进行改进，引入线性权重来表示状态特征与决策结果之间的因果逻辑。</li><li><strong>线性叶子节点</strong>：在SDT的叶子节点使用线性模型，这些模型通过学习状态特征的权重来预测动作价值。</li><li><strong>在线学习</strong>：SDT模型支持在线学习，能够根据实时数据更新模型参数，增强模型对新态势的适应能力。</li></ul><h3 id="5-3-基于模糊决策树的博弈对抗策略的上层决策模型"><a href="#5-3-基于模糊决策树的博弈对抗策略的上层决策模型" class="headerlink" title="5.3 基于模糊决策树的博弈对抗策略的上层决策模型"></a>5.3 基于模糊决策树的博弈对抗策略的上层决策模型</h3><h4 id="设计理念-2"><a href="#设计理念-2" class="headerlink" title="设计理念"></a>设计理念</h4><ul><li><strong>模糊决策树</strong>：利用模糊决策树处理高维度数据集中的模糊性和不确定性，提高决策的准确性和泛化能力。</li></ul><h4 id="实现细节-2"><a href="#实现细节-2" class="headerlink" title="实现细节"></a>实现细节</h4><ul><li><strong>属性模糊化</strong>：将连续型属性转换为模糊集合，并通过隶属度函数计算属性值在模糊集合中的隶属度。</li><li><strong>分裂属性选择</strong>：基于分类不确定性选择分裂属性，以最小化节点的平均模糊信息熵。</li><li><strong>战法规则提取</strong>：从模糊决策树中提取IF-THEN形式的战法规则，为博弈对抗提供具体的策略指导。</li></ul><h3 id="5-4-通用实现细节"><a href="#5-4-通用实现细节" class="headerlink" title="5.4 通用实现细节"></a>5.4 通用实现细节</h3><h4 id="损失函数与优化"><a href="#损失函数与优化" class="headerlink" title="损失函数与优化"></a>损失函数与优化</h4><ul><li><strong>损失函数</strong>：设计损失函数以衡量模型预测与实际结果之间的差异，常用的损失函数包括均方误差等。</li><li><strong>优化算法</strong>：采用Adam优化器等高级优化算法来更新模型参数，提高训练效率和模型性能。</li></ul><h4 id="训练与验证"><a href="#训练与验证" class="headerlink" title="训练与验证"></a>训练与验证</h4><ul><li><strong>训练过程</strong>：通过与环境的交互不断收集数据，利用这些数据训练上层决策模型。</li><li><strong>验证与测试</strong>：在不同的博弈场景中验证上层决策模型的有效性，调整模型参数以适应不同的战术需求。</li></ul><p>这些实现细节共同构成了上层决策模型的核心，使其能够在多智能体博弈对抗中发挥关键作用。通过这些细节的实现，上层决策模型能够提供有效的战略指导，并与下层执行模型协同工作，实现整体任务目标。</p><p>[1]乔天润.基于分层强化学习的多智能体博弈对抗策略[D].东南大学,2023.DOI:10.27014&#x2F;d.cnki.gdnau.2023.001144.</p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
      <category>多智能体强化学习任务分配</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
      <tag>科研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于多智能体强化学习的分层决策优化方法</title>
    <link href="/2024/11/15/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%88%86%E5%B1%82%E5%86%B3%E7%AD%96%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"/>
    <url>/2024/11/15/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%88%86%E5%B1%82%E5%86%B3%E7%AD%96%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="1-主要内容"><a href="#1-主要内容" class="headerlink" title="1. 主要内容"></a>1. 主要内容</h1><ol><li><strong>背景与目的</strong>：<ul><li>随着信息技术和人工智能的发展，大数据驱动的辅助决策方法变得更加科学和准确。</li><li>强化学习在决策优化方面具有优势，但传统方法难以解决多层次、多目标的决策优化问题，尤其是在长周期决策优化问题中，学习奖励的滞后性限制了效率。</li></ul></li><li><strong>方法论</strong>：<ul><li>提出基于多智能体强化学习的分层决策优化方法，应用目标分解思想解决长期决策优化问题。</li><li>该方法基于强化学习理论，使具有层级关系的多智能体相互合作，上层智能体学习目标的分解策略，下层智能体学习完成目标的行动策略。</li></ul></li></ol><h1 id="2-研究方法"><a href="#2-研究方法" class="headerlink" title="2. 研究方法"></a>2. 研究方法</h1><p>文章中提到的分层决策优化方法（HDQ）算法的具体实现涉及以下几个关键步骤：</p><ol><li><p><strong>定义智能体和环境交互</strong>：</p><ul><li>强化学习基于马尔可夫决策过程（MDP），包含状态集合 ( S )，动作集合 ( A )，状态转移矩阵 ( P )，奖励集合 ( R )，以及折扣率 ( \gamma )。</li></ul></li><li><p><strong>目标分解与层级决策</strong>：</p><ul><li>将长期目标 ( G ) 分解为子目标 ( g_t )，并通过计算状态 ( s_t ) 与子目标 ( g_t ) 之间的距离 ( dis(gt, st) ) 来判断子目标是否完成。</li></ul></li><li><p><strong>智能体的层级结构</strong>：</p><ul><li>设计具有层级关系的上层智能体 ( \pi_1 ) 和下层智能体 ( \pi_2 )。</li><li>上层智能体学习目标的分解策略，下层智能体学习实现子目标的行动策略。</li></ul></li><li><p><strong>神经网络建模</strong>：</p><ul><li>使用深度Q网络（DQN）作为值函数逼近器，引入神经网络来估计动作价值 ( Q(s, a; \theta) )。</li><li>采用Dueling DQN来缓解高估Q值的问题，引入优势函数 ( A(s, a) )。</li></ul></li><li><p><strong>智能体的参数更新</strong>：</p><ul><li>智能体参数交替更新，共同学习完成团队任务的最佳策略。</li><li>使用梯度下降法更新神经网络参数 ( \theta )，学习率 ( \alpha )。</li></ul></li><li><p><strong>实验设计与数据预处理</strong>：</p><ul><li>从MIMIC-IV数据库中提取脓毒症患者数据，包括性别、年龄、体重、SOFA评分等45个特征。</li><li>使用均值插值方法处理缺失值，最大最小归一化方法消除特征量纲。</li></ul></li><li><p><strong>状态和动作空间的定义</strong>：</p><ul><li>状态空间通过K-means算法聚类降维，定义700个不同的状态类别。</li><li>子目标基于SOFA评分，动作空间定义为两种药物组成的二维矩阵。</li></ul></li><li><p><strong>奖励函数的设计</strong>：</p><ul><li>设计分段常数函数作为奖励函数，根据患者的生存状态和状态改善情况给予不同的奖励。</li></ul></li></ol><p>[1]张倩,李天皓,白春光.基于多智能体强化学习的分层决策优化方法[J].电子科技大学学报(社科版),2022,24(06):90-96.DOI:10.14071&#x2F;j.1008-8105(2022)-1056.</p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
      <category>多智能体强化学习任务分配</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
      <tag>科研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于层次控制的多智能体对抗研究</title>
    <link href="/2024/11/14/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E5%9F%BA%E4%BA%8E%E5%B1%82%E6%AC%A1%E6%8E%A7%E5%88%B6%E7%9A%84%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%AF%B9%E6%8A%97%E7%A0%94%E7%A9%B6/"/>
    <url>/2024/11/14/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E5%9F%BA%E4%BA%8E%E5%B1%82%E6%AC%A1%E6%8E%A7%E5%88%B6%E7%9A%84%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%AF%B9%E6%8A%97%E7%A0%94%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-主要内容"><a href="#1-主要内容" class="headerlink" title="1. 主要内容"></a>1. 主要内容</h1><ul><li>针对复杂动作状态空间场景下单智能体策略学习问题，提出了一种基于预训练模型的分层强化学习算法。该算法分为三个层次：<ul><li>首先，基于先验知识为每个子策略设计了适宜其相应时间的宏动作；</li><li>其次是子策略控制器，其核心是基于监督学习的方法，训练能够适应不同需要的子策略，基于随机的宏动作产生子策略监督学习的数据，并且子策略只学习胜利时的操作轨迹；</li><li>最后是智能体的高级策略控制器，基于策略梯度算法进行扩展，屏蔽了底层繁琐的动作，只对于下层的子策略进行选择，使得作为决策的神经网络参数能够做出更好的动作。</li></ul></li><li>针对复杂动作状态空间场景下多智能体策略学习问题，提出了一种基于双向协调网络的多智能体强化学习算法。该算法基于Actor-Critic框架，其特点是：<ul><li>基于全局信息训练Critic网络，用以解决场景中马尔可夫性缺失问题；</li><li>采用双向RNN网络结构，用以解决场景中多智能体信息通信问题；</li><li>使用动作映射算法，使得智能体选择收益最高的合法联合动作。</li></ul></li><li>基于上述研究成果和《星际争霸2》对抗学习环境，将单智能体强化学习算法和多智能体强化学习算法进行有机融合，设计实现了一个基于层次控制的多智能体强化学习原型系统，并进行实验验证。</li></ul><h1 id="2-研究方法"><a href="#2-研究方法" class="headerlink" title="2. 研究方法"></a>2. 研究方法</h1><p>这篇论文的主要研究方法和算法集中在解决复杂动作状态空间下的多智能体对抗问题，具体包括以下几个方面：</p><ol><li><p><strong>基于预训练模型的分层强化学习算法</strong>：</p><ul><li><strong>宏动作设计</strong>：将复杂的动作序列打包成宏动作，减少智能体需要学习的原子动作数量。</li><li><strong>子策略控制器</strong>：基于监督学习的方法训练子策略，每个子策略对应一个宏动作。</li><li><strong>高级策略控制器（APC）</strong>：基于策略梯度算法扩展，负责在子策略之间进行选择。</li></ul></li><li><p><strong>基于双向协调网络的多智能体强化学习算法（BiC-DDPG）</strong>：</p><ul><li><strong>集中训练分散执行</strong>：解决多智能体对抗场景下马尔可夫性缺失问题，提高算法收敛性。</li><li><strong>Bi-RNN网络结构</strong>：实现智能体合作时的信息通信。</li><li><strong>动作映射算法</strong>：将连续的原始联合动作映射到合法离散联合动作空间，解决复杂联合动作空间下的智能体决策问题。</li></ul></li><li><p><strong>深度学习和强化学习算法</strong>：</p><ul><li><strong>深度神经网络</strong>：使用深度神经网络结构（如ResNet50）作为子策略的神经网络结构。</li><li><strong>强化学习算法</strong>：包括Q学习、DQN、策略梯度、Actor-Critic算法等。</li></ul></li><li><p><strong>实验验证</strong>：</p><ul><li>在《星际争霸2》环境中进行实验验证，包括全流程对抗和微操作对抗环境。</li><li>设计了不同难度的对抗场景，以及不同的子策略训练和测试。</li></ul></li><li><p><strong>原型系统实现</strong>：</p><ul><li>将单智能体和多智能体强化学习算法融合，设计实现了一个基于层次控制的多智能体强化学习原型系统。</li><li>在Python-sc2接口上复现SMAC接口对于观察数据、奖励机制以及动作空间的设计，并部署BiC-DDPG算法。</li></ul></li><li><p><strong>算法优化和调整</strong>：</p><ul><li>对算法的参数进行调整，以适应不同的实验环境和场景。</li><li>通过实验结果分析算法的性能和有效性。</li></ul></li></ol><p>[1]王功举.基于层次控制的多智能体对抗研究[D].军事科学院,2021.DOI:10.27193&#x2F;d.cnki.gjsky.2021.000110.</p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
      <category>多智能体强化学习任务分配</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
      <tag>科研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.3 无监督学习-强化学习-吴恩达</title>
    <link href="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/"/>
    <url>/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h2><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013185527334.png"></p><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013185513926.png"></p><ul><li>状态、动作、奖励和下一个状态(s, a, R(s), s’)</li></ul><h3 id="1-回报"><a href="#1-回报" class="headerlink" title="1. 回报"></a>1. 回报</h3><ul><li>折扣因子</li></ul><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013191147456.png"></p><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013191515723.png"></p><h3 id="2-决策"><a href="#2-决策" class="headerlink" title="2. 决策"></a>2. 决策</h3><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013191936751.png"></p><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013192130503.png"></p><ul><li><p>马尔可夫决策过程 MDP</p></li><li><p>在马尔可夫决策过程中，未来只取决于你现在所处的位置，而不取决于你是如何到达这里的。</p></li></ul><h3 id="3-状态-动作价值函数"><a href="#3-状态-动作价值函数" class="headerlink" title="3. 状态-动作价值函数"></a>3. 状态-动作价值函数</h3><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013214059896.png"></p><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013214515098.png"></p><h4 id="3-1-贝尔曼方程"><a href="#3-1-贝尔曼方程" class="headerlink" title="3.1 贝尔曼方程"></a>3.1 贝尔曼方程</h4><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013220256063.png"></p><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013221245911.png"></p><ul><li>如果你从状态s 开始，你将采取行动a，然后在此之后采取最佳行动，那么你将随着时间的推移看到一些奖励序列。</li></ul><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013221652384.png"></p><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013221916868.png"></p><h3 id="4-随机强化学习"><a href="#4-随机强化学习" class="headerlink" title="4. 随机强化学习"></a>4. 随机强化学习</h3><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013222607911.png"></p><h3 id="5-连续状态"><a href="#5-连续状态" class="headerlink" title="5. 连续状态"></a>5. 连续状态</h3><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013222846102.png"></p><ul><li>连续马尔可夫 MTP</li></ul><h3 id="6-学习状态值函数"><a href="#6-学习状态值函数" class="headerlink" title="6. 学习状态值函数"></a>6. 学习状态值函数</h3><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013223922575.png"></p><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013224639866.png"></p><ul><li>不知道Q，随机猜测</li></ul><h3 id="7-DQN"><a href="#7-DQN" class="headerlink" title="7. DQN"></a>7. DQN</h3><ul><li>意思是神经网络里的参数随机初始化，然后(s’,a’)输入，得到maxQ的预测</li></ul><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013225256166.png"></p><ul><li>交给神经网络训练的参数y中一部分是随机初始化神经网络生成的，但还有一部分是包含了当前状态的信息的，所以当训练次数增多后，外部的输入信息会逐步冲刷掉初始化的随机信息，给出真正的Q函数估计。</li></ul><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013225733542.png"></p><h4 id="7-1-贪婪算法"><a href="#7-1-贪婪算法" class="headerlink" title="7.1 贪婪算法"></a>7.1 贪婪算法</h4><ul><li>使用高ε开始，逐步降低直到0.01</li></ul><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013230506858.png"></p><h4 id="7-2-小批量和软更新"><a href="#7-2-小批量和软更新" class="headerlink" title="7.2 小批量和软更新"></a>7.2 小批量和软更新</h4><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013230853479.png"></p><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013231149426.png"></p><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013231255361.png"></p><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013231653864.png"></p><h3 id="8-局限性"><a href="#8-局限性" class="headerlink" title="8. 局限性"></a>8. 局限性</h3><p><img src="/2024/11/14/ML/class3-week3-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013232030585.png"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>ML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.2 无监督学习-推荐系统-吴恩达</title>
    <link href="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/"/>
    <url>/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h2><h3 id="1-使用每个特征数据"><a href="#1-使用每个特征数据" class="headerlink" title="1. 使用每个特征数据"></a>1. 使用每个特征数据</h3><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013091417801.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013092525171.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013092709205.png"></p><h3 id="2-协同过滤算法"><a href="#2-协同过滤算法" class="headerlink" title="2. 协同过滤算法"></a>2. 协同过滤算法</h3><ul><li>假设已经有了w和b，猜测特征x</li></ul><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013093541589.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013094256436.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013094536963.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013095022269.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013095116749.png"></p><ul><li><p>这种协同过滤是从多个用户收集数据，用户之间的这种协作可帮助您预测未来甚至其他用户的评级。</p></li><li><p>推荐系统的一个非常常见的用例是当您有二进制标签时，例如用户喜欢、喜欢或与项目交互的标签。</p></li></ul><h3 id="3-二进制标签"><a href="#3-二进制标签" class="headerlink" title="3.二进制标签"></a>3.二进制标签</h3><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013095506383.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013095650568.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013095901608.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013100113430.png"></p><ul><li>分类不用正则化</li></ul><h3 id="4-均值归一化"><a href="#4-均值归一化" class="headerlink" title="4. 均值归一化"></a>4. 均值归一化</h3><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013143727458.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013144130791.png"></p><ul><li>对未知用户，预测评分为均值</li></ul><h3 id="5-协同过滤Tensorflow实现"><a href="#5-协同过滤Tensorflow实现" class="headerlink" title="5. 协同过滤Tensorflow实现"></a>5. 协同过滤Tensorflow实现</h3><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013144725579.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013144803015.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013145539351.png"></p><h3 id="6-寻找相关特征"><a href="#6-寻找相关特征" class="headerlink" title="6. 寻找相关特征"></a>6. 寻找相关特征</h3><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013145951931.png"></p><ul><li>协同过滤的局限性</li></ul><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013150021292.png"></p><ul><li><p>冷启动问题</p></li><li><p>边缘信息</p></li></ul><h3 id="7-基于内容的过滤算法"><a href="#7-基于内容的过滤算法" class="headerlink" title="7. 基于内容的过滤算法"></a>7. 基于内容的过滤算法</h3><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013150639264.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013150936617.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013151110932.png"></p><ul><li>如何计算V</li></ul><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013151407807.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013151905392.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013152534237.png"></p><h3 id="8-从大型目录中推荐"><a href="#8-从大型目录中推荐" class="headerlink" title="8. 从大型目录中推荐"></a>8. 从大型目录中推荐</h3><ul><li>两个步骤：检索和排名</li></ul><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013152823434.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013153036731.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013153343967.png"></p><h3 id="9-基于内容的Tensorflow实现"><a href="#9-基于内容的Tensorflow实现" class="headerlink" title="9. 基于内容的Tensorflow实现"></a>9. 基于内容的Tensorflow实现</h3><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013154612258.png"></p><h3 id="10-降低特征数量"><a href="#10-降低特征数量" class="headerlink" title="10. 降低特征数量"></a>10. 降低特征数量</h3><ul><li>PCA主成分分析法，特征降为二维或者三维，便于可视化</li></ul><h4 id="10-1-PCA算法"><a href="#10-1-PCA算法" class="headerlink" title="10.1 PCA算法"></a>10.1 PCA算法</h4><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013170727751.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013171217861.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013171447596.png"></p><ul><li><p>当使用线性回归来预测目标输出Y并且PCA试图获取大量特征并平等对待它们并减少很好地表示数据所需的轴数</p></li><li><p>因此，如果您尝试预测y的值，则应使用线性回归;如果您尝试减少数据集中的特征数量，例如将其可视化，则应使用PCA。</p></li></ul><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013172253829.png"></p><ul><li>每个特征的方差贡献率</li></ul><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013172530272.png"></p><p><img src="/2024/11/14/ML/class3-week2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013172923497.png"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>ML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.1 无监督学习-无监督学习-吴恩达</title>
    <link href="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/"/>
    <url>/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><h3 id="1-聚类"><a href="#1-聚类" class="headerlink" title="1. 聚类"></a>1. 聚类</h3><h4 id="1-1-k-means"><a href="#1-1-k-means" class="headerlink" title="1.1 k-means"></a>1.1 k-means</h4><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012125528206.png"></p><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012125536447.png"></p><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012130426099.png"></p><ul><li>如果一个集群训练样本为零，可以消除该集群，最终得到k-1；另一种方法是重新初始化该集群质心</li></ul><h4 id="1-2-优化目标"><a href="#1-2-优化目标" class="headerlink" title="1.2 优化目标"></a>1.2 优化目标</h4><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012145049473.png"></p><h4 id="1-3-初始化"><a href="#1-3-初始化" class="headerlink" title="1.3 初始化"></a>1.3 初始化</h4><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012150757199.png"></p><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012151542672.png"></p><h4 id="1-4-选择聚类数量"><a href="#1-4-选择聚类数量" class="headerlink" title="1.4 选择聚类数量"></a>1.4 选择聚类数量</h4><ul><li>肘法</li></ul><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012151925053.png"></p><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012152146445.png"></p><h3 id="2-异常检测"><a href="#2-异常检测" class="headerlink" title="2. 异常检测"></a>2. 异常检测</h3><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012152706177.png"></p><h4 id="2-1-密度估计"><a href="#2-1-密度估计" class="headerlink" title="2.1 密度估计"></a>2.1 密度估计</h4><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012152845235.png"></p><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012153346742.png"></p><h4 id="2-2-高斯正态分布"><a href="#2-2-高斯正态分布" class="headerlink" title="2.2 高斯正态分布"></a>2.2 高斯正态分布</h4><ul><li>最大似然估计</li></ul><h4 id="2-3-异常检测算法"><a href="#2-3-异常检测算法" class="headerlink" title="2.3 异常检测算法"></a>2.3 异常检测算法</h4><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012154133115.png"></p><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012154923207.png"></p><h4 id="2-4-开发与评估异常检测系统"><a href="#2-4-开发与评估异常检测系统" class="headerlink" title="2.4 开发与评估异常检测系统."></a>2.4 开发与评估异常检测系统.</h4><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012215712447.png"></p><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012220215931.png"></p><ul><li><p>这种替代方案的缺点是，在调整算法后，您没有公平的方法来判断它在未来示例中的实际效果如何，因为您没有测试集。</p></li><li><p>当你的数据集很小的时候，特别是当你有异常的数量时，你的数据集很小，这可能是你最好的选择。</p></li></ul><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013082659472.png"></p><h4 id="2-5-异常检测vs监督学习"><a href="#2-5-异常检测vs监督学习" class="headerlink" title="2.5 异常检测vs监督学习"></a>2.5 异常检测vs监督学习</h4><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013084827450.png"></p><ul><li>例子</li></ul><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013084924028.png"></p><h4 id="2-6-选择用什么特征"><a href="#2-6-选择用什么特征" class="headerlink" title="2.6 选择用什么特征"></a>2.6 选择用什么特征</h4><ul><li>特征改变为高斯分布</li></ul><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013085546244.png"></p><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013090207839.png"></p><p><img src="/2024/11/14/ML/class3-week1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231013090413780.png"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>ML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.4 深度学习-决策树-吴恩达</title>
    <link href="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/"/>
    <url>/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012075401986.png"></p><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012075410387.png"></p><ul><li><p>根节点 决策节点 叶节点</p></li><li><p>决策树学习算法的工作是，从所有可能的决策树中，尝试选择一个希望在训练集上表现良好的树，然后理想地泛化到新数据，例如交叉验证和测试集</p></li></ul><h3 id="1-学习过程"><a href="#1-学习过程" class="headerlink" title="1. 学习过程"></a>1. 学习过程</h3><ul><li>决策树学习的第一步是，我们必须决定在根节点使用什么特征。</li></ul><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012081611286.png"></p><ul><li><p>决策 2：何时停止分裂？</p><ul><li>当一个节点完全是一类时</li><li>当分裂一个节点会导致树超过最大深度时</li><li>当纯度分数的提高低于一个阈值时</li><li>当节点中的样本数量低于一个阈值时</li></ul></li><li><p>您可能想要限制决策树深度的一个原因是确保我们的树不会变得太大和笨重，其次，通过保持树小，它不太容易过度拟合。</p></li></ul><h3 id="2-纯度"><a href="#2-纯度" class="headerlink" title="2. 纯度"></a>2. 纯度</h3><h4 id="2-1-熵-entropy"><a href="#2-1-熵-entropy" class="headerlink" title="2.1 熵 entropy"></a>2.1 熵 entropy</h4><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012082638836.png"></p><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012082823450.png"></p><ul><li><p>选择拆分信息增益</p></li><li><p>减少熵</p></li><li><p>信息增益 分之前的熵减去分后熵的加权平均</p></li><li><p>停止标准，每次信息增益如果太小停止分类</p></li></ul><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012083632353.png"></p><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012083921344.png"></p><h4 id="2-2-整合"><a href="#2-2-整合" class="headerlink" title="2.2 整合"></a>2.2 整合</h4><ul><li>从根节点开始，包含所有样本</li><li>计算所有可能特征的信息增益，并选择信息增益最高的特征</li><li>根据选定的特征划分数据集，并创建树的左分支和右分支</li><li>持续重复分裂过程，直到满足停止条件：<ul><li>当一个节点完全是一类时</li><li>当分裂一个节点会导致树超过最大深度时</li><li>额外分裂的信息增益小于阈值时</li><li>当节点中的样本数量低于阈值时</li></ul></li></ul><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012084601880.png"></p><ul><li>递归分类</li></ul><h3 id="3-独热编码-one-hot"><a href="#3-独热编码-one-hot" class="headerlink" title="3. 独热编码 one-hot"></a>3. 独热编码 one-hot</h3><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012085239987.png"></p><ul><li><p>通过one-hot编码，您可以让决策树处理可以采用两个以上离散值的特征，您还可以将其应用于新网络或线性回归或逻辑回归训练。</p></li><li><p>连续值</p></li><li><p>尝试不同的阈值，计算纯度</p></li></ul><h3 id="4-回归树"><a href="#4-回归树" class="headerlink" title="4. 回归树"></a>4. 回归树</h3><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012090404205.png"></p><ul><li>尝试减少方差</li></ul><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012091154958.png"></p><h3 id="5-使用多个决策树"><a href="#5-使用多个决策树" class="headerlink" title="5. 使用多个决策树"></a>5. 使用多个决策树</h3><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012092643280.png"></p><h4 id="5-1-有放回的采样"><a href="#5-1-有放回的采样" class="headerlink" title="5.1 有放回的采样"></a>5.1 有放回的采样</h4><ul><li><p>构建新的数据集</p></li><li><p>随机森林算法 Random Forest Algorithm</p></li></ul><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012093230276.png"></p><ul><li><p>随机化特征选择</p><ul><li>在每个节点选择用于分裂的特征时，如果有n个特征可用，随机选择一个包含k个特征的子集（k &lt; n），并允许算法仅从这个特征子集中进行选择。</li></ul></li><li><p>k的选择（根号n，log2(n)）</p></li></ul><h4 id="5-2-XGBoost-extreme-Gradient-Boosting"><a href="#5-2-XGBoost-extreme-Gradient-Boosting" class="headerlink" title="5.2 XGBoost (extreme Gradient Boosting)"></a>5.2 XGBoost (extreme Gradient Boosting)</h4><ul><li>提升树的开源实现</li><li>快速高效的实现</li><li>默认分裂标准和停止分裂标准的好选择</li><li>内置正则化以防止过拟合</li><li>机器学习竞赛中极具竞争力的算法（例如：Kaggle竞赛）</li></ul><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012094738491.png"></p><h3 id="6-何时使用决策树"><a href="#6-何时使用决策树" class="headerlink" title="6. 何时使用决策树"></a>6. 何时使用决策树</h3><ul><li>表格数据</li></ul><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012095356821.png"></p><p><img src="/2024/11/14/ML/class2-week4-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231012095814528.png"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>ML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.3 深度学习-在机器学习项目中下一步该做什么-吴恩达</title>
    <link href="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/"/>
    <url>/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="在机器学习项目中下一步该做什么"><a href="#在机器学习项目中下一步该做什么" class="headerlink" title="在机器学习项目中下一步该做什么"></a>在机器学习项目中下一步该做什么</h2><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011083027133.png"></p><h3 id="1-模型评估"><a href="#1-模型评估" class="headerlink" title="1. 模型评估"></a>1. 模型评估</h3><p>训练集分为两个子集</p><ul><li><p>training set</p></li><li><p>test set</p></li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011083802084.png"></p><p>不包含正则化项</p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011084012544.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011084442975.png" alt="image-20231011084442975"></p><p>就是相比于之前计算在测试集和训练集上误差的那两个公式，我们更常用模型分类错误的次数除以总的预测次数来表示误差</p><p>就是对于逻辑回归来说，可以通过计算误判占比的方法来代表成本函数，比如test set中误判的占比是10％，那么J test就是0.1</p><h4 id="1-1-分为三个子集，训练集、交叉验证集、测试集"><a href="#1-1-分为三个子集，训练集、交叉验证集、测试集" class="headerlink" title="1.1 分为三个子集，训练集、交叉验证集、测试集"></a>1.1 分为三个子集，训练集、交叉验证集、测试集</h4><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011091646019.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011091757791.png"></p><ul><li><p>选择最小的交叉验证集误差对应的模型</p></li><li><p>用测试集来评估泛化误差</p></li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011092256493.png"></p><h4 id="1-2-偏差和方差"><a href="#1-2-偏差和方差" class="headerlink" title="1.2 偏差和方差"></a>1.2 偏差和方差</h4><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011093159868.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011093401564.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011093433520.png"></p><ul><li>正则化如何影响偏差和方差，从而影响算法的性能</li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011093859951.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011094124259.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011094256539.png"></p><h4 id="1-3-指定一个用于性能评估的基准"><a href="#1-3-指定一个用于性能评估的基准" class="headerlink" title="1.3 指定一个用于性能评估的基准"></a>1.3 指定一个用于性能评估的基准</h4><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011103735186.png"></p><p>竞争算法</p><h4 id="1-4-学习曲线"><a href="#1-4-学习曲线" class="headerlink" title="1.4 学习曲线"></a>1.4 学习曲线</h4><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011104512509.png"></p><ul><li>训练集变大，误差增大</li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011104852894.png"></p><ul><li>这给出了这个结论，也许有点令人惊讶，如果学习算法具有高偏差，获得更多的训练数据本身就没有那么大的希望。</li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011105426342.png"></p><ul><li>所以在这种情况下，可能仅仅通过增加训练集的大小来降低交叉验证误差并让你的算法表现得越来越好，这与高偏差情况不同，在这种情况下你唯一要做的就是获得更多的训练数据，实际上并不能帮助您了解算法性能。</li></ul><h4 id="1-5-如何改进"><a href="#1-5-如何改进" class="headerlink" title="1.5 如何改进"></a>1.5 如何改进</h4><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011110222504.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011110708303.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011111707005.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011112028987.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011112250065.png"></p><h3 id="2-机器学习开发的迭代"><a href="#2-机器学习开发的迭代" class="headerlink" title="2. 机器学习开发的迭代"></a>2. 机器学习开发的迭代</h3><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011112605831.png"></p><ul><li>垃圾邮件分类</li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011112929003.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011113910756.png"></p><h4 id="2-1-误差分析"><a href="#2-1-误差分析" class="headerlink" title="2.1 误差分析"></a>2.1 误差分析</h4><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011114442995.png"></p><h4 id="2-2-数据增强"><a href="#2-2-数据增强" class="headerlink" title="2.2 数据增强"></a>2.2 数据增强</h4><ul><li>旋转图像扭曲放大缩小</li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011115040740.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011115116926.png"></p><ul><li>音频增强</li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011115211067.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011115324412.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011131113956.png"></p><h4 id="2-3-迁移学习-Transfer-learning"><a href="#2-3-迁移学习-Transfer-learning" class="headerlink" title="2.3 迁移学习 Transfer  learning"></a>2.3 迁移学习 Transfer  learning</h4><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011163140324.png"></p><ul><li><p>数据集小选择1，数据集大选择2</p></li><li><p>先在大的数据集训练（监督与训练），再在小的训练称为微调</p></li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011163230072.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011163351440.png"></p><h4 id="2-4-机器学习项目全周期"><a href="#2-4-机器学习项目全周期" class="headerlink" title="2.4 机器学习项目全周期"></a>2.4 机器学习项目全周期</h4><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011163931188.png"></p><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011164414049.png"></p><h4 id="2-5-倾斜数据集的误差指标"><a href="#2-5-倾斜数据集的误差指标" class="headerlink" title="2.5 倾斜数据集的误差指标"></a>2.5 倾斜数据集的误差指标</h4><ul><li>精确度和召回率</li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011165618174.png"></p><ul><li>精度和召回率</li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011170439331.png"></p><ul><li>F1score 更强调P和R中较低的那个 调和平均值</li></ul><p><img src="/2024/11/14/ML/class2-week3-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231011170740787.png"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>ML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.2 深度学习-Tenserflow实现-吴恩达</title>
    <link href="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/"/>
    <url>/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="Tenserflow实现"><a href="#Tenserflow实现" class="headerlink" title="Tenserflow实现"></a>Tenserflow实现</h2><h3 id="1-模型训练步骤"><a href="#1-模型训练步骤" class="headerlink" title="1. 模型训练步骤"></a>1. 模型训练步骤</h3><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010125603129.png" alt="模型训练步骤"></p><h4 id="1-1-Epochs-and-batches"><a href="#1-1-Epochs-and-batches" class="headerlink" title="1.1 Epochs and batches"></a>1.1 Epochs and batches</h4><p>在上述的 <code>compile</code> 语句中，<code>epochs</code> 的数量被设置为10。这指定了整个数据集在训练过程中应该被应用10次。在训练期间，你会看到描述训练进度的输出，看起来像这样：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Epoch</span> <span class="hljs-number">1</span>/<span class="hljs-number">10</span><br><span class="hljs-attribute">6250</span>/<span class="hljs-number">6250</span><span class="hljs-meta"> [==============================] - 6s 910us/step - loss: 0.1782</span><br></code></pre></td></tr></table></figure><p>第一行 <code>Epoch 1/10</code> 描述了模型当前正在运行的是哪个训练周期。为了提高效率，训练数据集被分成了“批次”。在Tensorflow中，默认的批次大小是32。我们的扩展数据集中有200000个样本，或者6250个批次。第二行的符号 <code>6250/6250 [====</code> 描述了已经执行了哪个批次。</p><h4 id="1-2-创建模型"><a href="#1-2-创建模型" class="headerlink" title="1.2 创建模型"></a>1.2 创建模型</h4><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010125701208.png"></p><h4 id="1-3-交叉熵损失函数"><a href="#1-3-交叉熵损失函数" class="headerlink" title="1.3 交叉熵损失函数"></a>1.3 交叉熵损失函数</h4><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010130715345.png"></p><ul><li>回归和分类使用不同的损失代价函数</li></ul><h4 id="1-4-梯度下降"><a href="#1-4-梯度下降" class="headerlink" title="1.4 梯度下降"></a>1.4 梯度下降</h4><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010130841602.png"></p><p>多层感知器：多层神经网路</p><h3 id="2-激活函数"><a href="#2-激活函数" class="headerlink" title="2. 激活函数"></a>2. 激活函数</h3><h4 id="2-1-ReLU-Activation"><a href="#2-1-ReLU-Activation" class="headerlink" title="2.1 ReLU Activation"></a>2.1 ReLU Activation</h4><p>This week, a new activation was introduced, the Rectified Linear Unit (ReLU).</p><p>𝑎&#x3D;𝑚𝑎𝑥(0,𝑧) </p><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010204558837.png" alt="ReLU"></p><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010204715345.png"></p><ul><li><p>二分类问题，sigmoid激活函数是最自然的选择，输出层使用</p></li><li><p>回归模型，输出有正有负，预测明天的股票价格，输出层使用线性激活函数</p></li><li><p>回归模型，输出为非负，预测房屋价格，非负，输出层选择ReLU函数</p></li><li><p>隐藏层选择Relu函数，ReLU计算速度更快，效率高，但事实证明更重要的第二个原因是ReLU函数仅在图形的一部分变平;左边这里<br>是完全平坦的，而sigmoid激活函数，它在两个地方变得平坦。梯度下降就会很慢，减慢学习速度</p></li><li><p>为什么要使用激活函数？</p><ul><li>若所有层都是用线性激活函数，那就变成了线性回归</li></ul></li></ul><h3 id="3-多分类问题"><a href="#3-多分类问题" class="headerlink" title="3. 多分类问题"></a>3. 多分类问题</h3><h4 id="3-1-Softmax函数"><a href="#3-1-Softmax函数" class="headerlink" title="3.1 Softmax函数"></a>3.1 Softmax函数</h4><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010212144511.png"></p><h4 id="3-2-代价函数"><a href="#3-2-代价函数" class="headerlink" title="3.2 代价函数"></a>3.2 代价函数</h4><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010212557352.png"></p><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010220105018.png"></p><h4 id="3-3-Tenserflow-实现"><a href="#3-3-Tenserflow-实现" class="headerlink" title="3.3 Tenserflow 实现"></a>3.3 Tenserflow 实现</h4><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010220327241.png"></p><h4 id="3-4-改进实现"><a href="#3-4-改进实现" class="headerlink" title="3.4 改进实现"></a>3.4 改进实现</h4><p>避免计算过程中出现过大或者过小值造成计算错误，改进方法在计算过程中进行了重新排列</p><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010221115720.png"></p><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010221418604.png"></p><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010221520301.png"></p><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010221537117.png"></p><h3 id="4-多标签分类"><a href="#4-多标签分类" class="headerlink" title="4. 多标签分类"></a>4. 多标签分类</h3><p>一个神经网络同时检测多个目标</p><h3 id="5-更快的训练方法"><a href="#5-更快的训练方法" class="headerlink" title="5. 更快的训练方法"></a>5. 更快的训练方法</h3><h4 id="5-1-Adam算法"><a href="#5-1-Adam算法" class="headerlink" title="5.1 Adam算法"></a>5.1 Adam算法</h4><p>自动调节α</p><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010231015869.png"></p><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010231157191.png"></p><h3 id="6-其他的网络层"><a href="#6-其他的网络层" class="headerlink" title="6. 其他的网络层"></a>6. 其他的网络层</h3><p>密集层</p><p>卷积层</p><ul><li><p>更快的计算</p></li><li><p>需要更少的训练数据，不太会过拟合</p></li></ul><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010231710233.png"></p><h3 id="7-计算图"><a href="#7-计算图" class="headerlink" title="7. 计算图"></a>7. 计算图</h3><p><img src="/2024/11/13/ML/class2-week2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Tenserflow%E5%AE%9E%E7%8E%B0-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231010235541548.png"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>ML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.1 深度学习-神经网络-吴恩达</title>
    <link href="/2024/11/13/ML/class2-week1-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E5%90%B4%E6%81%A9%E8%BE%BE/"/>
    <url>/2024/11/13/ML/class2-week1-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E5%90%B4%E6%81%A9%E8%BE%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><ul><li><p>输入层 输入为特征向量</p></li><li><p>隐藏层</p></li><li><p>输出层</p></li></ul><p><strong>Tensorflow and Keras</strong>  </p><ul><li>TensorFlow 是由谷歌开发的一个机器学习包。2019年，谷歌将 Keras 集成到 TensorFlow 中，并发布了 TensorFlow 2.0。Keras 是由 François Chollet 独立开发的框架，它为 TensorFlow 创建了一个简单、以层为中心的接口。本课程将使用 Keras 接口。</li></ul><h3 id="前向传播算法"><a href="#前向传播算法" class="headerlink" title="前向传播算法"></a>前向传播算法</h3><p><img src="/2024/11/13/ML/class2-week1-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231009222124079.png"></p><ul><li><p>从左到右向前计算，称为前向传播。</p></li><li><p>离输出层越近，隐藏层神经元越少。</p></li></ul><p><img src="/2024/11/13/ML/class2-week1-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231009222647437.png"></p><ul><li><p>两个特征，第一个隐藏层有三个神经元，激活函数为sigmoid，输出为a1，第二层同理；</p></li><li><p>输入向量要写成二维矩阵形式 x &#x3D; np.array([[200,17]])  1x2矩阵。</p></li></ul><p><img src="/2024/11/13/ML/class2-week1-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231009224920509.png"></p><p><img src="/2024/11/13/ML/class2-week1-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E5%90%B4%E6%81%A9%E8%BE%BE/image-20231009224946845.png"></p><ul><li>将权重拟合到数据（反向传播）如果数据被归一化，那么这个过程将会进行得更快。</li></ul>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>ML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.3 有监督机器学习回归和分类-逻辑回归-吴恩达</title>
    <link href="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    <url>/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<h2 id="Week3-逻辑回归"><a href="#Week3-逻辑回归" class="headerlink" title="Week3 逻辑回归"></a>Week3 逻辑回归</h2><h3 id="1-二元分类"><a href="#1-二元分类" class="headerlink" title="1. 二元分类"></a>1. 二元分类</h3><p>只有两种可能输出的分类问题称为二元分类。</p><h3 id="2-sigmoid-函数"><a href="#2-sigmoid-函数" class="headerlink" title="2. sigmoid 函数"></a>2. sigmoid 函数</h3><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008173829773.png"></p><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008173915794.png" alt="sigmoid"></p><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20241113221925070.png"></p><p>输入特征，输出0到1</p><h3 id="3-决策边界"><a href="#3-决策边界" class="headerlink" title="3. 决策边界"></a>3. 决策边界</h3><p>线性or非线性</p><h3 id="4-代价函数"><a href="#4-代价函数" class="headerlink" title="4. 代价函数"></a>4. 代价函数</h3><p>平方误差成本函数不是逻辑回归的理想成本函数，常用的是对数损失函数。</p><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008205513401.png" alt="squared error cost"></p><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008205613800.png" alt="凸和非凸"></p><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008205638121.png" alt="image-20231008205638121"></p><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008205807667.png" alt="logistic loss function"></p><p>请记住，损失函数衡量的是你在一个训练样例上的表现如何，它是通过总结你随后获得的所有训练样例的损失，成本函数衡量你在整个训练集上的表现。</p><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008210426343.png" alt="image-20231008210426343"></p><p>整体成本函数为凸函数，可以获得全局最小值</p><p>简化损失函数</p><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008211105952.png" alt="image-20231008211105952"></p><p>代价函数</p><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008211415275.png" alt="image-20231008211415275"></p><p>使用最大似然估计推导出来，是凸函数。</p><h3 id="5-梯度下降"><a href="#5-梯度下降" class="headerlink" title="5. 梯度下降"></a>5. 梯度下降</h3><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008211755913.png" alt="image-20231008211755913"></p><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008211932119.png" alt="image-20231008211932119"></p><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008211950319.png" alt="image-20231008211950319"></p><p>Same concepts:</p><ul><li>Monitor gradient descent(learning curve)</li><li>Vectorized implementation</li><li>Feature scaling</li></ul><h3 id="6-过拟合与欠拟合"><a href="#6-过拟合与欠拟合" class="headerlink" title="6. 过拟合与欠拟合"></a>6. 过拟合与欠拟合</h3><ul><li><p>欠拟合：高偏差 high bias  Does not fit thetraining set well</p></li><li><p>过拟合：高方差 high variance Fits the training setextremely well</p></li></ul><h3 id="7-解决过拟合"><a href="#7-解决过拟合" class="headerlink" title="7. 解决过拟合"></a>7. 解决过拟合</h3><ul><li><p>收集更多的训练样本</p></li><li><p>选择特征   select features to include&#x2F;exclude</p></li><li><p>正则化 Regularization 正则化是一种更温和地减少某些特征影响的方法，而不用像彻底消除它那样严厉。</p></li><li><p>那么正则化的作用是，它可以让你保留所有特征，但它们只是防止特征产生过大的影响，而这有时会导致过度拟合。</p></li></ul><h3 id="8-正则化-Regularization"><a href="#8-正则化-Regularization" class="headerlink" title="8. 正则化 Regularization"></a>8. 正则化 Regularization</h3><p>λ正则化参数</p><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008223908932.png" alt="image-20231008223908932"></p><p>正则化线性回归</p><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008224030737.png" alt="image-20231008224030737"></p><p>梯度下降</p><p><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008224109310.png" alt="image-20231008224109310"></p><p>正则化逻辑回归</p><h1 id><a href="#" class="headerlink" title></a><img src="/2024/11/13/ML/class1-week3-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9E%E5%BD%92%E5%92%8C%E5%88%86%E7%B1%BB-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/image-20231008225551317.png" alt="image-20231008225551317"></h1>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>ML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于演员-评论家框架的层次化多智能体协同决策方法</title>
    <link href="/2024/11/12/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E5%9F%BA%E4%BA%8E%E6%BC%94%E5%91%98-%E8%AF%84%E8%AE%BA%E5%AE%B6%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B1%82%E6%AC%A1%E5%8C%96%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%8D%8F%E5%90%8C%E5%86%B3%E7%AD%96%E6%96%B9%E6%B3%95/"/>
    <url>/2024/11/12/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E5%9F%BA%E4%BA%8E%E6%BC%94%E5%91%98-%E8%AF%84%E8%AE%BA%E5%AE%B6%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B1%82%E6%AC%A1%E5%8C%96%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%8D%8F%E5%90%8C%E5%86%B3%E7%AD%96%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><p>这篇文章的主要内容是提出了一种基于演员-评论家（Actor-Critic，AC）框架的层次化多智能体协同决策方法，旨在解决复杂作战环境下多智能体协同决策中的任务分配不合理和决策一致性较差的问题。该方法通过将决策过程分为不同层次，并使用AC框架来实现智能体之间的信息交流和决策协同，以提高决策效率和战斗力。在高层次，顶层智能体制定任务决策，将总任务分解并分配给底层智能体。在低层次，底层智能体根据子任务进行动作决策，并将结果反馈给高层次。</p><h1 id="研究方法和算法实现："><a href="#研究方法和算法实现：" class="headerlink" title="研究方法和算法实现："></a>研究方法和算法实现：</h1><div align="center"><img src="/2024/11/12/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E5%9F%BA%E4%BA%8E%E6%BC%94%E5%91%98-%E8%AF%84%E8%AE%BA%E5%AE%B6%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B1%82%E6%AC%A1%E5%8C%96%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%8D%8F%E5%90%8C%E5%86%B3%E7%AD%96%E6%96%B9%E6%B3%95/image-20241112210938443.png" alt="image-20241112210938443" style="zoom:40%;" align="center"></div><ol><li><strong>决策层次划分：</strong><ul><li>高层次（High Level, HL）：顶层智能体负责制定任务决策，将总任务分解并分配给底层智能体。</li><li>低层次（Low Level, LL）：底层智能体根据子任务进行动作决策，并将结果反馈给高层次。</li></ul></li><li><strong>状态空间和动作空间的分割：</strong><ul><li>根据层级关系对状态空间和指令空间进行分割，HL决策针对全局作战态势信息下达宏观作战指令，LL决策对执行宏观作战指令的作战编组进行动作操控。</li></ul></li><li><strong>上层任务分解</strong><ul><li>给定总任务<em>M</em>，拆分成子任务集{𝑀0,𝑀1,⋯,𝑀𝑖}</li><li>每一个子任务有任务类型、任务时间、任务状态和作战单元类型，可用one-hot独热码<ul><li>任务类型：主要分为打击任务和巡逻任务，打击任务包含对空拦截、对陆打击，巡逻任务包含空战巡逻、反地面战巡逻</li><li>任务时间：做离散化处理，用时刻𝑇1和时刻𝑇2来表示</li><li>任务状态：启动、未启动</li><li>作战单元：导弹驱逐舰和轰炸机</li></ul></li><li>在根据想定场景设计出子任务后，HL需要根据任务类型规划出任务启动时间，并进一步确定任务的启动次序。</li></ul></li><li><strong>奖惩函数设计：</strong><ul><li>高层智能体只需要聚焦于 子任务选择是否合适，因此高层智能体的奖励函数HL<del>r</del>设计为当任务合适时给予正奖励回报，反之则为负奖励回报。本文中根据全局任务是否完成判断子任务选择是否正确。</li></ul></li><li><strong>基于AC框架的层次化多智能体算法框架：</strong><ul><li>离策略修正的层次化学习(Hierarchical  reinforcement learning with off-policy correction,  HIRO)[31]算法是一种使用两层策略结构来解决复杂强化学习问题的一种单智能体算法，核心思想是高层策略提出目标，低层策略完成这一目标。</li><li>采用部分可观察马尔可夫决策过程（POMDP）对环境进行建模。</li><li>利用深度确定性策略梯度（Deep Deterministic Policy Gradient, DDPG）算法作为基础，结合多智能体深度强化学习，形成了Hierarchical Multi-Agent Actor-Critic（HMaAC）算法。</li></ul></li><li><strong>HMaAC算法设计：</strong><ul><li>初始化顶层和底层的Critic网络和Actor网络，以及经验回放缓冲池。</li><li>通过采样和最小化损失函数更新Critic网络，通过策略梯度更新Actor网络。</li><li>引入熵约束的概念，最大化策略的熵以学习设置合适的子目标。</li></ul></li><li><strong>仿真环境与仿真结果：</strong><ul><li>使用联合作战仿真推演平台作为实验验证环境，进行了2v2、4v4、6v6等不同规模的作战场景实验。</li><li>实验结果显示，HMaAC算法在多种复杂作战场景下均取得了较好的性能，展现了其在提升军事作战协同决策能力方面的潜力。</li></ul></li><li><strong>网络结构设计和训练参数：</strong><ul><li>设计了上层和下层的神经网络结构，均使用3层全连接层，使用ReLU和Tanh作为激活函数。</li><li>设定了一系列超参数，如最大episode数量、批处理参数、熵正则项系数等。</li></ul></li></ol><p><img src="/2024/11/12/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E5%9F%BA%E4%BA%8E%E6%BC%94%E5%91%98-%E8%AF%84%E8%AE%BA%E5%AE%B6%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B1%82%E6%AC%A1%E5%8C%96%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%8D%8F%E5%90%8C%E5%86%B3%E7%AD%96%E6%96%B9%E6%B3%95/image-20241113205648783.png"></p><ol><li><strong>训练结果分析：</strong><ul><li>对比了HMaAC算法和MADDPG算法在2v2仿真场景中的表现，HMaAC算法在奖励值和收敛速度上优于MADDPG算法。</li></ul></li></ol><p>文章最后指出，尽管HMaAC算法在实验中表现出色，但仍需在实地测试和实战演练中进一步验证其可行性和有效性，同时探讨在更复杂多样化作战环境中的适应性和鲁棒性。</p><p>[1]傅妍芳,雷凯麟,魏佳宁,等.基于演员-评论家框架的层次化多智能体协同决策方法[J].兵工学报,2024,45(10):3385-3396.</p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
      <category>多智能体强化学习任务分配</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
      <tag>科研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.2 因特网概述</title>
    <link href="/2024/11/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2%E5%9B%A0%E7%89%B9%E7%BD%91%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/11/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2%E5%9B%A0%E7%89%B9%E7%BD%91%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-2-因特网概述"><a href="#1-2-因特网概述" class="headerlink" title="1.2 因特网概述"></a>1.2 因特网概述</h1><h2 id="1-网络，互联网和因特网"><a href="#1-网络，互联网和因特网" class="headerlink" title="1. 网络，互联网和因特网"></a>1. 网络，互联网和因特网</h2><ul><li>网络是由若干结点和链接这些结点的链路组成</li><li>多个网络通过路由器互连起来，构成一个覆盖范围更大的网路，称为互联网</li><li>因特网是世界上最大的互联网络，连接在因特网上的计算机称为主机</li></ul><h3 id="1-1-internet和Internet的区别"><a href="#1-1-internet和Internet的区别" class="headerlink" title="1.1 internet和Internet的区别"></a>1.1 internet和Internet的区别</h3><ol><li>internet(互联网或互连网)是一个通用名词，它泛指由多个计算机网络互连而成的网络。在这些网络之间的通信协议可以是任意的。</li><li>Internet(因特网)则是一个专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定计算机网络，它采用TCPP协议族作为通信的规则，其前身是美国的ARPANET。</li></ol><h2 id="2-因特网服务提供者ISP-Internet-Service-Provider"><a href="#2-因特网服务提供者ISP-Internet-Service-Provider" class="headerlink" title="2. 因特网服务提供者ISP(Internet Service Provider)"></a>2. 因特网服务提供者ISP(Internet Service Provider)</h2><ul><li>通过向ISP缴纳费用，拿到IP地址和通信线路，路由器等连网设备的使用权</li><li>同时，每个接入因特网的用户，也可以成为ISP，只需购买调制解调器或路由器这样的设备，让其他用户与之相连</li></ul><p><img src="/2024/11/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2%E5%9B%A0%E7%89%B9%E7%BD%91%E6%A6%82%E8%BF%B0/image-20241115201435974.png" alt="image-20241115201435974"></p><h3 id="2-1-基于ISP的三层结构的因特网"><a href="#2-1-基于ISP的三层结构的因特网" class="headerlink" title="2.1 基于ISP的三层结构的因特网"></a>2.1 基于ISP的三层结构的因特网</h3><ul><li>第一层：国际性区域</li><li>第二层：区域性或国家性覆盖规模</li><li>第三层：本地ISP</li></ul><p><img src="/2024/11/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2%E5%9B%A0%E7%89%B9%E7%BD%91%E6%A6%82%E8%BF%B0/image-20241115201638639.png" alt="image-20241115201638639"></p><h2 id="3-因特网的标准化工作"><a href="#3-因特网的标准化工作" class="headerlink" title="3. 因特网的标准化工作"></a>3. 因特网的标准化工作</h2><ol><li><p>因特网的标准化工作对因特网的发展起到了非常重要的作用。</p></li><li><p>因特网在制定其标准上的一个很大的特点是面向公众。</p><ol><li>因特网所有的<a href="http://www.ietf.org/rfc.html">RFC(Request For Comments)技术文档</a>都可从因特网上免费下载；</li><li>任何人都可以随时用电子邮件发表对某个文档的意见或建议。</li></ol></li><li><p>因特网协会ISOC是一个国际性组织，它负责对因特网进行全面管理，以及在世界范围内促进其发展和使用。</p><ol><li>因特网体系结构委员会IAB,负责管理因特网有关协议的开发：</li><li>因特网工程部ETF，负责研究中短期工程问题，主要针对协议的开发和标准化</li><li>因特网研究部IRTF,从事理论方面的研究和开发一些需要长期考虑的问题。</li></ol></li><li><p>制订因特网的正式标准要经过以下4个阶段：</p><ol><li>因特网草案（在这个阶段还不是RFC文档）</li><li>建议标准（从这个阶段开始就成为RFC文档）<br>因特网体系结构委员会A由</li><li>草案标准</li><li>因特网标准</li></ol><blockquote><p>只有一小部分RFC文档最后才能变成因特网标准</p></blockquote></li></ol><h2 id="4-因特网的组成"><a href="#4-因特网的组成" class="headerlink" title="4. 因特网的组成"></a>4. 因特网的组成</h2><ol><li><p>边缘部分</p><blockquote><p>由所有连接在因特网上 的主机组成。这部分是用户直接使用的，用来进行通信（传送数据，音频或视频)和资源共享。</p></blockquote></li><li><p>核心部分</p><blockquote><p>由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）</p></blockquote><ol><li><strong>路由器</strong>是实现<strong>分组交换</strong>的关键构件，任务是<strong>转发收到的分组</strong></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>os</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github+hexo 搭建个人网站</title>
    <link href="/2024/11/12/hexo/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/"/>
    <url>/2024/11/12/hexo/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h1 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h1><h2 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h2><p>Git版本：Git-2.47.0.2-64-bit</p><p>Node.js版本：node-v22.11.0-x64</p><ol><li>官网下载，一路下一步安装即可。</li></ol><p>安装完成，右键git bash here，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git --version<br>node -v<br>npm -v<br></code></pre></td></tr></table></figure><p>安装成功，可查看版本。</p><ol start="2"><li>安装hexo:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo -g<br></code></pre></td></tr></table></figure><p>hexo 安装成功，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo -v<br></code></pre></td></tr></table></figure><h2 id="git-配置SSH-key"><a href="#git-配置SSH-key" class="headerlink" title="git 配置SSH key"></a>git 配置SSH key</h2><ol><li>生成key</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;xxx@qq.com&quot;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>进入C:\用户\用户名.ssh，进入ssh文件夹，复制id_rsa.pub文件里的所有内容</li><li>打开github主页，点击个人设置，点击左侧SSH and GPG keys，点击New SSh key</li><li>标题随便起，将复制的内容粘贴到Key，点击Add SSH key</li><li>测试是否成功，在git bash中输入：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -T git@github.com<br></code></pre></td></tr></table></figure><p><font style="color:rgb(83, 88, 97);">如果遇到选择，输入yes，看到成功即可。</font></p><ol start="6"><li>配置账号密码</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-comment">#你的github用户名</span><br>git config --global user.email <span class="hljs-string">&quot;xxx@163.com&quot;</span> <span class="hljs-comment">#填写你的github注册邮箱</span><br></code></pre></td></tr></table></figure><ol start="7"><li>安装部署插件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git -save<br></code></pre></td></tr></table></figure><h1 id="搭建个人博客"><a href="#搭建个人博客" class="headerlink" title="搭建个人博客"></a>搭建个人博客</h1><ol><li>新建文件夹，初始化个人博客，右键打开git bash，输入</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init <span class="hljs-comment">#初始化</span><br></code></pre></td></tr></table></figure><ol start="2"><li>生成静态网页并预览</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g <span class="hljs-comment"># 生成静态页面</span><br>hexo s <span class="hljs-comment"># 预览</span><br></code></pre></td></tr></table></figure><ol start="3"><li><p>打开网址即可预览</p></li><li><p>打开github 创建与用户名同名的仓库：username.github.io，并查看主分支是main or master</p></li><li><p>打开博客目录下的_config.ymal，找到对应内容并修改</p></li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">git@github.com:username/username.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br></code></pre></td></tr></table></figure><ol start="6"><li>发布到github</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo d<br></code></pre></td></tr></table></figure><ol start="7"><li>新建博客</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new <span class="hljs-string">&#x27;blog-name&#x27;</span><br>hexo new title -p  <span class="hljs-string">&#x27;subdir/title&#x27;</span><br></code></pre></td></tr></table></figure><p>在source&#x2F;_post目录下可查看新建的md文件。</p><p>注：可在hexo s服务开启的状态下修改问价内容查看预览内容。</p><p>要设置其他主题，可自行查找，博主参考Fluid风格的blog <a href="https://hexo.fluid-dev.com/docs/">Hexo Fluid 用户手册</a>。</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>个人博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rust todo</title>
    <link href="/2024/11/12/Rust/rust/"/>
    <url>/2024/11/12/Rust/rust/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu虚拟机磁盘扩容</title>
    <link href="/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/"/>
    <url>/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu虚拟机磁盘空间不够，如何扩容"><a href="#Ubuntu虚拟机磁盘空间不够，如何扩容" class="headerlink" title="Ubuntu虚拟机磁盘空间不够，如何扩容"></a>Ubuntu虚拟机磁盘空间不够，如何扩容</h1><h2 id="一、软件版本"><a href="#一、软件版本" class="headerlink" title="一、软件版本"></a>一、软件版本</h2><p>1.vmware 15.5.0</p><p>2.ubuntu 20.04</p><h2 id="二、操作步骤"><a href="#二、操作步骤" class="headerlink" title="二、操作步骤"></a>二、操作步骤</h2><p>1.打开虚拟机设置，点击硬盘<br><img src="/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/15fc8dc4f12fa5028a9388249f3af272.png" alt="在这里插入图片描述"></p><p>2.点击扩展<br><img src="/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/03bf87f8780d1f5f0d7b6c7130f738ca.png" alt="在这里插入图片描述"></p><p>3.此处我由50G增加到70G，点击扩展<br><img src="/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/19983adb5563d49266bf294485b59606.png" alt="在这里插入图片描述"></p><p>4.开启虚拟机</p><p>5.点击磁盘<br><img src="/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/c8428adcd11dfe842401ab61e80d16f2.png" alt="在这里插入图片描述"></p><p>6.看到有21G的未分配的磁盘空间</p><p><img src="/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/226cfc5dee27ecee83abb2ac08898792.png" alt="在这里插入图片描述"></p><p>7.点击扩展分区</p><p><img src="/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/e8a7616f83cfd499830719c53a862147.png" alt="在这里插入图片描述"></p><p>8.点击设置</p><p><img src="/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/6b93eb112dfe8bce5b66ddb825349451.png" alt="在这里插入图片描述"></p><p>9.调整大小</p><p>10.把按钮拖动到最大，点击调整大小<br><img src="/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/64180784c7a86f2bccc1103506efefda.png" alt="在这里插入图片描述"></p><p>11.选择文件系统进行同样的操作</p><p>12.在终端使用命令 df查看</p><p><img src="/2022/12/13/ubuntu/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/c8b5025526882a778881a1c67620328d.png" alt="在这里插入图片描述"></p><p>扩容成功！！！！！！！！！</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
