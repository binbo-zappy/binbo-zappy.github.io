

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Binbo">
  <meta name="keywords" content="">
  
    <meta name="description" content="泛型 Generics 实际上，泛型就是一种多态。泛型主要目的是为程序员提供编程的便利，减少代码的臃肿，同时可以极大地丰富语言本身的表达能力，为程序员提供了一个合适的炮管。 123456789fn add&lt;T&gt;(a:T, b:T) -&gt; T &#123;    a + b&#125;fn main() &#123;    println!(&quot;add i8: &amp;#12">
<meta property="og:type" content="article">
<meta property="og:title" content="2.8.1 泛型 Generics">
<meta property="og:url" content="http://binbo-zappy.github.io/2025/01/05/rust%E5%9C%A3%E7%BB%8F/2-8-1-%E6%B3%9B%E5%9E%8B-Generics/index.html">
<meta property="og:site_name" content="Binbo">
<meta property="og:description" content="泛型 Generics 实际上，泛型就是一种多态。泛型主要目的是为程序员提供编程的便利，减少代码的臃肿，同时可以极大地丰富语言本身的表达能力，为程序员提供了一个合适的炮管。 123456789fn add&lt;T&gt;(a:T, b:T) -&gt; T &#123;    a + b&#125;fn main() &#123;    println!(&quot;add i8: &amp;#12">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://binbo-zappy.github.io/imgs/rust.jpg">
<meta property="article:published_time" content="2025-01-05T14:37:24.000Z">
<meta property="article:modified_time" content="2025-01-08T02:34:06.613Z">
<meta property="article:author" content="Binbo">
<meta property="article:tag" content="rust">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://binbo-zappy.github.io/imgs/rust.jpg">
  
  
  
  <title>2.8.1 泛型 Generics - Binbo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"binbo-zappy.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Liekkas</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="2.8.1 泛型 Generics"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-01-05 22:37" pubdate>
          2025年1月5日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          4.6k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          39 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">2.8.1 泛型 Generics</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="泛型-generics">泛型 Generics</h1>
<p>实际上，泛型就是一种多态。泛型主要目的是为程序员提供编程的便利，减少代码的臃肿，同时可以极大地丰富语言本身的表达能力，为程序员提供了一个合适的炮管。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>&lt;T&gt;(a:T, b:T) <span class="hljs-punctuation">-&gt;</span> T &#123;<br>    a + b<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;add i8: &#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">2i8</span>, <span class="hljs-number">3i8</span>));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;add i32: &#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;add f64: &#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">1.23</span>, <span class="hljs-number">1.23</span>));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>将之前的代码改成上面这样，就是 Rust
泛型的初印象，这段代码虽然很简洁，但是并不能编译通过，我们会在后面进行详细讲解，现在只要对泛型有个大概的印象即可。</p>
<h2 id="泛型详解">1. 泛型详解</h2>
<p>上面代码的 <code>T</code> 就是<strong>泛型参数</strong>，实际上在
Rust 中，泛型参数的名称你可以任意起，但是出于惯例，我们都用
<code>T</code> （<code>T</code> 是 <code>type</code>
的首字母）来作为首选，这个名称越短越好，除非需要表达含义，否则一个字母是最完美的。</p>
<p>使用泛型参数，有一个先决条件，必需在使用前对其进行声明：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">largest</span>&lt;T&gt;(list: &amp;[T]) <span class="hljs-punctuation">-&gt;</span> T &#123;<br></code></pre></td></tr></table></figure>
<p>该泛型函数的作用是从列表中找出最大的值，其中列表中的元素类型为
T。首先 <code>largest&lt;T&gt;</code> 对泛型参数 <code>T</code>
进行了声明，然后才在函数参数中进行使用该泛型参数
<code>list: &amp;[T]</code> （还记得 <code>&amp;[T]</code>
类型吧？这是<a target="_blank" rel="noopener" href="https://course.rs/basic/compound-type/array.html#数组切片">数组切片</a>）。</p>
<p>总之，我们可以这样理解这个函数定义：函数 <code>largest</code>
有泛型类型 <code>T</code>，它有个参数 <code>list</code>，其类型是元素为
<code>T</code> 的数组切片，最后，该函数返回值的类型也是
<code>T</code>。</p>
<p>下面是一个错误的泛型函数的实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">largest</span>&lt;T&gt;(list: &amp;[T]) <span class="hljs-punctuation">-&gt;</span> T &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">largest</span> = list[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-keyword">for</span> &amp;item <span class="hljs-keyword">in</span> list.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>        <span class="hljs-keyword">if</span> item &gt; largest &#123;<br>            largest = item;<br>        &#125;<br>    &#125;<br><br>    largest<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">number_list</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">34</span>, <span class="hljs-number">50</span>, <span class="hljs-number">25</span>, <span class="hljs-number">100</span>, <span class="hljs-number">65</span>];<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">largest</span>(&amp;number_list);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The largest number is &#123;&#125;&quot;</span>, result);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">char_list</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;q&#x27;</span>];<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">largest</span>(&amp;char_list);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The largest char is &#123;&#125;&quot;</span>, result);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行后报错：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs console">error[E0369]: binary operation `&gt;` cannot be applied to type `T` // `&gt;`操作符不能用于类型`T`<br><span class="hljs-meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:5:17</span><br>  |<br>5 |         if item &gt; largest &#123;<br>  |            ---- ^ ------- T<br>  |            |<br>  |            T<br>  |<br>help: consider restricting type parameter `T` // 考虑对T进行类型上的限制 :<br>  |<br>1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; T &#123;<br>  |             ++++++++++++++++++++++<br></code></pre></td></tr></table></figure>
<p>因为 <code>T</code>
可以是任何类型，但不是所有的类型都能进行比较，因此上面的错误中，编译器建议我们给
<code>T</code> 添加一个类型限制：使用 <code>std::cmp::PartialOrd</code>
特征（Trait）对 <code>T</code>
进行限制，特征在下一节会详细介绍，现在你只要理解，该特征的目的就是让<strong>类型实现可比较的功能</strong>。</p>
<p>还记得我们一开始的 <code>add</code>
泛型函数吗？如果你运行它，会得到以下的报错：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs console">error[E0369]: cannot add `T` to `T` // 无法将 `T` 类型跟 `T` 类型进行相加<br><span class="hljs-meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:2:7</span><br>  |<br>2 |     a + b<br>  |     - ^ - T<br>  |     |<br>  |     T<br>  |<br>help: consider restricting type parameter `T`<br>  |<br>1 | fn add&lt;T: std::ops::Add&lt;Output = T&gt;&gt;(a:T, b:T) -&gt; T &#123;<br>  |         +++++++++++++++++++++++++++<br></code></pre></td></tr></table></figure>
<p>同样的，不是所有 <code>T</code> 类型都能进行相加操作，因此我们需要用
<code>std::ops::Add&lt;Output = T&gt;</code> 对 <code>T</code>
进行限制：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>&lt;T: std::ops::Add&lt;Output = T&gt;&gt;(a:T, b:T) <span class="hljs-punctuation">-&gt;</span> T &#123;<br>    a + b<br>&#125;<br></code></pre></td></tr></table></figure>
<p>进行如上修改后，就可以正常运行。</p>
<h3 id="显式地指定泛型的类型参数">1.1 显式地指定泛型的类型参数</h3>
<p>有时候，编译器无法推断你想要的泛型参数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::Display;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">create_and_print</span>&lt;T&gt;() <span class="hljs-keyword">where</span> T: <span class="hljs-built_in">From</span>&lt;<span class="hljs-type">i32</span>&gt; + Display &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span>: T = <span class="hljs-number">100</span>.<span class="hljs-title function_ invoke__">into</span>(); <span class="hljs-comment">// 创建了类型为 T 的变量 a，它的初始值由 100 转换而来</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a is: &#123;&#125;&quot;</span>, a);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-title function_ invoke__">create_and_print</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果运行以上代码，会得到报错：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs console">error[E0283]: type annotations needed // 需要标明类型<br><span class="hljs-meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:9:5</span><br>  |<br>9 |     create_and_print();<br>  |     ^^^^^^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the function `create_and_print` // 无法推断函数 `create_and_print` 的类型参数 `T` 的类型<br>  |<br>  = note: multiple `impl`s satisfying `_: From&lt;i32&gt;` found in the `core` crate:<br>          - impl From&lt;i32&gt; for AtomicI32;<br>          - impl From&lt;i32&gt; for f64;<br>          - impl From&lt;i32&gt; for i128;<br>          - impl From&lt;i32&gt; for i64;<br>note: required by a bound in `create_and_print`<br><span class="hljs-meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:3:35</span><br>  |<br>3 | fn create_and_print&lt;T&gt;() where T: From&lt;i32&gt; + Display &#123;<br>  |                                   ^^^^^^^^^ required by this bound in `create_and_print`<br>help: consider specifying the generic argument // 尝试指定泛型参数<br>  |<br>9 |     create_and_print::&lt;T&gt;();<br>  |                     +++++<br></code></pre></td></tr></table></figure>
<p>报错里说得很清楚，编译器不知道 <code>T</code>
到底应该是什么类型。不过好心的编译器已经帮我们列出了满足条件的类型，然后告诉我们解决方法：显式指定类型：<code>create_and_print::&lt;T&gt;()</code>。</p>
<p>于是，我们修改代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::Display;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">create_and_print</span>&lt;T&gt;() <span class="hljs-keyword">where</span> T: <span class="hljs-built_in">From</span>&lt;<span class="hljs-type">i32</span>&gt; + Display &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span>: T = <span class="hljs-number">100</span>.<span class="hljs-title function_ invoke__">into</span>(); <span class="hljs-comment">// 创建了类型为 T 的变量 a，它的初始值由 100 转换而来</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a is: &#123;&#125;&quot;</span>, a);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    create_and_print::&lt;<span class="hljs-type">i64</span>&gt;();<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<p>Tips:</p>
<p>这个函数声明指定了泛型参数 <code>T</code> 必须实现
<code>From&lt;i32&gt;</code> 和 <code>Display</code> 两个
trait。这意味着 <code>T</code> 类型可以从 <code>i32</code>
类型转换而来，并且可以被格式化输出</p>
<hr>
<h3 id="结构体中使用泛型">1.2 结构体中使用泛型</h3>
<p>结构体中的字段类型也可以用泛型来定义，下面代码定义了一个坐标点
<code>Point</code>，它可以存放任何类型的坐标值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>&lt;T&gt; &#123;<br>    x: T,<br>    y: T,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">integer</span> = Point &#123; x: <span class="hljs-number">5</span>, y: <span class="hljs-number">10</span> &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">float</span> = Point &#123; x: <span class="hljs-number">1.0</span>, y: <span class="hljs-number">4.0</span> &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里有两点需要特别的注意：</p>
<ul>
<li><strong>提前声明</strong>，跟泛型函数定义类似，首先我们在使用泛型参数之前必需要进行声明
<code>Point&lt;T&gt;</code>，接着就可以在结构体的字段类型中使用
<code>T</code> 来替代具体的类型</li>
<li><strong>x 和 y 是相同的类型</strong></li>
</ul>
<p>如果想让 <code>x</code> 和 <code>y</code>
既能类型相同，又能类型不同，就需要使用不同的泛型参数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>&lt;T,U&gt; &#123;<br>    x: T,<br>    y: U,<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = Point&#123;x: <span class="hljs-number">1</span>, y :<span class="hljs-number">1.1</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>切记，所有的泛型参数都要提前声明：<code>Point&lt;T,U&gt;</code> !
但是如果你的结构体变成这鬼样：<code>struct Woo&lt;T,U,V,W,X&gt;</code>，那么你需要考虑拆分这个结构体，减少泛型参数的个数和代码复杂度。</p>
<h3 id="枚举中使用泛型">1.3 枚举中使用泛型</h3>
<p>提到枚举类型，<code>Option</code>
永远是第一个应该被想起来的，在之前的章节中，它也多次出现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span>&lt;T&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(T),<br>    <span class="hljs-literal">None</span>,<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>Option&lt;T&gt;</code> 是一个拥有泛型 <code>T</code>
的枚举类型，它第一个成员是 <code>Some(T)</code>，存放了一个类型为
<code>T</code>
的值。得益于泛型的引入，我们可以在任何一个需要返回值的函数中，去使用
<code>Option&lt;T&gt;</code>
枚举类型来做为返回值，用于返回一个任意类型的值
<code>Some(T)</code>，或者没有值 <code>None</code>。</p>
<p>对于枚举而言，卧龙凤雏永远是绕不过去的存在：如果是
<code>Option</code> 是卧龙，那么 <code>Result</code>
就一定是凤雏，得两者可得天下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Result</span>&lt;T, E&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Ok</span>(T),<br>    <span class="hljs-title function_ invoke__">Err</span>(E),<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个枚举和 <code>Option</code> 一样，主要用于函数返回值，与
<code>Option</code>
用于值的存在与否不同，<code>Result</code>关注的主要是值的正确性。</p>
<p>如果函数正常运行，则最后返回一个 <code>Ok(T)</code>，<code>T</code>
是函数具体的返回值类型，如果函数异常运行，则返回一个
<code>Err(E)</code>，<code>E</code>
是错误类型。例如打开一个文件：如果成功打开文件，则返回
<code>Ok(std::fs::File)</code>，因此 <code>T</code> 对应的是
<code>std::fs::File</code> 类型；而当打开文件时出现问题时，返回
<code>Err(std::io::Error)</code>，<code>E</code> 对应的就是
<code>std::io::Error</code> 类型。</p>
<h2 id="方法中使用泛型">2. 方法中使用泛型</h2>
<p>上一章中，我们讲到什么是方法以及如何在结构体和枚举上定义方法。方法上也可以使用泛型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>&lt;T&gt; &#123;<br>    x: T,<br>    y: T,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">x</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;T &#123;<br>        &amp;<span class="hljs-keyword">self</span>.x<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = Point &#123; x: <span class="hljs-number">5</span>, y: <span class="hljs-number">10</span> &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;p.x = &#123;&#125;&quot;</span>, p.<span class="hljs-title function_ invoke__">x</span>());<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用泛型参数前，依然需要提前声明：<code>impl&lt;T&gt;</code>，只有提前声明了，我们才能在<code>Point&lt;T&gt;</code>中使用它，这样
Rust 就知道 <code>Point</code>
的尖括号中的类型是泛型而不是具体类型。需要注意的是，<strong>这里的
<code>Point&lt;T&gt;</code>
不再是泛型声明，而是一个完整的结构体类型，</strong>因为我们定义的结构体就是
<code>Point&lt;T&gt;</code> 而不再是 <code>Point</code>。</p>
<p>除了结构体中的泛型参数，我们还能在该结构体的方法中定义额外的泛型参数，就跟泛型函数一样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>&lt;T, U&gt; &#123;<br>    x: T,<br>    y: U,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T, U&gt; Point&lt;T, U&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">mixup</span>&lt;V, W&gt;(<span class="hljs-keyword">self</span>, other: Point&lt;V, W&gt;) <span class="hljs-punctuation">-&gt;</span> Point&lt;T, W&gt; &#123;<br>        Point &#123;<br>            x: <span class="hljs-keyword">self</span>.x,<br>            y: other.y,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p1</span> = Point &#123; x: <span class="hljs-number">5</span>, y: <span class="hljs-number">10.4</span> &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p2</span> = Point &#123; x: <span class="hljs-string">&quot;Hello&quot;</span>, y: <span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p3</span> = p1.<span class="hljs-title function_ invoke__">mixup</span>(p2);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;p3.x = &#123;&#125;, p3.y = &#123;&#125;&quot;</span>, p3.x, p3.y);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个例子中，<code>T,U</code> 是定义在结构体 <code>Point</code>
上的泛型参数，<code>V,W</code> 是单独定义在方法 <code>mixup</code>
上的泛型参数，它们并不冲突，说白了，你可以理解为，一个是结构体泛型，一个是函数泛型。</p>
<h3 id="为具体的泛型类型实现方法">2.1 为具体的泛型类型实现方法</h3>
<p>对于 <code>Point&lt;T&gt;</code> 类型，你不仅能定义基于
<code>T</code> 的方法，还能针对特定的具体类型，进行方法定义：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Point</span>&lt;<span class="hljs-type">f32</span>&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">distance_from_origin</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">f32</span> &#123;<br>        (<span class="hljs-keyword">self</span>.x.<span class="hljs-title function_ invoke__">powi</span>(<span class="hljs-number">2</span>) + <span class="hljs-keyword">self</span>.y.<span class="hljs-title function_ invoke__">powi</span>(<span class="hljs-number">2</span>)).<span class="hljs-title function_ invoke__">sqrt</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这段代码意味着 <code>Point&lt;f32&gt;</code> 类型会有一个方法
<code>distance_from_origin</code>，而其他 <code>T</code> 不是
<code>f32</code> 类型的
<code>Point&lt;T&gt;</code>实例则没有定义此方法。这个方法计算点实例与坐标<code>(0.0, 0.0)</code>
之间的距离，并使用了只能用于浮点型的数学运算符。</p>
<p>这样我们就能针对特定的泛型类型实现某个特定的方法，对于其它泛型类型则没有定义该方法。</p>
<h2 id="const-泛型rust-1.51-版本引入的重要特性">3. const 泛型（Rust 1.51
版本引入的重要特性）</h2>
<p>在之前的泛型中，可以抽象为一句话：针对类型实现的泛型，所有的泛型都是为了抽象不同的类型，那有没有针对值的泛型？可能很多同学感觉很难理解，值怎么使用泛型？不急，我们先从数组讲起。</p>
<p>在<a target="_blank" rel="noopener" href="https://course.rs/basic/compound-type/array.html">数组</a>那节，有提到过很重要的一点：<code>[i32; 2]</code>
和 <code>[i32; 3]</code> 是不同的数组类型，比如下面的代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">display_array</span>(arr: [<span class="hljs-type">i32</span>; <span class="hljs-number">3</span>]) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, arr);<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>    <span class="hljs-title function_ invoke__">display_array</span>(arr);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">2</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br>    <span class="hljs-title function_ invoke__">display_array</span>(arr);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行后报错：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs console">error[E0308]: mismatched types // 类型不匹配<br><span class="hljs-meta prompt_">  --&gt; </span><span class="language-bash">src/main.rs:10:19</span><br>   |<br>10 |     display_array(arr);<br>   |                   ^^^ expected an array with a fixed size of 3 elements, found one with 2 elements<br>                          // 期望一个长度为3的数组，却发现一个长度为2的<br></code></pre></td></tr></table></figure>
<p>结合代码和报错，可以很清楚的看出，<code>[i32; 3]</code> 和
<code>[i32; 2]</code>
确实是两个完全不同的类型，因此无法用同一个函数调用。</p>
<p>首先，让我们修改代码，让 <code>display_array</code> 能打印任意长度的
<code>i32</code> 数组：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">display_array</span>(arr: &amp;[<span class="hljs-type">i32</span>]) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, arr);<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>    <span class="hljs-title function_ invoke__">display_array</span>(&amp;arr);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">2</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br>    <span class="hljs-title function_ invoke__">display_array</span>(&amp;arr);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>很简单，只要使用数组切片，然后传入 <code>arr</code>
的不可变引用即可。</p>
<p>接着，将 <code>i32</code> 改成所有类型的数组：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">display_array</span>&lt;T: std::fmt::<span class="hljs-built_in">Debug</span>&gt;(arr: &amp;[T]) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, arr);<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>    <span class="hljs-title function_ invoke__">display_array</span>(&amp;arr);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">2</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br>    <span class="hljs-title function_ invoke__">display_array</span>(&amp;arr);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>也不难，唯一要注意的是需要对 <code>T</code> 加一个限制
<code>std::fmt::Debug</code>，该限制表明 <code>T</code> 可以用在
<code>println!("&#123;:?&#125;", arr)</code> 中，因为 <code>&#123;:?&#125;</code>
形式的格式化输出需要 <code>arr</code> 实现该特征。</p>
<p>通过引用，我们可以很轻松的解决处理任何类型数组的问题，但是如果在某些场景下引用不适宜用或者干脆不能用呢？你们知道为什么以前
Rust 的一些数组库，在使用的时候都限定长度不超过 32
吗？因为它们会为每个长度都单独实现一个函数，简直。。。毫无人性。难道没有什么办法可以解决这个问题吗？</p>
<p>好在，现在咱们有了 <strong>const
泛型，也就是针对值的泛型，正好可以用于处理数组长度的问题</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">display_array</span>&lt;T: std::fmt::<span class="hljs-built_in">Debug</span>, <span class="hljs-keyword">const</span> N: <span class="hljs-type">usize</span>&gt;(arr: [T; N]) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, arr);<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>    <span class="hljs-title function_ invoke__">display_array</span>(arr);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">2</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br>    <span class="hljs-title function_ invoke__">display_array</span>(arr);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如上所示，我们定义了一个类型为 <code>[T; N]</code> 的数组，其中
<code>T</code>
是一个基于类型的泛型参数，这个和之前讲的泛型没有区别，而重点在于
<code>N</code>
这个泛型参数，它是一个基于值的泛型参数！因为它用来替代的是数组的长度。</p>
<p><code>N</code> 就是 const 泛型，定义的语法是
<code>const N: usize</code>，表示 const 泛型 <code>N</code>
，它基于的值类型是 <code>usize</code>。</p>
<p>在泛型参数之前，Rust 完全不适合复杂矩阵的运算，自从有了 const
泛型，一切即将改变。</p>
<h3 id="const-泛型表达式">3.1 const 泛型表达式</h3>
<p>假设我们某段代码需要在内存很小的平台上工作，因此需要限制函数参数占用的内存大小，此时就可以使用
const 泛型表达式来实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 目前只能在nightly版本下使用</span><br><span class="hljs-meta">#![allow(incomplete_features)]</span><br><span class="hljs-meta">#![feature(generic_const_exprs)]</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">something</span>&lt;T&gt;(val: T)<br><span class="hljs-keyword">where</span><br>    Assert&lt;&#123; core::mem::size_of::&lt;T&gt;() &lt; <span class="hljs-number">768</span> &#125;&gt;: IsTrue,<br>    <span class="hljs-comment">//       ^-----------------------------^ 这里是一个 const 表达式，换成其它的 const 表达式也可以</span><br>&#123;<br>    <span class="hljs-comment">//</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-title function_ invoke__">something</span>([<span class="hljs-number">0u8</span>; <span class="hljs-number">0</span>]); <span class="hljs-comment">// ok</span><br>    <span class="hljs-title function_ invoke__">something</span>([<span class="hljs-number">0u8</span>; <span class="hljs-number">512</span>]); <span class="hljs-comment">// ok</span><br>    <span class="hljs-title function_ invoke__">something</span>([<span class="hljs-number">0u8</span>; <span class="hljs-number">1024</span>]); <span class="hljs-comment">// 编译错误，数组长度是1024字节，超过了768字节的参数长度限制</span><br>&#125;<br><br><span class="hljs-comment">// ---</span><br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-keyword">const</span> CHECK: <span class="hljs-type">bool</span>&gt; &#123;<br>    <span class="hljs-comment">//</span><br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">IsTrue</span> &#123;<br>    <span class="hljs-comment">//</span><br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">IsTrue</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-literal">true</span>&gt; &#123;<br>    <span class="hljs-comment">//</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="const-fn">3.2 const fn</h3>
<p>在讨论完 <code>const</code>
泛型后，不得不提及另一个与之密切相关且强大的特性：<code>const fn</code>，即常量函数。<code>const fn</code>
允许我们在编译期对函数进行求值，从而实现更高效、更灵活的代码设计。</p>
<h4 id="为什么需要-const-fn">为什么需要 const fn</h4>
<p>通常情况下，函数是在运行时被调用和执行的。然而，在某些场景下，我们希望在编译期就计算出一些值，以提高运行时的性能或满足某些编译期的约束条件。例如，定义数组的长度、计算常量值等。</p>
<p>有了
<code>const fn</code>，我们可以在编译期执行这些函数，从而将计算结果直接嵌入到生成的代码中。这不仅以高了运行时的性能，还使代码更加简洁和安全。</p>
<h4 id="const-fn-的基本用法">const fn 的基本用法</h4>
<p>要定义一个常量函数，只需要在函数声明前加上 <code>const</code>
关键字。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">const</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(a: <span class="hljs-type">usize</span>, b: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    a + b<br>&#125;<br><br><span class="hljs-keyword">const</span> RESULT: <span class="hljs-type">usize</span> = <span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The result is: &#123;&#125;&quot;</span>, RESULT);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="const-fn-的限制">const fn 的限制</h4>
<p>虽然 <code>const fn</code>
提供了很多便利，但是由于其在编译期执行，以确保函数能在编译期被安全地求值，因此有一些限制，例如，不可将随机数生成器写成
<code>const fn</code>。</p>
<p>无论在编译时还是运行时调用
<code>const fn</code>，它们的结果总是相同，即使多次调用也是如此。唯一的例外是，如果你在极端情况下进行复杂的浮点操作，你可能会得到（非常轻微的）不同结果。因此，不建议使
<code>数组长度 (arr.len())</code> 和 <code>Enum判别式</code>
依赖于浮点计算。</p>
<h4 id="结合-const-fn-与-const-泛型">结合 const fn 与 const 泛型</h4>
<p>将 <code>const fn</code> 与 <code>const 泛型</code>
结合，可以实现更加灵活和高效的代码设计。例如，创建一个固定大小的缓冲区结构，其中缓冲区大小由编译期计算确定：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Buffer</span>&lt;<span class="hljs-keyword">const</span> N: <span class="hljs-type">usize</span>&gt; &#123;<br>    data: [<span class="hljs-type">u8</span>; N],<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">compute_buffer_size</span>(factor: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    factor * <span class="hljs-number">1024</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">const</span> SIZE: <span class="hljs-type">usize</span> = <span class="hljs-title function_ invoke__">compute_buffer_size</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">buffer</span> = Buffer::&lt;SIZE&gt; &#123;<br>        data: [<span class="hljs-number">0</span>; SIZE],<br>    &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Buffer size: &#123;&#125; bytes&quot;</span>, buffer.data.<span class="hljs-title function_ invoke__">len</span>());<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>compute_buffer_size</code>
是一个常量函数，它根据传入的 <code>factor</code> 计算缓冲区的大小。在
<code>main</code> 函数中，我们使用 <code>compute_buffer_size(4)</code>
来计算缓冲区大小为 4096 字节，并将其作为泛型参数传递给
<code>Buffer</code>
结构体。这样，缓冲区的大小在编译期就被确定下来，避免了运行时的计算开销。</p>
<h2 id="泛型的性能">4. 泛型的性能</h2>
<p>在 Rust
中泛型是零成本的抽象，意味着你在使用泛型时，完全不用担心性能上的问题。</p>
<p>但是任何选择都是权衡得失的，既然我们获得了性能上的巨大优势，那么又失去了什么呢？Rust
是在编译期为泛型对应的多个类型，生成各自的代码，因此损失了编译速度和增大了最终生成文件的大小。</p>
<p>具体来说：</p>
<p>Rust 通过在编译时进行泛型代码的
<strong>单态化</strong>(<em>monomorphization</em>)来保证效率。单态化是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程。</p>
<p>编译器所做的工作正好与我们创建泛型函数的步骤相反，编译器寻找所有泛型代码被调用的位置并针对具体类型生成代码。</p>
<p>让我们看看一个使用标准库中 <code>Option</code> 枚举的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">integer</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">float</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5.0</span>);<br></code></pre></td></tr></table></figure>
<p>当 Rust 编译这些代码的时候，它会进行单态化。编译器会读取传递给
<code>Option&lt;T&gt;</code> 的值并发现有两种
<code>Option&lt;T&gt;</code>：一种对应 <code>i32</code> 另一种对应
<code>f64</code>。为此，它会将泛型定义 <code>Option&lt;T&gt;</code>
展开为 <code>Option_i32</code> 和
<code>Option_f64</code>，接着将泛型定义替换为这两个具体的定义。</p>
<p>编译器生成的单态化版本的代码看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option_i32</span> &#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-type">i32</span>),<br>    <span class="hljs-literal">None</span>,<br>&#125;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option_f64</span> &#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-type">f64</span>),<br>    <span class="hljs-literal">None</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">integer</span> = Option_i32::<span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">float</span> = Option_f64::<span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们可以使用泛型来编写不重复的代码，而 Rust
将会为每一个实例编译其特定类型的代码。这意味着在使用泛型时没有运行时开销；当代码运行，它的执行效率就跟好像手写每个具体定义的重复代码一样。<strong>这个单态化过程正是
Rust 泛型在运行时极其高效的原因。</strong></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/rust/" class="category-chain-item">rust</a>
  
  
    <span>></span>
    
  <a href="/categories/rust/rust%E5%9C%A3%E7%BB%8F/" class="category-chain-item">rust圣经</a>
  
  
    <span>></span>
    
  <a href="/categories/rust/rust%E5%9C%A3%E7%BB%8F/rust%E5%9F%BA%E7%A1%80/" class="category-chain-item">rust基础</a>
  
  

  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/rust/" class="print-no-link">#rust</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>2.8.1 泛型 Generics</div>
      <div>http://binbo-zappy.github.io/2025/01/05/rust圣经/2-8-1-泛型-Generics/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Binbo</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年1月5日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/01/05/rust%E5%9C%A3%E7%BB%8F/2-8-2-%E7%89%B9%E5%BE%81-Trait/" title="2.8.2 特征 Trait">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">2.8.2 特征 Trait</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/01/05/rust%E5%9C%A3%E7%BB%8F/2-8-%E6%B3%9B%E5%9E%8B%E5%92%8C%E7%89%B9%E5%BE%81/" title="2.8 泛型和特征">
                        <span class="hidden-mobile">2.8 泛型和特征</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
