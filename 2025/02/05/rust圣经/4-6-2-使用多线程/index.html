

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Binbo">
  <meta name="keywords" content="">
  
    <meta name="description" content="使用线程 1. 多线程编程的风险 由于多线程的代码是同时运行的，因此我们无法保证线程间的执行顺序，这会导致一些问题：  竞态条件(race conditions)，多个线程以非一致性的顺序同时访问数据资源 死锁(deadlocks)，两个线程都想使用某个资源，但是又都在等待对方释放资源后才能使用，结果最终都无法继续执行 一些因为多线程导致的很隐晦的 BUG，难以复现和解决  虽然">
<meta property="og:type" content="article">
<meta property="og:title" content="4.6.2 使用多线程">
<meta property="og:url" content="http://binbo-zappy.github.io/2025/02/05/rust%E5%9C%A3%E7%BB%8F/4-6-2-%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="Binbo">
<meta property="og:description" content="使用线程 1. 多线程编程的风险 由于多线程的代码是同时运行的，因此我们无法保证线程间的执行顺序，这会导致一些问题：  竞态条件(race conditions)，多个线程以非一致性的顺序同时访问数据资源 死锁(deadlocks)，两个线程都想使用某个资源，但是又都在等待对方释放资源后才能使用，结果最终都无法继续执行 一些因为多线程导致的很隐晦的 BUG，难以复现和解决  虽然">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://binbo-zappy.github.io/imgs/rust.jpg">
<meta property="article:published_time" content="2025-02-05T05:41:40.000Z">
<meta property="article:modified_time" content="2025-02-10T09:04:53.932Z">
<meta property="article:author" content="Binbo">
<meta property="article:tag" content="rust">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://binbo-zappy.github.io/imgs/rust.jpg">
  
  
  
  <title>4.6.2 使用多线程 - Binbo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"binbo-zappy.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Binbo&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="4.6.2 使用多线程"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-02-05 13:41" pubdate>
          2025年2月5日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5.3k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          45 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">4.6.2 使用多线程</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="使用线程">使用线程</h1>
<h2 id="多线程编程的风险">1. 多线程编程的风险</h2>
<p>由于多线程的代码是同时运行的，因此我们无法保证线程间的执行顺序，这会导致一些问题：</p>
<ul>
<li>竞态条件(race
conditions)，多个线程以非一致性的顺序同时访问数据资源</li>
<li>死锁(deadlocks)，两个线程都想使用某个资源，但是又都在等待对方释放资源后才能使用，结果最终都无法继续执行</li>
<li>一些因为多线程导致的很隐晦的 BUG，难以复现和解决</li>
</ul>
<p>虽然 Rust
已经通过各种机制减少了上述情况的发生，但是依然无法完全避免上述情况，因此我们在编程时需要格外的小心，同时本书也会列出多线程编程时常见的陷阱，让你提前规避可能的风险。</p>
<h2 id="创建线程">2. 创建线程</h2>
<p>使用 <code>thread::spawn</code> 可以创建线程：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::time::Duration;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">10</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;hi number &#123;&#125; from the spawned thread!&quot;</span>, i);<br>            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">5</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;hi number &#123;&#125; from the main thread!&quot;</span>, i);<br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>有几点值得注意：</p>
<ul>
<li>线程内部的代码使用闭包来执行</li>
<li><code>main</code>
线程一旦结束，程序就立刻结束，因此需要保持它的存活，直到其它子线程完成自己的任务</li>
<li><code>thread::sleep</code>
会让当前线程休眠指定的时间，随后其它线程会被调度运行（上一节并发与并行中有简单介绍过），因此就算你的电脑只有一个
CPU 核心，该程序也会表现的如同多 CPU 核心一般，这就是并发！</li>
</ul>
<p>来看看输出：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs console">hi number 1 from the main thread!<br>hi number 1 from the spawned thread!<br>hi number 2 from the main thread!<br>hi number 2 from the spawned thread!<br>hi number 3 from the main thread!<br>hi number 3 from the spawned thread!<br>hi number 4 from the spawned thread!<br>hi number 4 from the main thread!<br>hi number 5 from the spawned thread!<br></code></pre></td></tr></table></figure>
<p>如果多运行几次，你会发现好像每次输出会不太一样，因为：虽说线程往往是轮流执行的，但是这一点无法被保证！线程调度的方式往往取决于你使用的操作系统。总之，<strong>千万不要依赖线程的执行顺序</strong>。</p>
<h2 id="等待子线程的结束">3. 等待子线程的结束</h2>
<p>上面的代码你不但可能无法让子线程从 1 顺序打印到
10，而且可能打印的数字会变少，因为主线程会提前结束，导致子线程也随之结束，更过分的是，如果当前系统繁忙，甚至该子线程还没被创建，主线程就已经结束了！</p>
<p>因此我们需要一个方法，让主线程安全、可靠地等所有子线程完成任务后，再
kill self：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::time::Duration;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">5</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;hi number &#123;&#125; from the spawned thread!&quot;</span>, i);<br>            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;);<br><br>    handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">5</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;hi number &#123;&#125; from the main thread!&quot;</span>, i);<br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过调用
<code>handle.join</code>，可以让当前线程阻塞，直到它等待的子线程的结束，在上面代码中，由于
<code>main</code> 线程会被阻塞，因此它直到子线程结束后才会输出自己的
<code>1..5</code>：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs console">hi number 1 from the spawned thread!<br>hi number 2 from the spawned thread!<br>hi number 3 from the spawned thread!<br>hi number 4 from the spawned thread!<br>hi number 1 from the main thread!<br>hi number 2 from the main thread!<br>hi number 3 from the main thread!<br>hi number 4 from the main thread!<br></code></pre></td></tr></table></figure>
<p>以上输出清晰的展示了线程阻塞的作用，如果你将 <code>handle.join</code>
放置在 <code>main</code> 线程中的 <code>for</code>
循环后面，那就是另外一个结果：两个线程交替输出。</p>
<h2 id="在线程闭包中使用-move">4. 在线程闭包中使用 move</h2>
<p>在<a target="_blank" rel="noopener" href="https://course.rs/advance/functional-programing/closure.html#move-和-fn">闭包</a>章节中，有讲过
<code>move</code>
关键字在闭包中的使用可以让该闭包拿走环境中某个值的所有权，同样地，你可以使用
<code>move</code> 来将所有权从一个线程转移到另外一个线程。</p>
<p>首先，来看看在一个线程中直接使用另一个线程中的数据会如何：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;</span>, v);<br>    &#125;);<br><br>    handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>以上代码在子线程的闭包中捕获了环境中的 <code>v</code>
变量，来看看结果：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs console">error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function<br><span class="hljs-meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:6:32</span><br>  |<br>6 |     let handle = thread::spawn(|| &#123;<br>  |                                ^^ may outlive borrowed value `v`<br>7 |         println!(&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;, v);<br>  |                                           - `v` is borrowed here<br>  |<br>note: function requires argument type to outlive `&#x27;static`<br><span class="hljs-meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:6:18</span><br>  |<br>6 |       let handle = thread::spawn(|| &#123;<br>  |  __________________^<br>7 | |         println!(&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;, v);<br>8 | |     &#125;);<br>  | |______^<br>help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword<br>  |<br>6 |     let handle = thread::spawn(move || &#123;<br>  |                                ++++<br></code></pre></td></tr></table></figure>
<p>其实代码本身并没有什么问题，问题在于 Rust
无法确定新的线程会活多久（多个线程的结束顺序并不是固定的），所以也无法确定新线程所引用的
<code>v</code> 是否在使用过程中一直合法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;</span>, v);<br>    &#125;);<br><br>    <span class="hljs-title function_ invoke__">drop</span>(v); <span class="hljs-comment">// oh no!</span><br><br>    handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>大家要记住，线程的启动时间点和结束时间点是不确定的，因此存在一种可能，当主线程执行完，
<code>v</code>
被释放掉时，新的线程很可能还没有结束甚至还没有被创建成功，此时新线程对
<code>v</code> 的引用立刻就不再合法！</p>
<p>好在报错里进行了提示：<code>to force the closure to take ownership of v (and any other referenced variables), use the</code>move<code>keyword</code>，让我们使用
<code>move</code> 关键字拿走 <code>v</code> 的所有权即可：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;</span>, v);<br>    &#125;);<br><br>    handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>    <span class="hljs-comment">// 下面代码会报错borrow of moved value: `v`</span><br>    <span class="hljs-comment">// println!(&quot;&#123;:?&#125;&quot;,v);</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>如上所示，很简单的代码，而且 Rust
的所有权机制保证了数据使用上的安全：<code>v</code>
的所有权被转移给新的线程后，<code>main</code>
线程将无法继续使用：最后一行代码将报错。</p>
<h2 id="线程是如何结束的">5. 线程是如何结束的</h2>
<p>之前我们提到 <code>main</code>
线程是程序的主线程，一旦结束，则程序随之结束，同时各个子线程也将被强行终止。那么有一个问题，如果父线程不是
<code>main</code>
线程，那么父线程的结束会导致什么？自生自灭还是被干掉？</p>
<p>在系统编程中，操作系统提供了直接杀死线程的接口，简单粗暴，但是 Rust
并没有提供这样的接口，原因在于，粗暴地终止一个线程可能会导致资源没有释放、状态混乱等不可预期的结果，一向以安全自称的
Rust，自然不会砸自己的饭碗。</p>
<p>那么 Rust
中线程是如何结束的呢？答案很简单：线程的代码执行完，线程就会自动结束。但是如果线程中的代码不会执行完呢？那么情况可以分为两种进行讨论：</p>
<ul>
<li>线程的任务是一个循环 IO 读取，任务流程类似：IO
阻塞，等待读取新的数据 -&gt; 读到数据，处理完成 -&gt; 继续阻塞等待 ···
-&gt; 收到 socket 关闭的信号 -&gt;
结束线程，在此过程中，绝大部分时间线程都处于阻塞的状态，因此虽然看上去是循环，CPU
占用其实很小，也是网络服务中最最常见的模型</li>
<li>线程的任务是一个循环，里面没有任何阻塞，包括休眠这种操作也没有，此时
CPU 很不幸的会被跑满，而且你如果没有设置终止条件，该线程将持续跑满一个
CPU 核心，并且不会被终止，直到 <code>main</code> 线程的结束</li>
</ul>
<p>第一情况很常见，我们来模拟看看第二种情况：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::time::Duration;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 创建一个线程A</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">new_thread</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-comment">// 再创建一个线程B</span><br>        thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>            <span class="hljs-keyword">loop</span> &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;I am a new thread.&quot;</span>);<br>            &#125;<br>        &#125;)<br>    &#125;);<br><br>    <span class="hljs-comment">// 等待新创建的线程执行完成</span><br>    new_thread.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Child thread is finish!&quot;</span>);<br><br>    <span class="hljs-comment">// 睡眠一段时间，看子线程创建的子线程是否还在运行</span><br>    thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">100</span>));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>以上代码中，<code>main</code> 线程创建了一个新的线程
<code>A</code>，同时该新线程又创建了一个新的线程
<code>B</code>，可以看到 <code>A</code> 线程在创建完 <code>B</code>
线程后就立即结束了，而 <code>B</code> 线程则在不停地循环输出。</p>
<p>从之前的线程结束规则，我们可以猜测程序将这样执行：<code>A</code>
线程结束后，由它创建的 <code>B</code> 线程仍在疯狂输出，直到
<code>main</code> 线程在 100
毫秒后结束。如果你把该时间增加到几十秒，就可以看到你的 CPU 核心 100%
的盛况了-,-</p>
<h2 id="多线程的性能">6. 多线程的性能</h2>
<p>下面我们从多个方面来看看多线程的性能大概是怎么样的。</p>
<h3 id="创建线程的性能">6.1 创建线程的性能</h3>
<p>据不精确估算，创建一个线程大概需要 0.24
毫秒，随着线程的变多，这个值会变得更大，因此线程的创建耗时是不可忽略的，只有当真的需要处理一个值得用线程去处理的任务时，才使用线程，一些鸡毛蒜皮的任务，就无需创建线程了。</p>
<h3 id="创建多少线程合适">6.2 创建多少线程合适</h3>
<p>因为 CPU 的核心数限制，当任务是 CPU 密集型时，就算线程数超过了 CPU
核心数，也并不能帮你获得更好的性能，因为每个线程的任务都可以轻松让 CPU
的某个核心跑满，既然如此，让线程数等于 CPU 核心数是最好的。</p>
<p>但是当你的任务大部分时间都处于阻塞状态时，就可以考虑增多线程数量，这样当某个线程处于阻塞状态时，会被切走，进而运行其它的线程，典型就是网络
IO
操作，我们可以为每一个进来的用户连接创建一个线程去处理，该连接绝大部分时间都是处于
IO 读取阻塞状态，因此有限的 CPU
核心完全可以处理成百上千的用户连接线程，但是事实上，对于这种网络 IO
情况，一般都不再使用多线程的方式了，毕竟操作系统的线程数是有限的，意味着并发数也很容易达到上限，而且过多的线程也会导致线程上下文切换的代价过大，使用
<code>async/await</code> 的 <code>M:N</code>
并发模型，就没有这个烦恼。</p>
<h3 id="多线程的开销">6.3 多线程的开销</h3>
<p>下面的代码是一个无锁实现(CAS)的 <code>Hashmap</code>
在多线程下的使用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..num_threads &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">ht</span> = Arc::<span class="hljs-title function_ invoke__">clone</span>(&amp;ht);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">j</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..adds_per_thread &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">key</span> = <span class="hljs-title function_ invoke__">thread_rng</span>().gen::&lt;<span class="hljs-type">u32</span>&gt;();<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">value</span> = <span class="hljs-title function_ invoke__">thread_rng</span>().gen::&lt;<span class="hljs-type">u32</span>&gt;();<br>            ht.<span class="hljs-title function_ invoke__">set_item</span>(key, value);<br>        &#125;<br>    &#125;);<br><br>    handles.<span class="hljs-title function_ invoke__">push</span>(handle);<br>&#125;<br><br><span class="hljs-keyword">for</span> <span class="hljs-variable">handle</span> <span class="hljs-keyword">in</span> handles &#123;<br>    handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>按理来说，既然是无锁实现了，那么锁的开销应该几乎没有，性能会随着线程数的增加接近线性增长，但是真的是这样吗？</p>
<p>下图是该代码在 <code>48</code> 核机器上的运行结果：</p>
<figure>
<img src="/2025/02/05/rust%E5%9C%A3%E7%BB%8F/4-6-2-%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B/v2-af225672de09c0e377023f5f39dd87eb_1440w.png" srcset="/img/loading.gif" lazyload alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>从图上可以明显的看出：吞吐并不是线性增长，尤其从 <code>16</code>
核开始，甚至开始肉眼可见的下降，这是为什么呢？</p>
<p>限于书本的篇幅有限，我们只能给出大概的原因：</p>
<ul>
<li>虽然是无锁，但是内部是 CAS 实现，大量线程的同时访问，会让 CAS
重试次数大幅增加</li>
<li>线程过多时，CPU 缓存的命中率会显著下降，同时多个线程竞争一个 CPU
Cache-line 的情况也会经常发生</li>
<li>大量读写可能会让内存带宽也成为瓶颈</li>
<li>读和写不一样，无锁数据结构的读往往可以很好地线性增长，但是写不行，因为写竞争太大</li>
</ul>
<p>总之，多线程的开销往往是在锁、数据竞争、缓存失效上，这些限制了现代化软件系统随着
CPU 核心的增多性能也线性增加的野心。</p>
<h2 id="线程屏障barrier">7. 线程屏障(Barrier)</h2>
<p>在 Rust 中，可以使用 <code>Barrier</code>
让多个线程都执行到某个点后，才继续一起往后执行：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::&#123;Arc, Barrier&#125;;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">handles</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(<span class="hljs-number">6</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">barrier</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Barrier::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">6</span>));<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">6</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = barrier.<span class="hljs-title function_ invoke__">clone</span>();<br>        handles.<span class="hljs-title function_ invoke__">push</span>(thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span>|| &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;before wait&quot;</span>);<br>            b.<span class="hljs-title function_ invoke__">wait</span>();<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;after wait&quot;</span>);<br>        &#125;));<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">handle</span> <span class="hljs-keyword">in</span> handles &#123;<br>        handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面代码，我们在线程打印出 <code>before wait</code>
后增加了一个屏障，目的就是等所有的线程都打印出<strong>before
wait</strong>后，各个线程再继续执行：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs console">before wait<br>before wait<br>before wait<br>before wait<br>before wait<br>before wait<br>after wait<br>after wait<br>after wait<br>after wait<br>after wait<br>after wait<br></code></pre></td></tr></table></figure>
<h2 id="线程局部变量thread-local-variable">8. 线程局部变量(Thread Local
Variable)</h2>
<p>对于多线程编程，线程局部变量在一些场景下非常有用，而 Rust
通过标准库和三方库对此进行了支持。</p>
<h3 id="标准库-thread_local">8.1 标准库 thread_local</h3>
<p>使用 <code>thread_local</code>
宏可以初始化线程局部变量，然后在线程内部使用该变量的 <code>with</code>
方法获取变量值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cell::RefCell;<br><span class="hljs-keyword">use</span> std::thread;<br><br>thread_local!(<span class="hljs-keyword">static</span> FOO: RefCell&lt;<span class="hljs-type">u32</span>&gt; = RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>));<br><br>FOO.<span class="hljs-title function_ invoke__">with</span>(|f| &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(*f.<span class="hljs-title function_ invoke__">borrow</span>(), <span class="hljs-number">1</span>);<br>    *f.<span class="hljs-title function_ invoke__">borrow_mut</span>() = <span class="hljs-number">2</span>;<br>&#125;);<br><br><span class="hljs-comment">// 每个线程开始时都会拿到线程局部变量的FOO的初始值</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span>|| &#123;<br>    FOO.<span class="hljs-title function_ invoke__">with</span>(|f| &#123;<br>        <span class="hljs-built_in">assert_eq!</span>(*f.<span class="hljs-title function_ invoke__">borrow</span>(), <span class="hljs-number">1</span>);<br>        *f.<span class="hljs-title function_ invoke__">borrow_mut</span>() = <span class="hljs-number">3</span>;<br>    &#125;);<br>&#125;);<br><br><span class="hljs-comment">// 等待线程完成</span><br>t.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br><span class="hljs-comment">// 尽管子线程中修改为了3，我们在这里依然拥有main线程中的局部值：2</span><br>FOO.<span class="hljs-title function_ invoke__">with</span>(|f| &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(*f.<span class="hljs-title function_ invoke__">borrow</span>(), <span class="hljs-number">2</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>上面代码中，<code>FOO</code>
即是我们创建的<strong>线程局部变量</strong>，每个新的线程访问它时，都会使用它的初始值作为开始，各个线程中的
<code>FOO</code> 值彼此互不干扰。注意 <code>FOO</code> 使用
<code>static</code> 声明为生命周期为 <code>'static</code>
的静态变量。</p>
<p>可以注意到，线程中对 <code>FOO</code>
的使用是通过借用的方式，但是若我们需要每个线程独自获取它的拷贝，最后进行汇总，就有些强人所难了。</p>
<p>你还可以在结构体中使用线程局部变量：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cell::RefCell;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span>;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Foo</span> &#123;<br>    thread_local! &#123;<br>        <span class="hljs-keyword">static</span> FOO: RefCell&lt;<span class="hljs-type">usize</span>&gt; = RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    Foo::FOO.<span class="hljs-title function_ invoke__">with</span>(|x| <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, x));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>或者通过引用的方式使用它:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cell::RefCell;<br><span class="hljs-keyword">use</span> std::thread::LocalKey;<br><br>thread_local! &#123;<br>    <span class="hljs-keyword">static</span> FOO: RefCell&lt;<span class="hljs-type">usize</span>&gt; = RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Bar</span> &#123;<br>    foo: &amp;<span class="hljs-symbol">&#x27;static</span> LocalKey&lt;RefCell&lt;<span class="hljs-type">usize</span>&gt;&gt;,<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Bar</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">constructor</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span> &#123;<br>            foo: &amp;FOO,<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="三方库-thread-local">8.2 三方库 thread-local</h3>
<p>除了标准库外，一位大神还开发了 <a target="_blank" rel="noopener" href="https://github.com/Amanieu/thread_local-rs">thread-local</a>
库，它允许每个线程持有值的独立拷贝：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> thread_local::ThreadLocal;<br><span class="hljs-keyword">use</span> std::sync::Arc;<br><span class="hljs-keyword">use</span> std::cell::Cell;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">tls</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(ThreadLocal::<span class="hljs-title function_ invoke__">new</span>());<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[];<br><span class="hljs-comment">// 创建多个线程</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">5</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">tls2</span> = tls.<span class="hljs-title function_ invoke__">clone</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-comment">// 将计数器加1</span><br>        <span class="hljs-comment">// 请注意，由于线程 ID 在线程退出时会被回收，因此一个线程有可能回收另一个线程的对象</span><br>        <span class="hljs-comment">// 这只能在线程退出后发生，因此不会导致任何竞争条件</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">cell</span> = tls2.<span class="hljs-title function_ invoke__">get_or</span>(|| Cell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>));<br>        cell.<span class="hljs-title function_ invoke__">set</span>(cell.<span class="hljs-title function_ invoke__">get</span>() + <span class="hljs-number">1</span>);<br>    &#125;);<br>    v.<span class="hljs-title function_ invoke__">push</span>(handle);<br>&#125;<br><span class="hljs-keyword">for</span> <span class="hljs-variable">handle</span> <span class="hljs-keyword">in</span> v &#123;<br>    handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br><span class="hljs-comment">// 一旦所有子线程结束，收集它们的线程局部变量中的计数器值，然后进行求和</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">tls</span> = Arc::<span class="hljs-title function_ invoke__">try_unwrap</span>(tls).<span class="hljs-title function_ invoke__">unwrap</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">total</span> = tls.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">fold</span>(<span class="hljs-number">0</span>, |x, y| &#123;<br>    <span class="hljs-comment">// 打印每个线程局部变量中的计数器值，发现不一定有5个线程，</span><br>    <span class="hljs-comment">// 因为一些线程已退出，并且其他线程会回收退出线程的对象</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x: &#123;&#125;, y: &#123;&#125;&quot;</span>, x, y.<span class="hljs-title function_ invoke__">get</span>());<br>    x + y.<span class="hljs-title function_ invoke__">get</span>()<br>&#125;);<br><br><span class="hljs-comment">// 和为5</span><br><span class="hljs-built_in">assert_eq!</span>(total, <span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure>
<p>该库不仅仅使用了值的拷贝，而且还能自动把多个拷贝汇总到一个迭代器中，最后进行求和，非常好用。</p>
<h2 id="用条件控制线程的挂起和执行">9. 用条件控制线程的挂起和执行</h2>
<p>条件变量(Condition Variables)经常和 <code>Mutex</code>
一起使用，可以让线程挂起，直到某个条件发生后再继续执行：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::sync::&#123;Arc, Mutex, Condvar&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">pair</span> = Arc::<span class="hljs-title function_ invoke__">new</span>((Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>), Condvar::<span class="hljs-title function_ invoke__">new</span>()));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">pair2</span> = pair.<span class="hljs-title function_ invoke__">clone</span>();<br><br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span>|| &#123;<br>        <span class="hljs-keyword">let</span> (lock, cvar) = &amp;*pair2;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">started</span> = lock.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;changing started&quot;</span>);<br>        *started = <span class="hljs-literal">true</span>;<br>        cvar.<span class="hljs-title function_ invoke__">notify_one</span>();<br>    &#125;);<br><br>    <span class="hljs-keyword">let</span> (lock, cvar) = &amp;*pair;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">started</span> = lock.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">while</span> !*started &#123;<br>        started = cvar.<span class="hljs-title function_ invoke__">wait</span>(started).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;started changed&quot;</span>);<br>&#125;<br><br>这是一个非常好的问题！`started` 在两个线程中确实是**同一个值**，因为它们都通过 `Arc` 共享了同一个 `Mutex&lt;<span class="hljs-type">bool</span>&gt;`。让我们详细解释一下为什么它们是一样的，以及代码中是如何实现这种共享的。<br><br>---<br><br>### <span class="hljs-number">1</span>. **`Arc` 的作用**<br>`Arc`（原子引用计数）允许多个线程共享同一个数据的所有权。在这段代码中：<br>​```rust<br><span class="hljs-keyword">let</span> <span class="hljs-variable">pair</span> = Arc::<span class="hljs-title function_ invoke__">new</span>((Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>), Condvar::<span class="hljs-title function_ invoke__">new</span>()));<br>​```<br>- `pair` 是一个 `Arc`，它包含一个元组 `(Mutex&lt;<span class="hljs-type">bool</span>&gt;, Condvar)`。<br>- `Mutex&lt;<span class="hljs-type">bool</span>&gt;` 是一个互斥锁，保护一个布尔值 `<span class="hljs-literal">false</span>`。<br>- `Condvar` 是一个条件变量，用于线程间的通信。<br><br>当调用 `pair.<span class="hljs-title function_ invoke__">clone</span>()` 时：<br>​```rust<br><span class="hljs-keyword">let</span> <span class="hljs-variable">pair2</span> = pair.<span class="hljs-title function_ invoke__">clone</span>();<br>​```<br>- `pair2` 是 `pair` 的一个克隆，但它们指向**同一个内存地址**，即同一个 `Mutex&lt;<span class="hljs-type">bool</span>&gt;` 和 `Condvar`。<br><br>因此，`pair` 和 `pair2` 共享同一个 `Mutex&lt;<span class="hljs-type">bool</span>&gt;`，而 `started` 就是这个 `Mutex&lt;<span class="hljs-type">bool</span>&gt;` 中的布尔值。<br><br>---<br><br>### <span class="hljs-number">2</span>. **`started` 的共享**<br>在两个线程中，`started` 是通过 `Mutex` 访问的：<br>- 在新线程中：<br>  ```rust<br>  <span class="hljs-keyword">let</span> (lock, cvar) = &amp;*pair2;<br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">started</span> = lock.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>  *started = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li><p><code>lock.lock().unwrap()</code> 获取了 <code>Mutex</code>
的锁，并解引用 <code>Mutex</code> 中的布尔值。</p></li>
<li><p><code>*started = true</code> 修改了这个布尔值。</p></li>
<li><p>在主线程中： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> (lock, cvar) = &amp;*pair;<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">started</span> = lock.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><span class="hljs-keyword">while</span> !*started &#123;<br>    started = cvar.<span class="hljs-title function_ invoke__">wait</span>(started).<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure></p>
<ul>
<li>同样，<code>lock.lock().unwrap()</code> 获取了 <code>Mutex</code>
的锁，并解引用 <code>Mutex</code> 中的布尔值。</li>
<li><code>*started</code> 检查这个布尔值是否为 <code>true</code>。</li>
</ul></li>
</ul>
<p>由于 <code>pair</code> 和 <code>pair2</code> 共享同一个
<code>Mutex&lt;bool&gt;</code>，因此两个线程中的 <code>started</code>
是<strong>同一个布尔值</strong>。</p>
<hr>
<h3 id="mutex-的作用">3. <strong><code>Mutex</code> 的作用</strong></h3>
<p><code>Mutex</code> 确保了对 <code>started</code> 的访问是线程安全的：
- 当一个线程获取了 <code>Mutex</code> 的锁时，其他线程无法同时访问
<code>started</code>，直到锁被释放。 -
在新线程中，<code>lock.lock().unwrap()</code> 获取锁后，修改了
<code>started</code> 的值，然后释放锁。 -
在主线程中，<code>lock.lock().unwrap()</code> 获取锁后，检查
<code>started</code> 的值，如果为 <code>false</code>，则调用
<code>cvar.wait()</code> 释放锁并等待通知。</p>
<hr>
<h3 id="condvar-的作用">4. <strong><code>Condvar</code>
的作用</strong></h3>
<p><code>Condvar</code> 用于线程间的通信： - 在新线程中，修改完
<code>started</code> 后，调用 <code>cvar.notify_one()</code>
通知主线程条件已经满足。 - 在主线程中，<code>cvar.wait()</code> 会释放
<code>Mutex</code> 的锁并进入等待状态，直到收到通知。</p>
<hr>
<h3 id="总结">5. <strong>总结</strong></h3>
<ul>
<li><code>started</code>
在两个线程中是<strong>同一个值</strong>，因为它们通过 <code>Arc</code>
共享了同一个 <code>Mutex&lt;bool&gt;</code>。</li>
<li><code>Mutex</code> 确保了对 <code>started</code>
的访问是线程安全的。</li>
<li><code>Condvar</code> 用于在新线程修改 <code>started</code>
后通知主线程。</li>
</ul>
<hr>
<h3 id="代码的执行流程">代码的执行流程</h3>
<ol type="1">
<li>主线程创建 <code>Arc</code>，并克隆 <code>pair</code>
给新线程。</li>
<li>主线程获取 <code>Mutex</code> 的锁，检查 <code>started</code> 是否为
<code>true</code>，如果为 <code>false</code>，则进入等待状态。</li>
<li>新线程获取 <code>Mutex</code> 的锁，将 <code>started</code> 修改为
<code>true</code>，并通知主线程。</li>
<li>主线程被唤醒，重新获取锁，检查 <code>started</code> 为
<code>true</code>，退出循环，打印 "started changed"。</li>
</ol>
<p>希望这个解释能帮助你理解 <code>started</code>
在两个线程中的共享机制！如果还有疑问，欢迎继续提问！ <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br>上述代码流程如下：<br><br><span class="hljs-number">1</span>. `main` 线程首先进入 `<span class="hljs-keyword">while</span>` 循环，调用 `wait` 方法挂起等待子线程的通知，并释放了锁 `started`<br><span class="hljs-number">2</span>. 子线程获取到锁，并将其修改为 `<span class="hljs-literal">true</span>`，然后调用条件变量的 `notify_one` 方法来通知主线程继续执行<br><br><br><br>## <span class="hljs-number">10</span>. 只被调用一次的函数<br><br>有时，我们会需要**某个函数在多线程环境下只被调用一次**，例如初始化全局变量，无论是哪个线程先调用函数来初始化，都会保证全局变量只会被初始化一次，随后的其它线程调用就会忽略该函数：<br><br>```rust<br><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::sync::Once;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> VAL: <span class="hljs-type">usize</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> INIT: Once = Once::<span class="hljs-title function_ invoke__">new</span>();<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle1</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        INIT.<span class="hljs-title function_ invoke__">call_once</span>(|| &#123;<br>            <span class="hljs-keyword">unsafe</span> &#123;<br>                VAL = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;);<br>    &#125;);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle2</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        INIT.<span class="hljs-title function_ invoke__">call_once</span>(|| &#123;<br>            <span class="hljs-keyword">unsafe</span> &#123;<br>                VAL = <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;);<br>    &#125;);<br><br>    handle1.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    handle2.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-keyword">unsafe</span> &#123; VAL &#125;);<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>代码运行的结果取决于哪个线程先调用 <code>INIT.call_once</code>
（虽然代码具有先后顺序，但是线程的初始化顺序并无法被保证！因为线程初始化是异步的，且耗时较久），若
<code>handle1</code> 先，则输出 <code>1</code>，否则输出
<code>2</code>。</p>
<p><strong>call_once 方法</strong></p>
<p>执行初始化过程一次，并且只执行一次。</p>
<p>如果当前有另一个初始化过程正在运行，线程将阻止该方法被调用。</p>
<p>当这个函数返回时，保证一些初始化已经运行并完成，它还保证由执行的闭包所执行的任何内存写入都能被其他线程在这时可靠地观察到。</p>
<h2 id="总结-1">11. 总结</h2>
<p><a target="_blank" rel="noopener" href="https://course.rs/advance/concurrency-with-threads/intro.html">Rust
的线程模型</a>是 <code>1:1</code> 模型，因为 Rust
要保持尽量小的运行时。</p>
<p>我们可以使用 <code>thread::spawn</code>
来创建线程，创建出的多个线程之间并不存在执行顺序关系，因此代码逻辑千万不要依赖于线程间的执行顺序。</p>
<p><code>main</code>
线程若是结束，则所有子线程都将被终止，如果希望等待子线程结束后，再结束
<code>main</code> 线程，你需要使用创建线程时返回的句柄的
<code>join</code> 方法。</p>
<p>在线程中无法直接借用外部环境中的变量值，因为新线程的启动时间点和结束时间点是不确定的，所以
Rust 无法保证该线程中借用的变量在使用过程中依然是合法的。你可以使用
<code>move</code> 关键字将变量的所有权转移给新的线程，来解决此问题。</p>
<p>父线程结束后，子线程仍在持续运行，直到子线程的代码运行完成或者
<code>main</code> 线程的结束。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/rust/" class="category-chain-item">rust</a>
  
  
    <span>></span>
    
  <a href="/categories/rust/rust%E5%9C%A3%E7%BB%8F/" class="category-chain-item">rust圣经</a>
  
  
    <span>></span>
    
  <a href="/categories/rust/rust%E5%9C%A3%E7%BB%8F/rust%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6/" class="category-chain-item">rust高级进阶</a>
  
  

  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/rust/" class="print-no-link">#rust</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>4.6.2 使用多线程</div>
      <div>http://binbo-zappy.github.io/2025/02/05/rust圣经/4-6-2-使用多线程/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Binbo</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年2月5日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/02/05/rust%E5%9C%A3%E7%BB%8F/4-6-3-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92/" title="4.6.3 线程同步：消息传递">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">4.6.3 线程同步：消息传递</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/02/05/rust%E5%9C%A3%E7%BB%8F/4-6-1-%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C/" title="4.6.1 并发和并行">
                        <span class="hidden-mobile">4.6.1 并发和并行</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
