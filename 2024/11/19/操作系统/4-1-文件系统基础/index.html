

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Binbo">
  <meta name="keywords" content="">
  
    <meta name="description" content="第四章 文件管理 4.1 文件系统 1. 初始文件管理 文件：一组有意义的信息&#x2F;数据集合 文件管理 计算机中存放了各种各样的文件，一个文件有哪些属性？ 文件内部的数据应该怎样组织起来？ 文件之间又应该又应该怎么组织起来？ 计算机系统的层次结构从下往上看，OS应提供哪些功能，才能方便用户、应用程序使用文件？ 计算机系统的层次结构从上往下看，文件数据应该怎么存放在外存（磁盘）上？ 如何实现文">
<meta property="og:type" content="article">
<meta property="og:title" content="4.1 文件系统基础">
<meta property="og:url" content="http://binbo-zappy.github.io/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-1-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Binbo">
<meta property="og:description" content="第四章 文件管理 4.1 文件系统 1. 初始文件管理 文件：一组有意义的信息&#x2F;数据集合 文件管理 计算机中存放了各种各样的文件，一个文件有哪些属性？ 文件内部的数据应该怎样组织起来？ 文件之间又应该又应该怎么组织起来？ 计算机系统的层次结构从下往上看，OS应提供哪些功能，才能方便用户、应用程序使用文件？ 计算机系统的层次结构从上往下看，文件数据应该怎么存放在外存（磁盘）上？ 如何实现文">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://binbo-zappy.github.io/imgs/OS.png">
<meta property="article:published_time" content="2024-11-19T01:47:04.000Z">
<meta property="article:modified_time" content="2024-11-19T10:12:40.832Z">
<meta property="article:author" content="Binbo">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://binbo-zappy.github.io/imgs/OS.png">
  
  
  
  <title>4.1 文件系统基础 - Binbo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"binbo-zappy.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Binbo&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="4.1 文件系统基础"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-11-19 09:47" pubdate>
          2024年11月19日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          102 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">4.1 文件系统基础</h1>
            
            
              <div class="markdown-body">
                
                <p><strong>第四章 文件管理</strong></p>
<p><strong>4.1 文件系统</strong></p>
<p><strong>1. 初始文件管理</strong></p>
<p><strong>文件</strong>：<strong>一组有意义的信息&#x2F;数据集合</strong></p>
<p><strong>文件管理</strong></p>
<p>计算机中存放了各种各样的文件，一个<strong>文件有哪些属性</strong>？</p>
<p><strong>文件内部的数据应该怎样组织起来</strong>？</p>
<p><strong>文件之间又应该又应该怎么组织起来</strong>？</p>
<p>计算机系统的层次结构从下往上看，<strong>OS应提供哪些功能，才能方便用户、应用程序使用文件</strong>？</p>
<p>计算机系统的层次结构从上往下看，<strong>文件数据应该怎么存放在外存（磁盘）上</strong>？</p>
<p><strong>如何实现文件的共享和保护</strong></p>
<p><strong>文件的属性</strong></p>
<p><strong>文件名</strong></p>
<p>由创建文件的用户决定文件名，主要是为了方便用户找到文件，<strong>同一目录下不允许有重名文件</strong></p>
<p><strong>标识符</strong></p>
<p>一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分</p>
<p>各个文件的一种内部名称</p>
<p><strong>类型</strong></p>
<p>指明文件的类型位置：文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，对</p>
<p>用户不可见）</p>
<p><strong>大小</strong></p>
<p>指明文件大小</p>
<p><strong>创建时间</strong>、<strong>上次修改时间</strong></p>
<p><strong>文件所有者信息</strong></p>
<p><strong>保护信息</strong></p>
<p>对文件进行保护的访问控制信息</p>
<p><strong>文件内部的数据应该怎样组织起来？</strong></p>
<p><strong>无结构文件</strong>（如文本文件）– 由一些二进制或字符流组成，又称“<strong>流式文件</strong>”</p>
<p><strong>有结构文件</strong>（如数据库表）– 由一组相似的<strong>记录</strong>组成，又称“<strong>记录式文件</strong>”</p>
<p><strong>记录</strong>是一组相关<strong>数据项</strong>的集合</p>
<p><strong>数据项</strong>是文件系统中最基本的数据单位</p>
<p><strong>有结构文件</strong>中，<strong>各个记录间应该如何组织</strong>的问题</p>
<p>应该顺序存放？还是用索引表来表示记录间的顺序？– 这是“<strong>文件的逻辑结构</strong>”重点要探讨的</p>
<p>问题</p>
<p><strong>文件之间应该怎样组织起来？</strong></p>
<p>用户可以自己创建一层一层的<strong>目录</strong>，各层目录中存放相应的<strong>文件</strong>。<strong>系统中的各个文件就通过一层一</strong></p>
<p><strong>层的目录合理有序的组织起来了</strong></p>
<p>所谓的“<strong>目录</strong>”其实就是我们熟悉的“<strong>文件夹</strong>”</p>
<p><strong>目录</strong>其实也<strong>是一种特殊的有结构文件（由记录组成）</strong>，如何实现<strong>文件目录</strong>是之后会重点探讨的</p>
<p>问题</p>
<p><strong>操作系统应该向上提供哪些功能？</strong></p>
<p>可以“<strong>创建文件</strong>”（点击新建后，图形化交互进程在背后调用了“<strong>create 系统调用</strong>”）</p>
<p>可以<strong>“删除文件</strong>”（点击删除后，图形化交互进程在背后调用了”<strong>delete 系统调用</strong>“，将文件数据从</p>
<p>外存中删除）</p>
<p>可以“<strong>读文件</strong>”，将文件数据读入内存，才能让CPU处理（双击后，“记事本”应用程序通过操作系统</p>
<p>提供的“<strong>read 系统调用</strong>”，将文件数据从外存读入内存，并显示在屏幕上）</p>
<p>可以“<strong>写文件</strong>”，将更改过的文件数据写回外存（在“记事本”应用程序中编辑文件内容，点击“保存”</p>
<p>后，“记事本”应用程序通过操作系统提供的“<strong>write 系统调用</strong>”，将文件数据从内存写回外存）</p>
<p>读&#x2F;写文件之前，需要通过操作系统提供的”<strong>open 系统调用</strong>“来“<strong>打开文件</strong>”</p>
<p>读&#x2F;写文件结束之后，需要通过操作系统提供的”<strong>close 系统调用</strong>“来“<strong>关闭文件</strong>”</p>
<p>可用几个基本操作完成更复杂的操作</p>
<p>比如：“复制文件”：先创建一个新的空文件，再把源文件读入内存，再将内存中的数据写到新</p>
<p>文件中</p>
<p><strong>从上往下看，文件应如何存放在外存？</strong></p>
<p><strong>外存的结构</strong></p>
<p>与内存一样，<strong>外存</strong>也是由一个个<strong>存储单元</strong>组成的，每个存储单元可以存储一定量的数据 （如</p>
<p>1B）</p>
<p><strong>每个存储单元对应一个物理地址</strong></p>
<p>类似于内存分为一个个“内存块”，<strong>外存</strong>会分为一个个“<strong>块&#x2F;磁盘块&#x2F;物理块</strong>”。<strong>每个磁盘块的大小是</strong></p>
<p><strong>相等的，每块一般包含2的整数幂个地址</strong>（如本例中，一块包含 2<sup>10</sup> 个地址，即 1KB）。同样</p>
<p>类似的是，<strong>文件的逻辑地址</strong>也可以分为<strong>（逻辑块号，块内地址）</strong>，操作系统同样需要将<strong>逻辑地</strong></p>
<p><strong>址转换为外存的物理地址（物理块号，块内地址）</strong>的形式。<strong>块内地址的位数取决于磁盘块的大</strong></p>
<p><strong>小</strong></p>
<p><strong>操作系统以“块”为单位为文件分配存储空间</strong>，因此即使一个文件大小只有10B，但它依然需要</p>
<p>占用 1KB 的磁盘块。<strong>外存中的数据读入内存时同样以块为单位</strong></p>
<p><strong>文件应如何存放在外存？</strong></p>
<p>文件数据放在连续的几个磁盘块中？</p>
<p>文件数据放在离散的几个磁盘块中？此时，应该如何记录各个磁盘块之间的先后顺序呢？</p>
<p>操作系统又应该怎么管理空闲磁盘块？</p>
<p>这些都是“<strong>文件的物理结构</strong>”部分会探讨的内容</p>
<p><strong>其他需要由操作系统实现的文件管理功能</strong></p>
<p><strong>文件共享</strong>：使多个用户可以共享使用一个文件</p>
<p><strong>文件保护</strong>：如何保证不同的用户对文件有不同的操作权限</p>
<p><strong>2. 文件的逻辑结构</strong></p>
<p>“<strong>逻辑结构</strong>”：就是指在用户看来，文件内部的数据应该是如何组织起来的</p>
<p>“<strong>物理结构</strong>”：指的是在操作系统看来，文件的数据是如何存放在外存中的</p>
<p>类似于数据结构的“逻辑结构”和“物理结构”</p>
<p>如“线性表”就是一种逻辑结构，在用户角度看来，线性表就是一组有先后关系的元素序列，</p>
<p>如：a, b, c, d, e ……</p>
<p>“线性表”这种逻辑结构可以用不同的物理结构实现，如：顺序表&#x2F;链表。顺序表的各个元素在逻</p>
<p>辑上相邻，在物理上也相邻；而链表的各个元素在物理上可以是不相邻的。因此，顺序表可以</p>
<p>实现“随机访问”，而“链表”无法实现随机访问</p>
<p>可见，算法的具体实现与逻辑结构、物理结构都有关（文件也一样，文件操作的具体实现与文</p>
<p>件的逻辑结构、物理结构都有关）</p>
<p>按文件是否有结构分类，可以分为<strong>无结构文件</strong>、<strong>有结构文件</strong>两种</p>
<p><strong>无结构文件</strong></p>
<p><strong>文件内部的数据就是一系列二进制流或字符流组成</strong>。又称“<strong>流式文件</strong>”</p>
<p>如：Windows 操作系统中的 .txt 文件，文件内部的数据其实就是一系列字符流，没有明显的结</p>
<p>构特性。因此也不用探讨无结构文件的“逻辑结构”问题</p>
<p><strong>有结构文件</strong></p>
<p><strong>由一组相似的记录组成</strong>，又称“<strong>记录式文件</strong>”。每条<strong>记录</strong>又若干个<strong>数据项</strong>组成</p>
<p>如：数据库表文件</p>
<p>一般来说，每条<strong>记录</strong>有一个<strong>数据项</strong>可作为<strong>关键字</strong>（作为识别不同记录的ID）</p>
<p>根据各条记录的长度（占用的存储空间）是否相等，又可分为<strong>定长记录</strong>和<strong>可变长记录</strong>两种</p>
<p><strong>有结构文件的逻辑结构</strong>：根据有结构文件中的各条记录在逻辑上如何组织，可以分为三类</p>
<p><strong>顺序文件</strong></p>
<p><strong>索引文件</strong></p>
<p><strong>索引顺序文件</strong></p>
<p><strong>顺序文件</strong></p>
<p><strong>文件中的记录一个接一个地顺序排列（逻辑上）</strong>，<strong>记录</strong>可以是<strong>定长</strong>的或<strong>可变长</strong>的。各个记录在<strong>物理</strong></p>
<p><strong>上</strong>可以<strong>顺序存储</strong>或<strong>链式存储</strong></p>
<p><strong>顺序存储</strong>：逻辑上相邻的记录物理上也相邻（类似于顺序表）</p>
<p><strong>链式存储</strong>：逻辑上相邻的记录物理上不一定相邻（类似于链表）</p>
<p><strong>顺序文件</strong>还可按<strong>记录之间的关键字顺序</strong>分为：</p>
<p><strong>串结构</strong>：记录之间的顺序与关键字无关（通常按照记录存入的时间决定记录的顺序）</p>
<p><strong>顺序结构</strong>：记录之间的顺序按关键字顺序排列</p>
<p><strong>思考</strong>:</p>
<p>假设：已经知道了文件的起始地址（也就是第一个记录存放的位置）</p>
<p>思考1：能否快速找到第 i 个记录对应的地址？（即能否实现随机存取）</p>
<p>思考2：能否快速找到某个关键字对应的记录存放的位置？</p>
<p><strong>结论</strong>：定长记录的顺序文件，若物理上采用顺序存储，则可实现随机存取；若能再保证记录的</p>
<p>顺序结构，则可实现快速检索（即根据关键字快速找到对应记录）</p>
<p>注：一般来说，考试题目中所说的“顺序文件”指的是<strong>物理上顺序存储的顺序文件</strong>。之后的讲</p>
<p>解中提到的顺序文件也默认如此。可见，顺序文件的<strong>缺点</strong>是<strong>增加&#x2F;删除一个记录比较困难</strong></p>
<p>（如果是串结构则相对简单）</p>
<p><strong>索引文件</strong></p>
<p>对于可变长记录文件，要找到第 i 个记录，必须先顺序第查找前 i-1 个记录，但是很多应用场景中</p>
<p>又必须使用可变长记录。如何解决这个问题？</p>
<p><strong>索引表</strong>本身是<strong>定长记录的顺序文件</strong>。因此可以快速找到第 i 个记录对应的索引项</p>
<p>可将<strong>关键字作为索引号内容</strong>，若按关键字顺序排列，则还可以支持按照关键字折半查找</p>
<p>每当要增加&#x2F;删除一个记录时，需要对索引表进行修改。由于索引文件有很快的检索速度，因此主</p>
<p>要<strong>用于对信息处理的及时性要求比较高的场合</strong></p>
<p>另外，可以用不同的数据项建立多个索引表</p>
<p>如：学生信息表中，可用关键字“学号”建立一张索引表。也可用“姓名”建立一张索引表。这样就</p>
<p>可以根据“姓名”快速地检索文件了</p>
<p>Eg：SQL 就支持根据某个数据项建立索引的功能</p>
<p><strong>索引顺序文件</strong></p>
<p>思考<strong>索引文件</strong>的缺点：每个记录对应一个索引表项，因此索引表可能会很大</p>
<p>比如：文件的每个记录平均只占 8B，而每个索引表项占32个字节，那么索引表都要比文件内</p>
<p>容本身大4倍，这样对存储空间的利用率就太低了</p>
<p><strong>索引顺序文件</strong>是索引文件和顺序文件思想的结合</p>
<p>索引顺序文件中，同样会为文件建立一张<strong>索引表</strong>，但不同的是：<strong>并不是每个记录对应一个索引表</strong></p>
<p><strong>项，而是一组记录对应一个索引表项</strong></p>
<p>在本例中，学生记录按照学生姓名的开头字母进行分组。<strong>每个分组就是一个顺序文件，分组内</strong></p>
<p><strong>的记录不需要按关键字排序</strong></p>
<p>用这种策略确实可以让索引表“瘦身”，但是是否会出现不定长记录的顺序文件检索速度慢的问</p>
<p>题呢？</p>
<p>若一个顺序文件有10000个记录，则根据关键字检索文件，只能从头开始顺序查找（这里指</p>
<p>的并不是定长记录、顺序结构的顺序文件），平均须查找 5000 个记录</p>
<p>若采用索引顺序文件结构，可把 10000 个记录分为 √10000 &#x3D; 100 组，每组 100 个记录。</p>
<p>则需要先顺序查找索引表找到分组（共100个分组，因此索引表长度为 100，平均需要查</p>
<p>50 次），找到分组后，再在分组中顺序查找记录（每个分组100 个记录，因此平均需要查</p>
<p>50 次）。可见，采用索引顺序文件结构后，平均查找次数减少为 50 + 50 &#x3D; 100 次</p>
<p>同理，若文件共有 10<sup>6</sup>个记录，则可分为 1000 个分组，每个分组 1000 个记录。根据关键</p>
<p>字检索一个记录</p>
<p>平均需要查找 500 + 500 &#x3D; 1000 次。这个查找次数依然很多，如何解决呢？</p>
<p><strong>多级索引顺序文件</strong></p>
<p>为了进一步提高检索效率，可以为顺序文件建立<strong>多级索引表</strong>。例如，对于一个含 10<sup>6</sup>个记录的</p>
<p>文件，可先为该文件建立一张低级索引表，每 100 个记录为一组，故低级索引表中共有 10000</p>
<p>个表项（即10000个定长记录），再把这 10000 个定长记录分组，每组100个，为其建立顶级</p>
<p>索引表，故顶级索引表中共有 100 个表项</p>
<p><strong>3. 文件目录</strong></p>
<p>所谓<strong>文件目录</strong>就是我们很熟悉的 Windows 操作系统的“文件夹”</p>
<p>采用文件目录结构可以使文件之间的组织结构清晰，易于查找</p>
<p>编程时也可以很方便的用文件路径找到一个文件</p>
<p>&#x2F;&#x2F; 如:</p>
<p>FILE *fp;</p>
<p>fp &#x3D; fopen(“F:\data\myfile.dat”); &#x2F;&#x2F; 用户可以轻松实现“按名存取”</p>
<p><strong>文件目录的实现</strong></p>
<p>当我们双击“照片”后，操作系统会在这个<strong>目录表</strong>中找到关键字“照片”对应的<strong>目录项</strong>（也就是<strong>记</strong></p>
<p><strong>录</strong>），然后从外存中将“照片”目录的信息读入内存，于是，“照片”目录中的内容就可以显示出来了</p>
<p>目录文件中一条一条的<strong>记录</strong>就是一个”<strong>文件控制块（FCB）</strong>“</p>
<p>FCB 实现了文件名和文件之间的映射，使用户（用户程序）可以实现“按名存取”</p>
<p><strong>FCB 的有序集合称为“文件目录”</strong>，<strong>一个FCB就是一个文件目录项</strong></p>
<p>FCB 中包含了文件的基本信息（文件名、物理地址、逻辑结构、物理结构等），存取控制信息</p>
<p>（是否可读&#x2F;可写、禁止访问的用户名单等），使用信息（如文件的建立时间、修改时间等）。</p>
<p>最重要，最基本的还是<strong>文件名</strong>、<strong>文件存放的物理地址</strong></p>
<p><strong>需要对目录进行哪些操作？</strong></p>
<p>搜索：当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项</p>
<p>创建文件：创建一个新文件时，需要在其所属的目录中增加一个目录项</p>
<p>删除文件：当删除一个文件时，需要在目录中删除相应的目录项</p>
<p>显示目录：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性</p>
<p>修改目录：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项（如：文</p>
<p>件重命名）</p>
<p><strong>目录结构</strong></p>
<p><strong>单级目录结构</strong></p>
<p>早期操作系统并不支持多级目录，<strong>整个系统中只建立一张目录表，每个文件占一个目录项</strong></p>
<p>单级目录实现了“按名存取”，但是<strong>不允许文件重名</strong></p>
<p>在创建一个文件时，需要先检查目录表中有没有重名文件，确定不重名后才能允许建立文件，</p>
<p>并将新文件对应的目录项插入目录表中</p>
<p>显然，单级目录结构不适用于多用户操作系统</p>
<p><strong>两级目录结构</strong></p>
<p>早期的多用户操作系统，采用<strong>两级目录结构</strong></p>
<p>分为<strong>主文件目录（MFD，Master File Directory）</strong>和<strong>用户文件目录（UFD，User Flie</strong></p>
<p><strong>Directory）</strong></p>
<p><strong>多级目录结构（树形目录结构）</strong></p>
<p>用户（或用户进程）要访问某个文件时要用文件路径名标识文件，文件路径名是个字符串</p>
<p>各级目录之间用“&#x2F;”隔开。<strong>从根目录出发的路径</strong>称为<strong>绝对路径</strong></p>
<p>例如：自拍.jpg 的绝对路径是 “&#x2F;照片&#x2F;2015-08&#x2F;自拍.jpg”</p>
<p>系统根据绝对路径一层一层地找到下一级目录</p>
<p>1. 刚开始<strong>从外存读入根目录的目录表</strong></p>
<p>2. 找到“照片”目录的存放位置后，从外存读入对应的目录表</p>
<p>3. 再找到“2015-08”目录的存放位置，再从外存读入对应目录表</p>
<p>4. 最后才找到文件“自拍.jpg”的存放位置</p>
<p>整个过程需要3次读磁盘I&#x2F;O操作</p>
<p>很多时候，用户会连续访问同一目录内的多个文件（比如：接连查看“2015-08”目录内的多个照</p>
<p>片文件）</p>
<p>显然，每次都从根目录开始查找，是很低效的，因此可以设置一个“<strong>当前目录</strong>”</p>
<p>例如：此时已经打开了“照片”的目录文件，也就是说，这张目录表已调入内存，那么可以把</p>
<p>它设置为“当前目录”，当用户想要访问某个文件时，可以使用从当前目录出发的“<strong>相对路径</strong>”</p>
<p>在 Linux 中，“ .”表示当前目录，因此如果“照片”是当前目录，则”自拍.jpg”的相对路径为：</p>
<p>“.&#x2F;2015-08&#x2F;自拍.jpg”</p>
<p>从当前路径出发，只需要查询内存中的“照片”目录表，即可知道”2015-08”目录表的</p>
<p>存放位置</p>
<p>从外存调入该目录，即可知道“自拍.jpg”存放的位置了</p>
<p>可见，引入“<strong>当前目录</strong>”和“<strong>相对路径</strong>”后，磁盘I&#x2F;O的次数减少了。这就提升了访问文件的</p>
<p>效率</p>
<p><strong>树形目录结构</strong>可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理</p>
<p>和保护</p>
<p>但是，树形结构不便于实现文件的共享，为此，提出了“<strong>无环图目录结构</strong>”</p>
<p><strong>无环图目录结构</strong></p>
<p><strong>可以用不同的文件名指向同一个文件</strong>，甚至可以指向同一个目录（共享同一目录下的所有内</p>
<p>容）</p>
<p>需要为<strong>每个共享结点设置一个共享计数器</strong>，用于记录此时有多少个地方在共享该结点</p>
<p><strong>索引结点</strong>中设置一个链接计数变量count，用于表示链接到本索引结点上的用户<strong>目录项</strong>数</p>
<p>用户提出删除结点的请求时，只是删除该用户的FCB、并使共享计数器减1，并不会直接删除共</p>
<p>享结点。只有共享计数器减为0时，才删除结点</p>
<p>注意：共享文件不同于复制文件。在共享文件中，由于各用户指向的是同一个文件，因此只要</p>
<p>其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化</p>
<p><strong>索引结点（FCB的改进）</strong></p>
<p><strong>思考有何好处？</strong></p>
<p>假设一个FCB是64B，磁盘块的大小为1KB，则每个盘块中只能存放16个FCB。若一个文件目录</p>
<p>中共有640个目录项，则共需要占用 640 &#x2F; 16 &#x3D; 40 个盘块。因此按照某文件名检索该目录，平</p>
<p>均需要查询320 个目录项，平均需要启动磁盘20次（每次磁盘I&#x2F;O读入一块）</p>
<p>若使用<strong>索引结点机制</strong>，文件名占14B，索引结点指针站2B，则每个盘块可存放64个目录项，那</p>
<p>么按文件名检索目录平均只需要</p>
<p>读入 320 &#x2F; 64 &#x3D; 5 个磁盘块。显然，<strong>这将大大提升文件检索速度</strong></p>
<p>当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，</p>
<p>包括文件在外存中的存放位置，根据“存放位置”即可找到文件</p>
<p>存放<strong>在外存中的索引结点</strong>称为“<strong>磁盘索引结点</strong>”，当<strong>索引结点放入内存</strong>后称为“<strong>内存索引结点</strong>”</p>
<p>相比之下<strong>内存索引结点中需要增加一些信息</strong>，比如：文件是否被修改、此时有几个进程正在访问该</p>
<p>文件等</p>
<p><strong>4. 文件的物理结构</strong></p>
<p><strong>操作系统需要对磁盘块进行哪些管理？</strong></p>
<p><strong>对非空闲磁盘块的管理</strong>（存放了文件数据的磁盘块）</p>
<p>“<strong>文件的物理结构</strong>&#x2F;文件分配方式”要讨论的问题</p>
<p><strong>对空闲磁盘块的管理</strong></p>
<p>“<strong>文件存储空间管理</strong>“要讨论的问题</p>
<p><strong>文件的物理结构</strong>（文件分配方式）</p>
<p>即：文件数据应该怎样存放在外存中？</p>
<p><strong>连续分配</strong></p>
<p><strong>链接分配</strong></p>
<p><strong>隐式链接</strong>、<strong>显示链接</strong></p>
<p><strong>索引分配</strong></p>
<p><strong>文件块、磁盘块</strong></p>
<p>类似于<strong>内存分页</strong>，<strong>磁盘中的存储单元</strong>也会被分为一个个“<strong>块&#x2F;磁盘块&#x2F;物理块</strong>”。很多操作系统中，<strong>磁</strong></p>
<p><strong>盘块的大小与内存块、页面的大小相同</strong></p>
<p><strong>内存与磁盘之间的数据交换</strong>（即读&#x2F;写操作、磁盘I&#x2F;O）都是<strong>以“块”为单位</strong>进行的。即每次读入一</p>
<p>块，或每次写出一块</p>
<p>在内存管理中，进程的逻辑地址空间被分为一个一个页面</p>
<p>同样的，在外存管理中，为了方便对文件数据的管理，<strong>文件的逻辑地址空间也被分为了一个一个的</strong></p>
<p><strong>文件“块”</strong></p>
<p>操作系统为文件分配存储空间都是以块为单位的</p>
<p>若块的大小是1KB，则1MB大小的文件可以被分为1K个块</p>
<p>于是文件的逻辑地址也可以表示为<strong>（逻辑块号，块内地址）</strong>的形式</p>
<p>用户通过逻辑地址来操作自己的文件，<strong>操作系统要负责实现从逻辑地址到物理地址的映射</strong></p>
<p><strong>连续分配</strong></p>
<p><strong>连续分配</strong>方式要求<strong>每个文件在磁盘上占有一组连续的块</strong></p>
<p>用户通过逻辑地址来操作自己的文件，<strong>操作系统如何实现从逻辑地址到物理地址的映射？</strong></p>
<p>（逻辑块号，块内地址）→（物理块号，块内地址），只需转换块号就行，块内地址保持不变</p>
<p><strong>用户</strong>给出要访问的<strong>逻辑块号</strong>，操作系统找到该<strong>文件对应的目录项（FCB）</strong></p>
<p><strong>物理块号 &#x3D; 起始块号 + 逻辑块号</strong></p>
<p>可以直接算出逻辑块号对应的物理块号，因此<strong>连续分配支持顺序访问和直接访问（即随机访</strong></p>
<p><strong>问）</strong></p>
<p>当然，还需要检查用户提供的逻辑块号是否合法（ 逻辑块号 ≥ 长度 就不合法）</p>
<p>读取某个磁盘块时，需要移动磁头。访问的两个磁盘块相隔越远，移动磁头所需时间就越长。</p>
<p>结论：<strong>连续分配的文件在顺序读&#x2F;写时速度最快</strong></p>
<p>若此时文件A要拓展，需要再增加一个磁盘块（总共需要连续的4个磁盘块）。由于采用连续结</p>
<p>构，因此文件A占用的磁盘块必须是连续的。因此只能将文件A全部“迁移”到绿色区域</p>
<p>结论：<strong>物理上采用连续分配的文件不方便拓展</strong></p>
<p>结论：<strong>物理上采用连续分配，存储空间利用率低，会产生难以利用的磁盘碎片，可以用紧凑来</strong></p>
<p><strong>处理碎片，但是需要耗费很大的时间代价</strong></p>
<p><strong>总结</strong>:</p>
<p>优点：支持顺序访问和直接访问（即随机访问），连续分配的文件在顺序访问时速度最快</p>
<p>缺点：不方便文件拓展；存储空间利用率低，会产生磁盘碎片</p>
<p><strong>链接分配</strong></p>
<p><strong>链接分配采取离散分配的方式，可以为文件分配离散的磁盘块</strong>，分为<strong>隐式链接</strong>和<strong>显式链接</strong>两种</p>
<p>考试题目中遇到未指明隐式&#x2F;显式的“链接分配”，<strong>默认指的是隐式链接的链接分配</strong></p>
<p><strong>隐式链接</strong></p>
<p><strong>如何实现文件的逻辑块号到物理块号的转变？</strong></p>
<p><strong>用户</strong>给出要访问的<strong>逻辑块号</strong> i，操作系统找到该<strong>文件对应的目录项（FCB）</strong></p>
<p>从目录项中找到起始块号（即0号块），将0号逻辑块读入内存，由此知道1号逻辑块存放的</p>
<p>物理块号，于是读入1号逻辑块，再找到2号逻辑块的存放位置……以此类推</p>
<p>因此，<strong>读入i号逻辑块，总共需要 i+1 次磁盘I&#x2F;O</strong></p>
<p>结论：<strong>采用链式分配（隐式链接）方式的文件，只支持顺序访问，不支持随机访问，查</strong></p>
<p><strong>找效率低。另外，指向下一个盘块的指针也需要耗费少量的存储空间</strong></p>
<p><strong>是否方便拓展文件？</strong></p>
<p>若此时要拓展文件，则可以随便找一个空闲磁盘块，挂到文件的磁盘块链尾，并修改文件的</p>
<p>FCB</p>
<p>结论：<strong>采用隐式链接的链接分配方式，很方便文件拓展。另外，所有的空闲磁盘块都可</strong></p>
<p><strong>以被利用，不会有碎片问题，外存利用率高</strong></p>
<p><strong>总结</strong>:</p>
<p>优点：很方便文件拓展，不会有碎片问题，外存利用率高</p>
<p>缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费</p>
<p>少量的存储空间</p>
<p><strong>显式链接</strong></p>
<p><strong>把用于链接文件各物理块的指针显式地存放在一张表中</strong>，即 <strong>文件分配表（FAT，File</strong></p>
<p><strong>Allocation Table）</strong></p>
<p>假设某个新创建的文件“aaa”依次存放在磁盘块 2 → 5 → 0 → 1</p>
<p>假设某个新创建的文件“bbb”依次存放在磁盘块 4 → 23 → 3</p>
<p>注意：<strong>一个磁盘仅设置一张FAT</strong>。开机时，将FAT读入内存，并<strong>常驻内存</strong>。 <strong>FAT 的各个表项</strong></p>
<p><strong>在物理上连续存储，且每一个表项长度相同，因此“物理块号”字段可以是隐含的</strong></p>
<p><strong>如何实现文件的逻辑块号到物理块号的转变？</strong></p>
<p><strong>用户</strong>给出要访问的<strong>逻辑块号</strong> i，操作系统找到该<strong>文件对应的目录项（FCB）</strong></p>
<p>从目录项中找到起始块号，若i&gt;0，则查询内存中的<strong>文件分配表FAT</strong>，往后找到 i 号逻辑块对</p>
<p>应的物理块号。<strong>逻辑块号转换成物理块号的过程不需要读磁盘操作</strong></p>
<p>结论：<strong>采用链式分配（显式链接）方式的文件，支持顺序访问，也支持随机访问（想访</strong></p>
<p><strong>问 i 号逻辑块时，并不需要依次访问之前的 0 ~ i - 1号逻辑块），由于块号转换的过程不</strong></p>
<p><strong>需要访问磁盘，因此相比于隐式链接来说，访问速度快很多</strong></p>
<p>显然，<strong>显式链接也不会产生外部碎片，也可以很方便地对文件进行拓展</strong></p>
<p><strong>总结</strong>:</p>
<p>优点：很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式</p>
<p>链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高</p>
<p>缺点：文件分配表的需要占用一定的存储空间</p>
<p><strong>索引分配</strong></p>
<p><strong>索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录</strong></p>
<p><strong>了文件的各个逻辑块对应的物理块</strong></p>
<p>索引表的功能类似于内存管理中的页表 – 建立逻辑页面到物理页之间的映射关系</p>
<p>磁盘中存放索引表的磁盘块称为<strong>索引块</strong>，磁盘中存放文件数据的磁盘块称为<strong>数据块</strong></p>
<p>假设某个新创建的文件“aaa”的数据依次存放在磁盘块 2 → 5 → 13 → 9</p>
<p>7号磁盘块作为“aaa”的索引块，索引块中保存了索引表的内容</p>
<p>注：在显式链接的链式分配方式中，<strong>文件分配表FAT</strong> 是<strong>一个磁盘对应一张</strong>，而索引分配方式</p>
<p>中，<strong>索引表</strong>是<strong>一个文件对应一张</strong></p>
<p><strong>可以用固定的长度表示物理块号</strong>（如：假设磁盘总容量为 1TB &#x3D; 2<sup>40</sup>B，磁盘块大小为 1KB，则</p>
<p>共有 2<sup>30</sup>个磁盘块，则可用 4B 表示磁盘块号），因此，<strong>索引表中的“逻辑块号”可以是隐含的</strong></p>
<p><strong>如何实现文件的逻辑块号到物理块号的转换？</strong></p>
<p><strong>用户</strong>给出要访问的<strong>逻辑块号</strong> i，操作系统找到该<strong>文件对应的目录项（FCB）</strong></p>
<p>从目录项中可知<strong>索引表</strong>存放位置，将索引表从外存读入内存，并查找索引表即可知道 i 号逻辑</p>
<p>块在外存中的存放位置</p>
<p>结论：<strong>索引分配方式可以支持随机访问。文件拓展也很容易实现（只需要给文件分配一个空</strong></p>
<p><strong>闲块，并增加一个索引表项即可）但是索引表需要占用一定的存储空间</strong></p>
<p>若每个磁盘块1KB，一个索引表项4B，则一个磁盘块只能存放 256 个索引项。如果一个文件的大</p>
<p>小超过了256块，那么<strong>一个磁盘块</strong>是<strong>装不下文件的整张索引表</strong>的，<strong>如何解决这个问题？</strong></p>
<p><strong>链接方案</strong></p>
<p>如果索引表太大，一个索引块装不下，那么可以<strong>将多个索引块链接起来存放</strong></p>
<p>假设磁盘块大小为1KB，一个索引表项占4B，则一个磁盘块只能存放256个索引项</p>
<p>若一个文件大小为 256 * 256KB &#x3D; 65,536 KB &#x3D; 64MB，该文件共有 256 * 256 个块，也就</p>
<p>对应 256 * 256 个索引项，也就需要 256 个索引块来存储，这些索引块用链接方案连起来</p>
<p>若想要访问文件的最后一个逻辑块，就必须找到最后一个索引块（第256个索引块），而各</p>
<p>个索引块之间是用指针链接起来的，因此必须先顺序地读入前 255 个索引块</p>
<p>缺点：若文件很大，索引表很长，就需要将很多个索引块链接起来。想要找到 i 号索引</p>
<p>块，必须先依次读入 0 ~ i-1号索引块，这就导致磁盘I&#x2F;O次数过多，查找效率低下</p>
<p>这显然是很低效的，如何解决呢？</p>
<p><strong>多层索引</strong></p>
<p><strong>建立多层索引（原理类似于多级页表）</strong>。使第一层索引块指向第二层的索引块。还可根据文</p>
<p>件大小的要求再建立第三层、第四层索引块…</p>
<p>假设磁盘块大小为1KB，一个索引表项占4B，则一个磁盘块只能存放256个索引项</p>
<p><strong>若某文件采用两层索引</strong>，则该文件的最大长度可以到256 * 256 * 1KB &#x3D; 65,536 KB &#x3D; 64MB</p>
<p>可根据逻辑块号算出应该查找索引表中的哪个表项</p>
<p>如：要访问 1026 号逻辑块，则1026 &#x2F; 256 &#x3D; 4，1026 % 256 &#x3D; 2</p>
<p>因此可以先将一级索引表调入内存，查询 4 号表项，将其对应的二级索引表调入内存，</p>
<p>再查询二级索引表的2号表项即可知道 1026 号逻辑块存放的磁盘块号了。访问目标数据</p>
<p>块，需要3次磁盘I&#x2F;O</p>
<p><strong>若采用三层索引</strong>，则文件的最大长度为256 * 256 * 256 * 1KB &#x3D; 16GB</p>
<p>类似的，访问目标数据块，需要4次磁盘I&#x2F;O</p>
<p><strong>采用 K 层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要 K + 1 次读磁盘操</strong></p>
<p><strong>作</strong></p>
<p>缺点：即使是小文件，访问一个数据块依然需要K + 1次读磁盘</p>
<p><strong>混合索引</strong></p>
<p><strong>多种索引分配方式的结合</strong></p>
<p>例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一</p>
<p>级间接索引（指向单层索引表）、还包含两级间接索引（指向两层索引表）</p>
<p>优点：对于小文件来说，访问一个数据块所需的读磁盘次数更少</p>
<p><strong>重要考点</strong>:</p>
<p>① 要会根据多层索引、混合索引的结构计算出文件的最大长度</p>
<p>Key：各级索引表最大不能超过一个块</p>
<p>② 要能自己分析访问某个数据块所需要的读磁盘次数</p>
<p>Key：FCB中会存有指向顶级索引块的指针，因此可以根据FCB读入顶级索引块。每次读入</p>
<p>下一级的索引块都需要一次读磁盘操作。另外，要注意题目条件 – 顶级索引块是否已调入</p>
<p>内存</p>
<p><strong>5. 逻辑结构VS物理结构</strong></p>
<p><strong>文件的逻辑结构 vs 文件的物理结构</strong></p>
<p>逻辑结构中的链式存储和物理结构中的链接分配</p>
<p>文件内部各条记录链式存储：由创建文件的用户自己设计的</p>
<p>文件整体用链接分配：由操作系统决定</p>
<p>逻辑结构中的索引文件和物理结构中的索引分配</p>
<p>索引文件的索引表：</p>
<p>用户自己建立的，映射：关键字 → 记录存放的逻辑地址</p>
<p>索引分配的索引表：</p>
<p>操作系统建立的，映射：逻辑块号 → 物理块号</p>
<p><strong>6. 文件存储空间管理</strong></p>
<p>学习时注意从三个方面进行理解:</p>
<p>1. 用什么方式记录、组织空闲块？</p>
<p>2. 如何分配磁盘块</p>
<p>3. 如何回收磁盘块</p>
<p><strong>存储空间的划分与初始化</strong></p>
<p>安装Windows操作系统的时候，一个必经步骤是为<strong>磁盘分区</strong>（C:盘、D:盘、E:盘）</p>
<p>存储空间的划分：将物理磁盘划分为一个个<strong>文件卷（逻辑卷、逻辑盘）</strong></p>
<p>存储空间的初始化：将各个<strong>文件卷</strong>划分为<strong>目录区</strong>、<strong>文件区</strong></p>
<p><strong>目录区</strong>：主要存放文件目录信息（FCB）、用于磁盘存储空间管理的信息</p>
<p><strong>文件区</strong>：文件区用于存放文件数据</p>
<p><strong>空闲表法</strong></p>
<p>适用于”<strong>连续分配方式</strong>“</p>
<p><strong>如何分配磁盘块</strong>:</p>
<p>与内存管理中的动态分区分配很类似，为一个文件<strong>分配连续的存储空间</strong>。同样<strong>可采用首次适</strong></p>
<p><strong>应、最佳适应、最坏适应等算法来决定要为文件分配哪个区间</strong></p>
<p><strong>如何回收磁盘块</strong>:</p>
<p>与内存管理中的动态分区分配很类似，当回收某个存储区时需要有四种情况:</p>
<p>回收区的前后都没有相邻空闲区</p>
<p>回收区的前后都是空闲区</p>
<p>回收区前面是空闲区</p>
<p>回收区后面是空闲区</p>
<p>总之，<strong>回收时需要注意表项的合并问题</strong></p>
<p><strong>空闲链表法</strong></p>
<p><strong>空闲盘块链</strong>: 以盘块为单位组成一条空闲链</p>
<p>操作系统保存着<strong>链头、链尾指针</strong></p>
<p><strong>如何分配磁盘块</strong>:</p>
<p>若某文件申请 k 个盘块，则从链头开始依次摘下 k 个盘块分配，并修改空闲链的链头指针</p>
<p><strong>如何回收磁盘块</strong>:</p>
<p>回收的盘块依次挂到链尾，并修改空闲链的链尾指针</p>
<p>适用于<strong>离散分配</strong>的物理结构。为文件分配多个盘块时可能要重复多次操作</p>
<p><strong>空闲盘区链</strong>: 以盘区为单位组成一条空闲链</p>
<p>操作系统保存着<strong>链头、链尾指针</strong></p>
<p><strong>如何分配磁盘块</strong>:</p>
<p>若某文件申请 k 个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，按照算</p>
<p>法规则找到一个大小符合要求的空闲盘区，分配给文件。若没有合适的连续空闲块，也可以</p>
<p>将不同盘区的盘块同时分配给一个文件， 注意分配后可能要修改相应的链指针、盘区大小</p>
<p>等数据</p>
<p><strong>如何回收磁盘块</strong>:</p>
<p>若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空</p>
<p>闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾</p>
<p><strong>连续分配</strong>、<strong>离散分配</strong>都适用，为一个文件分配多个盘块时效率更高</p>
<p><strong>位示图法</strong></p>
<p><strong>每个二进制位对应一个盘块</strong></p>
<p>在本例中，“0” 代表盘块空闲，“1”代表盘块已分配</p>
<p><strong>位示图一般用连续的“字”来表示</strong></p>
<p>如本例中一个字的字长是16位</p>
<p><strong>字中的每一位对应一个盘块</strong>，因此可以用<strong>（字号，位号）</strong>对应一个<strong>盘块号</strong>，当然有的题目中也</p>
<p>描述为<strong>（行号，列号）</strong></p>
<p><strong>重要</strong>：要能自已推出<strong>盘块号</strong>与<strong>（字号，位号）</strong>相互转换的公式</p>
<p>注意题目条件：<strong>盘块号</strong>、<strong>字号</strong>、<strong>位号</strong>到底是从0开始还是从1开始</p>
<p>如本例中盘块号、字号、位号从0开始，若n表示字长，则</p>
<p>（字号，位号）&#x3D;（i，j）的二进制位对应的盘块号 b &#x3D; n * i + j</p>
<p>b号盘块对应的字号 i &#x3D; b &#x2F; n，位号 j &#x3D; b % n</p>
<p><strong>如何分配磁盘块</strong>:</p>
<p>若文件需要 k 个块</p>
<p>1. 顺序扫描位示图，找到K个相邻或不相邻的“0”</p>
<p>2. 根据字号、位号算出对应的盘块号，将相应盘块分配给文件</p>
<p>3. 将相应位设置为“1”</p>
<p><strong>如何回收磁盘块</strong>:</p>
<p>1. 根据回收的盘块号计算出对应的字号、位号</p>
<p>2. 将相应二进制位设为“0</p>
<p><strong>连续分配</strong>、<strong>离散分配</strong>都适用</p>
<p><strong>成组链接法</strong></p>
<p><strong>空闲表法、空闲链表法不适用于大型文件系统</strong>，因为空闲表或空闲链表可能过大</p>
<p>UNIX系统中采用了<strong>成组链接法</strong>对磁盘空闲块进行管理</p>
<p><strong>文件卷的目录区</strong>中专门用一个磁盘块作为“<strong>超级块</strong>”，当系统启动时需要<strong>将超级块读入内存</strong>，并且要</p>
<p>保证内存与外存中的“超级块”数据一致</p>
<p>注3: <strong>每个分组的盘块数量是存在上限的</strong></p>
<p>注4: <strong>最后一个分组的盘块数是比其他分组的盘块数少的</strong></p>
<p><strong>如何分配磁盘块</strong>:</p>
<p>若文件需要 1 个空闲块</p>
<p>1. 检查第一个分组的块数是否足够，1 &lt; 100，是足够的</p>
<p>2. 分配第一个分组中的 1 个空闲块，并修改空闲盘块数</p>
<p>若文件需要 100 个空闲块</p>
<p>1. 检查第一个分组的块数是否足够，100 &#x3D; 100，是足够的</p>
<p>2. 分配第一个分组中的100个空闲块。但是由于300号块内存放了再下一组的信息，因此300</p>
<p>号块的数据需要复制到超级块中</p>
<p><strong>如何回收磁盘块</strong>:</p>
<p>假设每个分组最多为100个空闲块，此时第一个分组已有99个块，还要再回收一块</p>
<p>可以将空闲块的信息放到第一个分组当中，并修改空闲盘块数</p>
<p>假设每个分组最多为100个空闲块，此时第一个分组已有100个块，还要再回收一块</p>
<p>需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一</p>
<p>个分组</p>
<p><strong>7. 文件的基本操作</strong></p>
<p><strong>创建文件</strong></p>
<p>可以“<strong>创建文件</strong>”（点击新建后，图形化交互进程在背后调用了“<strong>create 系统调用</strong>”）</p>
<p>进行 create 系统调用 时，需要提供的几个主要参数:</p>
<p>1. 所需的外存空间大小（如：一个盘块，即1KB）</p>
<p>2. 文件存放路径（“D:&#x2F;Demo”）</p>
<p>3. 文件名（这个地方默认为“新建文本文档.txt”）</p>
<p>操作系统在处理 create 系统调用 时，主要做了两件事:</p>
<p>1. <strong>在外存中找到文件所需的空间</strong>（结合上小节学习的空闲链表法、位示图、成组链接法等管理</p>
<p>策略，找到空闲空间）</p>
<p>2. 根据文件存放路径的信息找到该目录对应的目录文件（此处就是D:&#x2F;Demo目录），<strong>在目录中</strong></p>
<p><strong>创建该文件对应的目录项</strong>。目录项中包含了文件名、文件在外存中的存放位置等信息</p>
<p><strong>删除文件</strong></p>
<p>可以<strong>“删除文件</strong>”（点击删除后，图形化交互进程在背后调用了”<strong>delete 系统调用</strong>“，将文件数据从</p>
<p>外存中删除）</p>
<p>进行 delete 系统调用 时，需要提供的几个主要参数:</p>
<p>1. 文件存放路径（“D:&#x2F;Demo”）</p>
<p>2. 文件名（“test.txt” ）</p>
<p>操作系统在处理 delete 系统调用 时，主要做了几件事:</p>
<p>1. 根据文件存放路径找到相应的目录文件，<strong>从目录中找到文件名对应的目录项</strong></p>
<p>2. 根据该目录项记录的文件在外存的存放位置、文件大小等信息，<strong>回收文件占用的磁盘块</strong>（回</p>
<p>收磁盘块时，根据空闲表法、空闲链表法、位图法等管理策略的不同，需要做不同的处理）</p>
<p>3. <strong>从目录表中删除文件对应的目录项</strong></p>
<p><strong>打开文件</strong></p>
<p>读&#x2F;写文件之前，需要通过操作系统提供的”<strong>open 系统调用</strong>“来“<strong>打开文件</strong>”</p>
<p>在很多操作系统中，在对文件进行操作之前，要求用户先使用 open 系统调用 “打开文件”，需要提</p>
<p>供的几个主要参数:</p>
<p>1. 文件存放路径（“D:&#x2F;Demo”）</p>
<p>2. 文件名（“test.txt”）</p>
<p>3. 要对文件的操作类型（如：r只读；rw读写等）</p>
<p>操作系统在处理 open 系统调用 时，主要做了几件事:</p>
<p>1. 根据文件存放路径找到相应的目录文件，从目录中<strong>找到文件名对应的的目录项</strong>，并检查该用</p>
<p>户是否有指定的操作权限</p>
<p>2. <strong>将目录项复制到内存中的“打开文件表”中</strong>。并将对应表目的编号返回给用户。之后<strong>用户使用</strong></p>
<p><strong>打开文件表的编号(即</strong> 文件描述符 <strong>)来指明要操作的文件</strong></p>
<p><strong>关闭文件</strong></p>
<p>读&#x2F;写文件结束之后，需要通过操作系统提供的”<strong>close 系统调用</strong>“来“<strong>关闭文件</strong>”</p>
<p>进程使用完文件后，要“关闭文件”</p>
<p>操作系统在处理 close 系统调用 时，主要做了几件事:</p>
<p>1. 将进程的打开文件表相应表项删除</p>
<p>2. 回收分配给该文件的内存空间等资源</p>
<p>3. 系统打开文件表的打开计数器count减1，若count &#x3D; 0，则删除对应表项</p>
<p><strong>读文件</strong></p>
<p>可以“<strong>读文件</strong>”，将文件数据读入内存，才能让CPU处理（双击后，“记事本”应用程序通过操作系统</p>
<p>提供的“<strong>read 系统调用</strong>”，将文件数据从外存读入内存，并显示在屏幕上）</p>
<p>进程使用 read 系统调用 完成写操作:</p>
<p>1. 需要指明是哪个文件（在支持“打开文件”操作的系统中，<strong>只需要提供文件在打开文件表中</strong></p>
<p><strong>的索引号(又称</strong> 文件描述符 <strong>)即可</strong>）</p>
<p>2. 还需要指明要读入多少数据（如：读入1KB）、指明读入的数据要放在内存中的什么位置</p>
<p>3. 操作系统在处理 read 系统调用 时，会从读指针指向的外存中，将指定大小的数据读入用</p>
<p>户指定的内存区域中</p>
<p><strong>写文件</strong></p>
<p>可以“<strong>写文件</strong>”，将更改过的文件数据写回外存（在“记事本”应用程序中编辑文件内容，点击“保存”</p>
<p>后，“记事本”应用程序通过操作系统提供的“<strong>write 系统调用</strong>”，将文件数据从内存写回外存）</p>
<p>进程使用 write 系统调用 完成写操作:</p>
<p>1. 需要指明是哪个文件（在支持“打开文件”操作的系统中，<strong>只需要提供文件在打开文件表中的</strong></p>
<p><strong>索引号(又称</strong> 文件描述符 <strong>)即可</strong>）</p>
<p>2. 还需要指明要写出多少数据（如：写出1KB）、写回外存的数据放在内存中的什么位置</p>
<p>3. 操作系统在处理write系统调用时，会从用户指定的内存区域中，将指定大小的数据写回写指</p>
<p>针指向的外存</p>
<p><strong>8. 文件共享</strong></p>
<p><strong>操作系统为用户提供文件共享功能，可以让多个用户共享地使用同一个文件</strong></p>
<p>注意：<strong>多个用户共享同一个文件，意味着系统中只有“一份”文件数据，并且只要某个用户修改了该</strong></p>
<p><strong>文件的数据，其他用户也可以看到文件数据的变化</strong>。如果是多个用户都”复制”了同一个文件，那么</p>
<p>系统中会有“好几份”文件数据。其中一个用户修改了自己的那份文件数据，对其他用户的文件数据</p>
<p>并没有影响</p>
<p><strong>基于索引结点的共享方式（硬链接）</strong></p>
<p>知识回顾：<strong>索引结点</strong>，是一种文件目录瘦身策略。由于检索文件时只需用到文件名，因此可以将除</p>
<p>了文件名之外的其他信息放到索引结点中。这样目录项就只需要包含文件名、索引结点指针</p>
<p><strong>索引结点</strong>中设置一个链接计数变量count，<strong>用于表示链接到本索引结点上的用户目录项数</strong></p>
<p>若count&#x3D;2，说明此时有两个用户目录项链接到该索引结点上，或者说是有两个用户在共享此文件</p>
<p>若某个用户决定“删除”该文件，则只是要把用户目录中与该文件对应的目录项删除，且索引结点的</p>
<p>count值减1</p>
<p>若count&gt;0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空</p>
<p>当count&#x3D;0时系统负责删除文件</p>
<p><strong>基于符号链的共享方式（软链接）</strong></p>
<p>当User3访问“ccc”时，操作系统判断文件“ccc”属于<strong>Link类型文件</strong>，于是会<strong>根据其中记录的路径层</strong></p>
<p><strong>层查找目录</strong>，最终找到User1的目录表中的“aaa” 表项，于是就找到了文件1的索引结点</p>
<p><strong>即使软链接指向的共享文件已被删除，Link型文件依然存在，只是通过Link型文件中的路径去查</strong></p>
<p><strong>找共享文件会失败</strong>（找不到目录项）</p>
<p>由于用软链接的方式访问共享文件时要查询多级目录，会有多次磁盘I&#x2F;O，因此<strong>用软链接访问共享</strong></p>
<p><strong>文件的速度要比硬链接更慢</strong></p>
<p><strong>9. 文件保护</strong></p>
<p>保护文件数据的安全</p>
<p><strong>口令保护</strong></p>
<p>为文件设置一个“口令”（如: abc112233） ，用户请求访问该文件时必须提供“口令”</p>
<p>口令一般存放在文件对应的FCB或索引结点中。用户访问文件前需要先输入“口令”，操作系统会</p>
<p>将用户提供的口令与FCB中存储的口令进行对比，如果正确，则允许该用户访问文件</p>
<p>优点：保存口令的空间开销不多，验证口令的时间开销也很小</p>
<p>缺点：正确的“口令”存放在系统内部，不够安全</p>
<p><strong>加密保护</strong></p>
<p>使用某个”密码”对文件进行加密，在访问文件时需要提供正确的”密码“才能对文件进行正确的解密</p>
<p>Eg：一个最简单的加密算法 – 异或加密</p>
<p>优点：保密性强，不需要在系统中存储“密码”</p>
<p>缺点：编码&#x2F;译码，或者说加密&#x2F;解密需要花费一定时间</p>
<p><strong>访问控制</strong></p>
<p>在每个文件的FCB（或索引结点）中增加一个<strong>访问控制表（Access-Control List，ACL）</strong>，该表</p>
<p>中记录了各个用户可以对该文件执行哪些操作</p>
<p><strong>精简的访问列表</strong>：以“<strong>组</strong>”为单位，<strong>标记各“组”用户可以对文件执行哪些操作</strong>，系统需要管理分组的</p>
<p>信息</p>
<p>如：分为系统管理员、文件主、文件主的伙伴、其他用户几个分组</p>
<p>当某用户想要访问文件时，系统会检查该用户所属的分组是否有相应的访问权限</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" class="category-chain-item">计算机基础</a>
  
  
    <span>></span>
    
  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="category-chain-item">操作系统</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="print-no-link">#操作系统</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>4.1 文件系统基础</div>
      <div>http://binbo-zappy.github.io/2024/11/19/操作系统/4-1-文件系统基础/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Binbo</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年11月19日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-2-%E7%9B%AE%E5%BD%95/" title="4.2 日录">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">4.2 日录</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="3.2 虚拟内存管理">
                        <span class="hidden-mobile">3.2 虚拟内存管理</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
