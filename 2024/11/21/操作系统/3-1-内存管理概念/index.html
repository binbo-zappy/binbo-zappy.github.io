

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Binbo">
  <meta name="keywords" content="">
  
    <meta name="description" content="3.1 内存管理1. 内存的基础知识 1.1 什么是内存? 有何作用? 内存可存放数据, 程序执行前需要先放到内存中才能被CPU处理 – 缓和CPU与硬盘之间的速度矛盾  在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。那么，如何区分各个程序的数据是放在什么地方的呢?  方案：给内存的存储单元编地址 内存中也有一个一个的“小房间”，每个小房间就是一个“存">
<meta property="og:type" content="article">
<meta property="og:title" content="第三章 内存管理-3.1 内存管理概念">
<meta property="og:url" content="http://binbo-zappy.github.io/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/index.html">
<meta property="og:site_name" content="Binbo">
<meta property="og:description" content="3.1 内存管理1. 内存的基础知识 1.1 什么是内存? 有何作用? 内存可存放数据, 程序执行前需要先放到内存中才能被CPU处理 – 缓和CPU与硬盘之间的速度矛盾  在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。那么，如何区分各个程序的数据是放在什么地方的呢?  方案：给内存的存储单元编地址 内存中也有一个一个的“小房间”，每个小房间就是一个“存">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://binbo-zappy.github.io/imgs/OS.png">
<meta property="article:published_time" content="2024-11-21T01:47:02.000Z">
<meta property="article:modified_time" content="2024-11-21T10:23:14.773Z">
<meta property="article:author" content="Binbo">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://binbo-zappy.github.io/imgs/OS.png">
  
  
  
  <title>第三章 内存管理-3.1 内存管理概念 - Binbo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"binbo-zappy.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Binbo&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="第三章 内存管理-3.1 内存管理概念"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-11-21 09:47" pubdate>
          2024年11月21日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          11k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          93 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">第三章 内存管理-3.1 内存管理概念</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="3-1-内存管理"><a href="#3-1-内存管理" class="headerlink" title="3.1 内存管理"></a><strong>3.1 内存管理</strong></h1><h2 id="1-内存的基础知识"><a href="#1-内存的基础知识" class="headerlink" title="1. 内存的基础知识"></a><strong>1. 内存的基础知识</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121102355539.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="1-1-什么是内存-有何作用"><a href="#1-1-什么是内存-有何作用" class="headerlink" title="1.1 什么是内存? 有何作用?"></a>1.1 <strong>什么是内存? 有何作用?</strong></h3><ul>
<li><p>内存可存放数据, 程序执行前<strong>需要先放到内存中才能被CPU处理</strong> – 缓和CPU与硬盘之间的速度矛盾</p>
</li>
<li><p>在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。那么，<strong>如何区分各个程序的数据是放在什么地方的呢?</strong></p>
<ul>
<li>方案：<strong>给内存的存储单元编地址</strong></li>
<li>内存中也有一个一个的“小房间”，每个小房间就是一个“<strong>存储单元</strong>“</li>
<li><strong>内存地址</strong>从0开始，每个地址对应一个存储单元</li>
<li>如果计算机“<strong>按字节编址</strong>“，则每个存储单元大小为 1字节，即 1B，即 8个二进制位</li>
<li>如果字长为16位的计算机“<strong>按字编址</strong>”，则每个存储单元大小为 1个字，每个字的大小为 16 个二进制位</li>
</ul>
</li>
<li><p>补充知识:</p>
<ul>
<li>2<sup>10</sup> &#x3D; 1K（千）</li>
<li>2<sup>20</sup> &#x3D; 1M（兆，百万）</li>
<li>2<sup>30</sup> &#x3D; 1G（十亿，千兆）</li>
<li>注: 有的题目会告诉我们内存的大小，让我们确定地址长度应该是多少（即要多少个二进制位才能表示相应数目的存储单元）<ul>
<li>Q: 一台手机&#x2F;电脑 有 4GB 内存，是什么意思？</li>
<li>A: 是指该内存中可以存放 4 * 2<sup>30</sup>个字节。如果是按字节编址的话，也就是有 4 * 2<sup>30</sup> &#x3D; 2<sup>32</sup>个“小房间”，这么多“小房间”，需要 2<sup>32</sup>个地址才能一一标识，所以地址需要用 32 个二进制位来表示（0~2<sup>32</sup> -1）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-2-指令的工作原理"><a href="#1-2-指令的工作原理" class="headerlink" title="1.2 指令的工作原理"></a>1.2 <strong>指令的工作原理</strong></h3><ul>
<li><p>指令: 操作码 + 若干参数(可能包含地址参数)</p>
</li>
<li><p>指令的工作基于“地址”。每个地址对应一个数据的存储单元 </p>
</li>
<li><p>我们写的代码要翻译成CPU能识别的指令。这些指令会告诉CPU应该去内存的哪个地址读&#x2F;写数据，这个数据应该做什么样的处理</p>
</li>
</ul>
<h3 id="1-3-逻辑地址-vs-物理地址"><a href="#1-3-逻辑地址-vs-物理地址" class="headerlink" title="1.3 逻辑地址 vs 物理地址"></a>1.3 <strong>逻辑地址 vs 物理地址</strong></h3><ul>
<li><p><strong>物理地址（绝对地址）</strong>即内存中的实际地址</p>
</li>
<li><p>程序经过编译、链接后生成的指令中指明的是<strong>逻辑地址（相对地址）</strong></p>
<ul>
<li>即：相对于进程的起始地址而言的地址</li>
</ul>
</li>
</ul>
<h3 id="1-4-从写程序到程序运行"><a href="#1-4-从写程序到程序运行" class="headerlink" title="1.4 从写程序到程序运行"></a>1.4 <strong>从写程序到程序运行</strong></h3><ul>
<li><p><strong>编译</strong>：由编译程序将用户源代码编译成<strong>若干个目标模块</strong>（编译就是<strong>把高级语言翻译为机器语言</strong>）</p>
</li>
<li><p><strong>链接</strong>：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的<strong>装入模块</strong></p>
</li>
<li><p><strong>装入</strong>（装载）：由装入程序<strong>将装入模块装入内存</strong>运行</p>
</li>
</ul>
<h3 id="1-5-链接的三种方式"><a href="#1-5-链接的三种方式" class="headerlink" title="1.5 链接的三种方式"></a>1.5 <strong>链接的三种方式</strong></h3><ul>
<li><strong>静态链接</strong><ul>
<li><strong>在程序运行之前</strong>，先将各目标模块及它们所需的库函数连接成一个<strong>完整的可执行文件（装入模块）</strong>，之后不再拆开</li>
</ul>
</li>
<li><strong>装入时动态链接</strong><ul>
<li>将各目标模块装入内存时，<strong>边装入边链接</strong>的链接方式</li>
</ul>
</li>
<li><strong>运行时动态链接</strong><ul>
<li><strong>在程序执行中需要该目标模块时，才对它进行链接</strong></li>
<li>其优点是便于修改和更新，便于实现对目标模块的共享</li>
</ul>
</li>
</ul>
<h3 id="1-6-装入的三种方式"><a href="#1-6-装入的三种方式" class="headerlink" title="1.6 装入的三种方式"></a>1.6 <strong>装入的三种方式</strong></h3><ul>
<li><p><strong>绝对装入</strong></p>
<ul>
<li>在<strong>编译</strong>时，如果知道程序将放到内存中的哪个位置，编译程序<strong>将产生绝对地址</strong>的目标代码，装入程序按照装入模块中的地址，将程序和数据装入内存</li>
<li>绝对装入只适用于<strong>单道程序环境</strong></li>
<li>程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址</li>
</ul>
</li>
<li><p><strong>静态重定位(可重定位装入)</strong></p>
<ul>
<li>编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。<strong>装入</strong>时对地址进行“重定位”，<strong>将逻辑地址变换为物理地址</strong>（地址变换是在装入时一次完成的）</li>
<li><strong>静态重定位</strong>的特点是在一个<strong>作业装入内存时，必须分配其要求的全部内存空间</strong>，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。</li>
</ul>
</li>
<li><p><strong>动态重定位(动态运行时转入)</strong></p>
<ul>
<li>编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把<strong>地址转换推迟到程序真正要执行时才进行</strong>。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个<strong>重定位寄存器</strong>的支持 </li>
<li>重定位寄存器：存放装入模块存放的起始位置</li>
</ul>
</li>
<li><p>采用<strong>动态重定位</strong>时<strong>允许程序在内存中发生移动</strong></p>
<ul>
<li>可将程序分配到不连续的存储区中</li>
<li>在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存</li>
<li>便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间</li>
</ul>
</li>
</ul>
<h2 id="2-内存管理的概念"><a href="#2-内存管理的概念" class="headerlink" title="2. 内存管理的概念"></a><strong>2. 内存管理的概念</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121103658059.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="2-1-内存管理"><a href="#2-1-内存管理" class="headerlink" title="2.1 内存管理"></a>2.1 <strong>内存管理</strong></h3><ul>
<li>操作系统作为系统资源的管理者，当然也需要对内存进行管理，要管些什么呢？<ul>
<li>操作系统负责<strong>内存空间的分配与回收</strong></li>
<li>操作系统需要提供某种技术从逻辑上<strong>对内存空间进行扩充</strong></li>
<li>操作系统需要提供<strong>地址转换功能</strong>，负责程序的逻辑地址与物理地址的转换</li>
<li>操作系统需要提供<strong>内存保护</strong>功能。保证各进程在各自存储空间内运行，互不干扰</li>
</ul>
</li>
</ul>
<h3 id="2-2-内存空间的分配与回收"><a href="#2-2-内存空间的分配与回收" class="headerlink" title="2.2 内存空间的分配与回收"></a>2.2 <strong>内存空间的分配与回收</strong></h3><ul>
<li><p>操作系统要怎么记录哪些内存区域已经被分配出去了，哪些又还空闲？</p>
</li>
<li><p>很多位置都可以放，那应该放在哪里？</p>
</li>
<li><p>当进程运行结束之后，如何将进程占用的内存空间回收？</p>
</li>
<li><p><strong>分配方式</strong>:</p>
<ul>
<li><strong>连续分配管理方式</strong><ul>
<li><strong>连续分配</strong>：<strong>指为用户进程分配的必须是一个连续的内存空间</strong></li>
<li><strong>单一连续分配</strong>、<strong>固定分区分配</strong>、<strong>动态分区分配</strong></li>
</ul>
</li>
<li><strong>非连续分配管理方式</strong><ul>
<li><strong>非连续分配</strong>：<strong>指为用户进程分配的可以是一些分散的内存空间</strong></li>
<li><strong>基本分页存储管理</strong>、<strong>基本分段存储管理</strong>、<strong>段页式存储管理</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-内存空间的扩充"><a href="#2-3-内存空间的扩充" class="headerlink" title="2.3 内存空间的扩充"></a>2.3 <strong>内存空间的扩充</strong></h3><ul>
<li><p>实现虚拟性</p>
</li>
<li><p>实现内存空间扩充的相关技术: <strong>覆盖技术</strong>、<strong>交换技术</strong>、<strong>虚拟存储技术</strong></p>
</li>
</ul>
<h3 id="2-4-地址转化"><a href="#2-4-地址转化" class="headerlink" title="2.4 地址转化"></a>2.4 <strong>地址转化</strong></h3><ul>
<li><p>为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而<strong>逻辑地址到物理地址的转换</strong>（这个过程称为<strong>地址重定位</strong>）应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况</p>
</li>
<li><p>三种装入方式:</p>
<ul>
<li><strong>绝对装入</strong>: 单道程序阶段，此时还没产生操作系统</li>
<li><strong>可重定位装入(静态重定位)</strong>: 用于早期的多道批处理操作系统</li>
<li><strong>动态运行时转入(动态重定位)</strong>: 现代操作系统</li>
</ul>
</li>
</ul>
<h3 id="2-5-内存保护"><a href="#2-5-内存保护" class="headerlink" title="2.5 内存保护"></a>2.5 <strong>内存保护</strong></h3><ul>
<li>内存保护可采取两种方法：<ul>
<li>方法一：在CPU中设置一对<strong>上、下限寄存器</strong>，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界<ul>
<li>假设进程1的逻辑地址空间为 0<del>179；实际物理地址空间为 100</del>279</li>
<li>则上限寄存器存放100, 下限寄存器存放279</li>
</ul>
</li>
<li>方法二：采用<strong>重定位寄存器</strong>（又称<strong>基址寄存器</strong>）和<strong>界地址寄存器</strong>（又称<strong>限长寄存器</strong>）进行越界检查。<strong>重定位寄存器中存放的是进程的起始物理地址</strong>。<strong>界地址寄存器中存放的是进程的最大逻辑地址</strong><ul>
<li>假设进程1的逻辑地址空间为 0<del>179；实际物理地址空间为 100</del>279</li>
<li>则重定位寄存器存放100, 界地址寄存器存放179</li>
<li>CPU先通过界地址寄存器判断指令有没有越界, 没有的话再通过重定位寄存器计算物理地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-覆盖与交换"><a href="#3-覆盖与交换" class="headerlink" title="3. 覆盖与交换"></a><strong>3. 覆盖与交换</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121104512608.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="3-1-覆盖技术"><a href="#3-1-覆盖技术" class="headerlink" title="3.1 覆盖技术"></a>3.1 <strong>覆盖技术</strong></h3><ul>
<li><p>早期的计算机内存很小，比如 IBM 推出的第一台PC机最大只支持 1MB 大小的内存。因此经常会出现内存大小不够的情况。后来人们引入了<strong>覆盖技术</strong>，用来解决“程序大小超过物理内存总和”的问题</p>
</li>
<li><p>覆盖技术的思想:</p>
<ul>
<li><strong>将程序分为多个段</strong>（多个模块），常用的段常驻内存，不常用的段在需要时调入内存</li>
<li>内存中分为一个“<strong>固定区</strong>”和若干个“<strong>覆盖区</strong>”</li>
<li>需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束）</li>
<li>不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存</li>
<li>程序按照自身逻辑结构，让那些不可能同时被访问的程序段共享同一个覆盖区</li>
</ul>
</li>
<li><p>缺点:</p>
<ul>
<li>必须由程序员声明覆盖结构，操作系统完成自动覆盖。对用户不透明，增加了用户编程负担</li>
<li>覆盖技术<strong>只用于早期的操作系统中</strong>，现在已成为历史</li>
</ul>
</li>
</ul>
<h3 id="3-2-交换-对换-技术"><a href="#3-2-交换-对换-技术" class="headerlink" title="3.2 交换(对换)技术"></a>3.2 <strong>交换(对换)技术</strong></h3><ul>
<li><p>内存空间紧张时，系统将<strong>内存</strong>中某些<strong>进程</strong>暂时<strong>换出外存</strong>，把<strong>外存</strong>中某些已具备运行条件的<strong>进程换入内存</strong>（进程在内存与磁盘间动态调度）</p>
</li>
<li><p><strong>中级调度（内存调度）</strong>，就是要决定将哪个处于挂起状态的进程重新调入内存</p>
</li>
<li><p><strong>思考</strong>:</p>
<ul>
<li>应该在外存（磁盘）的什么位置保存被换出的进程？<ul>
<li>具有对换功能的操作系统中，通常把<strong>磁盘空间</strong>分为<strong>文件区</strong>和<strong>对换区</strong>两部分</li>
<li><strong>文件区</strong>主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用<strong>离散分配方式</strong></li>
<li><strong>对换区</strong>空间只占磁盘空间的小部分，<strong>被换出的进程数据就存放在对换区</strong>。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用<strong>连续分配方式</strong>(学过<strong>文件管理</strong>章节后即可理解)，总之，<strong>对换区的I&#x2F;O速度比文件区的更快</strong></li>
</ul>
</li>
<li>什么时候应该交换？<ul>
<li>交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停</li>
<li>例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出</li>
</ul>
</li>
<li>应该换出哪些进程？<ul>
<li>可优先换出阻塞进程；可换出优先级低的进程；</li>
<li>为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间…</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>注意</strong>：<strong>PCB 会常驻内存</strong>，不会被换出外存</p>
</li>
</ul>
<h2 id="4-连续分配管理方式"><a href="#4-连续分配管理方式" class="headerlink" title="4. 连续分配管理方式"></a><strong>4. 连续分配管理方式</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121110518884.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><strong>连续分配</strong>：<strong>指为用户进程分配的必须是一个连续的内存空间</strong></li>
</ul>
<h3 id="4-1-单一连续分配"><a href="#4-1-单一连续分配" class="headerlink" title="4.1 单一连续分配"></a>4.1 <strong>单一连续分配</strong></h3><ul>
<li><p>在<strong>单一连续分配方式</strong>中，<strong>内存</strong>被分为<strong>系统区</strong>和<strong>用户区</strong>。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。内存中只能有一道用户程序，<strong>用户程序独占整个用户区空间</strong></p>
</li>
<li><p>优点：实现简单；<strong>无外部碎片</strong>；可以采用覆盖技术扩充内存；不一定需要采取内存保护（eg：早期的 PC 操作系统 MS-DOS）</p>
</li>
<li><p>缺点：只能用于单用户、单任务的操作系统中；<strong>有内部碎片</strong>；存储器利用率极低</p>
<ul>
<li><strong>内部碎片</strong>：分配给某进程的内存区域中，如果有些部分没有用上</li>
<li><strong>外部碎片</strong>：内存中的某些空闲分区由于太小而难以利用</li>
</ul>
</li>
</ul>
<h2 id="4-2-固定分区分配"><a href="#4-2-固定分区分配" class="headerlink" title="4.2 固定分区分配"></a>4.2 <strong>固定分区分配</strong></h2><ul>
<li><p>20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个<strong>用户空间</strong>划分为<strong>若干个固定大小的分区</strong>，在<strong>每个分区中只装入一道作业</strong>，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式</p>
</li>
<li><p><strong>分区大小相等</strong></p>
<ul>
<li>缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合（比如：钢铁厂有n个相同的炼钢炉，就可把内存分为n个大小相等的区域存放n个炼钢炉控制程序）</li>
</ul>
</li>
<li><p><strong>分区大小不等</strong></p>
<ul>
<li>增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分</li>
<li>比如：划分多个小分区、适量中等分区、少量大分区</li>
</ul>
</li>
<li><p>操作系统需要建立一个数据结构 – <strong>分区说明表</strong>，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态（是否已分配）。当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”</p>
</li>
<li><p>优点：实现简单，<strong>无外部碎片</strong></p>
</li>
<li><p>缺点：</p>
<ul>
<li>a. 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能</li>
<li>b. <strong>会产生内部碎片</strong>，内存利用率低</li>
</ul>
</li>
</ul>
<h3 id="4-3-动态分区分配-可变分区分配"><a href="#4-3-动态分区分配-可变分区分配" class="headerlink" title="4.3 动态分区分配(可变分区分配)"></a>4.3 <strong>动态分区分配</strong>(可变分区分配)</h3><ul>
<li><p>这种分配方式<strong>不会预先划分内存分区</strong>，而是<strong>在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要</strong>。因此系统分区的大小和数目是可变的</p>
</li>
<li><p><strong>思考</strong>:</p>
<ul>
<li>系统要用什么样的数据结构记录内存的使用情况？<ul>
<li>可以通过<strong>空闲分区表</strong>或<strong>空闲分区链</strong>这两种数据结构记录内存使用情况</li>
<li><strong>空闲分区表</strong>: 每个空闲分区对应一个表项。表项中包含分区号、分区大小、分区起始地址等信息</li>
<li><strong>空闲分区链</strong>: 每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息</li>
</ul>
</li>
<li>当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？<ul>
<li>把一个新作业装入内存时，须按照一定的<strong>动态分区分配算法</strong>，从空闲分区表（或空闲分区链）中选出一个分区分配给该作业</li>
<li>由于分配算法算法对系统性能有很大的影响，因此人们对它进行了广泛的研究</li>
</ul>
</li>
<li>如何进行分区的分配与回收操作？<ul>
<li>假设系统采用的数据结构是“空闲分区表” <ul>
<li>分配<ul>
<li>可以根据实际分配情况, 对空闲分区表进行分区大小修改、删除表项等操作</li>
</ul>
</li>
<li>回收<ul>
<li>可以根据实际回收情况, 对空闲分区表进行合并表项(回收的区域有相邻的空白表项)、新增表项等操作</li>
</ul>
</li>
<li>注：各表项的顺序不一定按照地址递增顺序排列，具体的排列方式需要依据动态分区分配算法来确定</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>动态分区分配没有内部碎片，但是有外部碎片</strong></p>
<ul>
<li>如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些</li>
<li>“碎片”不能满足进程的需求。可以通过<strong>紧凑（拼凑，Compaction）技术来解决外部碎片</strong></li>
<li>“紧凑”之后需要把进程的起始地址修改, <strong>进程的起始地址</strong>存放在<strong>PCB</strong>当中, 进程上CPU运行之前,会把进程的起始地址放到<strong>重定位寄存器</strong>里</li>
</ul>
</li>
<li><p><strong>动态分区分配</strong>应该采用<strong>动态运行时装入(动态重定位)</strong></p>
<ul>
<li>因为通过紧凑技术会导致进程起始地址发生变化, 而动态重定位允许程序在内存中发生移动</li>
</ul>
</li>
</ul>
<h2 id="5-动态分区分配算法"><a href="#5-动态分区分配算法" class="headerlink" title="5. 动态分区分配算法"></a><strong>5. 动态分区分配算法</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121111606972.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>动态分区分配算法</strong>: <strong>在动态分区分配方式中， 当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配</strong></p>
<h3 id="5-1-首次适应算法-First-Fit"><a href="#5-1-首次适应算法-First-Fit" class="headerlink" title="5.1 首次适应算法(First Fit)"></a>5.1 <strong>首次适应算法</strong>(First Fit)</h3><ul>
<li><p>算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区</p>
</li>
<li><p>如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p>
</li>
<li><p>优点：首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。 但是这种规则也决定了当低地址部分有更小的分区可以满足需求时， 会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来（最佳适应算法的优点）</p>
</li>
</ul>
<h3 id="5-2-最佳适应算法-Best-Fit"><a href="#5-2-最佳适应算法-Best-Fit" class="headerlink" title="5.2 最佳适应算法(Best Fit)"></a>5.2 <strong>最佳适应算法</strong>(Best Fit)</h3><ul>
<li><p>算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区</p>
</li>
<li><p>如何实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p>
</li>
<li><p>缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片</p>
</li>
</ul>
<h3 id="5-3-最坏适应算法-Worst-Fit"><a href="#5-3-最坏适应算法-Worst-Fit" class="headerlink" title="5.3 最坏适应算法(Worst Fit)"></a>5.3 <strong>最坏适应算法</strong>(Worst Fit)</h3><ul>
<li><p>又称 最大适应算法（Largest Fit）</p>
</li>
<li><p>算法思想：为了解决最佳适应算法的问题 – 即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用</p>
</li>
<li><p>如何实现：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p>
</li>
<li><p>缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了</p>
</li>
</ul>
<h3 id="5-4-邻近适应算法-Next-Fit"><a href="#5-4-邻近适应算法-Next-Fit" class="headerlink" title="5.4 邻近适应算法(Next Fit)"></a>5.4 <strong>邻近适应算法</strong>(Next Fit)</h3><ul>
<li><p>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题</p>
</li>
<li><p>如何实现：空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p>
</li>
<li><p>缺点：邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用（最大适应算法的缺点）</p>
</li>
</ul>
<p>综合来看，<strong>四种算法中，首次适应算法的效果反而更好</strong></p>
<h2 id="6-基本分页存储管理的概念"><a href="#6-基本分页存储管理的概念" class="headerlink" title="6. 基本分页存储管理的概念"></a><strong>6. 基本分页存储管理的概念</strong></h2><ul>
<li><strong>非连续分配</strong>：<strong>指为用户进程分配的可以是一些分散的内存空间</strong></li>
</ul>
<p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121123601201.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="6-1-什么是分页存储"><a href="#6-1-什么是分页存储" class="headerlink" title="6.1 什么是分页存储?"></a>6.1 <strong>什么是分页存储?</strong></h3><ul>
<li><p>将<strong>内存空间</strong>分为一个个<strong>大小相等的分区</strong>（比如：每个分区4KB），每个分区就是一个“<strong>页框(PageFrame)<strong>”（</strong>页框</strong>&#x3D;<strong>页帧</strong>&#x3D;<strong>内存块</strong>&#x3D;<strong>物理块</strong>&#x3D;<strong>物理页面</strong>）。每个页框有一个编号，即“<strong>页框号</strong>”（<strong>页框号</strong>&#x3D;<strong>页帧号</strong>&#x3D;<strong>内存块号</strong>&#x3D;<strong>物理块号</strong>&#x3D;<strong>物理页号</strong>），<strong>页框号从0开始</strong></p>
</li>
<li><p>将<strong>进程的逻辑地址空间</strong>也分为<strong>与页框大小相等</strong>的一个个部分，每个部分称为一个“<strong>页</strong>”或“<strong>页面</strong>” 。每个页面也有一个编号，即“<strong>页号</strong>”，<strong>页号也是从0开始</strong></p>
</li>
<li><p>注意区分 <strong>页框</strong> vs <strong>页</strong> 的概念</p>
</li>
<li><p>操作系统<strong>以页框为单位为各个进程分配内存空间</strong>。进程的每个页面分别放入一个页框中。也就是说，进程的<strong>页面</strong>与内存的<strong>页框</strong>有一一对应的关系。<strong>各个页面不必连续存放，可以放到不相邻的各个页框中</strong></p>
<ul>
<li>注：进程的最后一个页面可能没有一个页框那么大。也就是说，<strong>分页存储有可能产生内部碎片</strong>，因此页框不能太大，否则可能产生过大的内部碎片造成浪费</li>
</ul>
</li>
</ul>
<h3 id="6-2-页表"><a href="#6-2-页表" class="headerlink" title="6.2 页表"></a>6.2 <strong>页表</strong></h3><ul>
<li>为了能知道进程的每个<strong>页面</strong>在内存中存放的位置，操作系统要为每个进程建立一张<strong>页表</strong><ul>
<li>注：页表通常存在<strong>PCB</strong>（进程控制块）中</li>
</ul>
</li>
</ul>
<p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121112224337.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="6-3-每个页表项多大？占几个字节？"><a href="#6-3-每个页表项多大？占几个字节？" class="headerlink" title="6.3 每个页表项多大？占几个字节？"></a>6.3 <strong>每个页表项多大？占几个字节？</strong></h3><ul>
<li><p>Eg：假设某系统物理内存大小为 4GB，页面大小为 4KB，则每个页表项至少应该为多少字节？</p>
</li>
<li><p>内存块大小&#x3D;页面大小&#x3D;4KB&#x3D; 2<sup>12</sup>B</p>
<ul>
<li>4GB 的内存总共会被分为 2<sup>32</sup> &#x2F; 2<sup>12</sup> &#x3D; 2<sup>20</sup>个内存块</li>
<li>内存块号的范围应该是 0 ~ 2<sup>20</sup> -1</li>
<li>内存块号至少要用 20 bit 来表示</li>
<li>内存按字节编址, 则至少要用3B来表示<strong>块号</strong>（3*8&#x3D;24bit）<ul>
<li><strong>注意</strong>：页表记录的只是内存块号，而不是内存块的起始地址！<ul>
<li>j 号内存块的起始地址 &#x3D; j * 内存块大小</li>
</ul>
</li>
<li><strong>重要考点</strong>：计算机中内存块的数量 → 页表项中块号至少占多少字节</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>页表项连续存放</strong>，因此<strong>页号可以是隐含的，不占存储空间（类比数组）</strong></p>
<ul>
<li>假设页表中的各页表项从内存地址为 X 的地方开始连续存放，如何找到页号为 i 的页表项？</li>
<li>i 号页表项的存放地址 &#x3D; X + i * 页表项大小</li>
</ul>
</li>
</ul>
<h3 id="6-4-如何通过页表实现逻辑地址到物理地址的转换？"><a href="#6-4-如何通过页表实现逻辑地址到物理地址的转换？" class="headerlink" title="6.4 如何通过页表实现逻辑地址到物理地址的转换？"></a>6.4 <strong>如何通过页表实现逻辑地址到物理地址的转换？</strong></h3><ul>
<li><strong>进程在内存中连续存放时</strong>，操作系统是如何实现逻辑地址到物理地址的转换的？<ul>
<li><strong>重定位寄存器</strong>：指明了进程在内存中的起始位置</li>
<li>物理地址 &#x3D; 进程在内存中的起始位置 + 逻辑地址</li>
<li>逻辑地址相对于起始位置的“偏移量”</li>
</ul>
</li>
<li>将进程地址空间<strong>分页</strong>之后，操作系统该如何实现逻辑地址到物理地址的转换？<ul>
<li>特点：虽然进程的各个<strong>页面是离散存放的</strong>，但是<strong>页面内部是连续存放的</strong></li>
<li>如果要访问逻辑地址 A，则:<ul>
<li>确定逻辑地址A 对应的“<strong>页号</strong>”P</li>
<li>找到P号页面在内存中的起始地址<ul>
<li>通过查找页表，找到页号P对应的内存块号，计算出内存块号在内存中的起始地址</li>
</ul>
</li>
<li>确定逻辑地址A 的“<strong>页内偏移量</strong>”W</li>
</ul>
</li>
<li>逻辑地址A 对应的物理地址 &#x3D; P号页面在内存中的起始地址 + 页内偏移量W</li>
</ul>
</li>
</ul>
<h3 id="6-5-如何确定一个逻辑地址对应的页号、页内偏移量？"><a href="#6-5-如何确定一个逻辑地址对应的页号、页内偏移量？" class="headerlink" title="6.5 如何确定一个逻辑地址对应的页号、页内偏移量？"></a>6.5 <strong>如何确定一个逻辑地址对应的页号、页内偏移量？</strong></h3><ul>
<li><p>Eg：在某计算机系统中，页面大小是50B。某进程逻辑地址空间大小为200B，则逻辑地址 110 对应的页号、页内偏移量是多少？</p>
<ul>
<li>页号 &#x3D; 110 &#x2F; 50 &#x3D; 2</li>
<li>页内偏移量 &#x3D; 110 % 50 &#x3D; 10</li>
</ul>
</li>
<li><p>页号 &#x3D; 逻辑地址 &#x2F; 页面长度 （取除法的整数部分）</p>
</li>
<li><p>页内偏移量 &#x3D; 逻辑地址 % 页面长度（取除法的余数部分）</p>
</li>
<li><p><strong>逻辑地址 可以拆分为（页号，页内偏移量）</strong></p>
</li>
<li><p>当<strong>页面大小</strong>刚好是<strong>2的整数幂时</strong>:</p>
</li>
</ul>
<p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121123228264.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><strong>总结：页面大小 刚好是 2的整数幂 有什么好处？</strong><ul>
<li>逻辑地址的拆分更加迅速 – 如果每个页面大小为 2KB，用二进制数表示逻辑地址，则末尾 K 位即为页内偏移量，其余部分就是页号。因此，如果让每个页面的大小为 2 的整数幂，计算机硬件就可以很方便地得出一个逻辑地址对应的页号和页内偏移量，而无需进行除法运算，从而提升了运行速度</li>
<li>物理地址的计算更加迅速 – 根据逻辑地址得到页号，根据页号查询页表从而找到页面存放的内存块号，将二进制表示的内存块号和页内偏移量拼接起来，就可以得到最终的物理地址</li>
</ul>
</li>
</ul>
<h3 id="6-6-逻辑地址结构"><a href="#6-6-逻辑地址结构" class="headerlink" title="6.6 逻辑地址结构"></a>6.6 <strong>逻辑地址结构</strong></h3><ul>
<li>页面大小刚好是2的整数幂时：</li>
</ul>
<p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121123548986.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>Tips：有些奇葩题目中<strong>页面大小有可能不是2的整数次幂</strong>，这种情况还是得用最原始的方法计算：<ul>
<li>页号 &#x3D; 逻辑地址 &#x2F; 页面长度 （取除法的整数部分）</li>
<li>页内偏移量 &#x3D; 逻辑地址 % 页面长度（取除法的余数部分）</li>
</ul>
</li>
</ul>
<h2 id="7-基本地址变换机构"><a href="#7-基本地址变换机构" class="headerlink" title="7. 基本地址变换机构"></a><strong>7. 基本地址变换机构</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121125306825.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><strong>基本地址变换机构</strong>：<strong>用于实现逻辑地址到物理地址转换的一组硬件机构</strong></li>
</ul>
<h3 id="7-1-页表寄存器"><a href="#7-1-页表寄存器" class="headerlink" title="7.1 页表寄存器"></a>7.1 <strong>页表寄存器</strong></h3><ul>
<li><p><strong>基本地址变换机构</strong>可以借助进程的<strong>页表</strong>将逻辑地址转换为物理地址</p>
</li>
<li><p>通常会在系统中设置一个<strong>页表寄存器</strong>(PTR)，存放<strong>页表在内存中的起始地址F</strong>和<strong>页表长度M</strong></p>
</li>
<li><p>进程未执行时，页表的始址和页表长度放在<strong>PCB</strong>(进程控制块)中，当进程被调度时，操作系统内核会把它们放到页表寄存器中</p>
</li>
</ul>
<h3 id="7-2-设页面大小为L，逻辑地址A到物理地址E的变换过程如下："><a href="#7-2-设页面大小为L，逻辑地址A到物理地址E的变换过程如下：" class="headerlink" title="7.2 设页面大小为L，逻辑地址A到物理地址E的变换过程如下："></a>7.2 <strong>设页面大小为L，逻辑地址A到物理地址E的变换过程如下</strong>：</h3><ul>
<li><p>注意: 页面大小是2的整数幂</p>
</li>
<li><p>计算<strong>页号P</strong>和<strong>页内偏移量W</strong></p>
<ul>
<li>如果用十进制数手算，则 P &#x3D; A &#x2F; L， W &#x3D; A % L</li>
<li>但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量</li>
</ul>
</li>
<li><p>比较页号P和页表长度M，若 P ≥ M， 则产生越界中断，否则继续执行</p>
<ul>
<li>注意：页号是从0开始的，而页表长度至少是1，因此P&#x3D;M时也会越界</li>
</ul>
</li>
<li><p>页表中页号P对应的 页表项地址 &#x3D; 页表起始地址F + 页号P * 页表项长度 ，取出该页表项内容b，即为内存块号</p>
<ul>
<li>注意区分<strong>页表项长度</strong>、 <strong>页表长度</strong>、<strong>页面大小</strong>的区别</li>
<li>页表长度：指的是这个页表中总共有几个页表项，即总共有几个页</li>
<li>页表项长度：指的是每个页表项占多大的存储空间</li>
<li>页面大小：指的是一个页面占多大的存储空间</li>
</ul>
</li>
<li><p>计算 E &#x3D; b * L + W，用得到的物理地址E去访存</p>
<ul>
<li>如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了</li>
</ul>
</li>
<li><p><strong>动手验证</strong>：</p>
<ul>
<li>假设页面大小L &#x3D; 1KB，最终要访问的内存块号b &#x3D; 2，页内偏移量W &#x3D; 1023</li>
<li>① 尝试用E &#x3D; b * L + W计算目标物理地址</li>
<li>② 尝试把内存块号、页内偏移量用二进制表示，并把它们拼接起来得到物理地址</li>
<li>对比①、②的结果是否一致</li>
</ul>
</li>
</ul>
<p><strong>例题</strong>：</p>
<ul>
<li>在<strong>分页存储管理</strong>(页式管理)的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，<strong>页式管理中地址是一维的</strong><ul>
<li>即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位</li>
</ul>
</li>
</ul>
<h3 id="7-3-页表项大小"><a href="#7-3-页表项大小" class="headerlink" title="7.3 页表项大小"></a>7.3 <strong>页表项大小</strong></h3><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121125207912.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="8-具有快表的地址变换机构"><a href="#8-具有快表的地址变换机构" class="headerlink" title="8. 具有快表的地址变换机构"></a><strong>8. 具有快表的地址变换机构</strong></h2><ul>
<li><strong>具有快表的地址变换机构</strong>：<strong>是基本地址变换机构的改进版本</strong></li>
</ul>
<p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121163126476.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="8-1-什么是快表-TLB"><a href="#8-1-什么是快表-TLB" class="headerlink" title="8.1 什么是快表(TLB)?"></a>8.1 <strong>什么是快表(TLB)?</strong></h3><ul>
<li><strong>快表</strong>，又称<strong>联想寄存器（TLB， translation lookaside buffer）</strong>，是一种访问速度比内存快很多的<strong>高速缓存</strong>（<strong>TLB不是内存！</strong>），用来存放最近访问的页表项的副本，可以加速地址变换的速度。与此对应，<strong>内存中的页表</strong>常称为<strong>慢表</strong></li>
<li><strong>引入快表后的地址变换过程</strong>:<ul>
<li>CPU给出逻辑地址，由某个硬件算得<strong>页号</strong>、<strong>页内偏移量</strong>，将页号与<strong>快表</strong>中的所有页号进行比较</li>
<li>如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的<strong>内存块号</strong>，再<strong>将内存块号与页内偏移量拼接形成物理地址</strong>，最后，访问该物理地址对应的<strong>内存单元</strong>。因此，<strong>若快表命中</strong>，则访问某个逻辑地址<strong>仅需一次访存</strong>即可</li>
<li>如果没有找到匹配的页号，则需要访问<strong>内存中的页表</strong>，找到对应页表项，得到页面存放的<strong>内存块号</strong>，再<strong>将内存块号与页内偏移量拼接形成物理地址</strong>，最后，访问该物理地址对应的<strong>内存单元</strong>。因此，<strong>若快表未命中</strong>，则<strong>访问某个逻辑地址需要两次访存</strong><ul>
<li>注意：<strong>在找到页表项后，应同时将其存入快表</strong>，以便后面可能的再次访问。<strong>若快表己满，则必须按照一定的算法对旧的页表项进行替换</strong></li>
</ul>
</li>
<li>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间</li>
<li>因为<strong>局部性原理</strong>，一般来说快表的命中率可以达到90%以上<ul>
<li>例：某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时1us，访问一次内存耗100us。若快表的命中率为90%，那么访问一个逻辑地址的平均耗时是多少?<ul>
<li>(1 + 100) * 0.9 + (1 + 100 + 100) * 0.1 &#x3D; 111 us</li>
<li><strong>有的系统支持快表和慢表同时查找</strong>，如果是这样，平均耗时应该是：</li>
<li>(1 + 100) * 0.9 + (100 + 100) * 0.1 &#x3D; 110.9 us</li>
<li>若未采用快表机制，则访问一个逻辑地址需要：</li>
<li>100 + 100 &#x3D; 200us</li>
<li>显然，引入快表机制后，访问一个逻辑地址的速度快多了</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="8-2-局部性原理"><a href="#8-2-局部性原理" class="headerlink" title="8.2 局部性原理"></a>8.2 <strong>局部性原理</strong></h3><ul>
<li><strong>时间局部性</strong><ul>
<li>如果执行了程序中的某条<strong>指令</strong>，那么不久后这条指令很有可能再次执行；如果某个<strong>数据</strong>被访问过，不久之后该数据很可能再次被访问（因为程序中存在大量的循环）</li>
</ul>
</li>
<li><strong>空间局部性</strong><ul>
<li>一旦程序访问了某个<strong>存储单元</strong>，在不久之后，其附近的存储单元也很有可能被访问（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）</li>
</ul>
</li>
<li>上小节介绍的基本地址变换机构中，每次要访问一个逻辑地址，都需要查询内存中的页表。由于局部性原理，可能连续很多次查到的都是同一个页表项</li>
</ul>
<h2 id="9-两级页表"><a href="#9-两级页表" class="headerlink" title="9. 两级页表"></a><strong>9. 两级页表</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121165419159.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="9-1-单级页表存在的问题"><a href="#9-1-单级页表存在的问题" class="headerlink" title="9.1 单级页表存在的问题"></a>9.1 <strong>单级页表存在的问题</strong></h3><ul>
<li>某计算机系统按字节寻址，支持 32 位的逻辑地址，采用分页存储管理，页面大小为4KB，页表项长度为 4B<ul>
<li>4KB &#x3D; 2<sup>12</sup>B，因此页内地址要用12位表示，剩余 20 位表示页号</li>
<li>因此，该系统中用户进程最多有 2<sup>20</sup> 页。相应的，一个进程的页表中，最多会有 2<sup>20</sup> &#x3D; 1M &#x3D;1,048,576 个页表项，所以一个页表最大需要 2<sup>20</sup> * 4B &#x3D; 2<sup>22</sup>B，共需要 2<sup>22</sup> &#x2F; 2<sup>12</sup> &#x3D; 2<sup>10</sup>个页框存储该页表，需要专门给进程分配2<sup>10</sup> &#x3D; <strong>1024个连续的页框</strong>来存放它的页表</li>
<li>根据页号查询页表的方法：K 号页对应的 页表项存放位置 &#x3D; 页表始址 + K * 4</li>
<li><strong>要在所有的页表项都连续存放的基础上才能用这种方法找到页表项</strong></li>
<li>根据<strong>局部性原理</strong>可知，很多时候，进程在一段时间内只需要访问某几个页面就可以正常运行了，因此没有必要让整个页表都常驻内存</li>
</ul>
</li>
<li>问题一：<strong>页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框</strong><ul>
<li>思考：我们是如何解决进程在内存中必须连续存储的问题？<ul>
<li>将进程地址空间分页，并为其建立一张页表，记录各页面的存放位置</li>
<li>同样的思路也可用于解决“页表必须连续存放”的问题，把必须连续存放的页表再分页</li>
<li>可将长长的页表进行分组，<strong>使每个内存块刚好可以放入一个分组</strong>（比如上面的例子中，页面大小4KB，每个页表项4B，每个页面可存放1K个页表项，因此每1K个连续的页表项为一组，每组刚好占一个内存块，再将各组离散地放到各个内存块中）</li>
<li>另外，要为离散分配的页表再建立一张页表，称为<strong>页目录表</strong>（又称<strong>外层页表</strong>或<strong>顶层页表</strong>）</li>
</ul>
</li>
</ul>
</li>
<li>问题二：<strong>没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面</strong><ul>
<li>可以在需要访问页面时才把页面调入内存（<strong>虚拟存储技术</strong>）, 可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存</li>
<li>若想访问的页面不在内存中，则产生<strong>缺页中断（内中断&#x2F;异常）</strong>，然后将目标页面从外存调入内存</li>
</ul>
</li>
</ul>
<h3 id="9-2-两级页表的原理、地址结构"><a href="#9-2-两级页表的原理、地址结构" class="headerlink" title="9.2 两级页表的原理、地址结构"></a>9.2 <strong>两级页表的原理、地址结构</strong></h3><ul>
<li><strong>如何实现地址变换</strong><ul>
<li>按照地址结构将逻辑地址拆分成三部分（一级页号、二级页号、页内偏移量）</li>
<li>从PCB 中读出页目录表始址，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置</li>
<li>根据二级页号查二级页表，找到最终想访问的内存块号</li>
<li>结合页内偏移量得到物理地址</li>
</ul>
</li>
</ul>
<h3 id="9-3-需要注意的几个细节"><a href="#9-3-需要注意的几个细节" class="headerlink" title="9.3 需要注意的几个细节"></a>9.3 <strong>需要注意的几个细节</strong></h3><ul>
<li>若分为两级页表后，页表依然很长，则可以采用更多级页表，一般来说<strong>各级页表的大小不能超过一个页面</strong><ul>
<li>例：某系统按字节编址，采用 40 位逻辑地址，页面大小为 4KB，页表项大小为 4B，假设采用纯页式存储，则要采用（）级页表，页内偏移量为（）位？<ul>
<li>页面大小 &#x3D; 4KB &#x3D; 2<sup>12</sup>B，按字节编址，因此页内偏移量为12位</li>
<li>页号 &#x3D; 40 - 12 &#x3D; 28 位</li>
<li>页面大小 &#x3D; 2<sup>12</sup>B，页表项大小 &#x3D; 4B，则每个页面可存放 2<sup>12</sup> &#x2F; 4 &#x3D; 2<sup>10</sup>个页表项</li>
<li>因此各级页表最多包含 2<sup>10</sup>个页表项，需要10位二进制位才能映射到 2<sup>10</sup>个页表项</li>
<li>因此每一级的页表对应页号应为10位，总共28位的页号至少要分为三级<ul>
<li>如果只分为两级页表，则一级页号占 18 位，也就是说页目录表中最多可能有 2<sup>18</sup> 个页表项，显然，一个页面是放不下这么多页表项的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>两级页表的访存次数分析（假设没有快表机构）<ul>
<li>第一次访存：访问内存中的页目录表</li>
<li>第二次访存：访问内存中的二级页表</li>
<li>第三次访存：访问目标内存单元</li>
</ul>
</li>
</ul>
<h2 id="10-基本分段存储管理方式"><a href="#10-基本分段存储管理方式" class="headerlink" title="10. 基本分段存储管理方式"></a><strong>10. 基本分段存储管理方式</strong></h2><ul>
<li><p><strong>基本分段存储管理</strong>：<strong>与“分页”最大的区别就是 – 离散分配时所分配地址空间的基本单位不同</strong></p>
</li>
<li><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121172738208.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
<h3 id="10-1-分段"><a href="#10-1-分段" class="headerlink" title="10.1 分段"></a>10.1 <strong>分段</strong></h3><ul>
<li><p>进程的地址空间：按照程序<strong>自身的逻辑</strong>关系<strong>划分为若干个段</strong>，每个段都有一个段名（在低级语言中，程序员使用段名来编程），<strong>每段从0开始编址</strong></p>
</li>
<li><p>内存分配规则：以段为单位进行分配，<strong>每个段在内存中占据连续空间，但各段之间可以不相邻</strong></p>
</li>
</ul>
<p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121171112237.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>分段系统的<strong>逻辑地址</strong>结构由<strong>段号（段名）</strong>和<strong>段内地址（段内偏移量）</strong>组成。如：</li>
</ul>
<h3 id="10-2-段表"><a href="#10-2-段表" class="headerlink" title="10.2 段表"></a>10.2 <strong>段表</strong></h3><ul>
<li>程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称“<strong>段表</strong>”</li>
</ul>
<p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121171506496.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="10-3-分段、分页管理的区别"><a href="#10-3-分段、分页管理的区别" class="headerlink" title="10.3 分段、分页管理的区别"></a>10.3 <strong>分段、分页管理的区别</strong></h3><ul>
<li><p><strong>页</strong>是<strong>信息的物理单位</strong>。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，<strong>对用户是不可见的</strong></p>
</li>
<li><p><strong>段</strong>是<strong>信息的逻辑单位</strong>。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。<strong>分段对用户是可见的</strong>，用户编程时需要显式地给出段名</p>
</li>
<li><p>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序</p>
</li>
<li><p><strong>分页</strong>的用户进程<strong>地址空间是一维的</strong>，程序员只需给出一个记忆符即可表示一个地址</p>
</li>
<li><p><strong>分段</strong>的用户进程<strong>地址空间是二维的</strong>，程序员在标识一个地址时，既要给出段名，也要给出段内地址</p>
</li>
<li><p><strong>分段</strong>比分页<strong>更容易实现信息的共享和保护</strong></p>
<ul>
<li>只需让各进程的段表项指向同一个段即可实现共享；页面不是按逻辑模块划分的，这就很难实现共享</li>
<li>不能被修改的代码称为<strong>纯代码</strong>或<strong>可重入代码</strong>（不属于临界资源），这样的代码是可以共享的。可修改的代码是不能共享的（比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一致）</li>
</ul>
</li>
<li><p><strong>访问一个逻辑地址需要几次访存</strong>？</p>
<ul>
<li><strong>分页（单级页表）</strong>：第一次访存 – 查内存中的页表，第二次访存 – 访问目标内存单元。总共<strong>两次访存</strong></li>
<li><strong>分段</strong>：第一次访存 – 查内存中的段表，第二次访存 – 访问目标内存单元。总共<strong>两次访存</strong></li>
<li>与分页系统类似，分段系统中也可以引入<strong>快表</strong>机构，将近期访问过的段表项放到快表中，这样可以少一次访问，加快地址变换速度</li>
</ul>
</li>
</ul>
<h2 id="11-段页式管理方式"><a href="#11-段页式管理方式" class="headerlink" title="11. 段页式管理方式"></a><strong>11. 段页式管理方式</strong></h2><p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121182311141.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="11-1-分页、分段的优缺点分析"><a href="#11-1-分页、分段的优缺点分析" class="headerlink" title="11.1 分页、分段的优缺点分析"></a>11.1 <strong>分页、分段的优缺点分析</strong></h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center"><strong>优点</strong></th>
<th align="center"><strong>缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">分页管理</td>
<td align="center">内存空间利用率高，<strong>不会产生外部碎片</strong>，只会有少量的页内碎片</td>
<td align="center">不方便按照逻辑模块实现信息的共享和保护</td>
</tr>
<tr>
<td align="center">分段管理</td>
<td align="center">很方便按照逻辑模块实现信息的共享和保护</td>
<td align="center">如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理<strong>会产生外部碎片</strong></td>
</tr>
</tbody></table>
<ul>
<li>分段管理中产生的外部碎片也可以用“<strong>紧凑</strong>”来解决，只是需要付出较大的时间代价</li>
</ul>
<h3 id="11-2-分段-分页-段页式管理"><a href="#11-2-分段-分页-段页式管理" class="headerlink" title="11.2 分段 + 分页 &#x3D; 段页式管理"></a>11.2 <strong>分段 + 分页 &#x3D; 段页式管理</strong></h3><ul>
<li>将进程按逻辑模块分段，再将各段分页（如每个页面4KB)</li>
<li>再将内存空间分为大小相同的内存块&#x2F;页框&#x2F;页帧&#x2F;物理块</li>
<li>进程前将各页面分别装入各内存块中</li>
</ul>
<h3 id="11-3-段页式管理的逻辑地址结构"><a href="#11-3-段页式管理的逻辑地址结构" class="headerlink" title="11.3 段页式管理的逻辑地址结构"></a>11.3 <strong>段页式管理的逻辑地址结构</strong></h3><ul>
<li><strong>分段系统</strong>的<strong>逻辑地址</strong>结构由<strong>段号（段名）</strong>和<strong>段内地址（段内偏移量）</strong>组成。如：</li>
</ul>
<p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121181503259.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p><strong>段页式系统</strong>的<strong>逻辑地址</strong>结构由<strong>段号</strong>、<strong>页号</strong>、<strong>页内地址（页内偏移量）</strong>组成。如：</p>
<ul>
<li>段号的位数决定了每个进程最多可以分几个段</li>
<li>页号位数决定了每个段最大有多少页</li>
<li>页内偏移量决定了页面大小、内存块大小是多少</li>
</ul>
</li>
<li><p>在上述例子中，若系统是按字节寻址的，则</p>
<ul>
<li>段号占16位，因此在该系统中，每个进程最多有216&#x3D;64K个段</li>
<li>页号占4位，因此每个段最多有24&#x3D;16页</li>
<li>页内偏移量占12位，因此每个页面每个内存块大小为212&#x3D;4096&#x3D;4KB</li>
</ul>
</li>
</ul>
<h3 id="11-4-段表、页表"><a href="#11-4-段表、页表" class="headerlink" title="11.4 段表、页表"></a>11.4 <strong>段表、页表</strong></h3><ul>
<li>每个段对应一个段表项，每个段表项由段号、页表长度、页表存放块号（页表起始地址)组成。每个段表项长度相等，段号是隐含的。</li>
<li>每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，页号是隐含的。</li>
</ul>
<p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121181902465.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="11-5-段页式管理地址变换过程"><a href="#11-5-段页式管理地址变换过程" class="headerlink" title="11.5 段页式管理地址变换过程"></a>11.5 <strong>段页式管理地址变换过程</strong></h3><ul>
<li><p>根据逻辑地址得到段号、页号、页内偏移量</p>
</li>
<li><p>判断段号是否越界。若S≥M,则产生越界中断，否则继续执行</p>
</li>
<li><p>查询段表找到对应的段表项，段表项的存放地址为F+S*段表项长度</p>
</li>
<li><p>检查页号是否越界，若页号≥页表长度，则发生越界中断，否则继续执行</p>
</li>
<li><p>根据页表存放块号、页号查询页表找到对应页表项</p>
</li>
<li><p>根据内存块号页内偏移量得到最终的物理地址</p>
</li>
<li><p>访问目标内存单元</p>
</li>
</ul>
<p><img src="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20241121182242000.png" srcset="/img/loading.gif" lazyload></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" class="category-chain-item">计算机基础</a>
  
  
    <span>></span>
    
  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="category-chain-item">操作系统</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="print-no-link">#操作系统</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>第三章 内存管理-3.1 内存管理概念</div>
      <div>http://binbo-zappy.github.io/2024/11/21/操作系统/3-1-内存管理概念/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Binbo</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年11月21日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="3.2 虚拟内存管理">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">3.2 虚拟内存管理</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-4-%E6%AD%BB%E9%94%81/" title="2.4 死锁">
                        <span class="hidden-mobile">2.4 死锁</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
