

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Binbo">
  <meta name="keywords" content="">
  
    <meta name="description" content="第5章 Linux网络编程基础API 1. socket地址API 1.1 主机字节序和网络字节序 字节序分为大端字节序（big endian）和小端字节序（little endian）。  大端字节序是指一个整数的高位字节（23～31 bit）存储在内存的低地址处，低位字节（0～7 bit）存储在内存的高地址处。 小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存">
<meta property="og:type" content="article">
<meta property="og:title" content="5. Linux网络编程基础API">
<meta property="og:url" content="http://binbo-zappy.github.io/2024/12/16/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-%E6%B8%B8%E5%8F%8C/5-Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/index.html">
<meta property="og:site_name" content="Binbo">
<meta property="og:description" content="第5章 Linux网络编程基础API 1. socket地址API 1.1 主机字节序和网络字节序 字节序分为大端字节序（big endian）和小端字节序（little endian）。  大端字节序是指一个整数的高位字节（23～31 bit）存储在内存的低地址处，低位字节（0～7 bit）存储在内存的高地址处。 小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://binbo-zappy.github.io/imgs/youshuang.png">
<meta property="article:published_time" content="2024-12-16T14:03:36.000Z">
<meta property="article:modified_time" content="2024-12-18T03:00:32.462Z">
<meta property="article:author" content="Binbo">
<meta property="article:tag" content="网络编程">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://binbo-zappy.github.io/imgs/youshuang.png">
  
  
  
  <title>5. Linux网络编程基础API - Binbo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"binbo-zappy.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Liekkas</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="5. Linux网络编程基础API"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-12-16 22:03" pubdate>
          2024年12月16日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          98 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">5. Linux网络编程基础API</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="第5章-linux网络编程基础api">第5章 Linux网络编程基础API</h1>
<h2 id="socket地址api">1. socket地址API</h2>
<h3 id="主机字节序和网络字节序">1.1 主机字节序和网络字节序</h3>
<p>字节序分为大端字节序（big endian）和小端字节序（little endian）。</p>
<ul>
<li>大端字节序是指一个整数的高位字节（23～31
bit）存储在内存的低地址处，低位字节（0～7
bit）存储在内存的高地址处。</li>
<li>小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处。</li>
</ul>
<p>代码清单5-1 判断机器字节序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> ＜stdio.h＞ </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">byteorder</span><span class="hljs-params">()</span> &#123; <br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span> <br>        <span class="hljs-type">short</span> value; <br>        <span class="hljs-type">char</span> union_bytes[<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">short</span>)]; <br>    &#125;test; <br>    test.value=<span class="hljs-number">0x0102</span>; <br>    <span class="hljs-keyword">if</span>((test.union_bytes[<span class="hljs-number">0</span>]==<span class="hljs-number">1</span>)＆＆(test.union_bytes[<span class="hljs-number">1</span>]==<span class="hljs-number">2</span>)) &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;big endian\n&quot;</span>); <br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((test.union_bytes[<span class="hljs-number">0</span>]==<span class="hljs-number">2</span>)＆＆(test.union_bytes[<span class="hljs-number">1</span>]==<span class="hljs-number">1</span>)) &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;little endian\n&quot;</span>); <br>    &#125; <span class="hljs-keyword">else</span> &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;unknown...\n&quot;</span>); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>现代PC大多采用小端字节序，因此<strong>小端字节序又被称为主机字节序</strong>。</p>
<p>发送端总是把要发送的数据转化成大端字节序数据后再发送，而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换（小端机转换，大端机不转换）。因此大端字节序也称为网络字节序，它给所有接收数据的主机提供了一个正确解释收到的格式化数据的保证。</p>
<p>需要指出的是，即使是同一台机器上的两个进程（比如一个由C语言编写，另一个由JAVA编写）通信，也要考虑字节序的问题（JAVA虚拟机采用大端字节序）。</p>
<p>Linux提供了如下4个函数来完成主机字节序和网络字节之间的转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜netinet/in.h＞ </span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">htonl</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> hostlong)</span>; <br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-title function_">htons</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> hostshort)</span>; <br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ntohl</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> netlong)</span>; <br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ntohs</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> netshort)</span>;<br></code></pre></td></tr></table></figure>
<p>它们的含义很明确，比如htonl表示“host to network long”，即将长整型（32
bit）的主机字节序数据转化为网络字节序数据。这4个函数中，长整型函数通常用来转换IP地址，短整型函数用来转换端口号（当然不限于此。任何格式化的数据通过网络传输时，都应该使用这些函数来转换字节序）。</p>
<h3 id="通用socket地址">1.2 通用socket地址</h3>
<p>socket网络编程接口中表示socket地址的是结构体sockaddr，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜bits/socket.h＞ </span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> &#123;</span> <br>    <span class="hljs-type">sa_family_t</span> sa_family; <br>    <span class="hljs-type">char</span> sa_data[<span class="hljs-number">14</span>]; <br>&#125;<br></code></pre></td></tr></table></figure>
<p>sa_family成员是地址族类型（sa_family_t）的变量。地址族类型通常与协议族类型对应。常见的协议族（protocol
family，也称domain，见后文）和对应的地址族如表5-1所示。</p>
<p><img src="/2024/12/16/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-%E6%B8%B8%E5%8F%8C/5-Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/image-20241217220808199.png" srcset="/img/loading.gif" lazyload></p>
<p>宏PF_*和AF_*都定义在bits/socket.h头文件中，且后者与前者有完全相同的值，所以二者通常混用。</p>
<p>sa_data成员用于存放socket地址值。但是，不同的协议族的地址值具有不同的含义和长度，如表5-2所示。</p>
<p><img src="/2024/12/16/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-%E6%B8%B8%E5%8F%8C/5-Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/image-20241217221007608.png" srcset="/img/loading.gif" lazyload></p>
<p>由表5-2可见，14字节的sa_data根本无法完全容纳多数协议族的地址值。因此，Linux定义了下面这个新的通用socket地址结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜bits/socket.h＞ </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span> &#123;</span> <br>    <span class="hljs-type">sa_family_t</span> sa_family; <br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> int__ss_align; <br>    char__ss_padding[<span class="hljs-number">128</span>-<span class="hljs-keyword">sizeof</span>(__ss_align)]; <br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个结构体不仅提供了足够大的空间用于存放地址值，而且是内存对齐的（这是__ss_align成员的作用）。</p>
<h3 id="专用socket地址">1.3 专用socket地址</h3>
<p>上面这两个通用socket地址结构体显然很不好用，比如设置与获取IP地址和端口号就需要执行烦琐的位操作。所以Linux为各个协议族提供了专门的socket地址结构体。</p>
<p>UNIX本地域协议族使用如下专用socket地址结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/un.h＞ </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> &#123;</span> <br>    <span class="hljs-type">sa_family_t</span> sin_family;<span class="hljs-comment">/*地址族：AF_UNIX*/</span> <br>    <span class="hljs-type">char</span> sun_path[<span class="hljs-number">108</span>];<span class="hljs-comment">/*文件路径名*/</span> <br>&#125;;<br></code></pre></td></tr></table></figure>
<p>TCP/IP协议族有sockaddr_in和sockaddr_in6两个专用socket地址结构体，它们分别用于IPv4和IPv6：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> &#123;</span><br>    <span class="hljs-type">sa_family_t</span> sin_family;<span class="hljs-comment">/*地址族：AF_INET*/</span> <br>    <span class="hljs-type">u_int16_t</span> sin_port;<span class="hljs-comment">/*端口号，要用网络字节序表示*/</span> <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">sin_addr</span>;</span><span class="hljs-comment">/*IPv4地址结构体，见下面*/</span> <br>&#125;; <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> &#123;</span> <br>    <span class="hljs-type">u_int32_t</span> s_addr;<span class="hljs-comment">/*IPv4地址，要用网络字节序表示*/</span> <br>&#125;; <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in6</span> &#123;</span> <br>    <span class="hljs-type">sa_family_t</span> sin6_family;<span class="hljs-comment">/*地址族：AF_INET6*/</span> <br>    <span class="hljs-type">u_int16_t</span> sin6_port;<span class="hljs-comment">/*端口号，要用网络字节序表示*/</span> <br>    <span class="hljs-type">u_int32_t</span> sin6_flowinfo;<span class="hljs-comment">/*流信息，应设置为0*/</span> <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in6_addr</span> <span class="hljs-title">sin6_addr</span>;</span><span class="hljs-comment">/*IPv6地址结构体，见下面*/</span> <br>    <span class="hljs-type">u_int32_t</span> sin6_scope_id;<span class="hljs-comment">/*scope ID，尚处于实验阶段*/</span> <br>&#125;; <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in6_addr</span> &#123;</span> <br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> sa_addr[<span class="hljs-number">16</span>];<span class="hljs-comment">/*IPv6地址，要用网络字节序表示*/</span> <br>&#125;;<br></code></pre></td></tr></table></figure>
<p>所有专用socket地址（以及sockaddr_storage）类型的变量在实际使用时都需要转化为通用socket地址类型sockaddr（强制转换即可），因为所有socket编程接口使用的地址参数的类型都是sockaddr。</p>
<h3 id="ip地址转换函数">1.4 IP地址转换函数</h3>
<p>用点分十进制字符串表示的IPv4地址和用网络字节序整数表示的IPv4地址之间的转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜arpa/inet.h＞ </span><br><span class="hljs-type">in_addr_t</span> <span class="hljs-title function_">inet_addr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*strptr)</span>; <br><span class="hljs-type">int</span> <span class="hljs-title function_">inet_aton</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*cp,<span class="hljs-keyword">struct</span> in_addr*inp)</span>; <br><span class="hljs-type">char</span>*<span class="hljs-title function_">inet_ntoa</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> in_addr in)</span>;<br></code></pre></td></tr></table></figure>
<p>inet_addr函数将用点分十进制字符串表示的IPv4地址转化为用网络字节序整数表示的IPv4地址。它失败时返回INADDR_NONE。</p>
<p>inet_aton函数完成和inet_addr同样的功能，但是将转化结果存储于参数inp指向的地址结构中。它成功时返回1，失败则返回0。</p>
<p>inet_ntoa函数将用网络字节序整数表示的IPv4地址转化为用点分十进制字符串表示的IPv4地址。但需要注意的是，该函数内部用一个静态变量存储转化结果，函数的返回值指向该静态内存，因此inet_ntoa是不可重入的。代码清单5-2揭示了其不可重入性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span>*szValue1=inet_ntoa(<span class="hljs-string">&quot;1.2.3.4&quot;</span>); <br><span class="hljs-type">char</span>*szValue2=inet_ntoa(<span class="hljs-string">&quot;10.194.71.60&quot;</span>); <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;address 1:%s\n&quot;</span>,szValue1); <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;address 2:%s\n&quot;</span>,szValue2);<br></code></pre></td></tr></table></figure>
<p>运行这段代码，得到的结果是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">address1:10.194.71.60 <br>address2:10.194.71.60<br></code></pre></td></tr></table></figure>
<p>下面这对更新的函数也能完成和前面3个函数同样的功能，并且它们同时适用于IPv4地址和IPv6地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜arpa/inet.h＞ </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">inet_pton</span><span class="hljs-params">(<span class="hljs-type">int</span> af,<span class="hljs-type">const</span> <span class="hljs-type">char</span>*src,<span class="hljs-type">void</span>*dst)</span>; <br><span class="hljs-type">const</span> <span class="hljs-type">char</span>*<span class="hljs-title function_">inet_ntop</span><span class="hljs-params">(<span class="hljs-type">int</span> af,<span class="hljs-type">const</span> <span class="hljs-type">void</span>*src,<span class="hljs-type">char</span>*dst,<span class="hljs-type">socklen_t</span> cnt)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>inet_pton函数将用字符串表示的IP地址src（用点分十进制字符串表示的IPv4地址或用十六进制字符串表示的IPv6地址）转换成用网络字节序整数表示的IP地址，并把转换结果存储于dst指向的内存中。
<ul>
<li>其中，af参数指定地址族，可以是AF_INET或者AF_INET6。inet_pton成功时返回1，失败则返回0并设置errno[1]。</li>
<li>inet_ntop函数进行相反的转换，前三个参数的含义与inet_pton的参数相同，最后一个参数cnt指定目标存储单元的大小。下面的两个宏能帮助我们指定这个大小（分别用于IPv4和IPv6）：</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜netinet/in.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INET_ADDRSTRLEN 16 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INET6_ADDRSTRLEN 46</span><br></code></pre></td></tr></table></figure>
<p>inet_ntop成功时返回目标存储单元的地址，失败则返回NULL并设置errno。</p>
<h2 id="创建socket">2. 创建socket</h2>
<p>UNIX/Linux的一个哲学是：所有东西都是文件。socket也不例外，它就是可读、可写、可控制、可关闭的文件描述符。下面的socket系统调用可创建一个socket：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/types.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/socket.h＞ </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain,<span class="hljs-type">int</span> type,<span class="hljs-type">int</span> protocol)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>domain参数告诉系统使用哪个底层协议族。
<ul>
<li>对TCP/IP协议族而言，该参数应该设置为PF_INET（Protocol Family of
Internet，用于IPv4）或PF_INET6（用于IPv6）；</li>
<li>对于UNIX本地域协议族而言，该参数应该设置为PF_UNIX。</li>
</ul></li>
<li>type参数指定服务类型。服务类型主要有SOCK_STREAM服务（流服务）和SOCK_UGRAM（数据报）服务。
<ul>
<li>对TCP/IP协议族而言，其值取SOCK_STREAM表示传输层使用TCP协议，</li>
<li>取SOCK_DGRAM表示传输层使用UDP协议。</li>
<li>自Linux内核版本2.6.17起，type参数可以接受上述服务类型与下面两个重要的标志相与的值：SOCK_NONBLOCK和SOCK_CLOEXEC。它们分别表示将新创建的socket设为非阻塞的，以
及用fork调用创建子进程时在子进程中关闭该socket。</li>
<li>在内核版本2.6.17之前的Linux中，文件描述符的这两个属性都需要使用额外的系统调用（比如fcntl）来设置。</li>
</ul></li>
<li>protocol参数是在前两个参数构成的协议集合下，再选择一个具体的协议。不过这个值通常都是唯一的（前两个参数已经完全决定了它的值）。几乎在所有情况下，我们都应该把它设置为0，表示使用默认协议。</li>
<li>socket系统调用成功时返回一个socket文件描述符，失败则返回-1并设置errno。</li>
</ul>
<h2 id="命名socket">3. 命名socket</h2>
<p>将一个socket与socket地址绑定称为给socket命名。</p>
<p>在服务器程序中，我们通常要命名socket，因为只有命名后客户端才能知道该如何连接它。</p>
<p>客户端则通常不需要命名socket，而是采用匿名方式，即使用操作系统自动分配的socket地址。</p>
<p>命名socket的系统调用是bind，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/types.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/socket.h＞ </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr*my_addr,<span class="hljs-type">socklen_t</span> addrlen)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>bind将my_addr所指的socket地址分配给未命名的sockfd文件描述符，</li>
<li>addrlen参数指出该socket地址的长度。</li>
<li>bind成功时返回0，失败则返回-1并设置errno。其中两种常见的errno是EACCES和EADDRINUSE，它们的含义分别是：
<ul>
<li>EACCES，被绑定的地址是受保护的地址，仅超级用户能够访问。比如普通用户将socket绑定到知名服务端口（端口号为0～1023）上时，bind将返回EACCES错误。</li>
<li>EADDRINUSE，被绑定的地址正在使用中。比如将socket绑定到一个处于TIME_WAIT状态的socket地址。</li>
</ul></li>
</ul>
<h2 id="监听socket">4. 监听socket</h2>
<p>socket被命名之后，还不能马上接受客户连接，创建一个监听队列以存放待处理的客户连接：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/socket.h＞ </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">listen</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-type">int</span> backlog)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>sockfd参数指定被监听的socket。</li>
<li>backlog参数提示内核监听队列的最大长度。监听队列的长度如果超过backlog，服务器将不受理新的客
户连接，客户端也将收到ECONNREFUSED错误信息。在内核版本2.2之前的Linux中，backlog参数是指所有处于半连接状态（SYN_RCVD）和完全连接状态（ESTABLISHED）的socket的上限。但自内核版本2.2之后，它只表示处于完全连接状态的socket的上限，处于半连接状态的socket的上限则由/proc/sys/net/ipv4/tcp_max_syn_backlog内核参数定义。backlog参数的典型值是5。</li>
<li>listen成功时返回0，失败则返回-1并设置errno。
下面我们编写一个服务器程序，如代码清单5-3所示，以研究backlog参数对listen系统调用的实际影响。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/socket.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜netinet/in.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜arpa/inet.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜signal.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜unistd.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜stdlib.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜assert.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜stdio.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜string.h＞ </span><br><span class="hljs-type">static</span> <span class="hljs-type">bool</span> stop=<span class="hljs-literal">false</span>; <span class="hljs-comment">/*SIGTERM信号的处理函数，触发时结束主程序中的*/</span> <br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">handle_term</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> &#123; <br>    stop=<span class="hljs-literal">true</span>; <br>&#125; <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>*argv[])</span> <br>&#123; <br>    signal(SIGTERM,handle_term); <br>    <span class="hljs-keyword">if</span>(argc＜=<span class="hljs-number">3</span>) &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage:%s ip_address port_number backlog\n&quot;</span>,basename(argv[<span class="hljs-number">0</span>])); <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br>    &#125; <br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*ip=argv[<span class="hljs-number">1</span>]; <br>    <span class="hljs-type">int</span> port=atoi(argv[<span class="hljs-number">2</span>]); <br>    <span class="hljs-type">int</span> backlog=atoi(argv[<span class="hljs-number">3</span>]); <br>    <span class="hljs-type">int</span> sock=socket(PF_INET,SOCK_STREAM,<span class="hljs-number">0</span>); <br>    assert(sock＞=<span class="hljs-number">0</span>); <span class="hljs-comment">/*创建一个IPv4 socket地址*/</span> <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span> <br>    bzero(＆address,<span class="hljs-keyword">sizeof</span>(address)); <br>    address.sin_family=AF_INET; <br>    inet_pton(AF_INET,ip,＆address.sin_addr); <br>    address.sin_port=htons(port); <br>    <span class="hljs-type">int</span> ret=bind(sock,(<span class="hljs-keyword">struct</span> sockaddr*)＆address,<span class="hljs-keyword">sizeof</span>(address)); <br>    assert(ret!=<span class="hljs-number">-1</span>); <br>    ret=listen(sock,backlog); <br>    assert(ret!=<span class="hljs-number">-1</span>); <span class="hljs-comment">/*循环等待连接，直到有SIGTERM信号将它中断*/</span> <br>    <span class="hljs-keyword">while</span>(!stop) &#123; <br>        sleep(<span class="hljs-number">1</span>); <br>    &#125; <span class="hljs-comment">/*关闭socket，见后文*/</span> <br>    close(sock); <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>该服务器程序（命名为testlisten）接收3个参数：IP地址、端口号和backlog值。我们在Kongming20上运行该服务器程序，并在ernest-laptop上多次执行telnet命令来连接该服务器程序。同时，每使用telnet命令建立一个连接，就执行一次netstat命令来查看服务器上连接的状态。具体操作过程如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">./testlisten 192.168.1.109 12345 5 <span class="hljs-comment">#监听12345端口，给backlog传递典</span><br>型值5<br>telnet 192.168.1.109 12345 <span class="hljs-comment">#多次执行之 </span><br>netstat-nt|grep 12345 <span class="hljs-comment">#多次执行之</span><br></code></pre></td></tr></table></figure>
<p>代码清单5-4是netstat命令某次输出的内容，它显示了这一时刻listen监听队列的内容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">Proto Recv-Q Send-Q Local Address Foreign Address State<br>tcp 0 0 192.168.1.109:12345 192.168.1.108:2240 SYN_RECV<br>tcp 0 0 192.168.1.109:12345 192.168.1.108:2228 SYN_RECV<br>tcp 0 0 192.168.1.109:12345 192.168.1.108:2230 SYN_RECV <br>tcp 0 0 192.168.1.109:12345 192.168.1.108:2238 SYN_RECV <br>tcp0 0 192.168.1.109:12345 192.168.1.108:2236 SYN_RECV <br>tcp0 0 192.168.1.109:12345 192.168.1.108:2217 ESTABLISHED <br>tcp0 0 192.168.1.109:12345 192.168.1.108:2226 ESTABLISHED <br>tcp0 0 192.168.1.109:12345 192.168.1.108:2224 ESTABLISHED <br>tcp0 0 192.168.1.109:12345 192.168.1.108:2212 ESTABLISHED <br>tcp0 0 192.168.1.109:12345 192.168.1.108:2220 ESTABLISHED<br></code></pre></td></tr></table></figure>
<p>可见，在监听队列中，处于ESTABLISHED状态的连接只有6个（backlog值加1），其他的连接都处于SYN_RCVD状态。我们改变服务器程序的第3个参数并重新运行之，能发现同样的规律，即完整连接最多有（backlog+1）个。在不同的系统上，运行结果会有些差别，不过监听队列中完整连接的上限通常比backlog值略大。</p>
<h2 id="接受连接">5. 接受连接</h2>
<p>下面的系统调用从listen队列中接受一个连接：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/types.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/socket.h＞ </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-keyword">struct</span> sockaddr*addr,<span class="hljs-type">socklen_t</span>*addrlen)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>sockfd参数是执行过listen系统调用的监听socket[1]。</li>
<li>addr参数用来获取被接受连接的远端socket地址，该socket地址的长度由addrlen参数指出。</li>
<li>accept成功时返回一个新的连接socket，该socket唯一地标识了被接受的这个连接，服务器可通过读写该socket来与被接受连接对应的客户端通信。</li>
<li>accept失败时返回-1并设置errno。</li>
</ul>
<p>现在考虑如下情况：如果监听队列中处于ESTABLISHED状态的连接对应的客户端出现网络异常（比如掉线），或者提前退出，那么服务器对这个连接执行的accept调用是否成功？我们编写一个简单的服务器程序来测试之，如代码清单5-5所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/socket.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜netinet/in.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜arpa/inet.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜assert.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜stdio.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜unistd.h＞</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜stdlib.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜errno.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜string.h＞ </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>*argv[])</span> &#123; <br>    <span class="hljs-keyword">if</span>(argc＜=<span class="hljs-number">2</span>) &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage:%s ip_address port_number\n&quot;</span>,basename(argv[<span class="hljs-number">0</span>])); <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br>    &#125; <br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*ip=argv[<span class="hljs-number">1</span>]; <br>    <span class="hljs-type">int</span> port=atoi(argv[<span class="hljs-number">2</span>]); <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span> <br>    bzero(＆address,<span class="hljs-keyword">sizeof</span>(address)); <br>    address.sin_family=AF_INET; <br>    inet_pton(AF_INET,ip,＆address.sin_addr); <br>    address.sin_port=htons(port); <br>    <span class="hljs-type">int</span> sock=socket(PF_INET,SOCK_STREAM,<span class="hljs-number">0</span>); <br>    assert(sock＞=<span class="hljs-number">0</span>); <br>    <span class="hljs-type">int</span> ret=bind(sock,(<span class="hljs-keyword">struct</span> sockaddr*)＆address,<span class="hljs-keyword">sizeof</span>(address)); <br>    assert(ret!=<span class="hljs-number">-1</span>); <br>    ret=listen(sock,<span class="hljs-number">5</span>); <br>    assert(ret!=<span class="hljs-number">-1</span>); <br>    <span class="hljs-comment">/*暂停20秒以等待客户端连接和相关操作（掉线或者退出）完成*/</span> <br>    sleep(<span class="hljs-number">20</span>); <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span> <br>    <span class="hljs-type">socklen_t</span> client_addrlength=<span class="hljs-keyword">sizeof</span>(client); <br>    <span class="hljs-type">int</span> connfd=accept(sock,(<span class="hljs-keyword">struct</span> sockaddr*)＆client,＆    client_addrlength);<br>    <span class="hljs-keyword">if</span>(connfd＜<span class="hljs-number">0</span>) &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;errno is:%d\n&quot;</span>,errno); <br>    &#125; <span class="hljs-keyword">else</span> &#123; <br>        <span class="hljs-comment">/*接受连接成功则打印出客户端的IP地址和端口号*/</span> <br>        <span class="hljs-type">char</span> remote[INET_ADDRSTRLEN]; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connected with ip:%s and port:%d\n&quot;</span>,inet_ntop(AF_INET,＆<br>        client.sin_addr,remote,INET_ADDRSTRLEN),ntohs(client.sin_port));<br>        close(connfd); <br>    &#125; <br>    close(sock); <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125; <br></code></pre></td></tr></table></figure>
<p>我们在Kongming20上运行该服务器程序（名为testaccept），并在ernest-laptop上执行telnet命令来连接该服务器程序。具体操作过程如下：
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">./testaccept 192.168.1.109 54321#监听54321端口 <br>telnet 192.168.1.109 54321<br></code></pre></td></tr></table></figure>
启动telnet客户端程序后，立即断开该客户端的网络连接（建立和断开连接的过程要在服务器启动后20秒内完成）。结果发现accept调用能够正常返回，服务器输出如下：
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">connected</span> with ip:<span class="hljs-number">192.168.1.108</span> and port:<span class="hljs-number">38545</span><br></code></pre></td></tr></table></figure>
接着，在服务器上运行netstat命令以查看accept返回的连接socket的状态：
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat-nt|grep 54321 <br>tcp 0 0 192.168.1.109:54321 192.168.1.108:38545 ESTABLISHED<br></code></pre></td></tr></table></figure>
netstat命令的输出说明，accept调用对于客户端网络断开毫不知情。下面我们重新执行上述过程，不过这次不断开客户端网络连接，而是在建立连接后立即退出客户端程序。这次accept调用同样正常返回，服务器输出如下：
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">connected</span> with ip:<span class="hljs-number">192.168.1.108</span> and port:<span class="hljs-number">52070</span><br></code></pre></td></tr></table></figure> 再次在服务器上运行netstat命令： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat-nt|grep 54321 <br>tcp 1 0 192.168.1.109:54321 192.168.1.108:52070 CLOSE_WAIT<br></code></pre></td></tr></table></figure>
由此可见，accept只是从监听队列中取出连接，而不论连接处于何种状态（如上面的ESTABLISHED状态和CLOSE_WAIT状态），更不关心任何网络状况的变化。</p>
<p>[1]
我们把执行过listen调用、处于LISTEN状态的socket称为监听socket，而所有处于ESTABLISHED状态的socket则称为连接socket。</p>
<h2 id="发起连接">6. 发起连接</h2>
<p>如果说服务器通过listen调用来被动接受连接，那么客户端需要通过如下系统调用来主动与服务器建立连接：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/types.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/socket.h＞ </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr*serv_addr,<span class="hljs-type">socklen_t</span> addrlen)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>sockfd参数由socket系统调用返回一个socket。</li>
<li>serv_addr参数是服务器监听的socket地址，</li>
<li>addrlen参数则指定这个地址的长度。</li>
<li>connect成功时返回0。一旦成功建立连接，sockfd就唯一地标识了这个连接，客户端就可以通过读写sockfd来与服务器通信。</li>
<li>connect失败则返回-1并设置errno。</li>
<li>其中两种常见的errno是ECONNREFUSED和ETIMEDOUT，它们的含义如下：
<ul>
<li>ECONNREFUSED，目标端口不存在，连接被拒绝。</li>
<li>ETIMEDOUT，连接超时。</li>
</ul></li>
</ul>
<h2 id="关闭连接">7. 关闭连接</h2>
<p>关闭一个连接实际上就是关闭该连接对应的socket，这可以通过如下关闭普通文件描述符的系统调用来完成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜unistd.h＞ </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>fd参数是待关闭的socket。</li>
<li>不过，close系统调用并非总是立即关闭一个连接，而是将fd的引用计数减1。只有当fd的引用计数为0时，才真正关闭连接。</li>
<li>多进程程序中，一次fork系统调用默认将使父进程中打开的socket的引用计数加1，因此我们必须在父进程和子进程中都对该socket执行close调用才能将连接关闭。</li>
<li>如果无论如何都要立即终止连接（而不是将socket的引用计数减1），可以使用如下的shutdown系统调用（相对于close来说，它是专门针对网络编程设计的）：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/socket.h＞ </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-type">int</span> howto)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>sockfd参数是待关闭的socket。</li>
<li>howto参数决定了shutdown的行为，它可取表5-3中的某个值。</li>
</ul>
<p><img src="/2024/12/16/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-%E6%B8%B8%E5%8F%8C/5-Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/image-20241218102201513.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>由此可见，shutdown能够分别关闭socket上的读或写，或者都关闭。而close在关闭连接时只能将socket上的读和写同时关闭。shutdown成功时返回0，失败则返回-1并设置errno。</li>
</ul>
<h2 id="数据读写">8. 数据读写</h2>
<h3 id="tcp数据读写">8.1 TCP数据读写</h3>
<p>对文件的读写操作read和write同样适用于socket。但是socket编程接口提供了几个专门用于socket数据读写的系统调用，它们增加了对数据读写的控制。其中用于TCP流数据读写的系统调用是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/types.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/socket.h＞ </span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recv</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-type">void</span>*buf,<span class="hljs-type">size_t</span> len,<span class="hljs-type">int</span> flags)</span>; <br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">send</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-type">const</span> <span class="hljs-type">void</span>*buf,<span class="hljs-type">size_t</span> len,<span class="hljs-type">int</span> flags)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>recv读取sockfd上的数据，</p></li>
<li><p>buf和len参数分别指定读缓冲区的位置和大小，</p></li>
<li><p>flags参数的含义见后文，通常设置为0即可。</p></li>
<li><p>recv成功时返回实际读取到的数据的长度，它可能小于我们期望的长度len。因此我们可能要多次调用recv，才能读取到完整的数据。recv可能返回0，这意味着通信对方已经关闭连接了。recv出错时返回-1并设置errno。</p></li>
<li><p>send往sockfd上写入数据，buf和len参数分别指定写缓冲区的位置和大小。send成功时返回实际写入的数据的长度，失败则返回-1并设置errno。</p></li>
<li><p>flags参数为数据收发提供了额外的控制，它可以取表5-4所示选项中的一个或几个的逻辑或。[1]</p></li>
</ul>
<p><img src="/2024/12/16/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-%E6%B8%B8%E5%8F%8C/5-Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/image-20241218102503163.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>我们举例来说明如何使用这些选项。MSG_OOB选项给应用程序提供了发送和接收带外数据的方法，如代码清单5-6和代码清单5-7所示。</li>
</ul>
<p>代码清单5-6 发送带外数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(argc &lt;= <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, basename(argv[<span class="hljs-number">0</span>]));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> port = atoi(argv[<span class="hljs-number">2</span>]);<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server_address</span>;</span><br>    bzero(&amp;server_address, <span class="hljs-keyword">sizeof</span>(server_address));<br>    server_address.sin_family = AF_INET;<br>    inet_pton(AF_INET, ip, &amp;server_address.sin_addr);<br>    server_address.sin_port = htons(port);<br><br>    <span class="hljs-type">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    assert(sockfd &gt;= <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(connect(sockfd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;server_address, <span class="hljs-keyword">sizeof</span>(server_address)))&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connect failed\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;send oob data out\n&quot;</span>);<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* oob_data = <span class="hljs-string">&quot;abc&quot;</span>;<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* normal_data = <span class="hljs-string">&quot;123&quot;</span>;<br>        send(sockfd, normal_data, <span class="hljs-built_in">strlen</span>(normal_data), <span class="hljs-number">0</span>);<br>        send(sockfd, oob_data, <span class="hljs-built_in">strlen</span>(oob_data), MSG_OOB);<br>        send(sockfd, normal_data, <span class="hljs-built_in">strlen</span>(normal_data), <span class="hljs-number">0</span>);<br>    &#125;<br><br>    close(sockfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>代码清单5-7 接收带外数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 1024</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(argc &lt;= <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, basename(argv[<span class="hljs-number">0</span>]));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> port = atoi(argv[<span class="hljs-number">2</span>]);<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    bzero(&amp;address, <span class="hljs-keyword">sizeof</span>(address));<br>    address.sin_family = AF_INET;<br>    inet_pton(AF_INET, ip, &amp;address.sin_addr);<br>    address.sin_port = htons(port);<br><br>    <span class="hljs-type">int</span> sock = socket(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    assert(sock &gt;= <span class="hljs-number">0</span>);<br><br>    <span class="hljs-type">int</span> ret = bind (sock, (<span class="hljs-keyword">struct</span> sockaddr* )&amp;address, <span class="hljs-keyword">sizeof</span>(address));<br>    assert(ret != <span class="hljs-number">-1</span>);<br><br>    ret = listen(sock, <span class="hljs-number">5</span>);<br>    assert(ret != <span class="hljs-number">-1</span>);<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span><br>    <span class="hljs-type">socklen_t</span> client_addrlength = <span class="hljs-keyword">sizeof</span>(client);<br>    <span class="hljs-type">int</span> connfd = accept(sock, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;client, &amp;client_addrlength);<br>    <span class="hljs-keyword">if</span>(connfd &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;errno is : %d\n&quot;</span>, errno);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">char</span> buffer[BUF_SIZE];<br><br>        <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-string">&#x27;\0&#x27;</span>, BUF_SIZE);<br>        ret = recv(connfd, buffer, BUF_SIZE - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;got %d bytes of normal data &#x27;%s&#x27;\n&quot;</span>, ret, buffer);<br><br>        <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-string">&#x27;\0&#x27;</span>, BUF_SIZE);<br>        ret = recv(connfd, buffer, BUF_SIZE - <span class="hljs-number">1</span>, MSG_OOB);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;got %d bytes of oob data &#x27;%s&#x27;\n&quot;</span>, ret, buffer);<br><br>        <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-string">&#x27;\0&#x27;</span>, BUF_SIZE);<br>        ret = recv(connfd, buffer, BUF_SIZE - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;got %d bytes of normal data &#x27;%s&#x27;\n&quot;</span>, ret, buffer);<br><br>        close(connfd);<br>    &#125;<br>    close(sock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们先在Kongming20上启动代码清单5-7所示的服务器程序（名为testoobrecv），然后从ernest-laptop上执行代码清单5-6所示的客户端程序（名为testoobsend）来向服务器发送带外数据。同时用tcpdump抓取这一过程中客户端和服务器交换的TCP报文段。具体操作如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$./testoobrecv 192.168.1.109 54321 <span class="hljs-comment">#在Kongming20上执行服务器程序，监听54321端口</span><br>$./testoobsend 192.168.1.109 54321 <span class="hljs-comment">#在ernest-laptop上执行客户端程序 </span><br><span class="hljs-built_in">sudo</span> tcpdump-ntx-i eth0 port 54321<br></code></pre></td></tr></table></figure>
<p>服务器程序的输出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">got 5 bytes of normal data <span class="hljs-string">&#x27;123ab&#x27;</span> <br>got 1 bytes of oob data <span class="hljs-string">&#x27;c&#x27;</span> <br>got 3 bytes of normal data <span class="hljs-string">&#x27;123&#x27;</span><br></code></pre></td></tr></table></figure>
<p>由此可见，客户端发送给服务器的3字节的带外数据“abc”中，仅有最后一个字符“c”被服务器当成真正的带外数据接收。并且，服务器对正常数据的接收将被带外数据截断，即前一部分正常数据“123ab”和后续的正常数据“123”是不能被一个recv调用全部读出的。</p>
<p>tcpdump的输出内容中，和带外数据相关的是代码清单5-8所示的TCP报文段。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">IP 192.168.1.108.60460＞192.168.1.109.54321:Flags[P.U],<span class="hljs-built_in">seq</span> <br>4:7,ack 1,win 92,urg 3,options[nop,nop,TS val 102794322 ecr 154703423],length 3<br></code></pre></td></tr></table></figure>
<ul>
<li>这里我们第一次看到tcpdump输出标志U，这表示该TCP报文段的头部被设置了紧急标志。“urg
3”是紧急偏移值，它指出带外数据在字节流中的位置的下一字节位置是7（3+4，其中4是该TCP报文段的序号值相对初始序号值的偏移）。因此，带外数据是字节流中的第6字节，即字符“c”。</li>
<li>值得一提的是，<strong>flags参数只对send和recv的当前调用生效</strong>，而后面我们将看到如何通过setsockopt系统调用永久性地修改socket的某些属性。</li>
</ul>
<h3 id="udp数据读写">8.2 UDP数据读写</h3>
<p>socket编程接口中用于UDP数据报读写的系统调用是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/types.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/socket.h＞ </span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recvfrom</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-type">void</span>*buf,<span class="hljs-type">size_t</span> len,<span class="hljs-type">int</span> flags,<span class="hljs-keyword">struct</span> sockaddr*src_addr,<span class="hljs-type">socklen_t</span>*addrlen)</span>;<br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sendto</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-type">const</span> <span class="hljs-type">void</span>*buf,<span class="hljs-type">size_t</span> len,<span class="hljs-type">int</span> flags,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr*dest_addr,<span class="hljs-type">socklen_t</span> addrlen)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>recvfrom读取sockfd上的数据，
<ul>
<li>buf和len参数分别指定读缓冲区的位置和大小。</li>
<li>因为UDP通信没有连接的概念，所以我们每次读取数据都需要获取发送端的socket地址，即参数src_addr所指的内容，addrlen参数则指定该地址的长度。</li>
</ul></li>
<li>sendto往sockfd上写入数据，
<ul>
<li>buf和len参数分别指定写缓冲区的位置和大小。</li>
<li>dest_addr参数指定接收端的socket地址，addrlen参数则指定该地址的长度。</li>
</ul></li>
<li>这两个系统调用的flags参数以及返回值的含义均与send/recv系统调用的flags参数及返回值相同。</li>
<li>值得一提的是，recvfrom/sendto系统调用也可以用于面向连接（STREAM）的socket的数据读写，只需要把最后两个参数都设置为NULL以忽略发送端/接收端的socket地址（因为我们已经和对方建立了连接，所以已经知道其socket地址了）。</li>
</ul>
<h3 id="通用数据读写函数">8.3 通用数据读写函数</h3>
<p>socket编程接口还提供了一对通用的数据读写系统调用。它们不仅能用于TCP流数据，也能用于UDP数据报：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/socket.h＞ </span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recvmsg</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-keyword">struct</span> msghdr*msg,<span class="hljs-type">int</span> flags)</span>; <br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sendmsg</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-keyword">struct</span> msghdr*msg,<span class="hljs-type">int</span> flags)</span>;<br></code></pre></td></tr></table></figure>
<p>sockfd参数指定被操作的目标socket。msg参数是msghdr结构体类型的指针，msghdr结构体的定义如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msghdr</span> &#123;</span><br>    <span class="hljs-type">void</span>*msg_name;<span class="hljs-comment">/*socket地址*/</span> <br>    <span class="hljs-type">socklen_t</span> msg_namelen;<span class="hljs-comment">/*socket地址的长度*/</span> <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span>*<span class="hljs-title">msg_iov</span>;</span><span class="hljs-comment">/*分散的内存块，见后文*/</span> <br>    <span class="hljs-type">int</span> msg_iovlen;<span class="hljs-comment">/*分散内存块的数量*/</span> <br>    <span class="hljs-type">void</span>*msg_control;<span class="hljs-comment">/*指向辅助数据的起始位置*/</span> <br>    <span class="hljs-type">socklen_t</span> msg_controllen;<span class="hljs-comment">/*辅助数据的大小*/</span> <br>    <span class="hljs-type">int</span> msg_flags;<span class="hljs-comment">/*复制函数中的flags参数，并在调用过程中更新*/</span><br>&#125;;<br></code></pre></td></tr></table></figure> -
msg_name成员指向一个socket地址结构变量。它指定通信对方的socket地址。对于面向连接的TCP协议，该成员没有意义，必须被设置为NULL。这是因为对数据流socket而言，对方的地址已经知道。
- msg_namelen成员则指定了msg_name所指socket地址的长度。 -
msg_iov成员是iovec结构体类型的指针，iovec结构体的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> &#123;</span><br>    <span class="hljs-type">void</span>*iov_base;<span class="hljs-comment">/*内存起始地址*/</span><br>    <span class="hljs-type">size_t</span> iov_len;<span class="hljs-comment">/*这块内存的长度*/</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>由上可见，iovec结构体封装了一块内存的起始位置和长度。</p>
<ul>
<li>msg_iovlen指定这样的iovec结构对象有多少个。</li>
<li>对于recvmsg而言，数据将被读取并存放在msg_iovlen块分散的内存中，这些内存的位置和长度则由msg_iov指向的数组指定，这称为分散读（scatter
read）；</li>
<li>对于sendmsg而言，msg_iovlen块分散内存中的数据将被一并发送，这称为集中写（gather
write）。</li>
</ul>
<p>msg_control和msg_controllen成员用于辅助数据的传送。</p>
<ul>
<li>msg_flags成员无须设定，它会复制recvmsg/sendmsg的flags参数的内容以影响数据读写过程。</li>
<li>recvmsg还会在调用结束前，将某些更新后的标志设置到msg_flags中。</li>
<li>recvmsg/sendmsg的flags参数以及返回值的含义均与send/recv的flags参数及返回值相同。</li>
</ul>
<p>[1]由于socket连接是全双工的，这里的“读端”是针对通信对方而言的。</p>
<h2 id="带外标记">9. 带外标记</h2>
<p>代码清单5-7演示了TCP带外数据的接收方法。但在实际应用中，我们通常无法预期带外数据何时到来。好在Linux内核检测到TCP紧急标志时，将通知应用程序有带外数据需要接收。内核通知应用程序带外数据到达的两种常见方式是：I/O复用产生的异常事件和SIGURG信号。但是，即使应用程序得到了有带外数据需要接收的通知，还需要知道带外数据在数据流中的具体位置，才能准确接收带外数据。这一点可通过如下系统调用实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/socket.h＞ </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sockatmark</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span>;<br></code></pre></td></tr></table></figure>
<p>sockatmark判断sockfd是否处于带外标记，即下一个被读取到的数据是否是带外数据。</p>
<p>如果是，sockatmark返回1，此时我们就可以利用带MSG_OOB标志的recv调用来接收带外数据。</p>
<p>如果不是，则sockatmark返回0。</p>
<h2 id="地址信息函数">10. 地址信息函数</h2>
<p>在某些情况下，我们想知道一个连接socket的本端socket地址，以及远端的socket地址。下面这两个函数正是用于解决这个问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/socket.h＞ </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getsockname</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-keyword">struct</span> sockaddr*address,<span class="hljs-type">socklen_t</span>*address_len)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">getpeername</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-keyword">struct</span> sockaddr*address,<span class="hljs-type">socklen_t</span>*address_len)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>getsockname
<ul>
<li>获取sockfd对应的本端socket地址，</li>
<li>并将其存储于address参数指定的内存中，</li>
<li>该socket地址的长度则存储于address_len参数指向的变量中。如果实际socket地址的长度大于address所指内存区的大小，那么该socket地址将被截断。</li>
<li>getsockname成功时返回0，失败返回-1并设置errno。</li>
</ul></li>
<li>getpeername
<ul>
<li>获取sockfd对应的远端socket地址，其参数及返回值的含义与getsockname的参数及返回值相同。</li>
</ul></li>
</ul>
<h2 id="socket选项">11. socket选项</h2>
<p>如果说fcntl系统调用是控制文件描述符属性的通用POSIX方法，那么下面两个系统调用则是专门用来读取和设置socket文件描述符属性的方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/socket.h＞ </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getsockopt</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-type">int</span> level,<span class="hljs-type">int</span> option_name,<span class="hljs-type">void</span>*option_value,<span class="hljs-type">socklen_t</span>*<span class="hljs-keyword">restrict</span> option_len)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">setsockopt</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-type">int</span> level,<span class="hljs-type">int</span> option_name,<span class="hljs-type">const</span></span><br><span class="hljs-params"><span class="hljs-type">void</span>*option_value,<span class="hljs-type">socklen_t</span> option_len)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>sockfd参数指定被操作的目标socket。</p></li>
<li><p>level参数指定要操作哪个协议的选项（即属性），比如IPv4、IPv6、TCP等。</p></li>
<li><p>option_name参数则指定选项的名字。</p></li>
<li><p>我们在表5-5中列举了socket通信中几个比较常用的socket选项。option_value和option_len参数分别是被操作选项的值和长度。不同的选项具有不同类型的值，如表5-5中“数据类型”一列所示。</p></li>
</ul>
<p><img src="/2024/12/16/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-%E6%B8%B8%E5%8F%8C/5-Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/image-20241218103926985.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>getsockopt和setsockopt这两个函数成功时返回0，失败时返回-1并设置errno。</li>
<li>值得指出的是，对服务器而言，有部分socket选项只能在调用listen系统调用前针对监听socket[1]设置才有效。这是因为连接socket只能由accept调用返回，</li>
<li>而accept从listen监听队列中接受的连接至少已经完成了TCP三次握手的前两个步骤（因为listen监听队列中的连接至少已进入SYN_RCVD状态，参见图3-8和代码清单5-4），这说明服务器已经往被接受连接上发送出了TCP同步报文段。</li>
<li>但有的socket选项却应该在TCP同步报文段中设置，比如TCP最大报文段选项（回忆3.2.2小节，该选项只能由同步报文段来发送）。</li>
<li>对这种情况，Linux给开发人员提供的解决方案是：对监听socket设置这些socket选项，那么accept返回的连接socket将自动继承这些选项。</li>
<li>这些socket选项包括：SO_DEBUG、SO_DONTROUTE、SO_KEEPALIVE、SO_LINGER、SO_OOBINLINE、SO_RCVBUF、SO_RCVLOWAT、SO_SNDBUF、SO_SNDLOWAT、TCP_MAXSEG和TCP_NODELAY。而对客户端而言，这些socket选项则应该在调用connect函数之前设置，因为connect调用成功返回之后，TCP三次握手已完成。</li>
</ul>
<h3 id="so_reuseaddr选项">11.1 SO_REUSEADDR选项</h3>
<p>我们在3.4.2小节讨论过TCP连接的TIME_WAIT状态，并提到服务器程序可以通过设置socket选项SO_REUSEADDR来强制使用被处于TIME_WAIT状态的连接占用的socket地址。具体实现方法如代码清单5-9所示。</p>
<p>代码清单5-9 重用本地地址 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> sock=socket(PF_INET,SOCK_STREAM,<span class="hljs-number">0</span>); <br>assert(sock＞=<span class="hljs-number">0</span>); <br><span class="hljs-type">int</span> reuse=<span class="hljs-number">1</span>; <br>setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,＆reuse,<span class="hljs-keyword">sizeof</span>(reuse)); <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span> <br>bzero(＆address,<span class="hljs-keyword">sizeof</span>(address)); <br>address.sin_family=AF_INET; <br>inet_pton(AF_INET,ip,＆address.sin_addr); <br>address.sin_port=htons(port); <br><span class="hljs-type">int</span> ret=bind(sock,(<span class="hljs-keyword">struct</span> sockaddr*)＆address,<span class="hljs-keyword">sizeof</span>(address));<br></code></pre></td></tr></table></figure>
<strong>经过setsockopt的设置之后，即使sock处于TIME_WAIT状态，与之绑定的socket地址也可以立即被重用。</strong>此外，我们也可以通过修改内核参数/proc/sys/net/ipv4/tcp_tw_recycle来快速回收被关闭的socket，从而使得TCP连接根本就不进入TIME_WAIT状态，进而允许应用程序立即重用本地的socket地址。</p>
<h3 id="so_rcvbuf和so_sndbuf选项">11.2 SO_RCVBUF和SO_SNDBUF选项</h3>
<p>SO_RCVBUF和SO_SNDBUF选项分别表示TCP接收缓冲区和发送缓冲区的大小。</p>
<p>不过，当我们用setsockopt来设置TCP的接收缓冲区和发送缓冲区的大小时，系统都会将其值加倍，并且不得小于某个最小值。TCP接收缓冲区的最小值是256字节，而发送缓冲区的最小值是2048字节（不过，不同的系统可能有不同的默认最小值）。</p>
<p>系统这样做的目的，主要是确保一个TCP连接拥有足够的空闲缓冲区来处理拥塞（比如快速重传算法就期望TCP接收缓冲区能至少容纳4个大小为SMSS的TCP报文段）。此外，我们可以直接修改内核参数/proc/sys/net/ipv4/tcp_rmem和/proc/sys/net/ipv4/tcp_wmem来强制TCP接收缓冲区和发送缓冲区的大小没有最小值限制。我们将在第16章讨论这两个内核参数。</p>
<p>下面我们编写一对客户端和服务器程序，如代码清单5-10和代码清单5-11所示，它们分别修改TCP发送缓冲区和接收缓冲区的大小。</p>
<p>代码清单5-10 修改TCP发送缓冲区的客户端程序 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/socket.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜arpa/inet.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜assert.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜stdio.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜unistd.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜string.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜stdlib.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE  512 </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>*argv[])</span> &#123; <br>    <span class="hljs-keyword">if</span>(argc＜=<span class="hljs-number">2</span>) &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage:%s ip_address port_numbersend_bufer_size\n&quot;</span>,basename(argv[<span class="hljs-number">0</span>]));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br>    &#125; <br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*ip=argv[<span class="hljs-number">1</span>]; <br>    <span class="hljs-type">int</span> port=atoi(argv[<span class="hljs-number">2</span>]); <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server_address</span>;</span> <br>    bzero(＆server_address,<span class="hljs-keyword">sizeof</span>(server_address)); <br>    server_address.sin_family=AF_INET; <br>    inet_pton(AF_INET,ip,＆server_address.sin_addr); <br>    server_address.sin_port=htons(port); <br>    <span class="hljs-type">int</span> sock=socket(PF_INET,SOCK_STREAM,<span class="hljs-number">0</span>); <br>    assert(sock＞=<span class="hljs-number">0</span>); <br>    <span class="hljs-type">int</span> sendbuf=atoi(argv[<span class="hljs-number">3</span>]); <br>    <span class="hljs-type">int</span> len=<span class="hljs-keyword">sizeof</span>(sendbuf); <br>    <span class="hljs-comment">/*先设置TCP发送缓冲区的大小，然后立即读取之*/</span><br>    setsockopt(sock,SOL_SOCKET,SO_SNDBUF,＆sendbuf,<span class="hljs-keyword">sizeof</span>(sendbuf)); <br>    getsockopt(sock,SOL_SOCKET,SO_SNDBUF,＆sendbuf,(<span class="hljs-type">socklen_t</span>*)＆len);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the tcp send buffer size after setting is%d\n&quot;</span>,sendbuf); <br>	<span class="hljs-keyword">if</span>(connect(sock,(<span class="hljs-keyword">struct</span> sockaddr*)＆ server_address,<span class="hljs-keyword">sizeof</span>(server_address))!=<span class="hljs-number">-1</span>) &#123; <br>        <span class="hljs-type">char</span> buffer[BUFFER_SIZE]; <br>        <span class="hljs-built_in">memset</span>(buffer,<span class="hljs-string">&#x27;a&#x27;</span>,BUFFER_SIZE); <br>        send(sock,buffer,BUFFER_SIZE,<span class="hljs-number">0</span>); <br>    &#125; <br>    close(sock); <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>代码清单5-11 修改TCP接收缓冲区的服务器程序 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/socket.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜netinet/in.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜arpa/inet.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜assert.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜stdio.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜unistd.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜stdlib.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜errno.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜string.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE 1024 </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>*argv[])</span> &#123; <br>    <span class="hljs-keyword">if</span>(argc＜=<span class="hljs-number">2</span>) &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage:%s ip_address port_number recv_buffer_size\n&quot;</span>,basename(argv[<span class="hljs-number">0</span>]));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br>    &#125; <br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*ip=argv[<span class="hljs-number">1</span>]; <br>    <span class="hljs-type">int</span> port=atoi(argv[<span class="hljs-number">2</span>]); <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span> <br>    bzero(＆address,<span class="hljs-keyword">sizeof</span>(address)); <br>    address.sin_family=AF_INET; <br>    inet_pton(AF_INET,ip,＆address.sin_addr); <br>    address.sin_port=htons(port); <br>    <span class="hljs-type">int</span> sock=socket(PF_INET,SOCK_STREAM,<span class="hljs-number">0</span>); <br>    assert(sock＞=<span class="hljs-number">0</span>); <br>    <span class="hljs-type">int</span> recvbuf=atoi(argv[<span class="hljs-number">3</span>]); <br>    <span class="hljs-type">int</span> len=<span class="hljs-keyword">sizeof</span>(recvbuf); <br>    <span class="hljs-comment">/*先设置TCP接收缓冲区的大小，然后立即读取之*/</span><br>    setsockopt(sock,SOL_SOCKET,SO_RCVBUF,＆recvbuf,<span class="hljs-keyword">sizeof</span>(recvbuf));<br>    getsockopt(sock,SOL_SOCKET,SO_RCVBUF,＆recvbuf,(<span class="hljs-type">socklen_t</span>*)＆len);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the tcp receive buffer size after settting is%d\n&quot;</span>,recvbuf);<br>    <span class="hljs-type">int</span> ret=bind(sock,(<span class="hljs-keyword">struct</span> sockaddr*)＆address,<span class="hljs-keyword">sizeof</span>(address)); <br>    assert(ret!=<span class="hljs-number">-1</span>); <br>    ret=listen(sock,<span class="hljs-number">5</span>); <br>    assert(ret!=<span class="hljs-number">-1</span>); <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span> <br>    <span class="hljs-type">socklen_t</span> client_addrlength=<span class="hljs-keyword">sizeof</span>(client); <br>    <span class="hljs-type">int</span> connfd=accept(sock,(<span class="hljs-keyword">struct</span> sockaddr*)＆client,＆client_addrlength);<br>    <span class="hljs-keyword">if</span>(connfd＜<span class="hljs-number">0</span>) &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;errno is:%d\n&quot;</span>,errno); <br>    &#125; <span class="hljs-keyword">else</span> &#123; <br>        <span class="hljs-type">char</span> buffer[BUFFER_SIZE]; <br>        <span class="hljs-built_in">memset</span>(buffer,<span class="hljs-string">&#x27;\0&#x27;</span>,BUFFER_SIZE); <br>        <span class="hljs-keyword">while</span>(recv(connfd,buffer,BUFFER_SIZE<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>)＞<span class="hljs-number">0</span>)&#123;&#125;<br>        close(connfd); <br>    &#125; <br>    close(sock); <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure>
我们在ernest-laptop上运行代码清单5-11所示的服务器程序（名为set_recv_buffer），然后在Kongming20上运行代码清单5-10所示的客户端程序（名为set_send_buffer）来向服务器发送512字节的数据，然后用tcpdump抓取这一过程中双方交换的TCP报文段。具体操作过程如下：
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">./set_recv_buffer 192.168.1.108 12345 50#将TCP接收缓冲区的大小设置为50字节<br>the tcp receive buffer size after settting is 256 <br>./set_send_buffer 192.168.1.108 12345 2000#将TCP发送缓冲区的大小设置为2 000字节<br>the tcp send buffer size after setting is 4000 <br>tcpdump-nt-i eth0 port 12345<br></code></pre></td></tr></table></figure>
从服务器的输出来看，系统允许的TCP接收缓冲区最小为256字节。当我们设置TCP接收缓冲区的大小为50字节时，系统将忽略我们的设置。从客户端的输出来看，我们设置的TCP发送缓冲区的大小被系统增加了一倍。这两种情况和我们前面讨论的一致。下面是此次TCP通信的tcpdump输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.IP 192.168.1.109.38663＞192.168.1.108.12345:Flags[S],<span class="hljs-built_in">seq</span> 1425875256,win 14600,options[mss 1460,sackOK,TS val 7782289 ecr 0,nop,wscale 4],length 0<br>2.IP 192.168.1.108.12345＞192.168.1.109.38663:Flags[S.],<span class="hljs-built_in">seq</span> 3109725840,ack 1425875257,win 192,options[mss 1460,sackOK,TS val 126229160 ecr 7782289,nop,wscale 6],length 0<br>3.IP 192.168.1.109.38663＞192.168.1.108.12345:Flags[.],ack 1,win 913,length 0<br>4.IP 192.168.1.109.38663＞192.168.1.108.12345:Flags[P.],<span class="hljs-built_in">seq</span> 1:193,ack 1,win 913,length 192<br>5.IP 192.168.1.108.12345＞192.168.1.109.38663:Flags[.],ack 193,win 0,length 0<br>6.IP 192.168.1.108.12345＞192.168.1.109.38663:Flags[.],ack 193,win 3,length 0<br>7.IP 192.168.1.109.38663＞192.168.1.108.12345:Flags[P.],<span class="hljs-built_in">seq</span> 193:385,ack 1,win 913,length 192<br>8.IP 192.168.1.108.12345＞192.168.1.109.38663:Flags[.],ack 385,win 3,length 0<br>9.IP 192.168.1.109.38663＞192.168.1.108.12345:Flags[P.],<span class="hljs-built_in">seq</span> 385:513,ack 1,win 913,length 128<br>10.IP 192.168.1.108.12345＞192.168.1.109.38663:Flags[.],ack 513,win 3,length 0<br>11.IP 192.168.1.109.38663＞192.168.1.108.12345:Flags[F.],<span class="hljs-built_in">seq</span> 513,ack 1,win 913,length 0<br>12.IP 192.168.1.108.12345＞192.168.1.109.38663:Flags[F.],<span class="hljs-built_in">seq</span> 1,ack 514,win 3,length 0<br>13.IP 192.168.1.109.38663＞192.168.1.108.12345:Flags[.],ack 2,win 913,length 0<br></code></pre></td></tr></table></figure>
<p>首先注意第2个TCP报文段，它指出服务器的接收通告窗口大小为192字节。该值小于256字节，显然是在情理之中。同时，该同步报文段还指出服务器采用的窗口扩大因子是6。所以服务器后续发送的大部分TCP报文段（6、8、10和12）的实际接收通告窗口大小都是3×26字节，即192字节。因此客户端每次最多给服务器发送192字节的数据。客户端一共给服务器发送了512字节的数据，这些数据必须至少被分为3个TCP报文段（4、7和9）来发送。</p>
<p>有意思的是TCP报文段5和6。当服务器收到客户端发送过来的第一批数据（TCP报文段4）时，它立即用TCP报文段5给予了确认，但该确认报文段的接收通告窗口的大小为0。这说明TCP模块发送该确认报文段时，应用程序还没来得及将数据从TCP接收缓冲中读出。所以此时客户端是不能发送数据给服务器的，直到服务器发送一个重复的确认报文段（TCP报文段6）来扩大其接收通告窗口。</p>
<h3 id="so_rcvlowat和so_sndlowat选项">11.3
SO_RCVLOWAT和SO_SNDLOWAT选项</h3>
<p>SO_RCVLOWAT和SO_SNDLOWAT选项分别表示TCP接收缓冲区和发送缓冲区的低水位标记。</p>
<p>它们一般被I/O复用系统调用（见第9章）用来判断socket是否可读或可写。</p>
<p>当TCP接收缓冲区中可读数据的总数大于其低水位标记时，I/O复用系统调用将通知应用程序可以从对应的socket上读取数据；</p>
<p>当TCP发送缓冲区中的空闲空间（可以写入数据的空间）大于其低水位标记时，I/O复用系统调用将通知应用程序可以往对应的socket上写入数据。</p>
<p>默认情况下，TCP接收缓冲区的低水位标记和TCP发送缓冲区的低水位标记均为1字节。</p>
<h3 id="so_linger选项">11.4 SO_LINGER选项</h3>
<p>SO_LINGER选项用于控制close系统调用在关闭TCP连接时的行为。默认情况下，当我们使用close系统调用来关闭一个socket时，close将立即返回，TCP模块负责把该socket对应的TCP发送缓冲区中残留的数据发送给对方。</p>
<p>如表5-5所示，设置（获取）SO_LINGER选项的值时，我们需要给setsockopt（getsockopt）系统调用传递一个linger类型的结构体，其定义如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/socket.h＞ </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linger</span> &#123;</span> <br>    <span class="hljs-type">int</span> l_onoff;<span class="hljs-comment">/*开启（非0）还是关闭（0）该选项*/</span><br>    <span class="hljs-type">int</span> l_linger;<span class="hljs-comment">/*滞留时间*/</span><br>&#125;;<br></code></pre></td></tr></table></figure>
根据linger结构体中两个成员变量的不同值，close系统调用可能产生如下3种行为之一：</p>
<p>❑l_onoff等于0。此时SO_LINGER选项不起作用，close用默认行为来关闭socket。</p>
<p>❑l_onoff不为0，l_linger等于0。此时close系统调用立即返回，TCP模块将丢弃被关闭的socket对应的TCP发送缓冲区中残留的数据，同时给对方发送一个复位报文段（见3.5.2小节）。因此，这种情况给服务器提供了异常终止一个连接的方法。</p>
<p>❑l_onoff不为0，l_linger大于0。此时close的行为取决于两个条件：一是被关闭的socket对应的TCP发送缓冲区中是否还有残留的数据；二是该socket是阻塞的，还是非阻塞的。对于阻塞的socket，close将等待一段长为l_linger的时间，直到TCP模块发送完所有残留数据并得到对方的确认。如果这段时间内TCP模块没有发送完残留数据并得到对方的确认，那么close系统调用将返回-1并设置errno为EWOULDBLOCK。如果socket是非阻塞的，close将立即返回，此时我们需要根据其返回值和errno来判断残留数据是否已经发送完毕。关于阻塞和非阻塞，我们将在第8章讨论。</p>
<p>[1]确切地说，socket在执行listen调用前是不能称为监听socket的，此处是指将执行listen调用的socket。</p>
<h2 id="网络信息api">12. 网络信息API</h2>
<p>socket地址的两个要素，即IP地址和端口号，都是用数值表示的。这不便于记忆，也不便于扩展（比如从IPv4转移到IPv6）。因此在前面的章节中，我们用主机名来访问一台机器，而避免直接使用其IP地址。同样，我们用服务名称来代替端口号。比如，下面两条telnet命令具有完全相同的作用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">telnet 127.0.0.1 80 <br>telnet localhost www<br></code></pre></td></tr></table></figure>
<p>上面的例子中，telnet客户端程序是通过调用某些网络信息API来实现主机名到IP地址的转换，以及服务名称到端口号的转换的。下面我们将讨论网络信息API中比较重要的几个。</p>
<h3 id="gethostbyname和gethostbyaddr">12.1
gethostbyname和gethostbyaddr</h3>
<p>gethostbyname函数根据主机名称获取主机的完整信息，gethostbyaddr函数根据IP地址获取主机的完整信息。gethostbyname函数通常先在本地的/etc/hosts配置文件中查找主机，如果没有找到，再去访问DNS服务器。这些在前面章节中都讨论过。这两个函数的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜netdb.h＞ </span><br><span class="hljs-keyword">struct</span> hostent*<span class="hljs-title function_">gethostbyname</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*name)</span>; <br><span class="hljs-keyword">struct</span> hostent*<span class="hljs-title function_">gethostbyaddr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>*addr,<span class="hljs-type">size_t</span> len,<span class="hljs-type">int</span> type)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>name参数指定目标主机的主机名，</li>
<li>addr参数指定目标主机的IP地址，</li>
<li>len参数指定addr所指IP地址的长度，</li>
<li>type参数指定addr所指IP地址的类型，
<ul>
<li>其合法取值包括AF_INET（用于IPv4地址）和AF_INET6（用于IPv6地址）。</li>
</ul></li>
</ul>
<p>这两个函数返回的都是hostent结构体类型的指针，hostent结构体的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜netdb.h＞ </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hostent</span> &#123;</span> <br>    <span class="hljs-type">char</span>*h_name;<span class="hljs-comment">/*主机名*/</span> <br>    <span class="hljs-type">char</span>**h_aliases;<span class="hljs-comment">/*主机别名列表，可能有多个*/</span> <br>    <span class="hljs-type">int</span> h_addrtype;<span class="hljs-comment">/*地址类型（地址族）*/</span> <br>    <span class="hljs-type">int</span> h_length;<span class="hljs-comment">/*地址长度*/</span> <br>    <span class="hljs-type">char</span>**h_addr_list;<span class="hljs-comment">/*按网络字节序列出的主机IP地址列表*/</span> <br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="getservbyname和getservbyport">12.2
getservbyname和getservbyport</h3>
<p>getservbyname函数根据名称获取某个服务的完整信息，getservbyport函数根据端口号获取某个服务的完整信息。它们实际上是通过读取/etc/services文件来获取服务的信息的。这两个函数的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜netdb.h＞ </span><br><span class="hljs-keyword">struct</span> servent*<span class="hljs-title function_">getservbyname</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*name,<span class="hljs-type">const</span> <span class="hljs-type">char</span>*proto)</span>; <br><span class="hljs-keyword">struct</span> servent*<span class="hljs-title function_">getservbyport</span><span class="hljs-params">(<span class="hljs-type">int</span> port,<span class="hljs-type">const</span> <span class="hljs-type">char</span>*proto)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>name参数指定目标服务的名字，</li>
<li>port参数指定目标服务对应的端口号。</li>
<li>proto参数指定服务类型，给它传递“tcp”表示获取流服务，给它传递“udp”表示获取数据报服务，给它传递NULL则表示获取所有类型的服务。</li>
</ul>
<p>这两个函数返回的都是servent结构体类型的指针，结构体servent的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜netdb.h＞ </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">servent</span> &#123;</span> <br>    <span class="hljs-type">char</span>*s_name;<span class="hljs-comment">/*服务名称*/</span> <br>    <span class="hljs-type">char</span>**s_aliases;<span class="hljs-comment">/*服务的别名列表，可能有多个*/</span> <br>    <span class="hljs-type">int</span> s_port;<span class="hljs-comment">/*端口号*/</span> <br>    <span class="hljs-type">char</span>*s_proto;<span class="hljs-comment">/*服务类型,通常是tcp或者udp*/</span> <br>&#125;;<br></code></pre></td></tr></table></figure>
<p>下面我们通过主机名和服务名来访问目标服务器上的daytime服务，以获取该机器的系统时间，如代码清单5-12所示。</p>
<p>代码清单5-12 访问daytime服务 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/socket.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜netinet/in.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜netdb.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜stdio.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜unistd.h＞ </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜assert.h＞ </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>*argv[])</span><br>&#123; <br>    assert(argc==<span class="hljs-number">2</span>); <br>    <span class="hljs-type">char</span>*host=argv[<span class="hljs-number">1</span>]; <br>    <span class="hljs-comment">/*获取目标主机地址信息*/</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hostent</span>*<span class="hljs-title">hostinfo</span>=</span>gethostbyname(host); <br>    assert(hostinfo); <br>    <span class="hljs-comment">/*获取daytime服务信息*/</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">servent</span>*<span class="hljs-title">servinfo</span>=</span>getservbyname(<span class="hljs-string">&quot;daytime&quot;</span>,<span class="hljs-string">&quot;tcp&quot;</span>); <br>    assert(servinfo); <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;daytime port is%d\n&quot;</span>,ntohs(servinfo-＞s_port)); <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span> <br>    address.sin_family=AF_INET; <br>    address.sin_port=servinfo-＞s_port; <br>    <span class="hljs-comment">/*注意下面的代码，因为h_addr_list本身是使用网络字节序的地址列表，所以使用其中的IP地址时，无须对目标IP地址转换字节序*/</span><br>    address.sin_addr=*(<span class="hljs-keyword">struct</span> in_addr*)*hostinfo-＞h_addr_list; <br>    <span class="hljs-type">int</span> sockfd=socket(AF_INET,SOCK_STREAM,<span class="hljs-number">0</span>); <br>    <span class="hljs-type">int</span> result=connect(sockfd,(<span class="hljs-keyword">struct</span> sockaddr*)＆<br>    address,<span class="hljs-keyword">sizeof</span>(address));<br>    assert(result!=<span class="hljs-number">-1</span>); <br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">128</span>]; <br>    result=read(sockfd,buffer,<span class="hljs-keyword">sizeof</span>(buffer)); <br>    assert(result＞<span class="hljs-number">0</span>); <br>    buffer[result]=<span class="hljs-string">&#x27;\0&#x27;</span>; <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the day tiem is:%s&quot;</span>,buffer); <br>    close(sockfd); <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure>
需要指出的是，上面讨论的4个函数都是不可重入的，即非线程安全的。不过netdb.h头文件给出了它们的可重入版本。正如Linux下所有其他函数的可重入版本的命名规则那样，这些函数的函数名是在原函数名尾部加上_r（re-entrant）。</p>
<h3 id="getaddrinfo">12.3 getaddrinfo</h3>
<p>getaddrinfo函数既能通过主机名获得IP地址（内部使用的是gethostbyname函数），也能通过服务名获得端口号（内部使用的是getservbyname函数）。它是否可重入取决于其内部调用的gethostbyname和getservbyname函数是否是它们的可重入版本。该函数的定义如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜netdb.h＞ </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getaddrinfo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*hostname,<span class="hljs-type">const</span> <span class="hljs-type">char</span>*service,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> addrinfo*hints,<span class="hljs-keyword">struct</span> addrinfo**result)</span>;<br></code></pre></td></tr></table></figure>
hostname参数可以接收主机名，也可以接收字符串表示的IP地址（IPv4采用点分十进制字符串，IPv6则采用十六进制字符串）。</p>
<p>同样，service参数可以接收服务名，也可以接收字符串表示的十进制端口号。</p>
<p>hints参数是应用程序给getaddrinfo的一个提示，以对getaddrinfo的输出进行更精确的控制。</p>
<p>hints参数可以被设置为NULL，表示允许getaddrinfo反馈任何可用的结果。result参数指向一个链表，该链表用于存储getaddrinfo反馈的结果。</p>
<p>getaddrinfo反馈的每一条结果都是addrinfo结构体类型的对象，结构体addrinfo的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span> &#123;</span> <br>    <span class="hljs-type">int</span> ai_flags;<span class="hljs-comment">/*见后文*/</span> <br>    <span class="hljs-type">int</span> ai_family;<span class="hljs-comment">/*地址族*/</span> <br>    <span class="hljs-type">int</span> ai_socktype;<span class="hljs-comment">/*服务类型，SOCK_STREAM或SOCK_DGRAM*/</span> <br>    <span class="hljs-type">int</span> ai_protocol;<span class="hljs-comment">/*见后文*/</span> <br>    <span class="hljs-type">socklen_t</span> ai_addrlen;<span class="hljs-comment">/*socket地址ai_addr的长度*/</span><br>    <span class="hljs-type">char</span>*ai_canonname;<span class="hljs-comment">/*主机的别名*/</span> <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span>*<span class="hljs-title">ai_addr</span>;</span><span class="hljs-comment">/*指向socket地址*/</span> <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span>*<span class="hljs-title">ai_next</span>;</span><span class="hljs-comment">/*指向下一个addrinfo结构的对象*/</span> <br>&#125;;<br></code></pre></td></tr></table></figure>
<p>该结构体中，ai_protocol成员是指具体的网络协议，其含义和socket系统调用的第三个参数相同，它通常被设置为0。ai_flags成员可以取表5-6中的标志的按位或。</p>
<p><img src="/2024/12/16/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-%E6%B8%B8%E5%8F%8C/5-Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/image-20241218105748187.png" srcset="/img/loading.gif" lazyload></p>
<p>当我们使用hints参数的时候，可以设置其ai_flags，ai_family，ai_socktype和ai_protocol四个字段，其他字段则必须被设置为NULL。</p>
<p>例如，代码清单5-13利用了hints参数获取主机ernest-laptop上的“daytime”流服务信息。</p>
<p>代码清单5-13 使用getaddrinfo函数 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span> <span class="hljs-title">hints</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span>*<span class="hljs-title">res</span>;</span> <br>bzero(＆hints,<span class="hljs-keyword">sizeof</span>(hints)); <br>hints.ai_socktype=SOCK_STREAM; <br>getaddrinfo(<span class="hljs-string">&quot;ernest-laptop&quot;</span>,<span class="hljs-string">&quot;daytime&quot;</span>,＆hints,＆res);<br></code></pre></td></tr></table></figure>
从代码清单5-13中我们能分析出，getaddrinfo将隐式地分配堆内存（可以通过valgrind等工具查看），因为res指针原本是没有指向一块合法内存的，所以，getaddrinfo调用结束后，我们必须使用如下配对函数来释放这块内存：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜netdb.h＞ </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">freeaddrinfo</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> addrinfo*res)</span>;<br></code></pre></td></tr></table></figure></p>
<h3 id="getnameinfo">12.4 getnameinfo</h3>
<p>getnameinfo函数能通过socket地址同时获得以字符串表示的主机名（内部使用的是gethostbyaddr函数）和服务名（内部使用的是getservbyport函数）。它是否可重入取决于其内部调用的gethostbyaddr和getservbyport函数是否是它们的可重入版本。该函数的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜netdb.h＞ </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getnameinfo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr*sockaddr,<span class="hljs-type">socklen_t</span> addrlen,</span><br><span class="hljs-params">                <span class="hljs-type">char</span>*host,<span class="hljs-type">socklen_t</span> hostlen,<span class="hljs-type">char</span>*serv,<span class="hljs-type">socklen_t</span> servlen,<span class="hljs-type">int</span> flags)</span>;<br></code></pre></td></tr></table></figure>
<p>getnameinfo将返回的主机名存储在host参数指向的缓存中，</p>
<p>将服务名存储在serv参数指向的缓存中，</p>
<p>hostlen和servlen参数分别指定这两块缓存的长度。</p>
<p>flags参数控制getnameinfo的行为，它可以接收表5-7中的选项。</p>
<p><img src="/2024/12/16/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-%E6%B8%B8%E5%8F%8C/5-Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/image-20241218105856738.png" srcset="/img/loading.gif" lazyload></p>
<p>getaddrinfo和getnameinfo函数成功时返回0，失败则返回错误码，可能的错误码如表5-8所示。</p>
<p><img src="/2024/12/16/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-%E6%B8%B8%E5%8F%8C/5-Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/image-20241218105912791.png" srcset="/img/loading.gif" lazyload></p>
<p>Linux下strerror函数能将数值错误码errno转换成易读的字符串形式。同样，下面的函数可将表5-8中的错误码转换成其字符串形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜netdb.h＞ </span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>*<span class="hljs-title function_">gai_strerror</span><span class="hljs-params">(<span class="hljs-type">int</span> error)</span>;<br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/c/" class="category-chain-item">c++</a>
  
  
    <span>></span>
    
  <a href="/categories/c/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8-%E6%B8%B8%E5%8F%8C/" class="category-chain-item">Linux高性能服务器-游双</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="print-no-link">#网络编程</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>5. Linux网络编程基础API</div>
      <div>http://binbo-zappy.github.io/2024/12/16/Linux高性能服务器编程-游双/5-Linux网络编程基础API/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Binbo</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年12月16日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/12/16/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-%E6%B8%B8%E5%8F%8C/6-%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0/" title="6. 高级I/O函数">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">6. 高级I/O函数</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/12/16/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-%E6%B8%B8%E5%8F%8C/4-TCP-IP%E9%80%9A%E4%BF%A1%E6%A1%88%E4%BE%8B/" title="4. TCP/IP通信案例：访问Internet上的Web服务器">
                        <span class="hidden-mobile">4. TCP/IP通信案例：访问Internet上的Web服务器</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
